// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import '../../../../../android/graphics/Rect.dart' as rect_;

import 'FaceContour.dart' as facecontour_;

import 'FaceLandmark.dart' as facelandmark_;

/// from: com.google.mlkit.vision.face.Face
class Face extends jni.JObject {
  @override
  late final jni.JObjType<Face> $type = type;

  Face.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/face/Face');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceType();
  static final _id_getHeadEulerAngleX = _class.instanceMethodId(
    r'getHeadEulerAngleX',
    r'()F',
  );

  static final _getHeadEulerAngleX = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public float getHeadEulerAngleX()
  double getHeadEulerAngleX() {
    return _getHeadEulerAngleX(
            reference.pointer, _id_getHeadEulerAngleX as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getHeadEulerAngleY = _class.instanceMethodId(
    r'getHeadEulerAngleY',
    r'()F',
  );

  static final _getHeadEulerAngleY = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public float getHeadEulerAngleY()
  double getHeadEulerAngleY() {
    return _getHeadEulerAngleY(
            reference.pointer, _id_getHeadEulerAngleY as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getHeadEulerAngleZ = _class.instanceMethodId(
    r'getHeadEulerAngleZ',
    r'()F',
  );

  static final _getHeadEulerAngleZ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public float getHeadEulerAngleZ()
  double getHeadEulerAngleZ() {
    return _getHeadEulerAngleZ(
            reference.pointer, _id_getHeadEulerAngleZ as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getBoundingBox = _class.instanceMethodId(
    r'getBoundingBox',
    r'()Landroid/graphics/Rect;',
  );

  static final _getBoundingBox = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Rect getBoundingBox()
  /// The returned object must be released after use, by calling the [release] method.
  rect_.Rect getBoundingBox() {
    return _getBoundingBox(
            reference.pointer, _id_getBoundingBox as jni.JMethodIDPtr)
        .object(const rect_.$RectType());
  }

  static final _id_getContour = _class.instanceMethodId(
    r'getContour',
    r'(I)Lcom/google/mlkit/vision/face/FaceContour;',
  );

  static final _getContour = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.mlkit.vision.face.FaceContour getContour(int i)
  /// The returned object must be released after use, by calling the [release] method.
  facecontour_.FaceContour getContour(
    int i,
  ) {
    return _getContour(reference.pointer, _id_getContour as jni.JMethodIDPtr, i)
        .object(const facecontour_.$FaceContourType());
  }

  static final _id_getLandmark = _class.instanceMethodId(
    r'getLandmark',
    r'(I)Lcom/google/mlkit/vision/face/FaceLandmark;',
  );

  static final _getLandmark = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.mlkit.vision.face.FaceLandmark getLandmark(int i)
  /// The returned object must be released after use, by calling the [release] method.
  facelandmark_.FaceLandmark getLandmark(
    int i,
  ) {
    return _getLandmark(
            reference.pointer, _id_getLandmark as jni.JMethodIDPtr, i)
        .object(const facelandmark_.$FaceLandmarkType());
  }

  static final _id_getLeftEyeOpenProbability = _class.instanceMethodId(
    r'getLeftEyeOpenProbability',
    r'()Ljava/lang/Float;',
  );

  static final _getLeftEyeOpenProbability = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Float getLeftEyeOpenProbability()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JFloat getLeftEyeOpenProbability() {
    return _getLeftEyeOpenProbability(reference.pointer,
            _id_getLeftEyeOpenProbability as jni.JMethodIDPtr)
        .object(const jni.JFloatType());
  }

  static final _id_getRightEyeOpenProbability = _class.instanceMethodId(
    r'getRightEyeOpenProbability',
    r'()Ljava/lang/Float;',
  );

  static final _getRightEyeOpenProbability = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Float getRightEyeOpenProbability()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JFloat getRightEyeOpenProbability() {
    return _getRightEyeOpenProbability(reference.pointer,
            _id_getRightEyeOpenProbability as jni.JMethodIDPtr)
        .object(const jni.JFloatType());
  }

  static final _id_getSmilingProbability = _class.instanceMethodId(
    r'getSmilingProbability',
    r'()Ljava/lang/Float;',
  );

  static final _getSmilingProbability = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Float getSmilingProbability()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JFloat getSmilingProbability() {
    return _getSmilingProbability(
            reference.pointer, _id_getSmilingProbability as jni.JMethodIDPtr)
        .object(const jni.JFloatType());
  }

  static final _id_getTrackingId = _class.instanceMethodId(
    r'getTrackingId',
    r'()Ljava/lang/Integer;',
  );

  static final _getTrackingId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Integer getTrackingId()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger getTrackingId() {
    return _getTrackingId(
            reference.pointer, _id_getTrackingId as jni.JMethodIDPtr)
        .object(const jni.JIntegerType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAllContours = _class.instanceMethodId(
    r'getAllContours',
    r'()Ljava/util/List;',
  );

  static final _getAllContours = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getAllContours()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<facecontour_.FaceContour> getAllContours() {
    return _getAllContours(
            reference.pointer, _id_getAllContours as jni.JMethodIDPtr)
        .object(const jni.JListType(facecontour_.$FaceContourType()));
  }

  static final _id_getAllLandmarks = _class.instanceMethodId(
    r'getAllLandmarks',
    r'()Ljava/util/List;',
  );

  static final _getAllLandmarks = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getAllLandmarks()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<facelandmark_.FaceLandmark> getAllLandmarks() {
    return _getAllLandmarks(
            reference.pointer, _id_getAllLandmarks as jni.JMethodIDPtr)
        .object(const jni.JListType(facelandmark_.$FaceLandmarkType()));
  }

  static final _id_zza = _class.instanceMethodId(
    r'zza',
    r'()Landroid/util/SparseArray;',
  );

  static final _zza = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.util.SparseArray zza()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject zza() {
    return _zza(reference.pointer, _id_zza as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lcom/google/android/gms/internal/mlkit_vision_face/zzf;Landroid/graphics/Matrix;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.android.gms.internal.mlkit_vision_face.zzf zzf, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  factory Face(
    jni.JObject zzf,
    jni.JObject matrix,
  ) {
    return Face.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            zzf.reference.pointer,
            matrix.reference.pointer)
        .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Lcom/google/android/gms/internal/mlkit_vision_face/zzow;Landroid/graphics/Matrix;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.android.gms.internal.mlkit_vision_face.zzow zzow, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  factory Face.new1(
    jni.JObject zzow,
    jni.JObject matrix,
  ) {
    return Face.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            zzow.reference.pointer,
            matrix.reference.pointer)
        .reference);
  }

  static final _id_zzb = _class.instanceMethodId(
    r'zzb',
    r'(Landroid/util/SparseArray;)V',
  );

  static final _zzb = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void zzb(android.util.SparseArray sparseArray)
  void zzb(
    jni.JObject sparseArray,
  ) {
    _zzb(reference.pointer, _id_zzb as jni.JMethodIDPtr,
            sparseArray.reference.pointer)
        .check();
  }

  static final _id_zzc = _class.instanceMethodId(
    r'zzc',
    r'(I)V',
  );

  static final _zzc = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void zzc(int i)
  void zzc(
    int i,
  ) {
    _zzc(reference.pointer, _id_zzc as jni.JMethodIDPtr, i).check();
  }
}

final class $FaceType extends jni.JObjType<Face> {
  const $FaceType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/face/Face;';

  @override
  Face fromReference(jni.JReference reference) => Face.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceType) && other is $FaceType;
  }
}
