// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import '../../../../../../android/graphics/Point.dart' as point_;

import '../../../../../../android/graphics/Rect.dart' as rect_;

/// from: com.google.mlkit.vision.barcode.common.Barcode$Address$AddressType
class Barcode_Address_AddressType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Address_AddressType> $type = type;

  Barcode_Address_AddressType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Address$AddressType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Address_AddressTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Address_AddressTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_Address_AddressType.implement(
    $Barcode_Address_AddressTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Address_AddressType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$Address$AddressType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Address_AddressTypeImpl {
  factory $Barcode_Address_AddressTypeImpl() =
      _$Barcode_Address_AddressTypeImpl;
}

class _$Barcode_Address_AddressTypeImpl
    implements $Barcode_Address_AddressTypeImpl {
  _$Barcode_Address_AddressTypeImpl();
}

final class $Barcode_Address_AddressTypeType
    extends jni.JObjType<Barcode_Address_AddressType> {
  const $Barcode_Address_AddressTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Address$AddressType;';

  @override
  Barcode_Address_AddressType fromReference(jni.JReference reference) =>
      Barcode_Address_AddressType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Address_AddressTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Address_AddressTypeType) &&
        other is $Barcode_Address_AddressTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Address
class Barcode_Address extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Address> $type = type;

  Barcode_Address.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Address');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_AddressType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;
  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()I',
  );

  static final _getType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer, _id_getType as jni.JMethodIDPtr).integer;
  }

  static final _id_new0 = _class.constructorId(
    r'(I[Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Address(
    int i,
    jni.JArray<jni.JString> strings,
  ) {
    return Barcode_Address.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, i, strings.reference.pointer)
        .reference);
  }

  static final _id_getAddressLines = _class.instanceMethodId(
    r'getAddressLines',
    r'()[Ljava/lang/String;',
  );

  static final _getAddressLines = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String[] getAddressLines()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getAddressLines() {
    return _getAddressLines(
            reference.pointer, _id_getAddressLines as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JStringType()));
  }
}

final class $Barcode_AddressType extends jni.JObjType<Barcode_Address> {
  const $Barcode_AddressType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Address;';

  @override
  Barcode_Address fromReference(jni.JReference reference) =>
      Barcode_Address.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_AddressType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_AddressType) &&
        other is $Barcode_AddressType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$BarcodeFormat
class Barcode_BarcodeFormat extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_BarcodeFormat> $type = type;

  Barcode_BarcodeFormat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$BarcodeFormat');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_BarcodeFormatType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_BarcodeFormatImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_BarcodeFormat.implement(
    $Barcode_BarcodeFormatImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_BarcodeFormat.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$BarcodeFormat',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_BarcodeFormatImpl {
  factory $Barcode_BarcodeFormatImpl() = _$Barcode_BarcodeFormatImpl;
}

class _$Barcode_BarcodeFormatImpl implements $Barcode_BarcodeFormatImpl {
  _$Barcode_BarcodeFormatImpl();
}

final class $Barcode_BarcodeFormatType
    extends jni.JObjType<Barcode_BarcodeFormat> {
  const $Barcode_BarcodeFormatType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$BarcodeFormat;';

  @override
  Barcode_BarcodeFormat fromReference(jni.JReference reference) =>
      Barcode_BarcodeFormat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_BarcodeFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_BarcodeFormatType) &&
        other is $Barcode_BarcodeFormatType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$BarcodeValueType
class Barcode_BarcodeValueType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_BarcodeValueType> $type = type;

  Barcode_BarcodeValueType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$BarcodeValueType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_BarcodeValueTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_BarcodeValueTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_BarcodeValueType.implement(
    $Barcode_BarcodeValueTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_BarcodeValueType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$BarcodeValueType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_BarcodeValueTypeImpl {
  factory $Barcode_BarcodeValueTypeImpl() = _$Barcode_BarcodeValueTypeImpl;
}

class _$Barcode_BarcodeValueTypeImpl implements $Barcode_BarcodeValueTypeImpl {
  _$Barcode_BarcodeValueTypeImpl();
}

final class $Barcode_BarcodeValueTypeType
    extends jni.JObjType<Barcode_BarcodeValueType> {
  const $Barcode_BarcodeValueTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$BarcodeValueType;';

  @override
  Barcode_BarcodeValueType fromReference(jni.JReference reference) =>
      Barcode_BarcodeValueType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_BarcodeValueTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_BarcodeValueTypeType) &&
        other is $Barcode_BarcodeValueTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime
class Barcode_CalendarDateTime extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_CalendarDateTime> $type = type;

  Barcode_CalendarDateTime.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_CalendarDateTimeType();
  static final _id_getDay = _class.instanceMethodId(
    r'getDay',
    r'()I',
  );

  static final _getDay = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getDay()
  int getDay() {
    return _getDay(reference.pointer, _id_getDay as jni.JMethodIDPtr).integer;
  }

  static final _id_getHours = _class.instanceMethodId(
    r'getHours',
    r'()I',
  );

  static final _getHours = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getHours()
  int getHours() {
    return _getHours(reference.pointer, _id_getHours as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getMinutes = _class.instanceMethodId(
    r'getMinutes',
    r'()I',
  );

  static final _getMinutes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getMinutes()
  int getMinutes() {
    return _getMinutes(reference.pointer, _id_getMinutes as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()I',
  );

  static final _getMonth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getMonth()
  int getMonth() {
    return _getMonth(reference.pointer, _id_getMonth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getSeconds = _class.instanceMethodId(
    r'getSeconds',
    r'()I',
  );

  static final _getSeconds = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getSeconds()
  int getSeconds() {
    return _getSeconds(reference.pointer, _id_getSeconds as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getYear = _class.instanceMethodId(
    r'getYear',
    r'()I',
  );

  static final _getYear = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getYear()
  int getYear() {
    return _getYear(reference.pointer, _id_getYear as jni.JMethodIDPtr).integer;
  }

  static final _id_getRawValue = _class.instanceMethodId(
    r'getRawValue',
    r'()Ljava/lang/String;',
  );

  static final _getRawValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getRawValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRawValue() {
    return _getRawValue(reference.pointer, _id_getRawValue as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(IIIIIIZLjava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, int i1, int i2, int i3, int i4, int i5, boolean z, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_CalendarDateTime(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    bool z,
    jni.JString string,
  ) {
    return Barcode_CalendarDateTime.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            i,
            i1,
            i2,
            i3,
            i4,
            i5,
            z ? 1 : 0,
            string.reference.pointer)
        .reference);
  }

  static final _id_isUtc = _class.instanceMethodId(
    r'isUtc',
    r'()Z',
  );

  static final _isUtc = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isUtc()
  bool isUtc() {
    return _isUtc(reference.pointer, _id_isUtc as jni.JMethodIDPtr).boolean;
  }
}

final class $Barcode_CalendarDateTimeType
    extends jni.JObjType<Barcode_CalendarDateTime> {
  const $Barcode_CalendarDateTimeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;';

  @override
  Barcode_CalendarDateTime fromReference(jni.JReference reference) =>
      Barcode_CalendarDateTime.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_CalendarDateTimeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_CalendarDateTimeType) &&
        other is $Barcode_CalendarDateTimeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$CalendarEvent
class Barcode_CalendarEvent extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_CalendarEvent> $type = type;

  Barcode_CalendarEvent.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$CalendarEvent');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_CalendarEventType();
  static final _id_getEnd = _class.instanceMethodId(
    r'getEnd',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;',
  );

  static final _getEnd = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime getEnd()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarDateTime getEnd() {
    return _getEnd(reference.pointer, _id_getEnd as jni.JMethodIDPtr)
        .object(const $Barcode_CalendarDateTimeType());
  }

  static final _id_getStart = _class.instanceMethodId(
    r'getStart',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;',
  );

  static final _getStart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime getStart()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarDateTime getStart() {
    return _getStart(reference.pointer, _id_getStart as jni.JMethodIDPtr)
        .object(const $Barcode_CalendarDateTimeType());
  }

  static final _id_getDescription = _class.instanceMethodId(
    r'getDescription',
    r'()Ljava/lang/String;',
  );

  static final _getDescription = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDescription() {
    return _getDescription(
            reference.pointer, _id_getDescription as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getLocation = _class.instanceMethodId(
    r'getLocation',
    r'()Ljava/lang/String;',
  );

  static final _getLocation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLocation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLocation() {
    return _getLocation(reference.pointer, _id_getLocation as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getOrganizer = _class.instanceMethodId(
    r'getOrganizer',
    r'()Ljava/lang/String;',
  );

  static final _getOrganizer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getOrganizer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOrganizer() {
    return _getOrganizer(
            reference.pointer, _id_getOrganizer as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getStatus = _class.instanceMethodId(
    r'getStatus',
    r'()Ljava/lang/String;',
  );

  static final _getStatus = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getStatus()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getStatus() {
    return _getStatus(reference.pointer, _id_getStatus as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSummary = _class.instanceMethodId(
    r'getSummary',
    r'()Ljava/lang/String;',
  );

  static final _getSummary = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getSummary()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSummary() {
    return _getSummary(reference.pointer, _id_getSummary as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime calendarDateTime, com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime calendarDateTime1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_CalendarEvent(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    Barcode_CalendarDateTime calendarDateTime,
    Barcode_CalendarDateTime calendarDateTime1,
  ) {
    return Barcode_CalendarEvent.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            calendarDateTime.reference.pointer,
            calendarDateTime1.reference.pointer)
        .reference);
  }
}

final class $Barcode_CalendarEventType
    extends jni.JObjType<Barcode_CalendarEvent> {
  const $Barcode_CalendarEventType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarEvent;';

  @override
  Barcode_CalendarEvent fromReference(jni.JReference reference) =>
      Barcode_CalendarEvent.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_CalendarEventType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_CalendarEventType) &&
        other is $Barcode_CalendarEventType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$ContactInfo
class Barcode_ContactInfo extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_ContactInfo> $type = type;

  Barcode_ContactInfo.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$ContactInfo');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_ContactInfoType();
  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$PersonName;',
  );

  static final _getName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$PersonName getName()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_PersonName getName() {
    return _getName(reference.pointer, _id_getName as jni.JMethodIDPtr)
        .object(const $Barcode_PersonNameType());
  }

  static final _id_getOrganization = _class.instanceMethodId(
    r'getOrganization',
    r'()Ljava/lang/String;',
  );

  static final _getOrganization = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getOrganization()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOrganization() {
    return _getOrganization(
            reference.pointer, _id_getOrganization as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/String;',
  );

  static final _getTitle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAddresses = _class.instanceMethodId(
    r'getAddresses',
    r'()Ljava/util/List;',
  );

  static final _getAddresses = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getAddresses()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Address> getAddresses() {
    return _getAddresses(
            reference.pointer, _id_getAddresses as jni.JMethodIDPtr)
        .object(const jni.JListType($Barcode_AddressType()));
  }

  static final _id_getEmails = _class.instanceMethodId(
    r'getEmails',
    r'()Ljava/util/List;',
  );

  static final _getEmails = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getEmails()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Email> getEmails() {
    return _getEmails(reference.pointer, _id_getEmails as jni.JMethodIDPtr)
        .object(const jni.JListType($Barcode_EmailType()));
  }

  static final _id_getPhones = _class.instanceMethodId(
    r'getPhones',
    r'()Ljava/util/List;',
  );

  static final _getPhones = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getPhones()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Phone> getPhones() {
    return _getPhones(reference.pointer, _id_getPhones as jni.JMethodIDPtr)
        .object(const jni.JListType($Barcode_PhoneType()));
  }

  static final _id_getUrls = _class.instanceMethodId(
    r'getUrls',
    r'()Ljava/util/List;',
  );

  static final _getUrls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getUrls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getUrls() {
    return _getUrls(reference.pointer, _id_getUrls as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_new0 = _class.constructorId(
    r'(Lcom/google/mlkit/vision/barcode/common/Barcode$PersonName;Ljava/lang/String;Ljava/lang/String;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.Barcode$PersonName personName, java.lang.String string, java.lang.String string1, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_ContactInfo(
    Barcode_PersonName personName,
    jni.JString string,
    jni.JString string1,
    jni.JList<Barcode_Phone> list,
    jni.JList<Barcode_Email> list1,
    jni.JList<jni.JString> list2,
    jni.JList<Barcode_Address> list3,
  ) {
    return Barcode_ContactInfo.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            personName.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer,
            list.reference.pointer,
            list1.reference.pointer,
            list2.reference.pointer,
            list3.reference.pointer)
        .reference);
  }
}

final class $Barcode_ContactInfoType extends jni.JObjType<Barcode_ContactInfo> {
  const $Barcode_ContactInfoType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$ContactInfo;';

  @override
  Barcode_ContactInfo fromReference(jni.JReference reference) =>
      Barcode_ContactInfo.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_ContactInfoType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_ContactInfoType) &&
        other is $Barcode_ContactInfoType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$DriverLicense
class Barcode_DriverLicense extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_DriverLicense> $type = type;

  Barcode_DriverLicense.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$DriverLicense');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_DriverLicenseType();
  static final _id_getAddressCity = _class.instanceMethodId(
    r'getAddressCity',
    r'()Ljava/lang/String;',
  );

  static final _getAddressCity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddressCity()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressCity() {
    return _getAddressCity(
            reference.pointer, _id_getAddressCity as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAddressState = _class.instanceMethodId(
    r'getAddressState',
    r'()Ljava/lang/String;',
  );

  static final _getAddressState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddressState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressState() {
    return _getAddressState(
            reference.pointer, _id_getAddressState as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAddressStreet = _class.instanceMethodId(
    r'getAddressStreet',
    r'()Ljava/lang/String;',
  );

  static final _getAddressStreet = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddressStreet()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressStreet() {
    return _getAddressStreet(
            reference.pointer, _id_getAddressStreet as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAddressZip = _class.instanceMethodId(
    r'getAddressZip',
    r'()Ljava/lang/String;',
  );

  static final _getAddressZip = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddressZip()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressZip() {
    return _getAddressZip(
            reference.pointer, _id_getAddressZip as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getBirthDate = _class.instanceMethodId(
    r'getBirthDate',
    r'()Ljava/lang/String;',
  );

  static final _getBirthDate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getBirthDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBirthDate() {
    return _getBirthDate(
            reference.pointer, _id_getBirthDate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getDocumentType = _class.instanceMethodId(
    r'getDocumentType',
    r'()Ljava/lang/String;',
  );

  static final _getDocumentType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getDocumentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDocumentType() {
    return _getDocumentType(
            reference.pointer, _id_getDocumentType as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getExpiryDate = _class.instanceMethodId(
    r'getExpiryDate',
    r'()Ljava/lang/String;',
  );

  static final _getExpiryDate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getExpiryDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getExpiryDate() {
    return _getExpiryDate(
            reference.pointer, _id_getExpiryDate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getFirstName = _class.instanceMethodId(
    r'getFirstName',
    r'()Ljava/lang/String;',
  );

  static final _getFirstName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getFirstName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFirstName() {
    return _getFirstName(
            reference.pointer, _id_getFirstName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getGender = _class.instanceMethodId(
    r'getGender',
    r'()Ljava/lang/String;',
  );

  static final _getGender = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getGender()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getGender() {
    return _getGender(reference.pointer, _id_getGender as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getIssueDate = _class.instanceMethodId(
    r'getIssueDate',
    r'()Ljava/lang/String;',
  );

  static final _getIssueDate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getIssueDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getIssueDate() {
    return _getIssueDate(
            reference.pointer, _id_getIssueDate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getIssuingCountry = _class.instanceMethodId(
    r'getIssuingCountry',
    r'()Ljava/lang/String;',
  );

  static final _getIssuingCountry = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getIssuingCountry()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getIssuingCountry() {
    return _getIssuingCountry(
            reference.pointer, _id_getIssuingCountry as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getLastName = _class.instanceMethodId(
    r'getLastName',
    r'()Ljava/lang/String;',
  );

  static final _getLastName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLastName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLastName() {
    return _getLastName(reference.pointer, _id_getLastName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getLicenseNumber = _class.instanceMethodId(
    r'getLicenseNumber',
    r'()Ljava/lang/String;',
  );

  static final _getLicenseNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLicenseNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLicenseNumber() {
    return _getLicenseNumber(
            reference.pointer, _id_getLicenseNumber as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getMiddleName = _class.instanceMethodId(
    r'getMiddleName',
    r'()Ljava/lang/String;',
  );

  static final _getMiddleName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getMiddleName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMiddleName() {
    return _getMiddleName(
            reference.pointer, _id_getMiddleName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6, java.lang.String string7, java.lang.String string8, java.lang.String string9, java.lang.String string10, java.lang.String string11, java.lang.String string12, java.lang.String string13)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_DriverLicense(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
    jni.JString string7,
    jni.JString string8,
    jni.JString string9,
    jni.JString string10,
    jni.JString string11,
    jni.JString string12,
    jni.JString string13,
  ) {
    return Barcode_DriverLicense.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            string5.reference.pointer,
            string6.reference.pointer,
            string7.reference.pointer,
            string8.reference.pointer,
            string9.reference.pointer,
            string10.reference.pointer,
            string11.reference.pointer,
            string12.reference.pointer,
            string13.reference.pointer)
        .reference);
  }
}

final class $Barcode_DriverLicenseType
    extends jni.JObjType<Barcode_DriverLicense> {
  const $Barcode_DriverLicenseType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$DriverLicense;';

  @override
  Barcode_DriverLicense fromReference(jni.JReference reference) =>
      Barcode_DriverLicense.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_DriverLicenseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_DriverLicenseType) &&
        other is $Barcode_DriverLicenseType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Email$FormatType
class Barcode_Email_FormatType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Email_FormatType> $type = type;

  Barcode_Email_FormatType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Email$FormatType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Email_FormatTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Email_FormatTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_Email_FormatType.implement(
    $Barcode_Email_FormatTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Email_FormatType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$Email$FormatType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Email_FormatTypeImpl {
  factory $Barcode_Email_FormatTypeImpl() = _$Barcode_Email_FormatTypeImpl;
}

class _$Barcode_Email_FormatTypeImpl implements $Barcode_Email_FormatTypeImpl {
  _$Barcode_Email_FormatTypeImpl();
}

final class $Barcode_Email_FormatTypeType
    extends jni.JObjType<Barcode_Email_FormatType> {
  const $Barcode_Email_FormatTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Email$FormatType;';

  @override
  Barcode_Email_FormatType fromReference(jni.JReference reference) =>
      Barcode_Email_FormatType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Email_FormatTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Email_FormatTypeType) &&
        other is $Barcode_Email_FormatTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Email
class Barcode_Email extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Email> $type = type;

  Barcode_Email.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Email');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_EmailType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;
  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()I',
  );

  static final _getType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer, _id_getType as jni.JMethodIDPtr).integer;
  }

  static final _id_getAddress = _class.instanceMethodId(
    r'getAddress',
    r'()Ljava/lang/String;',
  );

  static final _getAddress = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddress()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddress() {
    return _getAddress(reference.pointer, _id_getAddress as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getBody = _class.instanceMethodId(
    r'getBody',
    r'()Ljava/lang/String;',
  );

  static final _getBody = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getBody()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBody() {
    return _getBody(reference.pointer, _id_getBody as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSubject = _class.instanceMethodId(
    r'getSubject',
    r'()Ljava/lang/String;',
  );

  static final _getSubject = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getSubject()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSubject() {
    return _getSubject(reference.pointer, _id_getSubject as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Email(
    int i,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return Barcode_Email.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            i,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer)
        .reference);
  }
}

final class $Barcode_EmailType extends jni.JObjType<Barcode_Email> {
  const $Barcode_EmailType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Email;';

  @override
  Barcode_Email fromReference(jni.JReference reference) =>
      Barcode_Email.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_EmailType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_EmailType) &&
        other is $Barcode_EmailType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$GeoPoint
class Barcode_GeoPoint extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_GeoPoint> $type = type;

  Barcode_GeoPoint.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$GeoPoint');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_GeoPointType();
  static final _id_getLat = _class.instanceMethodId(
    r'getLat',
    r'()D',
  );

  static final _getLat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public double getLat()
  double getLat() {
    return _getLat(reference.pointer, _id_getLat as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getLng = _class.instanceMethodId(
    r'getLng',
    r'()D',
  );

  static final _getLng = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public double getLng()
  double getLng() {
    return _getLng(reference.pointer, _id_getLng as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_new0 = _class.constructorId(
    r'(DD)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Double, ffi.Double)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double, double)>();

  /// from: public void <init>(double d, double d1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_GeoPoint(
    double d,
    double d1,
  ) {
    return Barcode_GeoPoint.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr, d, d1)
            .reference);
  }
}

final class $Barcode_GeoPointType extends jni.JObjType<Barcode_GeoPoint> {
  const $Barcode_GeoPointType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$GeoPoint;';

  @override
  Barcode_GeoPoint fromReference(jni.JReference reference) =>
      Barcode_GeoPoint.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_GeoPointType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_GeoPointType) &&
        other is $Barcode_GeoPointType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$PersonName
class Barcode_PersonName extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_PersonName> $type = type;

  Barcode_PersonName.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$PersonName');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_PersonNameType();
  static final _id_getFirst = _class.instanceMethodId(
    r'getFirst',
    r'()Ljava/lang/String;',
  );

  static final _getFirst = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getFirst()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFirst() {
    return _getFirst(reference.pointer, _id_getFirst as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getFormattedName = _class.instanceMethodId(
    r'getFormattedName',
    r'()Ljava/lang/String;',
  );

  static final _getFormattedName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getFormattedName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFormattedName() {
    return _getFormattedName(
            reference.pointer, _id_getFormattedName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getLast = _class.instanceMethodId(
    r'getLast',
    r'()Ljava/lang/String;',
  );

  static final _getLast = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLast()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLast() {
    return _getLast(reference.pointer, _id_getLast as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getMiddle = _class.instanceMethodId(
    r'getMiddle',
    r'()Ljava/lang/String;',
  );

  static final _getMiddle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getMiddle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMiddle() {
    return _getMiddle(reference.pointer, _id_getMiddle as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPrefix = _class.instanceMethodId(
    r'getPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getPrefix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPrefix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPrefix() {
    return _getPrefix(reference.pointer, _id_getPrefix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPronunciation = _class.instanceMethodId(
    r'getPronunciation',
    r'()Ljava/lang/String;',
  );

  static final _getPronunciation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPronunciation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPronunciation() {
    return _getPronunciation(
            reference.pointer, _id_getPronunciation as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSuffix = _class.instanceMethodId(
    r'getSuffix',
    r'()Ljava/lang/String;',
  );

  static final _getSuffix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getSuffix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSuffix() {
    return _getSuffix(reference.pointer, _id_getSuffix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_PersonName(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
  ) {
    return Barcode_PersonName.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            string5.reference.pointer,
            string6.reference.pointer)
        .reference);
  }
}

final class $Barcode_PersonNameType extends jni.JObjType<Barcode_PersonName> {
  const $Barcode_PersonNameType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$PersonName;';

  @override
  Barcode_PersonName fromReference(jni.JReference reference) =>
      Barcode_PersonName.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_PersonNameType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_PersonNameType) &&
        other is $Barcode_PersonNameType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Phone$FormatType
class Barcode_Phone_FormatType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Phone_FormatType> $type = type;

  Barcode_Phone_FormatType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Phone$FormatType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Phone_FormatTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Phone_FormatTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_Phone_FormatType.implement(
    $Barcode_Phone_FormatTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Phone_FormatType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$Phone$FormatType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Phone_FormatTypeImpl {
  factory $Barcode_Phone_FormatTypeImpl() = _$Barcode_Phone_FormatTypeImpl;
}

class _$Barcode_Phone_FormatTypeImpl implements $Barcode_Phone_FormatTypeImpl {
  _$Barcode_Phone_FormatTypeImpl();
}

final class $Barcode_Phone_FormatTypeType
    extends jni.JObjType<Barcode_Phone_FormatType> {
  const $Barcode_Phone_FormatTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Phone$FormatType;';

  @override
  Barcode_Phone_FormatType fromReference(jni.JReference reference) =>
      Barcode_Phone_FormatType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Phone_FormatTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Phone_FormatTypeType) &&
        other is $Barcode_Phone_FormatTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Phone
class Barcode_Phone extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Phone> $type = type;

  Barcode_Phone.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Phone');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_PhoneType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;

  /// from: static public final int TYPE_FAX
  static const TYPE_FAX = 3;

  /// from: static public final int TYPE_MOBILE
  static const TYPE_MOBILE = 4;
  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()I',
  );

  static final _getType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer, _id_getType as jni.JMethodIDPtr).integer;
  }

  static final _id_getNumber = _class.instanceMethodId(
    r'getNumber',
    r'()Ljava/lang/String;',
  );

  static final _getNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getNumber() {
    return _getNumber(reference.pointer, _id_getNumber as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;I)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Phone(
    jni.JString string,
    int i,
  ) {
    return Barcode_Phone.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, string.reference.pointer, i)
        .reference);
  }
}

final class $Barcode_PhoneType extends jni.JObjType<Barcode_Phone> {
  const $Barcode_PhoneType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Phone;';

  @override
  Barcode_Phone fromReference(jni.JReference reference) =>
      Barcode_Phone.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_PhoneType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_PhoneType) &&
        other is $Barcode_PhoneType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Sms
class Barcode_Sms extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Sms> $type = type;

  Barcode_Sms.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/barcode/common/Barcode$Sms');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_SmsType();
  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getMessage()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMessage() {
    return _getMessage(reference.pointer, _id_getMessage as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPhoneNumber = _class.instanceMethodId(
    r'getPhoneNumber',
    r'()Ljava/lang/String;',
  );

  static final _getPhoneNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPhoneNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPhoneNumber() {
    return _getPhoneNumber(
            reference.pointer, _id_getPhoneNumber as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Sms(
    jni.JString string,
    jni.JString string1,
  ) {
    return Barcode_Sms.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .reference);
  }
}

final class $Barcode_SmsType extends jni.JObjType<Barcode_Sms> {
  const $Barcode_SmsType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Sms;';

  @override
  Barcode_Sms fromReference(jni.JReference reference) =>
      Barcode_Sms.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_SmsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_SmsType) && other is $Barcode_SmsType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$UrlBookmark
class Barcode_UrlBookmark extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_UrlBookmark> $type = type;

  Barcode_UrlBookmark.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$UrlBookmark');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_UrlBookmarkType();
  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/String;',
  );

  static final _getTitle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getUrl = _class.instanceMethodId(
    r'getUrl',
    r'()Ljava/lang/String;',
  );

  static final _getUrl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUrl() {
    return _getUrl(reference.pointer, _id_getUrl as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_UrlBookmark(
    jni.JString string,
    jni.JString string1,
  ) {
    return Barcode_UrlBookmark.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .reference);
  }
}

final class $Barcode_UrlBookmarkType extends jni.JObjType<Barcode_UrlBookmark> {
  const $Barcode_UrlBookmarkType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$UrlBookmark;';

  @override
  Barcode_UrlBookmark fromReference(jni.JReference reference) =>
      Barcode_UrlBookmark.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_UrlBookmarkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_UrlBookmarkType) &&
        other is $Barcode_UrlBookmarkType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$WiFi$EncryptionType
class Barcode_WiFi_EncryptionType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_WiFi_EncryptionType> $type = type;

  Barcode_WiFi_EncryptionType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$WiFi$EncryptionType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_WiFi_EncryptionTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_WiFi_EncryptionTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_WiFi_EncryptionType.implement(
    $Barcode_WiFi_EncryptionTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_WiFi_EncryptionType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$WiFi$EncryptionType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_WiFi_EncryptionTypeImpl {
  factory $Barcode_WiFi_EncryptionTypeImpl() =
      _$Barcode_WiFi_EncryptionTypeImpl;
}

class _$Barcode_WiFi_EncryptionTypeImpl
    implements $Barcode_WiFi_EncryptionTypeImpl {
  _$Barcode_WiFi_EncryptionTypeImpl();
}

final class $Barcode_WiFi_EncryptionTypeType
    extends jni.JObjType<Barcode_WiFi_EncryptionType> {
  const $Barcode_WiFi_EncryptionTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi$EncryptionType;';

  @override
  Barcode_WiFi_EncryptionType fromReference(jni.JReference reference) =>
      Barcode_WiFi_EncryptionType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_WiFi_EncryptionTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_WiFi_EncryptionTypeType) &&
        other is $Barcode_WiFi_EncryptionTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$WiFi
class Barcode_WiFi extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_WiFi> $type = type;

  Barcode_WiFi.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$WiFi');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_WiFiType();

  /// from: static public final int TYPE_OPEN
  static const TYPE_OPEN = 1;

  /// from: static public final int TYPE_WPA
  static const TYPE_WPA = 2;

  /// from: static public final int TYPE_WEP
  static const TYPE_WEP = 3;
  static final _id_getEncryptionType = _class.instanceMethodId(
    r'getEncryptionType',
    r'()I',
  );

  static final _getEncryptionType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getEncryptionType()
  int getEncryptionType() {
    return _getEncryptionType(
            reference.pointer, _id_getEncryptionType as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPassword = _class.instanceMethodId(
    r'getPassword',
    r'()Ljava/lang/String;',
  );

  static final _getPassword = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPassword()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPassword() {
    return _getPassword(reference.pointer, _id_getPassword as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSsid = _class.instanceMethodId(
    r'getSsid',
    r'()Ljava/lang/String;',
  );

  static final _getSsid = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getSsid()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSsid() {
    return _getSsid(reference.pointer, _id_getSsid as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;I)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_WiFi(
    jni.JString string,
    jni.JString string1,
    int i,
  ) {
    return Barcode_WiFi.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            i)
        .reference);
  }
}

final class $Barcode_WiFiType extends jni.JObjType<Barcode_WiFi> {
  const $Barcode_WiFiType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi;';

  @override
  Barcode_WiFi fromReference(jni.JReference reference) =>
      Barcode_WiFi.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_WiFiType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_WiFiType) &&
        other is $Barcode_WiFiType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode
class Barcode extends jni.JObject {
  @override
  late final jni.JObjType<Barcode> $type = type;

  Barcode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/barcode/common/Barcode');

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeType();

  /// from: static public final int FORMAT_UNKNOWN
  static const FORMAT_UNKNOWN = -1;

  /// from: static public final int FORMAT_ALL_FORMATS
  static const FORMAT_ALL_FORMATS = 0;

  /// from: static public final int FORMAT_CODE_128
  static const FORMAT_CODE_128 = 1;

  /// from: static public final int FORMAT_CODE_39
  static const FORMAT_CODE_39 = 2;

  /// from: static public final int FORMAT_CODE_93
  static const FORMAT_CODE_93 = 4;

  /// from: static public final int FORMAT_CODABAR
  static const FORMAT_CODABAR = 8;

  /// from: static public final int FORMAT_DATA_MATRIX
  static const FORMAT_DATA_MATRIX = 16;

  /// from: static public final int FORMAT_EAN_13
  static const FORMAT_EAN_13 = 32;

  /// from: static public final int FORMAT_EAN_8
  static const FORMAT_EAN_8 = 64;

  /// from: static public final int FORMAT_ITF
  static const FORMAT_ITF = 128;

  /// from: static public final int FORMAT_QR_CODE
  static const FORMAT_QR_CODE = 256;

  /// from: static public final int FORMAT_UPC_A
  static const FORMAT_UPC_A = 512;

  /// from: static public final int FORMAT_UPC_E
  static const FORMAT_UPC_E = 1024;

  /// from: static public final int FORMAT_PDF417
  static const FORMAT_PDF417 = 2048;

  /// from: static public final int FORMAT_AZTEC
  static const FORMAT_AZTEC = 4096;

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_CONTACT_INFO
  static const TYPE_CONTACT_INFO = 1;

  /// from: static public final int TYPE_EMAIL
  static const TYPE_EMAIL = 2;

  /// from: static public final int TYPE_ISBN
  static const TYPE_ISBN = 3;

  /// from: static public final int TYPE_PHONE
  static const TYPE_PHONE = 4;

  /// from: static public final int TYPE_PRODUCT
  static const TYPE_PRODUCT = 5;

  /// from: static public final int TYPE_SMS
  static const TYPE_SMS = 6;

  /// from: static public final int TYPE_TEXT
  static const TYPE_TEXT = 7;

  /// from: static public final int TYPE_URL
  static const TYPE_URL = 8;

  /// from: static public final int TYPE_WIFI
  static const TYPE_WIFI = 9;

  /// from: static public final int TYPE_GEO
  static const TYPE_GEO = 10;

  /// from: static public final int TYPE_CALENDAR_EVENT
  static const TYPE_CALENDAR_EVENT = 11;

  /// from: static public final int TYPE_DRIVER_LICENSE
  static const TYPE_DRIVER_LICENSE = 12;
  static final _id_getFormat = _class.instanceMethodId(
    r'getFormat',
    r'()I',
  );

  static final _getFormat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getFormat()
  int getFormat() {
    return _getFormat(reference.pointer, _id_getFormat as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getValueType = _class.instanceMethodId(
    r'getValueType',
    r'()I',
  );

  static final _getValueType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getValueType()
  int getValueType() {
    return _getValueType(
            reference.pointer, _id_getValueType as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getBoundingBox = _class.instanceMethodId(
    r'getBoundingBox',
    r'()Landroid/graphics/Rect;',
  );

  static final _getBoundingBox = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Rect getBoundingBox()
  /// The returned object must be released after use, by calling the [release] method.
  rect_.Rect getBoundingBox() {
    return _getBoundingBox(
            reference.pointer, _id_getBoundingBox as jni.JMethodIDPtr)
        .object(const rect_.$RectType());
  }

  static final _id_getCalendarEvent = _class.instanceMethodId(
    r'getCalendarEvent',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarEvent;',
  );

  static final _getCalendarEvent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarEvent getCalendarEvent()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarEvent getCalendarEvent() {
    return _getCalendarEvent(
            reference.pointer, _id_getCalendarEvent as jni.JMethodIDPtr)
        .object(const $Barcode_CalendarEventType());
  }

  static final _id_getContactInfo = _class.instanceMethodId(
    r'getContactInfo',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$ContactInfo;',
  );

  static final _getContactInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$ContactInfo getContactInfo()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_ContactInfo getContactInfo() {
    return _getContactInfo(
            reference.pointer, _id_getContactInfo as jni.JMethodIDPtr)
        .object(const $Barcode_ContactInfoType());
  }

  static final _id_getDriverLicense = _class.instanceMethodId(
    r'getDriverLicense',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$DriverLicense;',
  );

  static final _getDriverLicense = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$DriverLicense getDriverLicense()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_DriverLicense getDriverLicense() {
    return _getDriverLicense(
            reference.pointer, _id_getDriverLicense as jni.JMethodIDPtr)
        .object(const $Barcode_DriverLicenseType());
  }

  static final _id_getEmail = _class.instanceMethodId(
    r'getEmail',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$Email;',
  );

  static final _getEmail = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Email getEmail()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Email getEmail() {
    return _getEmail(reference.pointer, _id_getEmail as jni.JMethodIDPtr)
        .object(const $Barcode_EmailType());
  }

  static final _id_getGeoPoint = _class.instanceMethodId(
    r'getGeoPoint',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$GeoPoint;',
  );

  static final _getGeoPoint = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$GeoPoint getGeoPoint()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_GeoPoint getGeoPoint() {
    return _getGeoPoint(reference.pointer, _id_getGeoPoint as jni.JMethodIDPtr)
        .object(const $Barcode_GeoPointType());
  }

  static final _id_getPhone = _class.instanceMethodId(
    r'getPhone',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$Phone;',
  );

  static final _getPhone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Phone getPhone()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Phone getPhone() {
    return _getPhone(reference.pointer, _id_getPhone as jni.JMethodIDPtr)
        .object(const $Barcode_PhoneType());
  }

  static final _id_getSms = _class.instanceMethodId(
    r'getSms',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$Sms;',
  );

  static final _getSms = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Sms getSms()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Sms getSms() {
    return _getSms(reference.pointer, _id_getSms as jni.JMethodIDPtr)
        .object(const $Barcode_SmsType());
  }

  static final _id_getUrl = _class.instanceMethodId(
    r'getUrl',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$UrlBookmark;',
  );

  static final _getUrl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$UrlBookmark getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_UrlBookmark getUrl() {
    return _getUrl(reference.pointer, _id_getUrl as jni.JMethodIDPtr)
        .object(const $Barcode_UrlBookmarkType());
  }

  static final _id_getWifi = _class.instanceMethodId(
    r'getWifi',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi;',
  );

  static final _getWifi = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$WiFi getWifi()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_WiFi getWifi() {
    return _getWifi(reference.pointer, _id_getWifi as jni.JMethodIDPtr)
        .object(const $Barcode_WiFiType());
  }

  static final _id_getDisplayValue = _class.instanceMethodId(
    r'getDisplayValue',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getDisplayValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDisplayValue() {
    return _getDisplayValue(
            reference.pointer, _id_getDisplayValue as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getRawValue = _class.instanceMethodId(
    r'getRawValue',
    r'()Ljava/lang/String;',
  );

  static final _getRawValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getRawValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRawValue() {
    return _getRawValue(reference.pointer, _id_getRawValue as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lcom/google/mlkit/vision/barcode/common/internal/BarcodeSource;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.internal.BarcodeSource barcodeSource)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode(
    jni.JObject barcodeSource,
  ) {
    return Barcode.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, barcodeSource.reference.pointer)
        .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Lcom/google/mlkit/vision/barcode/common/internal/BarcodeSource;Landroid/graphics/Matrix;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.internal.BarcodeSource barcodeSource, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode.new1(
    jni.JObject barcodeSource,
    jni.JObject matrix,
  ) {
    return Barcode.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            barcodeSource.reference.pointer,
            matrix.reference.pointer)
        .reference);
  }

  static final _id_getRawBytes = _class.instanceMethodId(
    r'getRawBytes',
    r'()[B',
  );

  static final _getRawBytes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public byte[] getRawBytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getRawBytes() {
    return _getRawBytes(reference.pointer, _id_getRawBytes as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_getCornerPoints = _class.instanceMethodId(
    r'getCornerPoints',
    r'()[Landroid/graphics/Point;',
  );

  static final _getCornerPoints = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Point[] getCornerPoints()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<point_.Point> getCornerPoints() {
    return _getCornerPoints(
            reference.pointer, _id_getCornerPoints as jni.JMethodIDPtr)
        .object(const jni.JArrayType(point_.$PointType()));
  }
}

final class $BarcodeType extends jni.JObjType<Barcode> {
  const $BarcodeType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/barcode/common/Barcode;';

  @override
  Barcode fromReference(jni.JReference reference) =>
      Barcode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeType) && other is $BarcodeType;
  }
}
