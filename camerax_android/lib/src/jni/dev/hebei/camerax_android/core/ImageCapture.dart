// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'ImageProxy.dart' as imageproxy$_;

/// from: `dev.hebei.camerax_android.core.ImageCapture$CaptureMode`
class ImageCapture$CaptureMode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$CaptureMode> $type;

  @jni$_.internal
  ImageCapture$CaptureMode.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$CaptureMode');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$CaptureMode$NullableType();
  static const type = $ImageCapture$CaptureMode$Type();
  static final _id_MAXIMIZE_QUALITY = _class.staticFieldId(
    r'MAXIMIZE_QUALITY',
    r'Ldev/hebei/camerax_android/core/ImageCapture$CaptureMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.ImageCapture$CaptureMode MAXIMIZE_QUALITY`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$CaptureMode? get MAXIMIZE_QUALITY => _id_MAXIMIZE_QUALITY
      .get(_class, const $ImageCapture$CaptureMode$NullableType());

  static final _id_MINIMIZE_LATENCY = _class.staticFieldId(
    r'MINIMIZE_LATENCY',
    r'Ldev/hebei/camerax_android/core/ImageCapture$CaptureMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.ImageCapture$CaptureMode MINIMIZE_LATENCY`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$CaptureMode? get MINIMIZE_LATENCY => _id_MINIMIZE_LATENCY
      .get(_class, const $ImageCapture$CaptureMode$NullableType());

  static final _id_ZERO_SHUTTER_LAG = _class.staticFieldId(
    r'ZERO_SHUTTER_LAG',
    r'Ldev/hebei/camerax_android/core/ImageCapture$CaptureMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.ImageCapture$CaptureMode ZERO_SHUTTER_LAG`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$CaptureMode? get ZERO_SHUTTER_LAG => _id_ZERO_SHUTTER_LAG
      .get(_class, const $ImageCapture$CaptureMode$NullableType());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ldev/hebei/camerax_android/core/ImageCapture$CaptureMode;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public dev.hebei.camerax_android.core.ImageCapture$CaptureMode[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<ImageCapture$CaptureMode?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<ImageCapture$CaptureMode?>?>(
            const jni$_.JArrayNullableType<ImageCapture$CaptureMode?>(
                $ImageCapture$CaptureMode$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ldev/hebei/camerax_android/core/ImageCapture$CaptureMode;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public dev.hebei.camerax_android.core.ImageCapture$CaptureMode valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$CaptureMode? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<ImageCapture$CaptureMode?>(
            const $ImageCapture$CaptureMode$NullableType());
  }
}

final class $ImageCapture$CaptureMode$NullableType
    extends jni$_.JObjType<ImageCapture$CaptureMode?> {
  @jni$_.internal
  const $ImageCapture$CaptureMode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$CaptureMode;';

  @jni$_.internal
  @core$_.override
  ImageCapture$CaptureMode? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$CaptureMode.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$CaptureMode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$CaptureMode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$CaptureMode$NullableType) &&
        other is $ImageCapture$CaptureMode$NullableType;
  }
}

final class $ImageCapture$CaptureMode$Type
    extends jni$_.JObjType<ImageCapture$CaptureMode> {
  @jni$_.internal
  const $ImageCapture$CaptureMode$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$CaptureMode;';

  @jni$_.internal
  @core$_.override
  ImageCapture$CaptureMode fromReference(jni$_.JReference reference) =>
      ImageCapture$CaptureMode.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$CaptureMode?> get nullableType =>
      const $ImageCapture$CaptureMode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$CaptureMode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$CaptureMode$Type) &&
        other is $ImageCapture$CaptureMode$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$FlashMode`
class ImageCapture$FlashMode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$FlashMode> $type;

  @jni$_.internal
  ImageCapture$FlashMode.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$FlashMode');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$FlashMode$NullableType();
  static const type = $ImageCapture$FlashMode$Type();
  static final _id_AUTO = _class.staticFieldId(
    r'AUTO',
    r'Ldev/hebei/camerax_android/core/ImageCapture$FlashMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.ImageCapture$FlashMode AUTO`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$FlashMode? get AUTO =>
      _id_AUTO.get(_class, const $ImageCapture$FlashMode$NullableType());

  static final _id_ON = _class.staticFieldId(
    r'ON',
    r'Ldev/hebei/camerax_android/core/ImageCapture$FlashMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.ImageCapture$FlashMode ON`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$FlashMode? get ON =>
      _id_ON.get(_class, const $ImageCapture$FlashMode$NullableType());

  static final _id_OFF = _class.staticFieldId(
    r'OFF',
    r'Ldev/hebei/camerax_android/core/ImageCapture$FlashMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.ImageCapture$FlashMode OFF`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$FlashMode? get OFF =>
      _id_OFF.get(_class, const $ImageCapture$FlashMode$NullableType());

  static final _id_SCREEN = _class.staticFieldId(
    r'SCREEN',
    r'Ldev/hebei/camerax_android/core/ImageCapture$FlashMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.ImageCapture$FlashMode SCREEN`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$FlashMode? get SCREEN =>
      _id_SCREEN.get(_class, const $ImageCapture$FlashMode$NullableType());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ldev/hebei/camerax_android/core/ImageCapture$FlashMode;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public dev.hebei.camerax_android.core.ImageCapture$FlashMode[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<ImageCapture$FlashMode?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<ImageCapture$FlashMode?>?>(
            const jni$_.JArrayNullableType<ImageCapture$FlashMode?>(
                $ImageCapture$FlashMode$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ldev/hebei/camerax_android/core/ImageCapture$FlashMode;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public dev.hebei.camerax_android.core.ImageCapture$FlashMode valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$FlashMode? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<ImageCapture$FlashMode?>(
            const $ImageCapture$FlashMode$NullableType());
  }
}

final class $ImageCapture$FlashMode$NullableType
    extends jni$_.JObjType<ImageCapture$FlashMode?> {
  @jni$_.internal
  const $ImageCapture$FlashMode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$FlashMode;';

  @jni$_.internal
  @core$_.override
  ImageCapture$FlashMode? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$FlashMode.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$FlashMode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$FlashMode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$FlashMode$NullableType) &&
        other is $ImageCapture$FlashMode$NullableType;
  }
}

final class $ImageCapture$FlashMode$Type
    extends jni$_.JObjType<ImageCapture$FlashMode> {
  @jni$_.internal
  const $ImageCapture$FlashMode$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$FlashMode;';

  @jni$_.internal
  @core$_.override
  ImageCapture$FlashMode fromReference(jni$_.JReference reference) =>
      ImageCapture$FlashMode.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$FlashMode?> get nullableType =>
      const $ImageCapture$FlashMode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$FlashMode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$FlashMode$Type) &&
        other is $ImageCapture$FlashMode$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$Metadata`
class ImageCapture$Metadata extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$Metadata> $type;

  @jni$_.internal
  ImageCapture$Metadata.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$Metadata');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$Metadata$NullableType();
  static const type = $ImageCapture$Metadata$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/camera/core/ImageCapture$Metadata;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.camera.core.ImageCapture$Metadata metadata)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$Metadata(
    jni$_.JObject metadata,
  ) {
    final _$metadata = metadata.reference;
    return ImageCapture$Metadata.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$metadata.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'()V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$Metadata.new$1() {
    return ImageCapture$Metadata.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getLocation = _class.instanceMethodId(
    r'getLocation',
    r'()Landroid/location/Location;',
  );

  static final _getLocation = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final android.location.Location getLocation()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLocation() {
    return _getLocation(
            reference.pointer, _id_getLocation as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setLocation = _class.instanceMethodId(
    r'setLocation',
    r'(Landroid/location/Location;)V',
  );

  static final _setLocation = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setLocation(android.location.Location location)`
  void setLocation(
    jni$_.JObject? location,
  ) {
    final _$location = location?.reference ?? jni$_.jNullReference;
    _setLocation(reference.pointer, _id_setLocation as jni$_.JMethodIDPtr,
            _$location.pointer)
        .check();
  }

  static final _id_isReversedHorizontal = _class.instanceMethodId(
    r'isReversedHorizontal',
    r'()Z',
  );

  static final _isReversedHorizontal = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean isReversedHorizontal()`
  bool isReversedHorizontal() {
    return _isReversedHorizontal(
            reference.pointer, _id_isReversedHorizontal as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setReversedHorizontal = _class.instanceMethodId(
    r'setReversedHorizontal',
    r'(Z)V',
  );

  static final _setReversedHorizontal = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final void setReversedHorizontal(boolean z)`
  void setReversedHorizontal(
    bool z,
  ) {
    _setReversedHorizontal(reference.pointer,
            _id_setReversedHorizontal as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isReversedVertical = _class.instanceMethodId(
    r'isReversedVertical',
    r'()Z',
  );

  static final _isReversedVertical = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean isReversedVertical()`
  bool isReversedVertical() {
    return _isReversedVertical(
            reference.pointer, _id_isReversedVertical as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setReversedVertical = _class.instanceMethodId(
    r'setReversedVertical',
    r'(Z)V',
  );

  static final _setReversedVertical = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final void setReversedVertical(boolean z)`
  void setReversedVertical(
    bool z,
  ) {
    _setReversedVertical(reference.pointer,
            _id_setReversedVertical as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }
}

final class $ImageCapture$Metadata$NullableType
    extends jni$_.JObjType<ImageCapture$Metadata?> {
  @jni$_.internal
  const $ImageCapture$Metadata$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$Metadata;';

  @jni$_.internal
  @core$_.override
  ImageCapture$Metadata? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$Metadata.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$Metadata?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Metadata$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Metadata$NullableType) &&
        other is $ImageCapture$Metadata$NullableType;
  }
}

final class $ImageCapture$Metadata$Type
    extends jni$_.JObjType<ImageCapture$Metadata> {
  @jni$_.internal
  const $ImageCapture$Metadata$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$Metadata;';

  @jni$_.internal
  @core$_.override
  ImageCapture$Metadata fromReference(jni$_.JReference reference) =>
      ImageCapture$Metadata.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$Metadata?> get nullableType =>
      const $ImageCapture$Metadata$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Metadata$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Metadata$Type) &&
        other is $ImageCapture$Metadata$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$OnImageCapturedCallback$Stub`
class ImageCapture$OnImageCapturedCallback$Stub extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OnImageCapturedCallback$Stub> $type;

  @jni$_.internal
  ImageCapture$OnImageCapturedCallback$Stub.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$OnImageCapturedCallback$Stub');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $ImageCapture$OnImageCapturedCallback$Stub$NullableType();
  static const type = $ImageCapture$OnImageCapturedCallback$Stub$Type();
  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCaptureStarted()`
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract void onCaptureProcessProgressed(int i)`
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)`
  void onPostviewBitmapAvailable(
    jni$_.JObject bitmap,
  ) {
    final _$bitmap = bitmap.reference;
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni$_.JMethodIDPtr,
            _$bitmap.pointer)
        .check();
  }

  static final _id_onCaptureSuccess = _class.instanceMethodId(
    r'onCaptureSuccess',
    r'(Ldev/hebei/camerax_android/core/ImageProxy;)V',
  );

  static final _onCaptureSuccess = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onCaptureSuccess(dev.hebei.camerax_android.core.ImageProxy imageProxy)`
  void onCaptureSuccess(
    imageproxy$_.ImageProxy imageProxy,
  ) {
    final _$imageProxy = imageProxy.reference;
    _onCaptureSuccess(reference.pointer,
            _id_onCaptureSuccess as jni$_.JMethodIDPtr, _$imageProxy.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/Exception;)V',
  );

  static final _onError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onError(java.lang.Exception exception)`
  void onError(
    jni$_.JObject exception,
  ) {
    final _$exception = exception.reference;
    _onError(reference.pointer, _id_onError as jni$_.JMethodIDPtr,
            _$exception.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ImageCapture$OnImageCapturedCallback$Stub>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCaptureStarted()V') {
        _$impls[$p]!.onCaptureStarted();
        return jni$_.nullptr;
      }
      if ($d == r'onCaptureProcessProgressed(I)V') {
        _$impls[$p]!.onCaptureProcessProgressed(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'onPostviewBitmapAvailable(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onPostviewBitmapAvailable(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onCaptureSuccess(Ldev/hebei/camerax_android/core/ImageProxy;)V') {
        _$impls[$p]!.onCaptureSuccess(
          $a![0]!
              .as(const imageproxy$_.$ImageProxy$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'onError(Ljava/lang/Exception;)V') {
        _$impls[$p]!.onError(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ImageCapture$OnImageCapturedCallback$Stub $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'dev.hebei.camerax_android.core.ImageCapture$OnImageCapturedCallback$Stub',
      $p,
      _$invokePointer,
      [
        if ($impl.onCaptureStarted$async) r'onCaptureStarted()V',
        if ($impl.onCaptureProcessProgressed$async)
          r'onCaptureProcessProgressed(I)V',
        if ($impl.onPostviewBitmapAvailable$async)
          r'onPostviewBitmapAvailable(Landroid/graphics/Bitmap;)V',
        if ($impl.onCaptureSuccess$async)
          r'onCaptureSuccess(Ldev/hebei/camerax_android/core/ImageProxy;)V',
        if ($impl.onError$async) r'onError(Ljava/lang/Exception;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ImageCapture$OnImageCapturedCallback$Stub.implement(
    $ImageCapture$OnImageCapturedCallback$Stub $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ImageCapture$OnImageCapturedCallback$Stub.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ImageCapture$OnImageCapturedCallback$Stub {
  factory $ImageCapture$OnImageCapturedCallback$Stub({
    required void Function() onCaptureStarted,
    bool onCaptureStarted$async,
    required void Function(int i) onCaptureProcessProgressed,
    bool onCaptureProcessProgressed$async,
    required void Function(jni$_.JObject bitmap) onPostviewBitmapAvailable,
    bool onPostviewBitmapAvailable$async,
    required void Function(imageproxy$_.ImageProxy imageProxy) onCaptureSuccess,
    bool onCaptureSuccess$async,
    required void Function(jni$_.JObject exception) onError,
    bool onError$async,
  }) = _$ImageCapture$OnImageCapturedCallback$Stub;

  void onCaptureStarted();
  bool get onCaptureStarted$async => false;
  void onCaptureProcessProgressed(int i);
  bool get onCaptureProcessProgressed$async => false;
  void onPostviewBitmapAvailable(jni$_.JObject bitmap);
  bool get onPostviewBitmapAvailable$async => false;
  void onCaptureSuccess(imageproxy$_.ImageProxy imageProxy);
  bool get onCaptureSuccess$async => false;
  void onError(jni$_.JObject exception);
  bool get onError$async => false;
}

final class _$ImageCapture$OnImageCapturedCallback$Stub
    with $ImageCapture$OnImageCapturedCallback$Stub {
  _$ImageCapture$OnImageCapturedCallback$Stub({
    required void Function() onCaptureStarted,
    this.onCaptureStarted$async = false,
    required void Function(int i) onCaptureProcessProgressed,
    this.onCaptureProcessProgressed$async = false,
    required void Function(jni$_.JObject bitmap) onPostviewBitmapAvailable,
    this.onPostviewBitmapAvailable$async = false,
    required void Function(imageproxy$_.ImageProxy imageProxy) onCaptureSuccess,
    this.onCaptureSuccess$async = false,
    required void Function(jni$_.JObject exception) onError,
    this.onError$async = false,
  })  : _onCaptureStarted = onCaptureStarted,
        _onCaptureProcessProgressed = onCaptureProcessProgressed,
        _onPostviewBitmapAvailable = onPostviewBitmapAvailable,
        _onCaptureSuccess = onCaptureSuccess,
        _onError = onError;

  final void Function() _onCaptureStarted;
  final bool onCaptureStarted$async;
  final void Function(int i) _onCaptureProcessProgressed;
  final bool onCaptureProcessProgressed$async;
  final void Function(jni$_.JObject bitmap) _onPostviewBitmapAvailable;
  final bool onPostviewBitmapAvailable$async;
  final void Function(imageproxy$_.ImageProxy imageProxy) _onCaptureSuccess;
  final bool onCaptureSuccess$async;
  final void Function(jni$_.JObject exception) _onError;
  final bool onError$async;

  void onCaptureStarted() {
    return _onCaptureStarted();
  }

  void onCaptureProcessProgressed(int i) {
    return _onCaptureProcessProgressed(i);
  }

  void onPostviewBitmapAvailable(jni$_.JObject bitmap) {
    return _onPostviewBitmapAvailable(bitmap);
  }

  void onCaptureSuccess(imageproxy$_.ImageProxy imageProxy) {
    return _onCaptureSuccess(imageProxy);
  }

  void onError(jni$_.JObject exception) {
    return _onError(exception);
  }
}

final class $ImageCapture$OnImageCapturedCallback$Stub$NullableType
    extends jni$_.JObjType<ImageCapture$OnImageCapturedCallback$Stub?> {
  @jni$_.internal
  const $ImageCapture$OnImageCapturedCallback$Stub$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OnImageCapturedCallback$Stub;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageCapturedCallback$Stub? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$OnImageCapturedCallback$Stub.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageCapturedCallback$Stub?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OnImageCapturedCallback$Stub$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OnImageCapturedCallback$Stub$NullableType) &&
        other is $ImageCapture$OnImageCapturedCallback$Stub$NullableType;
  }
}

final class $ImageCapture$OnImageCapturedCallback$Stub$Type
    extends jni$_.JObjType<ImageCapture$OnImageCapturedCallback$Stub> {
  @jni$_.internal
  const $ImageCapture$OnImageCapturedCallback$Stub$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OnImageCapturedCallback$Stub;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageCapturedCallback$Stub fromReference(
          jni$_.JReference reference) =>
      ImageCapture$OnImageCapturedCallback$Stub.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageCapturedCallback$Stub?> get nullableType =>
      const $ImageCapture$OnImageCapturedCallback$Stub$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OnImageCapturedCallback$Stub$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OnImageCapturedCallback$Stub$Type) &&
        other is $ImageCapture$OnImageCapturedCallback$Stub$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$OnImageCapturedCallback`
class ImageCapture$OnImageCapturedCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OnImageCapturedCallback> $type;

  @jni$_.internal
  ImageCapture$OnImageCapturedCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$OnImageCapturedCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $ImageCapture$OnImageCapturedCallback$NullableType();
  static const type = $ImageCapture$OnImageCapturedCallback$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/camera/core/ImageCapture$OnImageCapturedCallback;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.camera.core.ImageCapture$OnImageCapturedCallback onImageCapturedCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OnImageCapturedCallback(
    jni$_.JObject onImageCapturedCallback,
  ) {
    final _$onImageCapturedCallback = onImageCapturedCallback.reference;
    return ImageCapture$OnImageCapturedCallback.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$onImageCapturedCallback.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ldev/hebei/camerax_android/core/ImageCapture$OnImageCapturedCallback$Stub;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(dev.hebei.camerax_android.core.ImageCapture$OnImageCapturedCallback$Stub stub)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OnImageCapturedCallback.new$1(
    ImageCapture$OnImageCapturedCallback$Stub stub,
  ) {
    final _$stub = stub.reference;
    return ImageCapture$OnImageCapturedCallback.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$stub.pointer)
        .reference);
  }
}

final class $ImageCapture$OnImageCapturedCallback$NullableType
    extends jni$_.JObjType<ImageCapture$OnImageCapturedCallback?> {
  @jni$_.internal
  const $ImageCapture$OnImageCapturedCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OnImageCapturedCallback;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageCapturedCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$OnImageCapturedCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageCapturedCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OnImageCapturedCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OnImageCapturedCallback$NullableType) &&
        other is $ImageCapture$OnImageCapturedCallback$NullableType;
  }
}

final class $ImageCapture$OnImageCapturedCallback$Type
    extends jni$_.JObjType<ImageCapture$OnImageCapturedCallback> {
  @jni$_.internal
  const $ImageCapture$OnImageCapturedCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OnImageCapturedCallback;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageCapturedCallback fromReference(
          jni$_.JReference reference) =>
      ImageCapture$OnImageCapturedCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageCapturedCallback?> get nullableType =>
      const $ImageCapture$OnImageCapturedCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OnImageCapturedCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$OnImageCapturedCallback$Type) &&
        other is $ImageCapture$OnImageCapturedCallback$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$OnImageSavedCallback$Stub`
class ImageCapture$OnImageSavedCallback$Stub extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OnImageSavedCallback$Stub> $type;

  @jni$_.internal
  ImageCapture$OnImageSavedCallback$Stub.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$OnImageSavedCallback$Stub');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $ImageCapture$OnImageSavedCallback$Stub$NullableType();
  static const type = $ImageCapture$OnImageSavedCallback$Stub$Type();
  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCaptureStarted()`
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract void onCaptureProcessProgressed(int i)`
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)`
  void onPostviewBitmapAvailable(
    jni$_.JObject bitmap,
  ) {
    final _$bitmap = bitmap.reference;
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni$_.JMethodIDPtr,
            _$bitmap.pointer)
        .check();
  }

  static final _id_onImageSaved = _class.instanceMethodId(
    r'onImageSaved',
    r'(Ldev/hebei/camerax_android/core/ImageCapture$OutputFileResults;)V',
  );

  static final _onImageSaved = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onImageSaved(dev.hebei.camerax_android.core.ImageCapture$OutputFileResults outputFileResults)`
  void onImageSaved(
    ImageCapture$OutputFileResults outputFileResults,
  ) {
    final _$outputFileResults = outputFileResults.reference;
    _onImageSaved(reference.pointer, _id_onImageSaved as jni$_.JMethodIDPtr,
            _$outputFileResults.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/lang/Exception;)V',
  );

  static final _onError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onError(java.lang.Exception exception)`
  void onError(
    jni$_.JObject exception,
  ) {
    final _$exception = exception.reference;
    _onError(reference.pointer, _id_onError as jni$_.JMethodIDPtr,
            _$exception.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ImageCapture$OnImageSavedCallback$Stub>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCaptureStarted()V') {
        _$impls[$p]!.onCaptureStarted();
        return jni$_.nullptr;
      }
      if ($d == r'onCaptureProcessProgressed(I)V') {
        _$impls[$p]!.onCaptureProcessProgressed(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'onPostviewBitmapAvailable(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onPostviewBitmapAvailable(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onImageSaved(Ldev/hebei/camerax_android/core/ImageCapture$OutputFileResults;)V') {
        _$impls[$p]!.onImageSaved(
          $a![0]!.as(const $ImageCapture$OutputFileResults$Type(),
              releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'onError(Ljava/lang/Exception;)V') {
        _$impls[$p]!.onError(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ImageCapture$OnImageSavedCallback$Stub $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'dev.hebei.camerax_android.core.ImageCapture$OnImageSavedCallback$Stub',
      $p,
      _$invokePointer,
      [
        if ($impl.onCaptureStarted$async) r'onCaptureStarted()V',
        if ($impl.onCaptureProcessProgressed$async)
          r'onCaptureProcessProgressed(I)V',
        if ($impl.onPostviewBitmapAvailable$async)
          r'onPostviewBitmapAvailable(Landroid/graphics/Bitmap;)V',
        if ($impl.onImageSaved$async)
          r'onImageSaved(Ldev/hebei/camerax_android/core/ImageCapture$OutputFileResults;)V',
        if ($impl.onError$async) r'onError(Ljava/lang/Exception;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ImageCapture$OnImageSavedCallback$Stub.implement(
    $ImageCapture$OnImageSavedCallback$Stub $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ImageCapture$OnImageSavedCallback$Stub.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ImageCapture$OnImageSavedCallback$Stub {
  factory $ImageCapture$OnImageSavedCallback$Stub({
    required void Function() onCaptureStarted,
    bool onCaptureStarted$async,
    required void Function(int i) onCaptureProcessProgressed,
    bool onCaptureProcessProgressed$async,
    required void Function(jni$_.JObject bitmap) onPostviewBitmapAvailable,
    bool onPostviewBitmapAvailable$async,
    required void Function(ImageCapture$OutputFileResults outputFileResults)
        onImageSaved,
    bool onImageSaved$async,
    required void Function(jni$_.JObject exception) onError,
    bool onError$async,
  }) = _$ImageCapture$OnImageSavedCallback$Stub;

  void onCaptureStarted();
  bool get onCaptureStarted$async => false;
  void onCaptureProcessProgressed(int i);
  bool get onCaptureProcessProgressed$async => false;
  void onPostviewBitmapAvailable(jni$_.JObject bitmap);
  bool get onPostviewBitmapAvailable$async => false;
  void onImageSaved(ImageCapture$OutputFileResults outputFileResults);
  bool get onImageSaved$async => false;
  void onError(jni$_.JObject exception);
  bool get onError$async => false;
}

final class _$ImageCapture$OnImageSavedCallback$Stub
    with $ImageCapture$OnImageSavedCallback$Stub {
  _$ImageCapture$OnImageSavedCallback$Stub({
    required void Function() onCaptureStarted,
    this.onCaptureStarted$async = false,
    required void Function(int i) onCaptureProcessProgressed,
    this.onCaptureProcessProgressed$async = false,
    required void Function(jni$_.JObject bitmap) onPostviewBitmapAvailable,
    this.onPostviewBitmapAvailable$async = false,
    required void Function(ImageCapture$OutputFileResults outputFileResults)
        onImageSaved,
    this.onImageSaved$async = false,
    required void Function(jni$_.JObject exception) onError,
    this.onError$async = false,
  })  : _onCaptureStarted = onCaptureStarted,
        _onCaptureProcessProgressed = onCaptureProcessProgressed,
        _onPostviewBitmapAvailable = onPostviewBitmapAvailable,
        _onImageSaved = onImageSaved,
        _onError = onError;

  final void Function() _onCaptureStarted;
  final bool onCaptureStarted$async;
  final void Function(int i) _onCaptureProcessProgressed;
  final bool onCaptureProcessProgressed$async;
  final void Function(jni$_.JObject bitmap) _onPostviewBitmapAvailable;
  final bool onPostviewBitmapAvailable$async;
  final void Function(ImageCapture$OutputFileResults outputFileResults)
      _onImageSaved;
  final bool onImageSaved$async;
  final void Function(jni$_.JObject exception) _onError;
  final bool onError$async;

  void onCaptureStarted() {
    return _onCaptureStarted();
  }

  void onCaptureProcessProgressed(int i) {
    return _onCaptureProcessProgressed(i);
  }

  void onPostviewBitmapAvailable(jni$_.JObject bitmap) {
    return _onPostviewBitmapAvailable(bitmap);
  }

  void onImageSaved(ImageCapture$OutputFileResults outputFileResults) {
    return _onImageSaved(outputFileResults);
  }

  void onError(jni$_.JObject exception) {
    return _onError(exception);
  }
}

final class $ImageCapture$OnImageSavedCallback$Stub$NullableType
    extends jni$_.JObjType<ImageCapture$OnImageSavedCallback$Stub?> {
  @jni$_.internal
  const $ImageCapture$OnImageSavedCallback$Stub$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OnImageSavedCallback$Stub;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageSavedCallback$Stub? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$OnImageSavedCallback$Stub.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageSavedCallback$Stub?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OnImageSavedCallback$Stub$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OnImageSavedCallback$Stub$NullableType) &&
        other is $ImageCapture$OnImageSavedCallback$Stub$NullableType;
  }
}

final class $ImageCapture$OnImageSavedCallback$Stub$Type
    extends jni$_.JObjType<ImageCapture$OnImageSavedCallback$Stub> {
  @jni$_.internal
  const $ImageCapture$OnImageSavedCallback$Stub$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OnImageSavedCallback$Stub;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageSavedCallback$Stub fromReference(
          jni$_.JReference reference) =>
      ImageCapture$OnImageSavedCallback$Stub.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageSavedCallback$Stub?> get nullableType =>
      const $ImageCapture$OnImageSavedCallback$Stub$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OnImageSavedCallback$Stub$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OnImageSavedCallback$Stub$Type) &&
        other is $ImageCapture$OnImageSavedCallback$Stub$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$OnImageSavedCallback`
class ImageCapture$OnImageSavedCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OnImageSavedCallback> $type;

  @jni$_.internal
  ImageCapture$OnImageSavedCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$OnImageSavedCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$OnImageSavedCallback$NullableType();
  static const type = $ImageCapture$OnImageSavedCallback$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/camera/core/ImageCapture$OnImageSavedCallback;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.camera.core.ImageCapture$OnImageSavedCallback onImageSavedCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OnImageSavedCallback(
    jni$_.JObject onImageSavedCallback,
  ) {
    final _$onImageSavedCallback = onImageSavedCallback.reference;
    return ImageCapture$OnImageSavedCallback.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$onImageSavedCallback.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ldev/hebei/camerax_android/core/ImageCapture$OnImageSavedCallback$Stub;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(dev.hebei.camerax_android.core.ImageCapture$OnImageSavedCallback$Stub stub)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OnImageSavedCallback.new$1(
    ImageCapture$OnImageSavedCallback$Stub stub,
  ) {
    final _$stub = stub.reference;
    return ImageCapture$OnImageSavedCallback.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$stub.pointer)
        .reference);
  }
}

final class $ImageCapture$OnImageSavedCallback$NullableType
    extends jni$_.JObjType<ImageCapture$OnImageSavedCallback?> {
  @jni$_.internal
  const $ImageCapture$OnImageSavedCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OnImageSavedCallback;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageSavedCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$OnImageSavedCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageSavedCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OnImageSavedCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OnImageSavedCallback$NullableType) &&
        other is $ImageCapture$OnImageSavedCallback$NullableType;
  }
}

final class $ImageCapture$OnImageSavedCallback$Type
    extends jni$_.JObjType<ImageCapture$OnImageSavedCallback> {
  @jni$_.internal
  const $ImageCapture$OnImageSavedCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OnImageSavedCallback;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageSavedCallback fromReference(jni$_.JReference reference) =>
      ImageCapture$OnImageSavedCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageSavedCallback?> get nullableType =>
      const $ImageCapture$OnImageSavedCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OnImageSavedCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$OnImageSavedCallback$Type) &&
        other is $ImageCapture$OnImageSavedCallback$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$OutputFileOptions$Builder`
class ImageCapture$OutputFileOptions$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OutputFileOptions$Builder> $type;

  @jni$_.internal
  ImageCapture$OutputFileOptions$Builder.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$OutputFileOptions$Builder');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $ImageCapture$OutputFileOptions$Builder$NullableType();
  static const type = $ImageCapture$OutputFileOptions$Builder$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/camera/core/ImageCapture$OutputFileOptions$Builder;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.camera.core.ImageCapture$OutputFileOptions$Builder builder)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileOptions$Builder(
    jni$_.JObject builder,
  ) {
    final _$builder = builder.reference;
    return ImageCapture$OutputFileOptions$Builder.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$builder.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/File;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileOptions$Builder.new$1(
    jni$_.JObject file,
  ) {
    final _$file = file.reference;
    return ImageCapture$OutputFileOptions$Builder.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$file.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/OutputStream;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileOptions$Builder.new$2(
    jni$_.JObject outputStream,
  ) {
    final _$outputStream = outputStream.reference;
    return ImageCapture$OutputFileOptions$Builder.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$outputStream.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/content/ContentValues;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.ContentResolver contentResolver, android.net.Uri uri, android.content.ContentValues contentValues)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileOptions$Builder.new$3(
    jni$_.JObject contentResolver,
    jni$_.JObject uri,
    jni$_.JObject contentValues,
  ) {
    final _$contentResolver = contentResolver.reference;
    final _$uri = uri.reference;
    final _$contentValues = contentValues.reference;
    return ImageCapture$OutputFileOptions$Builder.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$contentResolver.pointer,
            _$uri.pointer,
            _$contentValues.pointer)
        .reference);
  }

  static final _id_setMetadata = _class.instanceMethodId(
    r'setMetadata',
    r'(Ldev/hebei/camerax_android/core/ImageCapture$Metadata;)Ldev/hebei/camerax_android/core/ImageCapture$OutputFileOptions$Builder;',
  );

  static final _setMetadata = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final dev.hebei.camerax_android.core.ImageCapture$OutputFileOptions$Builder setMetadata(dev.hebei.camerax_android.core.ImageCapture$Metadata metadata)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$OutputFileOptions$Builder setMetadata(
    ImageCapture$Metadata metadata,
  ) {
    final _$metadata = metadata.reference;
    return _setMetadata(reference.pointer,
            _id_setMetadata as jni$_.JMethodIDPtr, _$metadata.pointer)
        .object<ImageCapture$OutputFileOptions$Builder>(
            const $ImageCapture$OutputFileOptions$Builder$Type());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Ldev/hebei/camerax_android/core/ImageCapture$OutputFileOptions;',
  );

  static final _build = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final dev.hebei.camerax_android.core.ImageCapture$OutputFileOptions build()`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$OutputFileOptions build() {
    return _build(reference.pointer, _id_build as jni$_.JMethodIDPtr)
        .object<ImageCapture$OutputFileOptions>(
            const $ImageCapture$OutputFileOptions$Type());
  }
}

final class $ImageCapture$OutputFileOptions$Builder$NullableType
    extends jni$_.JObjType<ImageCapture$OutputFileOptions$Builder?> {
  @jni$_.internal
  const $ImageCapture$OutputFileOptions$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OutputFileOptions$Builder;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileOptions$Builder? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$OutputFileOptions$Builder.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileOptions$Builder?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OutputFileOptions$Builder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OutputFileOptions$Builder$NullableType) &&
        other is $ImageCapture$OutputFileOptions$Builder$NullableType;
  }
}

final class $ImageCapture$OutputFileOptions$Builder$Type
    extends jni$_.JObjType<ImageCapture$OutputFileOptions$Builder> {
  @jni$_.internal
  const $ImageCapture$OutputFileOptions$Builder$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OutputFileOptions$Builder;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileOptions$Builder fromReference(
          jni$_.JReference reference) =>
      ImageCapture$OutputFileOptions$Builder.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileOptions$Builder?> get nullableType =>
      const $ImageCapture$OutputFileOptions$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileOptions$Builder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OutputFileOptions$Builder$Type) &&
        other is $ImageCapture$OutputFileOptions$Builder$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$OutputFileOptions`
class ImageCapture$OutputFileOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OutputFileOptions> $type;

  @jni$_.internal
  ImageCapture$OutputFileOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$OutputFileOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$OutputFileOptions$NullableType();
  static const type = $ImageCapture$OutputFileOptions$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/camera/core/ImageCapture$OutputFileOptions;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.camera.core.ImageCapture$OutputFileOptions outputFileOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileOptions(
    jni$_.JObject outputFileOptions,
  ) {
    final _$outputFileOptions = outputFileOptions.reference;
    return ImageCapture$OutputFileOptions.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$outputFileOptions.pointer)
        .reference);
  }
}

final class $ImageCapture$OutputFileOptions$NullableType
    extends jni$_.JObjType<ImageCapture$OutputFileOptions?> {
  @jni$_.internal
  const $ImageCapture$OutputFileOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OutputFileOptions;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$OutputFileOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OutputFileOptions$NullableType) &&
        other is $ImageCapture$OutputFileOptions$NullableType;
  }
}

final class $ImageCapture$OutputFileOptions$Type
    extends jni$_.JObjType<ImageCapture$OutputFileOptions> {
  @jni$_.internal
  const $ImageCapture$OutputFileOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OutputFileOptions;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileOptions fromReference(jni$_.JReference reference) =>
      ImageCapture$OutputFileOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileOptions?> get nullableType =>
      const $ImageCapture$OutputFileOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$OutputFileOptions$Type) &&
        other is $ImageCapture$OutputFileOptions$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture$OutputFileResults`
class ImageCapture$OutputFileResults extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OutputFileResults> $type;

  @jni$_.internal
  ImageCapture$OutputFileResults.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/ImageCapture$OutputFileResults');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$OutputFileResults$NullableType();
  static const type = $ImageCapture$OutputFileResults$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/camera/core/ImageCapture$OutputFileResults;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.camera.core.ImageCapture$OutputFileResults outputFileResults)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileResults(
    jni$_.JObject outputFileResults,
  ) {
    final _$outputFileResults = outputFileResults.reference;
    return ImageCapture$OutputFileResults.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$outputFileResults.pointer)
        .reference);
  }

  static final _id_getSavedUri = _class.instanceMethodId(
    r'getSavedUri',
    r'()Landroid/net/Uri;',
  );

  static final _getSavedUri = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final android.net.Uri getSavedUri()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSavedUri() {
    return _getSavedUri(
            reference.pointer, _id_getSavedUri as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $ImageCapture$OutputFileResults$NullableType
    extends jni$_.JObjType<ImageCapture$OutputFileResults?> {
  @jni$_.internal
  const $ImageCapture$OutputFileResults$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OutputFileResults;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileResults? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ImageCapture$OutputFileResults.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileResults?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileResults$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OutputFileResults$NullableType) &&
        other is $ImageCapture$OutputFileResults$NullableType;
  }
}

final class $ImageCapture$OutputFileResults$Type
    extends jni$_.JObjType<ImageCapture$OutputFileResults> {
  @jni$_.internal
  const $ImageCapture$OutputFileResults$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/ImageCapture$OutputFileResults;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileResults fromReference(jni$_.JReference reference) =>
      ImageCapture$OutputFileResults.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileResults?> get nullableType =>
      const $ImageCapture$OutputFileResults$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileResults$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$OutputFileResults$Type) &&
        other is $ImageCapture$OutputFileResults$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.ImageCapture`
class ImageCapture extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture> $type;

  @jni$_.internal
  ImageCapture.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'dev/hebei/camerax_android/core/ImageCapture');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$NullableType();
  static const type = $ImageCapture$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture() {
    return ImageCapture.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $ImageCapture$NullableType extends jni$_.JObjType<ImageCapture?> {
  @jni$_.internal
  const $ImageCapture$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ldev/hebei/camerax_android/core/ImageCapture;';

  @jni$_.internal
  @core$_.override
  ImageCapture? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ImageCapture.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$NullableType) &&
        other is $ImageCapture$NullableType;
  }
}

final class $ImageCapture$Type extends jni$_.JObjType<ImageCapture> {
  @jni$_.internal
  const $ImageCapture$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ldev/hebei/camerax_android/core/ImageCapture;';

  @jni$_.internal
  @core$_.override
  ImageCapture fromReference(jni$_.JReference reference) =>
      ImageCapture.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture?> get nullableType =>
      const $ImageCapture$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Type) &&
        other is $ImageCapture$Type;
  }
}
