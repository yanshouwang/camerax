// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'AspectRatioStrategy.dart' as aspectratiostrategy$_;

import 'ResolutionFilter.dart' as resolutionfilter$_;

import 'ResolutionStrategy.dart' as resolutionstrategy$_;

/// from: `dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$Builder`
class ResolutionSelector$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ResolutionSelector$Builder> $type;

  @jni$_.internal
  ResolutionSelector$Builder.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$Builder');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ResolutionSelector$Builder$NullableType();
  static const type = $ResolutionSelector$Builder$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector$Builder;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.camera.core.resolutionselector.ResolutionSelector$Builder builder)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ResolutionSelector$Builder(
    jni$_.JObject builder,
  ) {
    final _$builder = builder.reference;
    return ResolutionSelector$Builder.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$builder.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'()V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ResolutionSelector$Builder.new$1() {
    return ResolutionSelector$Builder.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_setAllowedResolutionMode = _class.instanceMethodId(
    r'setAllowedResolutionMode',
    r'(Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode;)Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _setAllowedResolutionMode = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$Builder setAllowedResolutionMode(dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$ResolutionMode resolutionMode)`
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector$Builder setAllowedResolutionMode(
    ResolutionSelector$ResolutionMode resolutionMode,
  ) {
    final _$resolutionMode = resolutionMode.reference;
    return _setAllowedResolutionMode(
            reference.pointer,
            _id_setAllowedResolutionMode as jni$_.JMethodIDPtr,
            _$resolutionMode.pointer)
        .object<ResolutionSelector$Builder>(
            const $ResolutionSelector$Builder$Type());
  }

  static final _id_setAspectRatioStrategy = _class.instanceMethodId(
    r'setAspectRatioStrategy',
    r'(Ldev/hebei/camerax_android/core/resolutionselector/AspectRatioStrategy;)Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _setAspectRatioStrategy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$Builder setAspectRatioStrategy(dev.hebei.camerax_android.core.resolutionselector.AspectRatioStrategy aspectRatioStrategy)`
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector$Builder setAspectRatioStrategy(
    aspectratiostrategy$_.AspectRatioStrategy aspectRatioStrategy,
  ) {
    final _$aspectRatioStrategy = aspectRatioStrategy.reference;
    return _setAspectRatioStrategy(
            reference.pointer,
            _id_setAspectRatioStrategy as jni$_.JMethodIDPtr,
            _$aspectRatioStrategy.pointer)
        .object<ResolutionSelector$Builder>(
            const $ResolutionSelector$Builder$Type());
  }

  static final _id_setResolutionFilter = _class.instanceMethodId(
    r'setResolutionFilter',
    r'(Ldev/hebei/camerax_android/core/resolutionselector/ResolutionFilter;)Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _setResolutionFilter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$Builder setResolutionFilter(dev.hebei.camerax_android.core.resolutionselector.ResolutionFilter resolutionFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector$Builder setResolutionFilter(
    resolutionfilter$_.ResolutionFilter resolutionFilter,
  ) {
    final _$resolutionFilter = resolutionFilter.reference;
    return _setResolutionFilter(
            reference.pointer,
            _id_setResolutionFilter as jni$_.JMethodIDPtr,
            _$resolutionFilter.pointer)
        .object<ResolutionSelector$Builder>(
            const $ResolutionSelector$Builder$Type());
  }

  static final _id_setResolutionStrategy = _class.instanceMethodId(
    r'setResolutionStrategy',
    r'(Ldev/hebei/camerax_android/core/resolutionselector/ResolutionStrategy;)Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _setResolutionStrategy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$Builder setResolutionStrategy(dev.hebei.camerax_android.core.resolutionselector.ResolutionStrategy resolutionStrategy)`
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector$Builder setResolutionStrategy(
    resolutionstrategy$_.ResolutionStrategy resolutionStrategy,
  ) {
    final _$resolutionStrategy = resolutionStrategy.reference;
    return _setResolutionStrategy(
            reference.pointer,
            _id_setResolutionStrategy as jni$_.JMethodIDPtr,
            _$resolutionStrategy.pointer)
        .object<ResolutionSelector$Builder>(
            const $ResolutionSelector$Builder$Type());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector;',
  );

  static final _build = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector build()`
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector build() {
    return _build(reference.pointer, _id_build as jni$_.JMethodIDPtr)
        .object<ResolutionSelector>(const $ResolutionSelector$Type());
  }
}

final class $ResolutionSelector$Builder$NullableType
    extends jni$_.JObjType<ResolutionSelector$Builder?> {
  @jni$_.internal
  const $ResolutionSelector$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$Builder;';

  @jni$_.internal
  @core$_.override
  ResolutionSelector$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ResolutionSelector$Builder.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ResolutionSelector$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ResolutionSelector$Builder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionSelector$Builder$NullableType) &&
        other is $ResolutionSelector$Builder$NullableType;
  }
}

final class $ResolutionSelector$Builder$Type
    extends jni$_.JObjType<ResolutionSelector$Builder> {
  @jni$_.internal
  const $ResolutionSelector$Builder$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$Builder;';

  @jni$_.internal
  @core$_.override
  ResolutionSelector$Builder fromReference(jni$_.JReference reference) =>
      ResolutionSelector$Builder.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ResolutionSelector$Builder?> get nullableType =>
      const $ResolutionSelector$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ResolutionSelector$Builder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionSelector$Builder$Type) &&
        other is $ResolutionSelector$Builder$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$ResolutionMode`
class ResolutionSelector$ResolutionMode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ResolutionSelector$ResolutionMode> $type;

  @jni$_.internal
  ResolutionSelector$ResolutionMode.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ResolutionSelector$ResolutionMode$NullableType();
  static const type = $ResolutionSelector$ResolutionMode$Type();
  static final _id_PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION =
      _class.staticFieldId(
    r'PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION',
    r'Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$ResolutionMode PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION`
  /// The returned object must be released after use, by calling the [release] method.
  static ResolutionSelector$ResolutionMode?
      get PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION =>
          _id_PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION.get(
              _class, const $ResolutionSelector$ResolutionMode$NullableType());

  static final _id_PREFER_HIGHER_RESOLUTION_OVER_CAPTURE_RATE =
      _class.staticFieldId(
    r'PREFER_HIGHER_RESOLUTION_OVER_CAPTURE_RATE',
    r'Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode;',
  );

  /// from: `static public final dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$ResolutionMode PREFER_HIGHER_RESOLUTION_OVER_CAPTURE_RATE`
  /// The returned object must be released after use, by calling the [release] method.
  static ResolutionSelector$ResolutionMode?
      get PREFER_HIGHER_RESOLUTION_OVER_CAPTURE_RATE =>
          _id_PREFER_HIGHER_RESOLUTION_OVER_CAPTURE_RATE.get(
              _class, const $ResolutionSelector$ResolutionMode$NullableType());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$ResolutionMode[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<ResolutionSelector$ResolutionMode?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<ResolutionSelector$ResolutionMode?>?>(
            const jni$_.JArrayNullableType<ResolutionSelector$ResolutionMode?>(
                $ResolutionSelector$ResolutionMode$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$ResolutionMode valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ResolutionSelector$ResolutionMode? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<ResolutionSelector$ResolutionMode?>(
            const $ResolutionSelector$ResolutionMode$NullableType());
  }
}

final class $ResolutionSelector$ResolutionMode$NullableType
    extends jni$_.JObjType<ResolutionSelector$ResolutionMode?> {
  @jni$_.internal
  const $ResolutionSelector$ResolutionMode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode;';

  @jni$_.internal
  @core$_.override
  ResolutionSelector$ResolutionMode? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ResolutionSelector$ResolutionMode.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ResolutionSelector$ResolutionMode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ResolutionSelector$ResolutionMode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ResolutionSelector$ResolutionMode$NullableType) &&
        other is $ResolutionSelector$ResolutionMode$NullableType;
  }
}

final class $ResolutionSelector$ResolutionMode$Type
    extends jni$_.JObjType<ResolutionSelector$ResolutionMode> {
  @jni$_.internal
  const $ResolutionSelector$ResolutionMode$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode;';

  @jni$_.internal
  @core$_.override
  ResolutionSelector$ResolutionMode fromReference(jni$_.JReference reference) =>
      ResolutionSelector$ResolutionMode.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ResolutionSelector$ResolutionMode?> get nullableType =>
      const $ResolutionSelector$ResolutionMode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ResolutionSelector$ResolutionMode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionSelector$ResolutionMode$Type) &&
        other is $ResolutionSelector$ResolutionMode$Type;
  }
}

/// from: `dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector`
class ResolutionSelector extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ResolutionSelector> $type;

  @jni$_.internal
  ResolutionSelector.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'dev/hebei/camerax_android/core/resolutionselector/ResolutionSelector');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ResolutionSelector$NullableType();
  static const type = $ResolutionSelector$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ResolutionSelector(
    jni$_.JObject resolutionSelector,
  ) {
    final _$resolutionSelector = resolutionSelector.reference;
    return ResolutionSelector.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$resolutionSelector.pointer)
        .reference);
  }

  static final _id_getAllowedResolutionMode = _class.instanceMethodId(
    r'getAllowedResolutionMode',
    r'()Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector$ResolutionMode;',
  );

  static final _getAllowedResolutionMode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.ResolutionSelector$ResolutionMode getAllowedResolutionMode()`
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector$ResolutionMode getAllowedResolutionMode() {
    return _getAllowedResolutionMode(reference.pointer,
            _id_getAllowedResolutionMode as jni$_.JMethodIDPtr)
        .object<ResolutionSelector$ResolutionMode>(
            const $ResolutionSelector$ResolutionMode$Type());
  }

  static final _id_getAspectRatioStrategy = _class.instanceMethodId(
    r'getAspectRatioStrategy',
    r'()Ldev/hebei/camerax_android/core/resolutionselector/AspectRatioStrategy;',
  );

  static final _getAspectRatioStrategy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.AspectRatioStrategy getAspectRatioStrategy()`
  /// The returned object must be released after use, by calling the [release] method.
  aspectratiostrategy$_.AspectRatioStrategy getAspectRatioStrategy() {
    return _getAspectRatioStrategy(
            reference.pointer, _id_getAspectRatioStrategy as jni$_.JMethodIDPtr)
        .object<aspectratiostrategy$_.AspectRatioStrategy>(
            const aspectratiostrategy$_.$AspectRatioStrategy$Type());
  }

  static final _id_getResolutionFilter = _class.instanceMethodId(
    r'getResolutionFilter',
    r'()Ldev/hebei/camerax_android/core/resolutionselector/ResolutionFilter;',
  );

  static final _getResolutionFilter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.ResolutionFilter getResolutionFilter()`
  /// The returned object must be released after use, by calling the [release] method.
  resolutionfilter$_.ResolutionFilter? getResolutionFilter() {
    return _getResolutionFilter(
            reference.pointer, _id_getResolutionFilter as jni$_.JMethodIDPtr)
        .object<resolutionfilter$_.ResolutionFilter?>(
            const resolutionfilter$_.$ResolutionFilter$NullableType());
  }

  static final _id_getResolutionStrategy = _class.instanceMethodId(
    r'getResolutionStrategy',
    r'()Ldev/hebei/camerax_android/core/resolutionselector/ResolutionStrategy;',
  );

  static final _getResolutionStrategy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final dev.hebei.camerax_android.core.resolutionselector.ResolutionStrategy getResolutionStrategy()`
  /// The returned object must be released after use, by calling the [release] method.
  resolutionstrategy$_.ResolutionStrategy? getResolutionStrategy() {
    return _getResolutionStrategy(
            reference.pointer, _id_getResolutionStrategy as jni$_.JMethodIDPtr)
        .object<resolutionstrategy$_.ResolutionStrategy?>(
            const resolutionstrategy$_.$ResolutionStrategy$NullableType());
  }
}

final class $ResolutionSelector$NullableType
    extends jni$_.JObjType<ResolutionSelector?> {
  @jni$_.internal
  const $ResolutionSelector$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector;';

  @jni$_.internal
  @core$_.override
  ResolutionSelector? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ResolutionSelector.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ResolutionSelector?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ResolutionSelector$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionSelector$NullableType) &&
        other is $ResolutionSelector$NullableType;
  }
}

final class $ResolutionSelector$Type
    extends jni$_.JObjType<ResolutionSelector> {
  @jni$_.internal
  const $ResolutionSelector$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Ldev/hebei/camerax_android/core/resolutionselector/ResolutionSelector;';

  @jni$_.internal
  @core$_.override
  ResolutionSelector fromReference(jni$_.JReference reference) =>
      ResolutionSelector.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ResolutionSelector?> get nullableType =>
      const $ResolutionSelector$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ResolutionSelector$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionSelector$Type) &&
        other is $ResolutionSelector$Type;
  }
}
