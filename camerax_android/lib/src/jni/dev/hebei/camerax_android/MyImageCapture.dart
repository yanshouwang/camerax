// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import '../../../android/content/ContentResolver.dart' as contentresolver_;

import '../../../android/content/ContentValues.dart' as contentvalues_;

import '../../../android/net/Uri.dart' as uri_;

import '../../../androidx/camera/core/ImageProxy.dart' as imageproxy_;

import '../../../java/io/File.dart' as file_;

/// from: dev.hebei.camerax_android.MyImageCapture$Companion
class MyImageCapture_Companion extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_Companion> $type = type;

  MyImageCapture_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'dev/hebei/camerax_android/MyImageCapture$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_CompanionType();
  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return MyImageCapture_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $MyImageCapture_CompanionType
    extends jni.JObjType<MyImageCapture_Companion> {
  const $MyImageCapture_CompanionType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$Companion;';

  @override
  MyImageCapture_Companion fromReference(jni.JReference reference) =>
      MyImageCapture_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCapture_CompanionType) &&
        other is $MyImageCapture_CompanionType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOnImageCapturedCallback
class MyImageCapture_MyOnImageCapturedCallback extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOnImageCapturedCallback> $type =
      type;

  MyImageCapture_MyOnImageCapturedCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOnImageCapturedCallbackType();
  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void onCaptureStarted()
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract void onCaptureProcessProgressed(int i)
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onCaptureSuccess = _class.instanceMethodId(
    r'onCaptureSuccess',
    r'(Landroidx/camera/core/ImageProxy;)V',
  );

  static final _onCaptureSuccess = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onCaptureSuccess(androidx.camera.core.ImageProxy imageProxy)
  void onCaptureSuccess(
    imageproxy_.ImageProxy imageProxy,
  ) {
    _onCaptureSuccess(
            reference.pointer,
            _id_onCaptureSuccess as jni.JMethodIDPtr,
            imageProxy.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onError(androidx.camera.core.ImageCaptureException imageCaptureException)
  void onError(
    jni.JObject imageCaptureException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            imageCaptureException.reference.pointer)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)
  void onPostviewBitmapAvailable(
    jni.JObject bitmap,
  ) {
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyImageCapture_MyOnImageCapturedCallbackImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCaptureStarted()V') {
        _$impls[$p]!.onCaptureStarted();
        return jni.nullptr;
      }
      if ($d == r'onCaptureProcessProgressed(I)V') {
        _$impls[$p]!.onCaptureProcessProgressed(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onCaptureSuccess(Landroidx/camera/core/ImageProxy;)V') {
        _$impls[$p]!.onCaptureSuccess(
          $a[0].castTo(const imageproxy_.$ImageProxyType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Landroidx/camera/core/ImageCaptureException;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onPostviewBitmapAvailable(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onPostviewBitmapAvailable(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MyImageCapture_MyOnImageCapturedCallback.implement(
    $MyImageCapture_MyOnImageCapturedCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyImageCapture_MyOnImageCapturedCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'dev.hebei.camerax_android.MyImageCapture$MyOnImageCapturedCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MyImageCapture_MyOnImageCapturedCallbackImpl {
  factory $MyImageCapture_MyOnImageCapturedCallbackImpl({
    required void Function() onCaptureStarted,
    required void Function(int i) onCaptureProcessProgressed,
    required void Function(imageproxy_.ImageProxy imageProxy) onCaptureSuccess,
    required void Function(jni.JObject imageCaptureException) onError,
    required void Function(jni.JObject bitmap) onPostviewBitmapAvailable,
  }) = _$MyImageCapture_MyOnImageCapturedCallbackImpl;

  void onCaptureStarted();
  void onCaptureProcessProgressed(int i);
  void onCaptureSuccess(imageproxy_.ImageProxy imageProxy);
  void onError(jni.JObject imageCaptureException);
  void onPostviewBitmapAvailable(jni.JObject bitmap);
}

class _$MyImageCapture_MyOnImageCapturedCallbackImpl
    implements $MyImageCapture_MyOnImageCapturedCallbackImpl {
  _$MyImageCapture_MyOnImageCapturedCallbackImpl({
    required void Function() onCaptureStarted,
    required void Function(int i) onCaptureProcessProgressed,
    required void Function(imageproxy_.ImageProxy imageProxy) onCaptureSuccess,
    required void Function(jni.JObject imageCaptureException) onError,
    required void Function(jni.JObject bitmap) onPostviewBitmapAvailable,
  })  : _onCaptureStarted = onCaptureStarted,
        _onCaptureProcessProgressed = onCaptureProcessProgressed,
        _onCaptureSuccess = onCaptureSuccess,
        _onError = onError,
        _onPostviewBitmapAvailable = onPostviewBitmapAvailable;

  final void Function() _onCaptureStarted;
  final void Function(int i) _onCaptureProcessProgressed;
  final void Function(imageproxy_.ImageProxy imageProxy) _onCaptureSuccess;
  final void Function(jni.JObject imageCaptureException) _onError;
  final void Function(jni.JObject bitmap) _onPostviewBitmapAvailable;

  void onCaptureStarted() {
    return _onCaptureStarted();
  }

  void onCaptureProcessProgressed(int i) {
    return _onCaptureProcessProgressed(i);
  }

  void onCaptureSuccess(imageproxy_.ImageProxy imageProxy) {
    return _onCaptureSuccess(imageProxy);
  }

  void onError(jni.JObject imageCaptureException) {
    return _onError(imageCaptureException);
  }

  void onPostviewBitmapAvailable(jni.JObject bitmap) {
    return _onPostviewBitmapAvailable(bitmap);
  }
}

final class $MyImageCapture_MyOnImageCapturedCallbackType
    extends jni.JObjType<MyImageCapture_MyOnImageCapturedCallback> {
  const $MyImageCapture_MyOnImageCapturedCallbackType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallback;';

  @override
  MyImageCapture_MyOnImageCapturedCallback fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOnImageCapturedCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOnImageCapturedCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyImageCapture_MyOnImageCapturedCallbackType) &&
        other is $MyImageCapture_MyOnImageCapturedCallbackType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOnImageCapturedCallbackImpl
class MyImageCapture_MyOnImageCapturedCallbackImpl extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOnImageCapturedCallbackImpl> $type =
      type;

  MyImageCapture_MyOnImageCapturedCallbackImpl.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallbackImpl');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOnImageCapturedCallbackImplType();
  static final _id_new0 = _class.constructorId(
    r'(Ldev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallback;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(dev.hebei.camerax_android.MyImageCapture$MyOnImageCapturedCallback myOnImageCapturedCallback)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOnImageCapturedCallbackImpl(
    MyImageCapture_MyOnImageCapturedCallback myOnImageCapturedCallback,
  ) {
    return MyImageCapture_MyOnImageCapturedCallbackImpl.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            myOnImageCapturedCallback.reference.pointer)
        .reference);
  }

  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onCaptureStarted()
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onCaptureProcessProgressed(int i)
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onCaptureSuccess = _class.instanceMethodId(
    r'onCaptureSuccess',
    r'(Landroidx/camera/core/ImageProxy;)V',
  );

  static final _onCaptureSuccess = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onCaptureSuccess(androidx.camera.core.ImageProxy imageProxy)
  void onCaptureSuccess(
    imageproxy_.ImageProxy imageProxy,
  ) {
    _onCaptureSuccess(
            reference.pointer,
            _id_onCaptureSuccess as jni.JMethodIDPtr,
            imageProxy.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onError(androidx.camera.core.ImageCaptureException imageCaptureException)
  void onError(
    jni.JObject imageCaptureException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            imageCaptureException.reference.pointer)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)
  void onPostviewBitmapAvailable(
    jni.JObject bitmap,
  ) {
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }
}

final class $MyImageCapture_MyOnImageCapturedCallbackImplType
    extends jni.JObjType<MyImageCapture_MyOnImageCapturedCallbackImpl> {
  const $MyImageCapture_MyOnImageCapturedCallbackImplType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallbackImpl;';

  @override
  MyImageCapture_MyOnImageCapturedCallbackImpl fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOnImageCapturedCallbackImpl.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($MyImageCapture_MyOnImageCapturedCallbackImplType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyImageCapture_MyOnImageCapturedCallbackImplType) &&
        other is $MyImageCapture_MyOnImageCapturedCallbackImplType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOnImageSavedCallback
class MyImageCapture_MyOnImageSavedCallback extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOnImageSavedCallback> $type = type;

  MyImageCapture_MyOnImageSavedCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOnImageSavedCallbackType();
  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void onCaptureStarted()
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract void onCaptureProcessProgressed(int i)
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onImageSaved = _class.instanceMethodId(
    r'onImageSaved',
    r'(Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileResults;)V',
  );

  static final _onImageSaved = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onImageSaved(dev.hebei.camerax_android.MyImageCapture$MyOutputFileResults myOutputFileResults)
  void onImageSaved(
    MyImageCapture_MyOutputFileResults myOutputFileResults,
  ) {
    _onImageSaved(reference.pointer, _id_onImageSaved as jni.JMethodIDPtr,
            myOutputFileResults.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onError(androidx.camera.core.ImageCaptureException imageCaptureException)
  void onError(
    jni.JObject imageCaptureException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            imageCaptureException.reference.pointer)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)
  void onPostviewBitmapAvailable(
    jni.JObject bitmap,
  ) {
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyImageCapture_MyOnImageSavedCallbackImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCaptureStarted()V') {
        _$impls[$p]!.onCaptureStarted();
        return jni.nullptr;
      }
      if ($d == r'onCaptureProcessProgressed(I)V') {
        _$impls[$p]!.onCaptureProcessProgressed(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onImageSaved(Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileResults;)V') {
        _$impls[$p]!.onImageSaved(
          $a[0].castTo(const $MyImageCapture_MyOutputFileResultsType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Landroidx/camera/core/ImageCaptureException;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onPostviewBitmapAvailable(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onPostviewBitmapAvailable(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MyImageCapture_MyOnImageSavedCallback.implement(
    $MyImageCapture_MyOnImageSavedCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyImageCapture_MyOnImageSavedCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'dev.hebei.camerax_android.MyImageCapture$MyOnImageSavedCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MyImageCapture_MyOnImageSavedCallbackImpl {
  factory $MyImageCapture_MyOnImageSavedCallbackImpl({
    required void Function() onCaptureStarted,
    required void Function(int i) onCaptureProcessProgressed,
    required void Function(
            MyImageCapture_MyOutputFileResults myOutputFileResults)
        onImageSaved,
    required void Function(jni.JObject imageCaptureException) onError,
    required void Function(jni.JObject bitmap) onPostviewBitmapAvailable,
  }) = _$MyImageCapture_MyOnImageSavedCallbackImpl;

  void onCaptureStarted();
  void onCaptureProcessProgressed(int i);
  void onImageSaved(MyImageCapture_MyOutputFileResults myOutputFileResults);
  void onError(jni.JObject imageCaptureException);
  void onPostviewBitmapAvailable(jni.JObject bitmap);
}

class _$MyImageCapture_MyOnImageSavedCallbackImpl
    implements $MyImageCapture_MyOnImageSavedCallbackImpl {
  _$MyImageCapture_MyOnImageSavedCallbackImpl({
    required void Function() onCaptureStarted,
    required void Function(int i) onCaptureProcessProgressed,
    required void Function(
            MyImageCapture_MyOutputFileResults myOutputFileResults)
        onImageSaved,
    required void Function(jni.JObject imageCaptureException) onError,
    required void Function(jni.JObject bitmap) onPostviewBitmapAvailable,
  })  : _onCaptureStarted = onCaptureStarted,
        _onCaptureProcessProgressed = onCaptureProcessProgressed,
        _onImageSaved = onImageSaved,
        _onError = onError,
        _onPostviewBitmapAvailable = onPostviewBitmapAvailable;

  final void Function() _onCaptureStarted;
  final void Function(int i) _onCaptureProcessProgressed;
  final void Function(MyImageCapture_MyOutputFileResults myOutputFileResults)
      _onImageSaved;
  final void Function(jni.JObject imageCaptureException) _onError;
  final void Function(jni.JObject bitmap) _onPostviewBitmapAvailable;

  void onCaptureStarted() {
    return _onCaptureStarted();
  }

  void onCaptureProcessProgressed(int i) {
    return _onCaptureProcessProgressed(i);
  }

  void onImageSaved(MyImageCapture_MyOutputFileResults myOutputFileResults) {
    return _onImageSaved(myOutputFileResults);
  }

  void onError(jni.JObject imageCaptureException) {
    return _onError(imageCaptureException);
  }

  void onPostviewBitmapAvailable(jni.JObject bitmap) {
    return _onPostviewBitmapAvailable(bitmap);
  }
}

final class $MyImageCapture_MyOnImageSavedCallbackType
    extends jni.JObjType<MyImageCapture_MyOnImageSavedCallback> {
  const $MyImageCapture_MyOnImageSavedCallbackType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallback;';

  @override
  MyImageCapture_MyOnImageSavedCallback fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOnImageSavedCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOnImageSavedCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCapture_MyOnImageSavedCallbackType) &&
        other is $MyImageCapture_MyOnImageSavedCallbackType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOnImageSavedCallbackImpl
class MyImageCapture_MyOnImageSavedCallbackImpl extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOnImageSavedCallbackImpl> $type =
      type;

  MyImageCapture_MyOnImageSavedCallbackImpl.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallbackImpl');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOnImageSavedCallbackImplType();
  static final _id_new0 = _class.constructorId(
    r'(Ldev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallback;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(dev.hebei.camerax_android.MyImageCapture$MyOnImageSavedCallback myOnImageSavedCallback)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOnImageSavedCallbackImpl(
    MyImageCapture_MyOnImageSavedCallback myOnImageSavedCallback,
  ) {
    return MyImageCapture_MyOnImageSavedCallbackImpl.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            myOnImageSavedCallback.reference.pointer)
        .reference);
  }

  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onCaptureStarted()
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onCaptureProcessProgressed(int i)
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onImageSaved = _class.instanceMethodId(
    r'onImageSaved',
    r'(Landroidx/camera/core/ImageCapture$OutputFileResults;)V',
  );

  static final _onImageSaved = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onImageSaved(androidx.camera.core.ImageCapture$OutputFileResults outputFileResults)
  void onImageSaved(
    jni.JObject outputFileResults,
  ) {
    _onImageSaved(reference.pointer, _id_onImageSaved as jni.JMethodIDPtr,
            outputFileResults.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onError(androidx.camera.core.ImageCaptureException imageCaptureException)
  void onError(
    jni.JObject imageCaptureException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            imageCaptureException.reference.pointer)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)
  void onPostviewBitmapAvailable(
    jni.JObject bitmap,
  ) {
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }
}

final class $MyImageCapture_MyOnImageSavedCallbackImplType
    extends jni.JObjType<MyImageCapture_MyOnImageSavedCallbackImpl> {
  const $MyImageCapture_MyOnImageSavedCallbackImplType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallbackImpl;';

  @override
  MyImageCapture_MyOnImageSavedCallbackImpl fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOnImageSavedCallbackImpl.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOnImageSavedCallbackImplType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyImageCapture_MyOnImageSavedCallbackImplType) &&
        other is $MyImageCapture_MyOnImageSavedCallbackImplType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOutputFileOptions$MyBuilder
class MyImageCapture_MyOutputFileOptions_MyBuilder extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOutputFileOptions_MyBuilder> $type =
      type;

  MyImageCapture_MyOutputFileOptions_MyBuilder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOutputFileOptions$MyBuilder');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOutputFileOptions_MyBuilderType();
  static final _id_new0 = _class.constructorId(
    r'(Ljava/io/File;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOutputFileOptions_MyBuilder(
    file_.File file,
  ) {
    return MyImageCapture_MyOutputFileOptions_MyBuilder.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            file.reference.pointer)
        .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/content/ContentValues;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ContentResolver contentResolver, android.net.Uri uri, android.content.ContentValues contentValues)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOutputFileOptions_MyBuilder.new1(
    contentresolver_.ContentResolver contentResolver,
    uri_.Uri uri,
    contentvalues_.ContentValues contentValues,
  ) {
    return MyImageCapture_MyOutputFileOptions_MyBuilder.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer,
            contentValues.reference.pointer)
        .reference);
  }

  static final _id_new2 = _class.constructorId(
    r'(Ljava/io/OutputStream;)V',
  );

  static final _new2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.io.OutputStream outputStream)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOutputFileOptions_MyBuilder.new2(
    jni.JObject outputStream,
  ) {
    return MyImageCapture_MyOutputFileOptions_MyBuilder.fromReference(_new2(
            _class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr,
            outputStream.reference.pointer)
        .reference);
  }

  static final _id_setMetadata = _class.instanceMethodId(
    r'setMetadata',
    r'(Landroidx/camera/core/ImageCapture$Metadata;)Landroidx/camera/core/ImageCapture$OutputFileOptions$Builder;',
  );

  static final _setMetadata = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final androidx.camera.core.ImageCapture$OutputFileOptions$Builder setMetadata(androidx.camera.core.ImageCapture$Metadata metadata)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject setMetadata(
    jni.JObject metadata,
  ) {
    return _setMetadata(reference.pointer, _id_setMetadata as jni.JMethodIDPtr,
            metadata.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroidx/camera/core/ImageCapture$OutputFileOptions;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final androidx.camera.core.ImageCapture$OutputFileOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $MyImageCapture_MyOutputFileOptions_MyBuilderType
    extends jni.JObjType<MyImageCapture_MyOutputFileOptions_MyBuilder> {
  const $MyImageCapture_MyOutputFileOptions_MyBuilderType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileOptions$MyBuilder;';

  @override
  MyImageCapture_MyOutputFileOptions_MyBuilder fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOutputFileOptions_MyBuilder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($MyImageCapture_MyOutputFileOptions_MyBuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyImageCapture_MyOutputFileOptions_MyBuilderType) &&
        other is $MyImageCapture_MyOutputFileOptions_MyBuilderType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOutputFileOptions
class MyImageCapture_MyOutputFileOptions extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOutputFileOptions> $type = type;

  MyImageCapture_MyOutputFileOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOutputFileOptions');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOutputFileOptionsType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOutputFileOptions() {
    return MyImageCapture_MyOutputFileOptions.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyImageCapture_MyOutputFileOptionsType
    extends jni.JObjType<MyImageCapture_MyOutputFileOptions> {
  const $MyImageCapture_MyOutputFileOptionsType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileOptions;';

  @override
  MyImageCapture_MyOutputFileOptions fromReference(jni.JReference reference) =>
      MyImageCapture_MyOutputFileOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOutputFileOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCapture_MyOutputFileOptionsType) &&
        other is $MyImageCapture_MyOutputFileOptionsType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOutputFileResults
class MyImageCapture_MyOutputFileResults extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOutputFileResults> $type = type;

  MyImageCapture_MyOutputFileResults.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOutputFileResults');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOutputFileResultsType();
  static final _id_new0 = _class.constructorId(
    r'(Landroidx/camera/core/ImageCapture$OutputFileResults;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(androidx.camera.core.ImageCapture$OutputFileResults outputFileResults)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOutputFileResults(
    jni.JObject outputFileResults,
  ) {
    return MyImageCapture_MyOutputFileResults.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            outputFileResults.reference.pointer)
        .reference);
  }

  static final _id_getSavedUri = _class.instanceMethodId(
    r'getSavedUri',
    r'()Landroid/net/Uri;',
  );

  static final _getSavedUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.net.Uri getSavedUri()
  /// The returned object must be released after use, by calling the [release] method.
  uri_.Uri getSavedUri() {
    return _getSavedUri(reference.pointer, _id_getSavedUri as jni.JMethodIDPtr)
        .object(const uri_.$UriType());
  }
}

final class $MyImageCapture_MyOutputFileResultsType
    extends jni.JObjType<MyImageCapture_MyOutputFileResults> {
  const $MyImageCapture_MyOutputFileResultsType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileResults;';

  @override
  MyImageCapture_MyOutputFileResults fromReference(jni.JReference reference) =>
      MyImageCapture_MyOutputFileResults.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOutputFileResultsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCapture_MyOutputFileResultsType) &&
        other is $MyImageCapture_MyOutputFileResultsType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture
class MyImageCapture extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture> $type = type;

  MyImageCapture.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'dev/hebei/camerax_android/MyImageCapture');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCaptureType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Ldev/hebei/camerax_android/MyImageCapture$Companion;',
  );

  /// from: static public final dev.hebei.camerax_android.MyImageCapture$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static MyImageCapture_Companion get Companion =>
      _id_Companion.get(_class, const $MyImageCapture_CompanionType());

  /// from: static public final int CAPTURE_MODE_MINIMIZE_LATENCY
  static const CAPTURE_MODE_MINIMIZE_LATENCY = 1;

  /// from: static public final int CAPTURE_MODE_MAXIMIZE_QUALITY
  static const CAPTURE_MODE_MAXIMIZE_QUALITY = 0;

  /// from: static public final int FLASH_MODE_AUTO
  static const FLASH_MODE_AUTO = 0;

  /// from: static public final int FLASH_MODE_OFF
  static const FLASH_MODE_OFF = 2;

  /// from: static public final int FLASH_MODE_ON
  static const FLASH_MODE_ON = 1;

  /// from: static public final int FLASH_MODE_SCREEN
  static const FLASH_MODE_SCREEN = 3;
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture() {
    return MyImageCapture.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyImageCaptureType extends jni.JObjType<MyImageCapture> {
  const $MyImageCaptureType();

  @override
  String get signature => r'Ldev/hebei/camerax_android/MyImageCapture;';

  @override
  MyImageCapture fromReference(jni.JReference reference) =>
      MyImageCapture.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCaptureType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCaptureType) &&
        other is $MyImageCaptureType;
  }
}
