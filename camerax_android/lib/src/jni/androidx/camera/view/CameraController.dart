// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

import '../../../android/util/Size.dart' as size_;

import '../../../com/google/common/util/concurrent/ListenableFuture.dart'
    as listenablefuture_;

import '../../../java/util/concurrent/Executor.dart' as executor_;

import '../../core/util/Consumer.dart' as consumer_;

import '../../lifecycle/LiveData.dart' as livedata_;

import '../core/CameraSelector.dart' as cameraselector_;

import '../core/DynamicRange.dart' as dynamicrange_;

import '../core/ZoomState.dart' as zoomstate_;

import '../core/resolutionselector/ResolutionSelector.dart'
    as resolutionselector_;

import '../video/QualitySelector.dart' as qualityselector_;

import '../video/Recording.dart' as recording_;

import '../video/VideoRecordEvent.dart' as videorecordevent_;

import 'video/AudioConfig.dart' as audioconfig_;

/// from: androidx.camera.view.CameraController$OutputSize$OutputAspectRatio
class CameraController_OutputSize_OutputAspectRatio extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_OutputSize_OutputAspectRatio> $type =
      type;

  CameraController_OutputSize_OutputAspectRatio.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/view/CameraController$OutputSize$OutputAspectRatio');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_OutputSize_OutputAspectRatioType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CameraController_OutputSize_OutputAspectRatioImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory CameraController_OutputSize_OutputAspectRatio.implement(
    $CameraController_OutputSize_OutputAspectRatioImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = CameraController_OutputSize_OutputAspectRatio.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.view.CameraController$OutputSize$OutputAspectRatio',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CameraController_OutputSize_OutputAspectRatioImpl {
  factory $CameraController_OutputSize_OutputAspectRatioImpl() =
      _$CameraController_OutputSize_OutputAspectRatioImpl;
}

class _$CameraController_OutputSize_OutputAspectRatioImpl
    implements $CameraController_OutputSize_OutputAspectRatioImpl {
  _$CameraController_OutputSize_OutputAspectRatioImpl();
}

final class $CameraController_OutputSize_OutputAspectRatioType
    extends jni.JObjType<CameraController_OutputSize_OutputAspectRatio> {
  const $CameraController_OutputSize_OutputAspectRatioType();

  @override
  String get signature =>
      r'Landroidx/camera/view/CameraController$OutputSize$OutputAspectRatio;';

  @override
  CameraController_OutputSize_OutputAspectRatio fromReference(
          jni.JReference reference) =>
      CameraController_OutputSize_OutputAspectRatio.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($CameraController_OutputSize_OutputAspectRatioType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($CameraController_OutputSize_OutputAspectRatioType) &&
        other is $CameraController_OutputSize_OutputAspectRatioType;
  }
}

/// from: androidx.camera.view.CameraController$OutputSize
class CameraController_OutputSize extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_OutputSize> $type = type;

  CameraController_OutputSize.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/view/CameraController$OutputSize');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_OutputSizeType();

  /// from: static public final int UNASSIGNED_ASPECT_RATIO
  static const UNASSIGNED_ASPECT_RATIO = -1;
  static final _id_new0 = _class.constructorId(
    r'(I)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void <init>(int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraController_OutputSize(
    int i,
  ) {
    return CameraController_OutputSize.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr, i)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Landroid/util/Size;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.util.Size size)
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraController_OutputSize.new1(
    size_.Size size,
  ) {
    return CameraController_OutputSize.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            size.reference.pointer)
        .reference);
  }

  static final _id_getAspectRatio = _class.instanceMethodId(
    r'getAspectRatio',
    r'()I',
  );

  static final _getAspectRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getAspectRatio()
  int getAspectRatio() {
    return _getAspectRatio(
            reference.pointer, _id_getAspectRatio as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getResolution = _class.instanceMethodId(
    r'getResolution',
    r'()Landroid/util/Size;',
  );

  static final _getResolution = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.util.Size getResolution()
  /// The returned object must be released after use, by calling the [release] method.
  size_.Size getResolution() {
    return _getResolution(
            reference.pointer, _id_getResolution as jni.JMethodIDPtr)
        .object(const size_.$SizeType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $CameraController_OutputSizeType
    extends jni.JObjType<CameraController_OutputSize> {
  const $CameraController_OutputSizeType();

  @override
  String get signature => r'Landroidx/camera/view/CameraController$OutputSize;';

  @override
  CameraController_OutputSize fromReference(jni.JReference reference) =>
      CameraController_OutputSize.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraController_OutputSizeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController_OutputSizeType) &&
        other is $CameraController_OutputSizeType;
  }
}

/// from: androidx.camera.view.CameraController$UseCases
class CameraController_UseCases extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_UseCases> $type = type;

  CameraController_UseCases.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/view/CameraController$UseCases');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_UseCasesType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CameraController_UseCasesImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory CameraController_UseCases.implement(
    $CameraController_UseCasesImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = CameraController_UseCases.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.view.CameraController$UseCases',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CameraController_UseCasesImpl {
  factory $CameraController_UseCasesImpl() = _$CameraController_UseCasesImpl;
}

class _$CameraController_UseCasesImpl
    implements $CameraController_UseCasesImpl {
  _$CameraController_UseCasesImpl();
}

final class $CameraController_UseCasesType
    extends jni.JObjType<CameraController_UseCases> {
  const $CameraController_UseCasesType();

  @override
  String get signature => r'Landroidx/camera/view/CameraController$UseCases;';

  @override
  CameraController_UseCases fromReference(jni.JReference reference) =>
      CameraController_UseCases.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraController_UseCasesType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController_UseCasesType) &&
        other is $CameraController_UseCasesType;
  }
}

/// from: androidx.camera.view.CameraController
class CameraController extends jni.JObject {
  @override
  late final jni.JObjType<CameraController> $type = type;

  CameraController.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/view/CameraController');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraControllerType();

  /// from: static public final int COORDINATE_SYSTEM_VIEW_REFERENCED
  static const COORDINATE_SYSTEM_VIEW_REFERENCED = 1;

  /// from: static public final int TAP_TO_FOCUS_NOT_STARTED
  static const TAP_TO_FOCUS_NOT_STARTED = 0;

  /// from: static public final int TAP_TO_FOCUS_STARTED
  static const TAP_TO_FOCUS_STARTED = 1;

  /// from: static public final int TAP_TO_FOCUS_FOCUSED
  static const TAP_TO_FOCUS_FOCUSED = 2;

  /// from: static public final int TAP_TO_FOCUS_NOT_FOCUSED
  static const TAP_TO_FOCUS_NOT_FOCUSED = 3;

  /// from: static public final int TAP_TO_FOCUS_FAILED
  static const TAP_TO_FOCUS_FAILED = 4;

  /// from: static public final int IMAGE_CAPTURE
  static const IMAGE_CAPTURE = 1;

  /// from: static public final int IMAGE_ANALYSIS
  static const IMAGE_ANALYSIS = 2;

  /// from: static public final int VIDEO_CAPTURE
  static const VIDEO_CAPTURE = 4;
  static final _id_getInitializationFuture = _class.instanceMethodId(
    r'getInitializationFuture',
    r'()Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _getInitializationFuture = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.common.util.concurrent.ListenableFuture getInitializationFuture()
  /// The returned object must be released after use, by calling the [release] method.
  listenablefuture_.ListenableFuture<jni.JObject> getInitializationFuture() {
    return _getInitializationFuture(
            reference.pointer, _id_getInitializationFuture as jni.JMethodIDPtr)
        .object(
            const listenablefuture_.$ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setEnabledUseCases = _class.instanceMethodId(
    r'setEnabledUseCases',
    r'(I)V',
  );

  static final _setEnabledUseCases = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setEnabledUseCases(int i)
  void setEnabledUseCases(
    int i,
  ) {
    _setEnabledUseCases(
            reference.pointer, _id_setEnabledUseCases as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setPreviewTargetSize = _class.instanceMethodId(
    r'setPreviewTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setPreviewTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setPreviewTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setPreviewTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setPreviewTargetSize(
            reference.pointer,
            _id_setPreviewTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getPreviewTargetSize = _class.instanceMethodId(
    r'getPreviewTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getPreviewTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getPreviewTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getPreviewTargetSize() {
    return _getPreviewTargetSize(
            reference.pointer, _id_getPreviewTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_setPreviewResolutionSelector = _class.instanceMethodId(
    r'setPreviewResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setPreviewResolutionSelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setPreviewResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)
  void setPreviewResolutionSelector(
    resolutionselector_.ResolutionSelector resolutionSelector,
  ) {
    _setPreviewResolutionSelector(
            reference.pointer,
            _id_setPreviewResolutionSelector as jni.JMethodIDPtr,
            resolutionSelector.reference.pointer)
        .check();
  }

  static final _id_getPreviewResolutionSelector = _class.instanceMethodId(
    r'getPreviewResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getPreviewResolutionSelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector getPreviewResolutionSelector()
  /// The returned object must be released after use, by calling the [release] method.
  resolutionselector_.ResolutionSelector getPreviewResolutionSelector() {
    return _getPreviewResolutionSelector(reference.pointer,
            _id_getPreviewResolutionSelector as jni.JMethodIDPtr)
        .object(const resolutionselector_.$ResolutionSelectorType());
  }

  static final _id_isImageCaptureEnabled = _class.instanceMethodId(
    r'isImageCaptureEnabled',
    r'()Z',
  );

  static final _isImageCaptureEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isImageCaptureEnabled()
  bool isImageCaptureEnabled() {
    return _isImageCaptureEnabled(
            reference.pointer, _id_isImageCaptureEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getImageCaptureFlashMode = _class.instanceMethodId(
    r'getImageCaptureFlashMode',
    r'()I',
  );

  static final _getImageCaptureFlashMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageCaptureFlashMode()
  int getImageCaptureFlashMode() {
    return _getImageCaptureFlashMode(
            reference.pointer, _id_getImageCaptureFlashMode as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageCaptureFlashMode = _class.instanceMethodId(
    r'setImageCaptureFlashMode',
    r'(I)V',
  );

  static final _setImageCaptureFlashMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageCaptureFlashMode(int i)
  void setImageCaptureFlashMode(
    int i,
  ) {
    _setImageCaptureFlashMode(reference.pointer,
            _id_setImageCaptureFlashMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setScreenFlashUiInfo = _class.instanceMethodId(
    r'setScreenFlashUiInfo',
    r'(Landroidx/camera/view/internal/ScreenFlashUiInfo;)V',
  );

  static final _setScreenFlashUiInfo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setScreenFlashUiInfo(androidx.camera.view.internal.ScreenFlashUiInfo screenFlashUiInfo)
  void setScreenFlashUiInfo(
    jni.JObject screenFlashUiInfo,
  ) {
    _setScreenFlashUiInfo(
            reference.pointer,
            _id_setScreenFlashUiInfo as jni.JMethodIDPtr,
            screenFlashUiInfo.reference.pointer)
        .check();
  }

  static final _id_updateScreenFlashToImageCapture = _class.instanceMethodId(
    r'updateScreenFlashToImageCapture',
    r'()V',
  );

  static final _updateScreenFlashToImageCapture = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void updateScreenFlashToImageCapture()
  void updateScreenFlashToImageCapture() {
    _updateScreenFlashToImageCapture(reference.pointer,
            _id_updateScreenFlashToImageCapture as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getScreenFlashUiInfoByPriority = _class.instanceMethodId(
    r'getScreenFlashUiInfoByPriority',
    r'()Landroidx/camera/view/internal/ScreenFlashUiInfo;',
  );

  static final _getScreenFlashUiInfoByPriority = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.internal.ScreenFlashUiInfo getScreenFlashUiInfoByPriority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getScreenFlashUiInfoByPriority() {
    return _getScreenFlashUiInfoByPriority(reference.pointer,
            _id_getScreenFlashUiInfoByPriority as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_takePicture = _class.instanceMethodId(
    r'takePicture',
    r'(Landroidx/camera/core/ImageCapture$OutputFileOptions;Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageSavedCallback;)V',
  );

  static final _takePicture = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void takePicture(androidx.camera.core.ImageCapture$OutputFileOptions outputFileOptions, java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageSavedCallback onImageSavedCallback)
  void takePicture(
    jni.JObject outputFileOptions,
    executor_.Executor executor,
    jni.JObject onImageSavedCallback,
  ) {
    _takePicture(
            reference.pointer,
            _id_takePicture as jni.JMethodIDPtr,
            outputFileOptions.reference.pointer,
            executor.reference.pointer,
            onImageSavedCallback.reference.pointer)
        .check();
  }

  static final _id_takePicture1 = _class.instanceMethodId(
    r'takePicture',
    r'(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageCapturedCallback;)V',
  );

  static final _takePicture1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void takePicture(java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageCapturedCallback onImageCapturedCallback)
  void takePicture1(
    executor_.Executor executor,
    jni.JObject onImageCapturedCallback,
  ) {
    _takePicture1(
            reference.pointer,
            _id_takePicture1 as jni.JMethodIDPtr,
            executor.reference.pointer,
            onImageCapturedCallback.reference.pointer)
        .check();
  }

  static final _id_setImageCaptureMode = _class.instanceMethodId(
    r'setImageCaptureMode',
    r'(I)V',
  );

  static final _setImageCaptureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageCaptureMode(int i)
  void setImageCaptureMode(
    int i,
  ) {
    _setImageCaptureMode(
            reference.pointer, _id_setImageCaptureMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getImageCaptureMode = _class.instanceMethodId(
    r'getImageCaptureMode',
    r'()I',
  );

  static final _getImageCaptureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageCaptureMode()
  int getImageCaptureMode() {
    return _getImageCaptureMode(
            reference.pointer, _id_getImageCaptureMode as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageCaptureTargetSize = _class.instanceMethodId(
    r'setImageCaptureTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setImageCaptureTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageCaptureTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setImageCaptureTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setImageCaptureTargetSize(
            reference.pointer,
            _id_setImageCaptureTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getImageCaptureTargetSize = _class.instanceMethodId(
    r'getImageCaptureTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getImageCaptureTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getImageCaptureTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getImageCaptureTargetSize() {
    return _getImageCaptureTargetSize(reference.pointer,
            _id_getImageCaptureTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_setImageCaptureResolutionSelector = _class.instanceMethodId(
    r'setImageCaptureResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setImageCaptureResolutionSelector =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageCaptureResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)
  void setImageCaptureResolutionSelector(
    resolutionselector_.ResolutionSelector resolutionSelector,
  ) {
    _setImageCaptureResolutionSelector(
            reference.pointer,
            _id_setImageCaptureResolutionSelector as jni.JMethodIDPtr,
            resolutionSelector.reference.pointer)
        .check();
  }

  static final _id_getImageCaptureResolutionSelector = _class.instanceMethodId(
    r'getImageCaptureResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getImageCaptureResolutionSelector =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector getImageCaptureResolutionSelector()
  /// The returned object must be released after use, by calling the [release] method.
  resolutionselector_.ResolutionSelector getImageCaptureResolutionSelector() {
    return _getImageCaptureResolutionSelector(reference.pointer,
            _id_getImageCaptureResolutionSelector as jni.JMethodIDPtr)
        .object(const resolutionselector_.$ResolutionSelectorType());
  }

  static final _id_setImageCaptureIoExecutor = _class.instanceMethodId(
    r'setImageCaptureIoExecutor',
    r'(Ljava/util/concurrent/Executor;)V',
  );

  static final _setImageCaptureIoExecutor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageCaptureIoExecutor(java.util.concurrent.Executor executor)
  void setImageCaptureIoExecutor(
    executor_.Executor executor,
  ) {
    _setImageCaptureIoExecutor(
            reference.pointer,
            _id_setImageCaptureIoExecutor as jni.JMethodIDPtr,
            executor.reference.pointer)
        .check();
  }

  static final _id_getImageCaptureIoExecutor = _class.instanceMethodId(
    r'getImageCaptureIoExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getImageCaptureIoExecutor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.concurrent.Executor getImageCaptureIoExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  executor_.Executor getImageCaptureIoExecutor() {
    return _getImageCaptureIoExecutor(reference.pointer,
            _id_getImageCaptureIoExecutor as jni.JMethodIDPtr)
        .object(const executor_.$ExecutorType());
  }

  static final _id_isImageAnalysisEnabled = _class.instanceMethodId(
    r'isImageAnalysisEnabled',
    r'()Z',
  );

  static final _isImageAnalysisEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isImageAnalysisEnabled()
  bool isImageAnalysisEnabled() {
    return _isImageAnalysisEnabled(
            reference.pointer, _id_isImageAnalysisEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setImageAnalysisAnalyzer = _class.instanceMethodId(
    r'setImageAnalysisAnalyzer',
    r'(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageAnalysis$Analyzer;)V',
  );

  static final _setImageAnalysisAnalyzer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisAnalyzer(java.util.concurrent.Executor executor, androidx.camera.core.ImageAnalysis$Analyzer analyzer)
  void setImageAnalysisAnalyzer(
    executor_.Executor executor,
    jni.JObject analyzer,
  ) {
    _setImageAnalysisAnalyzer(
            reference.pointer,
            _id_setImageAnalysisAnalyzer as jni.JMethodIDPtr,
            executor.reference.pointer,
            analyzer.reference.pointer)
        .check();
  }

  static final _id_clearImageAnalysisAnalyzer = _class.instanceMethodId(
    r'clearImageAnalysisAnalyzer',
    r'()V',
  );

  static final _clearImageAnalysisAnalyzer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void clearImageAnalysisAnalyzer()
  void clearImageAnalysisAnalyzer() {
    _clearImageAnalysisAnalyzer(reference.pointer,
            _id_clearImageAnalysisAnalyzer as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getImageAnalysisBackpressureStrategy =
      _class.instanceMethodId(
    r'getImageAnalysisBackpressureStrategy',
    r'()I',
  );

  static final _getImageAnalysisBackpressureStrategy =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public int getImageAnalysisBackpressureStrategy()
  int getImageAnalysisBackpressureStrategy() {
    return _getImageAnalysisBackpressureStrategy(reference.pointer,
            _id_getImageAnalysisBackpressureStrategy as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageAnalysisBackpressureStrategy =
      _class.instanceMethodId(
    r'setImageAnalysisBackpressureStrategy',
    r'(I)V',
  );

  static final _setImageAnalysisBackpressureStrategy =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageAnalysisBackpressureStrategy(int i)
  void setImageAnalysisBackpressureStrategy(
    int i,
  ) {
    _setImageAnalysisBackpressureStrategy(reference.pointer,
            _id_setImageAnalysisBackpressureStrategy as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setImageAnalysisImageQueueDepth = _class.instanceMethodId(
    r'setImageAnalysisImageQueueDepth',
    r'(I)V',
  );

  static final _setImageAnalysisImageQueueDepth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageAnalysisImageQueueDepth(int i)
  void setImageAnalysisImageQueueDepth(
    int i,
  ) {
    _setImageAnalysisImageQueueDepth(reference.pointer,
            _id_setImageAnalysisImageQueueDepth as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getImageAnalysisImageQueueDepth = _class.instanceMethodId(
    r'getImageAnalysisImageQueueDepth',
    r'()I',
  );

  static final _getImageAnalysisImageQueueDepth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageAnalysisImageQueueDepth()
  int getImageAnalysisImageQueueDepth() {
    return _getImageAnalysisImageQueueDepth(reference.pointer,
            _id_getImageAnalysisImageQueueDepth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageAnalysisTargetSize = _class.instanceMethodId(
    r'setImageAnalysisTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setImageAnalysisTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setImageAnalysisTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setImageAnalysisTargetSize(
            reference.pointer,
            _id_setImageAnalysisTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getImageAnalysisTargetSize = _class.instanceMethodId(
    r'getImageAnalysisTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getImageAnalysisTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getImageAnalysisTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getImageAnalysisTargetSize() {
    return _getImageAnalysisTargetSize(reference.pointer,
            _id_getImageAnalysisTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_setImageAnalysisResolutionSelector = _class.instanceMethodId(
    r'setImageAnalysisResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setImageAnalysisResolutionSelector =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)
  void setImageAnalysisResolutionSelector(
    resolutionselector_.ResolutionSelector resolutionSelector,
  ) {
    _setImageAnalysisResolutionSelector(
            reference.pointer,
            _id_setImageAnalysisResolutionSelector as jni.JMethodIDPtr,
            resolutionSelector.reference.pointer)
        .check();
  }

  static final _id_getImageAnalysisResolutionSelector = _class.instanceMethodId(
    r'getImageAnalysisResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getImageAnalysisResolutionSelector =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector getImageAnalysisResolutionSelector()
  /// The returned object must be released after use, by calling the [release] method.
  resolutionselector_.ResolutionSelector getImageAnalysisResolutionSelector() {
    return _getImageAnalysisResolutionSelector(reference.pointer,
            _id_getImageAnalysisResolutionSelector as jni.JMethodIDPtr)
        .object(const resolutionselector_.$ResolutionSelectorType());
  }

  static final _id_setImageAnalysisBackgroundExecutor = _class.instanceMethodId(
    r'setImageAnalysisBackgroundExecutor',
    r'(Ljava/util/concurrent/Executor;)V',
  );

  static final _setImageAnalysisBackgroundExecutor =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisBackgroundExecutor(java.util.concurrent.Executor executor)
  void setImageAnalysisBackgroundExecutor(
    executor_.Executor executor,
  ) {
    _setImageAnalysisBackgroundExecutor(
            reference.pointer,
            _id_setImageAnalysisBackgroundExecutor as jni.JMethodIDPtr,
            executor.reference.pointer)
        .check();
  }

  static final _id_getImageAnalysisBackgroundExecutor = _class.instanceMethodId(
    r'getImageAnalysisBackgroundExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getImageAnalysisBackgroundExecutor =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public java.util.concurrent.Executor getImageAnalysisBackgroundExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  executor_.Executor getImageAnalysisBackgroundExecutor() {
    return _getImageAnalysisBackgroundExecutor(reference.pointer,
            _id_getImageAnalysisBackgroundExecutor as jni.JMethodIDPtr)
        .object(const executor_.$ExecutorType());
  }

  static final _id_setImageAnalysisOutputImageFormat = _class.instanceMethodId(
    r'setImageAnalysisOutputImageFormat',
    r'(I)V',
  );

  static final _setImageAnalysisOutputImageFormat =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageAnalysisOutputImageFormat(int i)
  void setImageAnalysisOutputImageFormat(
    int i,
  ) {
    _setImageAnalysisOutputImageFormat(reference.pointer,
            _id_setImageAnalysisOutputImageFormat as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getImageAnalysisOutputImageFormat = _class.instanceMethodId(
    r'getImageAnalysisOutputImageFormat',
    r'()I',
  );

  static final _getImageAnalysisOutputImageFormat =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public int getImageAnalysisOutputImageFormat()
  int getImageAnalysisOutputImageFormat() {
    return _getImageAnalysisOutputImageFormat(reference.pointer,
            _id_getImageAnalysisOutputImageFormat as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_isVideoCaptureEnabled = _class.instanceMethodId(
    r'isVideoCaptureEnabled',
    r'()Z',
  );

  static final _isVideoCaptureEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isVideoCaptureEnabled()
  bool isVideoCaptureEnabled() {
    return _isVideoCaptureEnabled(
            reference.pointer, _id_isVideoCaptureEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_startRecording = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/FileOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.FileOutputOptions fileOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  recording_.Recording startRecording(
    jni.JObject fileOutputOptions,
    audioconfig_.AudioConfig audioConfig,
    executor_.Executor executor,
    consumer_.Consumer<videorecordevent_.VideoRecordEvent> consumer,
  ) {
    return _startRecording(
            reference.pointer,
            _id_startRecording as jni.JMethodIDPtr,
            fileOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const recording_.$RecordingType());
  }

  static final _id_startRecording1 = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/FileDescriptorOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.FileDescriptorOutputOptions fileDescriptorOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  recording_.Recording startRecording1(
    jni.JObject fileDescriptorOutputOptions,
    audioconfig_.AudioConfig audioConfig,
    executor_.Executor executor,
    consumer_.Consumer<videorecordevent_.VideoRecordEvent> consumer,
  ) {
    return _startRecording1(
            reference.pointer,
            _id_startRecording1 as jni.JMethodIDPtr,
            fileDescriptorOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const recording_.$RecordingType());
  }

  static final _id_startRecording2 = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/MediaStoreOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.MediaStoreOutputOptions mediaStoreOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  recording_.Recording startRecording2(
    jni.JObject mediaStoreOutputOptions,
    audioconfig_.AudioConfig audioConfig,
    executor_.Executor executor,
    consumer_.Consumer<videorecordevent_.VideoRecordEvent> consumer,
  ) {
    return _startRecording2(
            reference.pointer,
            _id_startRecording2 as jni.JMethodIDPtr,
            mediaStoreOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const recording_.$RecordingType());
  }

  static final _id_isRecording = _class.instanceMethodId(
    r'isRecording',
    r'()Z',
  );

  static final _isRecording = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isRecording()
  bool isRecording() {
    return _isRecording(reference.pointer, _id_isRecording as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setVideoCaptureQualitySelector = _class.instanceMethodId(
    r'setVideoCaptureQualitySelector',
    r'(Landroidx/camera/video/QualitySelector;)V',
  );

  static final _setVideoCaptureQualitySelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setVideoCaptureQualitySelector(androidx.camera.video.QualitySelector qualitySelector)
  void setVideoCaptureQualitySelector(
    qualityselector_.QualitySelector qualitySelector,
  ) {
    _setVideoCaptureQualitySelector(
            reference.pointer,
            _id_setVideoCaptureQualitySelector as jni.JMethodIDPtr,
            qualitySelector.reference.pointer)
        .check();
  }

  static final _id_getVideoCaptureQualitySelector = _class.instanceMethodId(
    r'getVideoCaptureQualitySelector',
    r'()Landroidx/camera/video/QualitySelector;',
  );

  static final _getVideoCaptureQualitySelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.video.QualitySelector getVideoCaptureQualitySelector()
  /// The returned object must be released after use, by calling the [release] method.
  qualityselector_.QualitySelector getVideoCaptureQualitySelector() {
    return _getVideoCaptureQualitySelector(reference.pointer,
            _id_getVideoCaptureQualitySelector as jni.JMethodIDPtr)
        .object(const qualityselector_.$QualitySelectorType());
  }

  static final _id_setVideoCaptureMirrorMode = _class.instanceMethodId(
    r'setVideoCaptureMirrorMode',
    r'(I)V',
  );

  static final _setVideoCaptureMirrorMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setVideoCaptureMirrorMode(int i)
  void setVideoCaptureMirrorMode(
    int i,
  ) {
    _setVideoCaptureMirrorMode(reference.pointer,
            _id_setVideoCaptureMirrorMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getVideoCaptureMirrorMode = _class.instanceMethodId(
    r'getVideoCaptureMirrorMode',
    r'()I',
  );

  static final _getVideoCaptureMirrorMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getVideoCaptureMirrorMode()
  int getVideoCaptureMirrorMode() {
    return _getVideoCaptureMirrorMode(reference.pointer,
            _id_getVideoCaptureMirrorMode as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setVideoCaptureDynamicRange = _class.instanceMethodId(
    r'setVideoCaptureDynamicRange',
    r'(Landroidx/camera/core/DynamicRange;)V',
  );

  static final _setVideoCaptureDynamicRange = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setVideoCaptureDynamicRange(androidx.camera.core.DynamicRange dynamicRange)
  void setVideoCaptureDynamicRange(
    dynamicrange_.DynamicRange dynamicRange,
  ) {
    _setVideoCaptureDynamicRange(
            reference.pointer,
            _id_setVideoCaptureDynamicRange as jni.JMethodIDPtr,
            dynamicRange.reference.pointer)
        .check();
  }

  static final _id_getVideoCaptureDynamicRange = _class.instanceMethodId(
    r'getVideoCaptureDynamicRange',
    r'()Landroidx/camera/core/DynamicRange;',
  );

  static final _getVideoCaptureDynamicRange = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.DynamicRange getVideoCaptureDynamicRange()
  /// The returned object must be released after use, by calling the [release] method.
  dynamicrange_.DynamicRange getVideoCaptureDynamicRange() {
    return _getVideoCaptureDynamicRange(reference.pointer,
            _id_getVideoCaptureDynamicRange as jni.JMethodIDPtr)
        .object(const dynamicrange_.$DynamicRangeType());
  }

  static final _id_setVideoCaptureTargetFrameRate = _class.instanceMethodId(
    r'setVideoCaptureTargetFrameRate',
    r'(Landroid/util/Range;)V',
  );

  static final _setVideoCaptureTargetFrameRate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setVideoCaptureTargetFrameRate(android.util.Range range)
  void setVideoCaptureTargetFrameRate(
    jni.JObject range,
  ) {
    _setVideoCaptureTargetFrameRate(
            reference.pointer,
            _id_setVideoCaptureTargetFrameRate as jni.JMethodIDPtr,
            range.reference.pointer)
        .check();
  }

  static final _id_getVideoCaptureTargetFrameRate = _class.instanceMethodId(
    r'getVideoCaptureTargetFrameRate',
    r'()Landroid/util/Range;',
  );

  static final _getVideoCaptureTargetFrameRate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.util.Range getVideoCaptureTargetFrameRate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVideoCaptureTargetFrameRate() {
    return _getVideoCaptureTargetFrameRate(reference.pointer,
            _id_getVideoCaptureTargetFrameRate as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setCameraSelector = _class.instanceMethodId(
    r'setCameraSelector',
    r'(Landroidx/camera/core/CameraSelector;)V',
  );

  static final _setCameraSelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setCameraSelector(androidx.camera.core.CameraSelector cameraSelector)
  void setCameraSelector(
    cameraselector_.CameraSelector cameraSelector,
  ) {
    _setCameraSelector(
            reference.pointer,
            _id_setCameraSelector as jni.JMethodIDPtr,
            cameraSelector.reference.pointer)
        .check();
  }

  static final _id_hasCamera = _class.instanceMethodId(
    r'hasCamera',
    r'(Landroidx/camera/core/CameraSelector;)Z',
  );

  static final _hasCamera = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasCamera(androidx.camera.core.CameraSelector cameraSelector)
  bool hasCamera(
    cameraselector_.CameraSelector cameraSelector,
  ) {
    return _hasCamera(reference.pointer, _id_hasCamera as jni.JMethodIDPtr,
            cameraSelector.reference.pointer)
        .boolean;
  }

  static final _id_getCameraSelector = _class.instanceMethodId(
    r'getCameraSelector',
    r'()Landroidx/camera/core/CameraSelector;',
  );

  static final _getCameraSelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraSelector getCameraSelector()
  /// The returned object must be released after use, by calling the [release] method.
  cameraselector_.CameraSelector getCameraSelector() {
    return _getCameraSelector(
            reference.pointer, _id_getCameraSelector as jni.JMethodIDPtr)
        .object(const cameraselector_.$CameraSelectorType());
  }

  static final _id_isPinchToZoomEnabled = _class.instanceMethodId(
    r'isPinchToZoomEnabled',
    r'()Z',
  );

  static final _isPinchToZoomEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isPinchToZoomEnabled()
  bool isPinchToZoomEnabled() {
    return _isPinchToZoomEnabled(
            reference.pointer, _id_isPinchToZoomEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPinchToZoomEnabled = _class.instanceMethodId(
    r'setPinchToZoomEnabled',
    r'(Z)V',
  );

  static final _setPinchToZoomEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setPinchToZoomEnabled(boolean z)
  void setPinchToZoomEnabled(
    bool z,
  ) {
    _setPinchToZoomEnabled(reference.pointer,
            _id_setPinchToZoomEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isTapToFocusEnabled = _class.instanceMethodId(
    r'isTapToFocusEnabled',
    r'()Z',
  );

  static final _isTapToFocusEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isTapToFocusEnabled()
  bool isTapToFocusEnabled() {
    return _isTapToFocusEnabled(
            reference.pointer, _id_isTapToFocusEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setTapToFocusEnabled = _class.instanceMethodId(
    r'setTapToFocusEnabled',
    r'(Z)V',
  );

  static final _setTapToFocusEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setTapToFocusEnabled(boolean z)
  void setTapToFocusEnabled(
    bool z,
  ) {
    _setTapToFocusEnabled(reference.pointer,
            _id_setTapToFocusEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getTapToFocusState = _class.instanceMethodId(
    r'getTapToFocusState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getTapToFocusState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getTapToFocusState()
  /// The returned object must be released after use, by calling the [release] method.
  livedata_.LiveData<jni.JInteger> getTapToFocusState() {
    return _getTapToFocusState(
            reference.pointer, _id_getTapToFocusState as jni.JMethodIDPtr)
        .object(const livedata_.$LiveDataType(jni.JIntegerType()));
  }

  static final _id_getZoomState = _class.instanceMethodId(
    r'getZoomState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getZoomState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getZoomState()
  /// The returned object must be released after use, by calling the [release] method.
  livedata_.LiveData<zoomstate_.ZoomState> getZoomState() {
    return _getZoomState(
            reference.pointer, _id_getZoomState as jni.JMethodIDPtr)
        .object(const livedata_.$LiveDataType(zoomstate_.$ZoomStateType()));
  }

  static final _id_getCameraInfo = _class.instanceMethodId(
    r'getCameraInfo',
    r'()Landroidx/camera/core/CameraInfo;',
  );

  static final _getCameraInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraInfo getCameraInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCameraInfo() {
    return _getCameraInfo(
            reference.pointer, _id_getCameraInfo as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getCameraControl = _class.instanceMethodId(
    r'getCameraControl',
    r'()Landroidx/camera/core/CameraControl;',
  );

  static final _getCameraControl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraControl getCameraControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCameraControl() {
    return _getCameraControl(
            reference.pointer, _id_getCameraControl as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setZoomRatio = _class.instanceMethodId(
    r'setZoomRatio',
    r'(F)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _setZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture setZoomRatio(float f)
  /// The returned object must be released after use, by calling the [release] method.
  listenablefuture_.ListenableFuture<jni.JObject> setZoomRatio(
    double f,
  ) {
    return _setZoomRatio(
            reference.pointer, _id_setZoomRatio as jni.JMethodIDPtr, f)
        .object(
            const listenablefuture_.$ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setLinearZoom = _class.instanceMethodId(
    r'setLinearZoom',
    r'(F)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _setLinearZoom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture setLinearZoom(float f)
  /// The returned object must be released after use, by calling the [release] method.
  listenablefuture_.ListenableFuture<jni.JObject> setLinearZoom(
    double f,
  ) {
    return _setLinearZoom(
            reference.pointer, _id_setLinearZoom as jni.JMethodIDPtr, f)
        .object(
            const listenablefuture_.$ListenableFutureType(jni.JObjectType()));
  }

  static final _id_getTorchState = _class.instanceMethodId(
    r'getTorchState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getTorchState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getTorchState()
  /// The returned object must be released after use, by calling the [release] method.
  livedata_.LiveData<jni.JInteger> getTorchState() {
    return _getTorchState(
            reference.pointer, _id_getTorchState as jni.JMethodIDPtr)
        .object(const livedata_.$LiveDataType(jni.JIntegerType()));
  }

  static final _id_enableTorch = _class.instanceMethodId(
    r'enableTorch',
    r'(Z)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _enableTorch = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture enableTorch(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  listenablefuture_.ListenableFuture<jni.JObject> enableTorch(
    bool z,
  ) {
    return _enableTorch(
            reference.pointer, _id_enableTorch as jni.JMethodIDPtr, z ? 1 : 0)
        .object(
            const listenablefuture_.$ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setEffects = _class.instanceMethodId(
    r'setEffects',
    r'(Ljava/util/Set;)V',
  );

  static final _setEffects = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setEffects(java.util.Set set)
  void setEffects(
    jni.JSet<jni.JObject> set0,
  ) {
    _setEffects(reference.pointer, _id_setEffects as jni.JMethodIDPtr,
            set0.reference.pointer)
        .check();
  }

  static final _id_clearEffects = _class.instanceMethodId(
    r'clearEffects',
    r'()V',
  );

  static final _clearEffects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void clearEffects()
  void clearEffects() {
    _clearEffects(reference.pointer, _id_clearEffects as jni.JMethodIDPtr)
        .check();
  }

  static final _id_createUseCaseGroup = _class.instanceMethodId(
    r'createUseCaseGroup',
    r'()Landroidx/camera/core/UseCaseGroup;',
  );

  static final _createUseCaseGroup = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected androidx.camera.core.UseCaseGroup createUseCaseGroup()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createUseCaseGroup() {
    return _createUseCaseGroup(
            reference.pointer, _id_createUseCaseGroup as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $CameraControllerType extends jni.JObjType<CameraController> {
  const $CameraControllerType();

  @override
  String get signature => r'Landroidx/camera/view/CameraController;';

  @override
  CameraController fromReference(jni.JReference reference) =>
      CameraController.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraControllerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraControllerType) &&
        other is $CameraControllerType;
  }
}
