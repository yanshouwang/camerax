// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'video/AudioConfig.dart' as audioconfig$_;

/// from: `androidx.camera.view.CameraController$OutputSize$OutputAspectRatio`
class CameraController$OutputSize$OutputAspectRatio extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<CameraController$OutputSize$OutputAspectRatio> $type;

  @jni$_.internal
  CameraController$OutputSize$OutputAspectRatio.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/view/CameraController$OutputSize$OutputAspectRatio',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CameraController$OutputSize$OutputAspectRatio?>
  nullableType = $CameraController$OutputSize$OutputAspectRatio$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CameraController$OutputSize$OutputAspectRatio> type =
      $CameraController$OutputSize$OutputAspectRatio$Type$();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $CameraController$OutputSize$OutputAspectRatio>
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $CameraController$OutputSize$OutputAspectRatio $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.camera.view.CameraController$OutputSize$OutputAspectRatio',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory CameraController$OutputSize$OutputAspectRatio.implement(
    $CameraController$OutputSize$OutputAspectRatio $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return CameraController$OutputSize$OutputAspectRatio.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $CameraController$OutputSize$OutputAspectRatio {
  factory $CameraController$OutputSize$OutputAspectRatio() =
      _$CameraController$OutputSize$OutputAspectRatio;
}

final class _$CameraController$OutputSize$OutputAspectRatio
    with $CameraController$OutputSize$OutputAspectRatio {
  _$CameraController$OutputSize$OutputAspectRatio();
}

final class $CameraController$OutputSize$OutputAspectRatio$NullableType$
    extends jni$_.JType<CameraController$OutputSize$OutputAspectRatio?> {
  @jni$_.internal
  const $CameraController$OutputSize$OutputAspectRatio$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/view/CameraController$OutputSize$OutputAspectRatio;';

  @jni$_.internal
  @core$_.override
  CameraController$OutputSize$OutputAspectRatio? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : CameraController$OutputSize$OutputAspectRatio.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CameraController$OutputSize$OutputAspectRatio?>
  get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($CameraController$OutputSize$OutputAspectRatio$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($CameraController$OutputSize$OutputAspectRatio$NullableType$) &&
        other is $CameraController$OutputSize$OutputAspectRatio$NullableType$;
  }
}

final class $CameraController$OutputSize$OutputAspectRatio$Type$
    extends jni$_.JType<CameraController$OutputSize$OutputAspectRatio> {
  @jni$_.internal
  const $CameraController$OutputSize$OutputAspectRatio$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/view/CameraController$OutputSize$OutputAspectRatio;';

  @jni$_.internal
  @core$_.override
  CameraController$OutputSize$OutputAspectRatio fromReference(
    jni$_.JReference reference,
  ) => CameraController$OutputSize$OutputAspectRatio.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CameraController$OutputSize$OutputAspectRatio?>
  get nullableType =>
      const $CameraController$OutputSize$OutputAspectRatio$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($CameraController$OutputSize$OutputAspectRatio$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($CameraController$OutputSize$OutputAspectRatio$Type$) &&
        other is $CameraController$OutputSize$OutputAspectRatio$Type$;
  }
}

/// from: `androidx.camera.view.CameraController$OutputSize`
class CameraController$OutputSize extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<CameraController$OutputSize> $type;

  @jni$_.internal
  CameraController$OutputSize.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/view/CameraController$OutputSize',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CameraController$OutputSize?> nullableType =
      $CameraController$OutputSize$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CameraController$OutputSize> type =
      $CameraController$OutputSize$Type$();

  /// from: `static public final int UNASSIGNED_ASPECT_RATIO`
  static const UNASSIGNED_ASPECT_RATIO = -1;
  static final _id_new$ = _class.constructorId(r'(I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraController$OutputSize(int i) {
    return CameraController$OutputSize.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Landroid/util/Size;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.util.Size size)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraController$OutputSize.new$1(jni$_.JObject? size) {
    final _$size = size?.reference ?? jni$_.jNullReference;
    return CameraController$OutputSize.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$size.pointer,
      ).reference,
    );
  }

  static final _id_getAspectRatio = _class.instanceMethodId(
    r'getAspectRatio',
    r'()I',
  );

  static final _getAspectRatio =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getAspectRatio()`
  int getAspectRatio() {
    return _getAspectRatio(
      reference.pointer,
      _id_getAspectRatio as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getResolution = _class.instanceMethodId(
    r'getResolution',
    r'()Landroid/util/Size;',
  );

  static final _getResolution =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.util.Size getResolution()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getResolution() {
    return _getResolution(
      reference.pointer,
      _id_getResolution as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $CameraController$OutputSize$NullableType$
    extends jni$_.JType<CameraController$OutputSize?> {
  @jni$_.internal
  const $CameraController$OutputSize$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/view/CameraController$OutputSize;';

  @jni$_.internal
  @core$_.override
  CameraController$OutputSize? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : CameraController$OutputSize.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CameraController$OutputSize?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CameraController$OutputSize$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController$OutputSize$NullableType$) &&
        other is $CameraController$OutputSize$NullableType$;
  }
}

final class $CameraController$OutputSize$Type$
    extends jni$_.JType<CameraController$OutputSize> {
  @jni$_.internal
  const $CameraController$OutputSize$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/view/CameraController$OutputSize;';

  @jni$_.internal
  @core$_.override
  CameraController$OutputSize fromReference(jni$_.JReference reference) =>
      CameraController$OutputSize.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CameraController$OutputSize?> get nullableType =>
      const $CameraController$OutputSize$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CameraController$OutputSize$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController$OutputSize$Type$) &&
        other is $CameraController$OutputSize$Type$;
  }
}

/// from: `androidx.camera.view.CameraController$UseCases`
class CameraController$UseCases extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<CameraController$UseCases> $type;

  @jni$_.internal
  CameraController$UseCases.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/view/CameraController$UseCases',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CameraController$UseCases?> nullableType =
      $CameraController$UseCases$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CameraController$UseCases> type =
      $CameraController$UseCases$Type$();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $CameraController$UseCases> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $CameraController$UseCases $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.camera.view.CameraController$UseCases',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory CameraController$UseCases.implement(
    $CameraController$UseCases $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return CameraController$UseCases.fromReference($i.implementReference());
  }
}

abstract base mixin class $CameraController$UseCases {
  factory $CameraController$UseCases() = _$CameraController$UseCases;
}

final class _$CameraController$UseCases with $CameraController$UseCases {
  _$CameraController$UseCases();
}

final class $CameraController$UseCases$NullableType$
    extends jni$_.JType<CameraController$UseCases?> {
  @jni$_.internal
  const $CameraController$UseCases$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/view/CameraController$UseCases;';

  @jni$_.internal
  @core$_.override
  CameraController$UseCases? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : CameraController$UseCases.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CameraController$UseCases?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CameraController$UseCases$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController$UseCases$NullableType$) &&
        other is $CameraController$UseCases$NullableType$;
  }
}

final class $CameraController$UseCases$Type$
    extends jni$_.JType<CameraController$UseCases> {
  @jni$_.internal
  const $CameraController$UseCases$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/view/CameraController$UseCases;';

  @jni$_.internal
  @core$_.override
  CameraController$UseCases fromReference(jni$_.JReference reference) =>
      CameraController$UseCases.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CameraController$UseCases?> get nullableType =>
      const $CameraController$UseCases$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CameraController$UseCases$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController$UseCases$Type$) &&
        other is $CameraController$UseCases$Type$;
  }
}

/// from: `androidx.camera.view.CameraController`
class CameraController extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<CameraController> $type;

  @jni$_.internal
  CameraController.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/view/CameraController',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CameraController?> nullableType =
      $CameraController$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CameraController> type = $CameraController$Type$();

  /// from: `static public final int COORDINATE_SYSTEM_VIEW_REFERENCED`
  static const COORDINATE_SYSTEM_VIEW_REFERENCED = 1;

  /// from: `static public final int TAP_TO_FOCUS_NOT_STARTED`
  static const TAP_TO_FOCUS_NOT_STARTED = 0;

  /// from: `static public final int TAP_TO_FOCUS_STARTED`
  static const TAP_TO_FOCUS_STARTED = 1;

  /// from: `static public final int TAP_TO_FOCUS_FOCUSED`
  static const TAP_TO_FOCUS_FOCUSED = 2;

  /// from: `static public final int TAP_TO_FOCUS_NOT_FOCUSED`
  static const TAP_TO_FOCUS_NOT_FOCUSED = 3;

  /// from: `static public final int TAP_TO_FOCUS_FAILED`
  static const TAP_TO_FOCUS_FAILED = 4;

  /// from: `static public final int IMAGE_CAPTURE`
  static const IMAGE_CAPTURE = 1;

  /// from: `static public final int IMAGE_ANALYSIS`
  static const IMAGE_ANALYSIS = 2;

  /// from: `static public final int VIDEO_CAPTURE`
  static const VIDEO_CAPTURE = 4;
  static final _id_getInitializationFuture = _class.instanceMethodId(
    r'getInitializationFuture',
    r'()Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _getInitializationFuture =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public com.google.common.util.concurrent.ListenableFuture<java.lang.Void> getInitializationFuture()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getInitializationFuture() {
    return _getInitializationFuture(
      reference.pointer,
      _id_getInitializationFuture as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setEnabledUseCases = _class.instanceMethodId(
    r'setEnabledUseCases',
    r'(I)V',
  );

  static final _setEnabledUseCases =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setEnabledUseCases(int i)`
  void setEnabledUseCases(int i) {
    _setEnabledUseCases(
      reference.pointer,
      _id_setEnabledUseCases as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setPreviewTargetSize = _class.instanceMethodId(
    r'setPreviewTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setPreviewTargetSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setPreviewTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)`
  void setPreviewTargetSize(CameraController$OutputSize? outputSize) {
    final _$outputSize = outputSize?.reference ?? jni$_.jNullReference;
    _setPreviewTargetSize(
      reference.pointer,
      _id_setPreviewTargetSize as jni$_.JMethodIDPtr,
      _$outputSize.pointer,
    ).check();
  }

  static final _id_getPreviewTargetSize = _class.instanceMethodId(
    r'getPreviewTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getPreviewTargetSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.view.CameraController$OutputSize getPreviewTargetSize()`
  /// The returned object must be released after use, by calling the [release] method.
  CameraController$OutputSize? getPreviewTargetSize() {
    return _getPreviewTargetSize(
      reference.pointer,
      _id_getPreviewTargetSize as jni$_.JMethodIDPtr,
    ).object<CameraController$OutputSize?>(
      const $CameraController$OutputSize$NullableType$(),
    );
  }

  static final _id_setPreviewResolutionSelector = _class.instanceMethodId(
    r'setPreviewResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setPreviewResolutionSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setPreviewResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)`
  void setPreviewResolutionSelector(jni$_.JObject? resolutionSelector) {
    final _$resolutionSelector =
        resolutionSelector?.reference ?? jni$_.jNullReference;
    _setPreviewResolutionSelector(
      reference.pointer,
      _id_setPreviewResolutionSelector as jni$_.JMethodIDPtr,
      _$resolutionSelector.pointer,
    ).check();
  }

  static final _id_getPreviewResolutionSelector = _class.instanceMethodId(
    r'getPreviewResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getPreviewResolutionSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.resolutionselector.ResolutionSelector getPreviewResolutionSelector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPreviewResolutionSelector() {
    return _getPreviewResolutionSelector(
      reference.pointer,
      _id_getPreviewResolutionSelector as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setPreviewDynamicRange = _class.instanceMethodId(
    r'setPreviewDynamicRange',
    r'(Landroidx/camera/core/DynamicRange;)V',
  );

  static final _setPreviewDynamicRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setPreviewDynamicRange(androidx.camera.core.DynamicRange dynamicRange)`
  void setPreviewDynamicRange(jni$_.JObject? dynamicRange) {
    final _$dynamicRange = dynamicRange?.reference ?? jni$_.jNullReference;
    _setPreviewDynamicRange(
      reference.pointer,
      _id_setPreviewDynamicRange as jni$_.JMethodIDPtr,
      _$dynamicRange.pointer,
    ).check();
  }

  static final _id_getPreviewDynamicRange = _class.instanceMethodId(
    r'getPreviewDynamicRange',
    r'()Landroidx/camera/core/DynamicRange;',
  );

  static final _getPreviewDynamicRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.DynamicRange getPreviewDynamicRange()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPreviewDynamicRange() {
    return _getPreviewDynamicRange(
      reference.pointer,
      _id_getPreviewDynamicRange as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_isImageCaptureEnabled = _class.instanceMethodId(
    r'isImageCaptureEnabled',
    r'()Z',
  );

  static final _isImageCaptureEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isImageCaptureEnabled()`
  bool isImageCaptureEnabled() {
    return _isImageCaptureEnabled(
      reference.pointer,
      _id_isImageCaptureEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getImageCaptureFlashMode = _class.instanceMethodId(
    r'getImageCaptureFlashMode',
    r'()I',
  );

  static final _getImageCaptureFlashMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getImageCaptureFlashMode()`
  int getImageCaptureFlashMode() {
    return _getImageCaptureFlashMode(
      reference.pointer,
      _id_getImageCaptureFlashMode as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setImageCaptureFlashMode = _class.instanceMethodId(
    r'setImageCaptureFlashMode',
    r'(I)V',
  );

  static final _setImageCaptureFlashMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setImageCaptureFlashMode(int i)`
  void setImageCaptureFlashMode(int i) {
    _setImageCaptureFlashMode(
      reference.pointer,
      _id_setImageCaptureFlashMode as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setScreenFlashUiInfo = _class.instanceMethodId(
    r'setScreenFlashUiInfo',
    r'(Landroidx/camera/view/internal/ScreenFlashUiInfo;)V',
  );

  static final _setScreenFlashUiInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setScreenFlashUiInfo(androidx.camera.view.internal.ScreenFlashUiInfo screenFlashUiInfo)`
  void setScreenFlashUiInfo(jni$_.JObject? screenFlashUiInfo) {
    final _$screenFlashUiInfo =
        screenFlashUiInfo?.reference ?? jni$_.jNullReference;
    _setScreenFlashUiInfo(
      reference.pointer,
      _id_setScreenFlashUiInfo as jni$_.JMethodIDPtr,
      _$screenFlashUiInfo.pointer,
    ).check();
  }

  static final _id_updateScreenFlashToImageCapture = _class.instanceMethodId(
    r'updateScreenFlashToImageCapture',
    r'()V',
  );

  static final _updateScreenFlashToImageCapture =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void updateScreenFlashToImageCapture()`
  void updateScreenFlashToImageCapture() {
    _updateScreenFlashToImageCapture(
      reference.pointer,
      _id_updateScreenFlashToImageCapture as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_getScreenFlashUiInfoByPriority = _class.instanceMethodId(
    r'getScreenFlashUiInfoByPriority',
    r'()Landroidx/camera/view/internal/ScreenFlashUiInfo;',
  );

  static final _getScreenFlashUiInfoByPriority =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.view.internal.ScreenFlashUiInfo getScreenFlashUiInfoByPriority()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getScreenFlashUiInfoByPriority() {
    return _getScreenFlashUiInfoByPriority(
      reference.pointer,
      _id_getScreenFlashUiInfoByPriority as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_takePicture = _class.instanceMethodId(
    r'takePicture',
    r'(Landroidx/camera/core/ImageCapture$OutputFileOptions;Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageSavedCallback;)V',
  );

  static final _takePicture =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void takePicture(androidx.camera.core.ImageCapture$OutputFileOptions outputFileOptions, java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageSavedCallback onImageSavedCallback)`
  void takePicture(
    jni$_.JObject? outputFileOptions,
    jni$_.JObject? executor,
    jni$_.JObject? onImageSavedCallback,
  ) {
    final _$outputFileOptions =
        outputFileOptions?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$onImageSavedCallback =
        onImageSavedCallback?.reference ?? jni$_.jNullReference;
    _takePicture(
      reference.pointer,
      _id_takePicture as jni$_.JMethodIDPtr,
      _$outputFileOptions.pointer,
      _$executor.pointer,
      _$onImageSavedCallback.pointer,
    ).check();
  }

  static final _id_takePicture$1 = _class.instanceMethodId(
    r'takePicture',
    r'(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageCapturedCallback;)V',
  );

  static final _takePicture$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void takePicture(java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageCapturedCallback onImageCapturedCallback)`
  void takePicture$1(
    jni$_.JObject? executor,
    jni$_.JObject? onImageCapturedCallback,
  ) {
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$onImageCapturedCallback =
        onImageCapturedCallback?.reference ?? jni$_.jNullReference;
    _takePicture$1(
      reference.pointer,
      _id_takePicture$1 as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$onImageCapturedCallback.pointer,
    ).check();
  }

  static final _id_setImageCaptureMode = _class.instanceMethodId(
    r'setImageCaptureMode',
    r'(I)V',
  );

  static final _setImageCaptureMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setImageCaptureMode(int i)`
  void setImageCaptureMode(int i) {
    _setImageCaptureMode(
      reference.pointer,
      _id_setImageCaptureMode as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getImageCaptureMode = _class.instanceMethodId(
    r'getImageCaptureMode',
    r'()I',
  );

  static final _getImageCaptureMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getImageCaptureMode()`
  int getImageCaptureMode() {
    return _getImageCaptureMode(
      reference.pointer,
      _id_getImageCaptureMode as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setImageCaptureTargetSize = _class.instanceMethodId(
    r'setImageCaptureTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setImageCaptureTargetSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setImageCaptureTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)`
  void setImageCaptureTargetSize(CameraController$OutputSize? outputSize) {
    final _$outputSize = outputSize?.reference ?? jni$_.jNullReference;
    _setImageCaptureTargetSize(
      reference.pointer,
      _id_setImageCaptureTargetSize as jni$_.JMethodIDPtr,
      _$outputSize.pointer,
    ).check();
  }

  static final _id_getImageCaptureTargetSize = _class.instanceMethodId(
    r'getImageCaptureTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getImageCaptureTargetSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.view.CameraController$OutputSize getImageCaptureTargetSize()`
  /// The returned object must be released after use, by calling the [release] method.
  CameraController$OutputSize? getImageCaptureTargetSize() {
    return _getImageCaptureTargetSize(
      reference.pointer,
      _id_getImageCaptureTargetSize as jni$_.JMethodIDPtr,
    ).object<CameraController$OutputSize?>(
      const $CameraController$OutputSize$NullableType$(),
    );
  }

  static final _id_setImageCaptureResolutionSelector = _class.instanceMethodId(
    r'setImageCaptureResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setImageCaptureResolutionSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setImageCaptureResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)`
  void setImageCaptureResolutionSelector(jni$_.JObject? resolutionSelector) {
    final _$resolutionSelector =
        resolutionSelector?.reference ?? jni$_.jNullReference;
    _setImageCaptureResolutionSelector(
      reference.pointer,
      _id_setImageCaptureResolutionSelector as jni$_.JMethodIDPtr,
      _$resolutionSelector.pointer,
    ).check();
  }

  static final _id_getImageCaptureResolutionSelector = _class.instanceMethodId(
    r'getImageCaptureResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getImageCaptureResolutionSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.resolutionselector.ResolutionSelector getImageCaptureResolutionSelector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getImageCaptureResolutionSelector() {
    return _getImageCaptureResolutionSelector(
      reference.pointer,
      _id_getImageCaptureResolutionSelector as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setImageCaptureIoExecutor = _class.instanceMethodId(
    r'setImageCaptureIoExecutor',
    r'(Ljava/util/concurrent/Executor;)V',
  );

  static final _setImageCaptureIoExecutor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setImageCaptureIoExecutor(java.util.concurrent.Executor executor)`
  void setImageCaptureIoExecutor(jni$_.JObject? executor) {
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    _setImageCaptureIoExecutor(
      reference.pointer,
      _id_setImageCaptureIoExecutor as jni$_.JMethodIDPtr,
      _$executor.pointer,
    ).check();
  }

  static final _id_getImageCaptureIoExecutor = _class.instanceMethodId(
    r'getImageCaptureIoExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getImageCaptureIoExecutor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.concurrent.Executor getImageCaptureIoExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getImageCaptureIoExecutor() {
    return _getImageCaptureIoExecutor(
      reference.pointer,
      _id_getImageCaptureIoExecutor as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_isImageAnalysisEnabled = _class.instanceMethodId(
    r'isImageAnalysisEnabled',
    r'()Z',
  );

  static final _isImageAnalysisEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isImageAnalysisEnabled()`
  bool isImageAnalysisEnabled() {
    return _isImageAnalysisEnabled(
      reference.pointer,
      _id_isImageAnalysisEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setImageAnalysisAnalyzer = _class.instanceMethodId(
    r'setImageAnalysisAnalyzer',
    r'(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageAnalysis$Analyzer;)V',
  );

  static final _setImageAnalysisAnalyzer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setImageAnalysisAnalyzer(java.util.concurrent.Executor executor, androidx.camera.core.ImageAnalysis$Analyzer analyzer)`
  void setImageAnalysisAnalyzer(
    jni$_.JObject? executor,
    jni$_.JObject? analyzer,
  ) {
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$analyzer = analyzer?.reference ?? jni$_.jNullReference;
    _setImageAnalysisAnalyzer(
      reference.pointer,
      _id_setImageAnalysisAnalyzer as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$analyzer.pointer,
    ).check();
  }

  static final _id_clearImageAnalysisAnalyzer = _class.instanceMethodId(
    r'clearImageAnalysisAnalyzer',
    r'()V',
  );

  static final _clearImageAnalysisAnalyzer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clearImageAnalysisAnalyzer()`
  void clearImageAnalysisAnalyzer() {
    _clearImageAnalysisAnalyzer(
      reference.pointer,
      _id_clearImageAnalysisAnalyzer as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_getImageAnalysisBackpressureStrategy = _class
      .instanceMethodId(r'getImageAnalysisBackpressureStrategy', r'()I');

  static final _getImageAnalysisBackpressureStrategy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getImageAnalysisBackpressureStrategy()`
  int getImageAnalysisBackpressureStrategy() {
    return _getImageAnalysisBackpressureStrategy(
      reference.pointer,
      _id_getImageAnalysisBackpressureStrategy as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setImageAnalysisBackpressureStrategy = _class
      .instanceMethodId(r'setImageAnalysisBackpressureStrategy', r'(I)V');

  static final _setImageAnalysisBackpressureStrategy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setImageAnalysisBackpressureStrategy(int i)`
  void setImageAnalysisBackpressureStrategy(int i) {
    _setImageAnalysisBackpressureStrategy(
      reference.pointer,
      _id_setImageAnalysisBackpressureStrategy as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setImageAnalysisImageQueueDepth = _class.instanceMethodId(
    r'setImageAnalysisImageQueueDepth',
    r'(I)V',
  );

  static final _setImageAnalysisImageQueueDepth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setImageAnalysisImageQueueDepth(int i)`
  void setImageAnalysisImageQueueDepth(int i) {
    _setImageAnalysisImageQueueDepth(
      reference.pointer,
      _id_setImageAnalysisImageQueueDepth as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getImageAnalysisImageQueueDepth = _class.instanceMethodId(
    r'getImageAnalysisImageQueueDepth',
    r'()I',
  );

  static final _getImageAnalysisImageQueueDepth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getImageAnalysisImageQueueDepth()`
  int getImageAnalysisImageQueueDepth() {
    return _getImageAnalysisImageQueueDepth(
      reference.pointer,
      _id_getImageAnalysisImageQueueDepth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setImageAnalysisTargetSize = _class.instanceMethodId(
    r'setImageAnalysisTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setImageAnalysisTargetSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setImageAnalysisTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)`
  void setImageAnalysisTargetSize(CameraController$OutputSize? outputSize) {
    final _$outputSize = outputSize?.reference ?? jni$_.jNullReference;
    _setImageAnalysisTargetSize(
      reference.pointer,
      _id_setImageAnalysisTargetSize as jni$_.JMethodIDPtr,
      _$outputSize.pointer,
    ).check();
  }

  static final _id_getImageAnalysisTargetSize = _class.instanceMethodId(
    r'getImageAnalysisTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getImageAnalysisTargetSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.view.CameraController$OutputSize getImageAnalysisTargetSize()`
  /// The returned object must be released after use, by calling the [release] method.
  CameraController$OutputSize? getImageAnalysisTargetSize() {
    return _getImageAnalysisTargetSize(
      reference.pointer,
      _id_getImageAnalysisTargetSize as jni$_.JMethodIDPtr,
    ).object<CameraController$OutputSize?>(
      const $CameraController$OutputSize$NullableType$(),
    );
  }

  static final _id_setImageAnalysisResolutionSelector = _class.instanceMethodId(
    r'setImageAnalysisResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setImageAnalysisResolutionSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setImageAnalysisResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)`
  void setImageAnalysisResolutionSelector(jni$_.JObject? resolutionSelector) {
    final _$resolutionSelector =
        resolutionSelector?.reference ?? jni$_.jNullReference;
    _setImageAnalysisResolutionSelector(
      reference.pointer,
      _id_setImageAnalysisResolutionSelector as jni$_.JMethodIDPtr,
      _$resolutionSelector.pointer,
    ).check();
  }

  static final _id_getImageAnalysisResolutionSelector = _class.instanceMethodId(
    r'getImageAnalysisResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getImageAnalysisResolutionSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.resolutionselector.ResolutionSelector getImageAnalysisResolutionSelector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getImageAnalysisResolutionSelector() {
    return _getImageAnalysisResolutionSelector(
      reference.pointer,
      _id_getImageAnalysisResolutionSelector as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setImageAnalysisBackgroundExecutor = _class.instanceMethodId(
    r'setImageAnalysisBackgroundExecutor',
    r'(Ljava/util/concurrent/Executor;)V',
  );

  static final _setImageAnalysisBackgroundExecutor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setImageAnalysisBackgroundExecutor(java.util.concurrent.Executor executor)`
  void setImageAnalysisBackgroundExecutor(jni$_.JObject? executor) {
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    _setImageAnalysisBackgroundExecutor(
      reference.pointer,
      _id_setImageAnalysisBackgroundExecutor as jni$_.JMethodIDPtr,
      _$executor.pointer,
    ).check();
  }

  static final _id_getImageAnalysisBackgroundExecutor = _class.instanceMethodId(
    r'getImageAnalysisBackgroundExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getImageAnalysisBackgroundExecutor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.concurrent.Executor getImageAnalysisBackgroundExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getImageAnalysisBackgroundExecutor() {
    return _getImageAnalysisBackgroundExecutor(
      reference.pointer,
      _id_getImageAnalysisBackgroundExecutor as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setImageAnalysisOutputImageFormat = _class.instanceMethodId(
    r'setImageAnalysisOutputImageFormat',
    r'(I)V',
  );

  static final _setImageAnalysisOutputImageFormat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setImageAnalysisOutputImageFormat(int i)`
  void setImageAnalysisOutputImageFormat(int i) {
    _setImageAnalysisOutputImageFormat(
      reference.pointer,
      _id_setImageAnalysisOutputImageFormat as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getImageAnalysisOutputImageFormat = _class.instanceMethodId(
    r'getImageAnalysisOutputImageFormat',
    r'()I',
  );

  static final _getImageAnalysisOutputImageFormat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getImageAnalysisOutputImageFormat()`
  int getImageAnalysisOutputImageFormat() {
    return _getImageAnalysisOutputImageFormat(
      reference.pointer,
      _id_getImageAnalysisOutputImageFormat as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isVideoCaptureEnabled = _class.instanceMethodId(
    r'isVideoCaptureEnabled',
    r'()Z',
  );

  static final _isVideoCaptureEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isVideoCaptureEnabled()`
  bool isVideoCaptureEnabled() {
    return _isVideoCaptureEnabled(
      reference.pointer,
      _id_isVideoCaptureEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_startRecording = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/FileOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.video.Recording startRecording(androidx.camera.video.FileOutputOptions fileOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent> consumer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startRecording(
    jni$_.JObject? fileOutputOptions,
    audioconfig$_.AudioConfig? audioConfig,
    jni$_.JObject? executor,
    jni$_.JObject? consumer,
  ) {
    final _$fileOutputOptions =
        fileOutputOptions?.reference ?? jni$_.jNullReference;
    final _$audioConfig = audioConfig?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$consumer = consumer?.reference ?? jni$_.jNullReference;
    return _startRecording(
      reference.pointer,
      _id_startRecording as jni$_.JMethodIDPtr,
      _$fileOutputOptions.pointer,
      _$audioConfig.pointer,
      _$executor.pointer,
      _$consumer.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_startRecording$1 = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/FileDescriptorOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.video.Recording startRecording(androidx.camera.video.FileDescriptorOutputOptions fileDescriptorOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent> consumer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startRecording$1(
    jni$_.JObject? fileDescriptorOutputOptions,
    audioconfig$_.AudioConfig? audioConfig,
    jni$_.JObject? executor,
    jni$_.JObject? consumer,
  ) {
    final _$fileDescriptorOutputOptions =
        fileDescriptorOutputOptions?.reference ?? jni$_.jNullReference;
    final _$audioConfig = audioConfig?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$consumer = consumer?.reference ?? jni$_.jNullReference;
    return _startRecording$1(
      reference.pointer,
      _id_startRecording$1 as jni$_.JMethodIDPtr,
      _$fileDescriptorOutputOptions.pointer,
      _$audioConfig.pointer,
      _$executor.pointer,
      _$consumer.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_startRecording$2 = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/MediaStoreOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.video.Recording startRecording(androidx.camera.video.MediaStoreOutputOptions mediaStoreOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent> consumer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startRecording$2(
    jni$_.JObject? mediaStoreOutputOptions,
    audioconfig$_.AudioConfig? audioConfig,
    jni$_.JObject? executor,
    jni$_.JObject? consumer,
  ) {
    final _$mediaStoreOutputOptions =
        mediaStoreOutputOptions?.reference ?? jni$_.jNullReference;
    final _$audioConfig = audioConfig?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$consumer = consumer?.reference ?? jni$_.jNullReference;
    return _startRecording$2(
      reference.pointer,
      _id_startRecording$2 as jni$_.JMethodIDPtr,
      _$mediaStoreOutputOptions.pointer,
      _$audioConfig.pointer,
      _$executor.pointer,
      _$consumer.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_isRecording = _class.instanceMethodId(
    r'isRecording',
    r'()Z',
  );

  static final _isRecording =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isRecording()`
  bool isRecording() {
    return _isRecording(
      reference.pointer,
      _id_isRecording as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setVideoCaptureQualitySelector = _class.instanceMethodId(
    r'setVideoCaptureQualitySelector',
    r'(Landroidx/camera/video/QualitySelector;)V',
  );

  static final _setVideoCaptureQualitySelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setVideoCaptureQualitySelector(androidx.camera.video.QualitySelector qualitySelector)`
  void setVideoCaptureQualitySelector(jni$_.JObject? qualitySelector) {
    final _$qualitySelector =
        qualitySelector?.reference ?? jni$_.jNullReference;
    _setVideoCaptureQualitySelector(
      reference.pointer,
      _id_setVideoCaptureQualitySelector as jni$_.JMethodIDPtr,
      _$qualitySelector.pointer,
    ).check();
  }

  static final _id_getVideoCaptureQualitySelector = _class.instanceMethodId(
    r'getVideoCaptureQualitySelector',
    r'()Landroidx/camera/video/QualitySelector;',
  );

  static final _getVideoCaptureQualitySelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.video.QualitySelector getVideoCaptureQualitySelector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getVideoCaptureQualitySelector() {
    return _getVideoCaptureQualitySelector(
      reference.pointer,
      _id_getVideoCaptureQualitySelector as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setVideoCaptureMirrorMode = _class.instanceMethodId(
    r'setVideoCaptureMirrorMode',
    r'(I)V',
  );

  static final _setVideoCaptureMirrorMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setVideoCaptureMirrorMode(int i)`
  void setVideoCaptureMirrorMode(int i) {
    _setVideoCaptureMirrorMode(
      reference.pointer,
      _id_setVideoCaptureMirrorMode as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getVideoCaptureMirrorMode = _class.instanceMethodId(
    r'getVideoCaptureMirrorMode',
    r'()I',
  );

  static final _getVideoCaptureMirrorMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getVideoCaptureMirrorMode()`
  int getVideoCaptureMirrorMode() {
    return _getVideoCaptureMirrorMode(
      reference.pointer,
      _id_getVideoCaptureMirrorMode as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setVideoCaptureDynamicRange = _class.instanceMethodId(
    r'setVideoCaptureDynamicRange',
    r'(Landroidx/camera/core/DynamicRange;)V',
  );

  static final _setVideoCaptureDynamicRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setVideoCaptureDynamicRange(androidx.camera.core.DynamicRange dynamicRange)`
  void setVideoCaptureDynamicRange(jni$_.JObject? dynamicRange) {
    final _$dynamicRange = dynamicRange?.reference ?? jni$_.jNullReference;
    _setVideoCaptureDynamicRange(
      reference.pointer,
      _id_setVideoCaptureDynamicRange as jni$_.JMethodIDPtr,
      _$dynamicRange.pointer,
    ).check();
  }

  static final _id_getVideoCaptureDynamicRange = _class.instanceMethodId(
    r'getVideoCaptureDynamicRange',
    r'()Landroidx/camera/core/DynamicRange;',
  );

  static final _getVideoCaptureDynamicRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.DynamicRange getVideoCaptureDynamicRange()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getVideoCaptureDynamicRange() {
    return _getVideoCaptureDynamicRange(
      reference.pointer,
      _id_getVideoCaptureDynamicRange as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setVideoCaptureTargetFrameRate = _class.instanceMethodId(
    r'setVideoCaptureTargetFrameRate',
    r'(Landroid/util/Range;)V',
  );

  static final _setVideoCaptureTargetFrameRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setVideoCaptureTargetFrameRate(android.util.Range<java.lang.Integer> range)`
  void setVideoCaptureTargetFrameRate(jni$_.JObject? range) {
    final _$range = range?.reference ?? jni$_.jNullReference;
    _setVideoCaptureTargetFrameRate(
      reference.pointer,
      _id_setVideoCaptureTargetFrameRate as jni$_.JMethodIDPtr,
      _$range.pointer,
    ).check();
  }

  static final _id_getVideoCaptureTargetFrameRate = _class.instanceMethodId(
    r'getVideoCaptureTargetFrameRate',
    r'()Landroid/util/Range;',
  );

  static final _getVideoCaptureTargetFrameRate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.util.Range<java.lang.Integer> getVideoCaptureTargetFrameRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getVideoCaptureTargetFrameRate() {
    return _getVideoCaptureTargetFrameRate(
      reference.pointer,
      _id_getVideoCaptureTargetFrameRate as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setCameraSelector = _class.instanceMethodId(
    r'setCameraSelector',
    r'(Landroidx/camera/core/CameraSelector;)V',
  );

  static final _setCameraSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCameraSelector(androidx.camera.core.CameraSelector cameraSelector)`
  void setCameraSelector(jni$_.JObject? cameraSelector) {
    final _$cameraSelector = cameraSelector?.reference ?? jni$_.jNullReference;
    _setCameraSelector(
      reference.pointer,
      _id_setCameraSelector as jni$_.JMethodIDPtr,
      _$cameraSelector.pointer,
    ).check();
  }

  static final _id_hasCamera = _class.instanceMethodId(
    r'hasCamera',
    r'(Landroidx/camera/core/CameraSelector;)Z',
  );

  static final _hasCamera =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasCamera(androidx.camera.core.CameraSelector cameraSelector)`
  bool hasCamera(jni$_.JObject? cameraSelector) {
    final _$cameraSelector = cameraSelector?.reference ?? jni$_.jNullReference;
    return _hasCamera(
      reference.pointer,
      _id_hasCamera as jni$_.JMethodIDPtr,
      _$cameraSelector.pointer,
    ).boolean;
  }

  static final _id_getCameraSelector = _class.instanceMethodId(
    r'getCameraSelector',
    r'()Landroidx/camera/core/CameraSelector;',
  );

  static final _getCameraSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.CameraSelector getCameraSelector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCameraSelector() {
    return _getCameraSelector(
      reference.pointer,
      _id_getCameraSelector as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_isPinchToZoomEnabled = _class.instanceMethodId(
    r'isPinchToZoomEnabled',
    r'()Z',
  );

  static final _isPinchToZoomEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPinchToZoomEnabled()`
  bool isPinchToZoomEnabled() {
    return _isPinchToZoomEnabled(
      reference.pointer,
      _id_isPinchToZoomEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setPinchToZoomEnabled = _class.instanceMethodId(
    r'setPinchToZoomEnabled',
    r'(Z)V',
  );

  static final _setPinchToZoomEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setPinchToZoomEnabled(boolean z)`
  void setPinchToZoomEnabled(bool z) {
    _setPinchToZoomEnabled(
      reference.pointer,
      _id_setPinchToZoomEnabled as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_isTapToFocusEnabled = _class.instanceMethodId(
    r'isTapToFocusEnabled',
    r'()Z',
  );

  static final _isTapToFocusEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isTapToFocusEnabled()`
  bool isTapToFocusEnabled() {
    return _isTapToFocusEnabled(
      reference.pointer,
      _id_isTapToFocusEnabled as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setTapToFocusEnabled = _class.instanceMethodId(
    r'setTapToFocusEnabled',
    r'(Z)V',
  );

  static final _setTapToFocusEnabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTapToFocusEnabled(boolean z)`
  void setTapToFocusEnabled(bool z) {
    _setTapToFocusEnabled(
      reference.pointer,
      _id_setTapToFocusEnabled as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getTapToFocusState = _class.instanceMethodId(
    r'getTapToFocusState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getTapToFocusState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.lifecycle.LiveData<java.lang.Integer> getTapToFocusState()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTapToFocusState() {
    return _getTapToFocusState(
      reference.pointer,
      _id_getTapToFocusState as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getTapToFocusInfoState = _class.instanceMethodId(
    r'getTapToFocusInfoState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getTapToFocusInfoState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.lifecycle.LiveData<androidx.camera.view.TapToFocusInfo> getTapToFocusInfoState()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTapToFocusInfoState() {
    return _getTapToFocusInfoState(
      reference.pointer,
      _id_getTapToFocusInfoState as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setTapToFocusAutoCancelDuration = _class.instanceMethodId(
    r'setTapToFocusAutoCancelDuration',
    r'(JLjava/util/concurrent/TimeUnit;)V',
  );

  static final _setTapToFocusAutoCancelDuration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTapToFocusAutoCancelDuration(long j, java.util.concurrent.TimeUnit timeUnit)`
  void setTapToFocusAutoCancelDuration(int j, jni$_.JObject? timeUnit) {
    final _$timeUnit = timeUnit?.reference ?? jni$_.jNullReference;
    _setTapToFocusAutoCancelDuration(
      reference.pointer,
      _id_setTapToFocusAutoCancelDuration as jni$_.JMethodIDPtr,
      j,
      _$timeUnit.pointer,
    ).check();
  }

  static final _id_getZoomState = _class.instanceMethodId(
    r'getZoomState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getZoomState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.lifecycle.LiveData<androidx.camera.core.ZoomState> getZoomState()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getZoomState() {
    return _getZoomState(
      reference.pointer,
      _id_getZoomState as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getCameraInfo = _class.instanceMethodId(
    r'getCameraInfo',
    r'()Landroidx/camera/core/CameraInfo;',
  );

  static final _getCameraInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.CameraInfo getCameraInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCameraInfo() {
    return _getCameraInfo(
      reference.pointer,
      _id_getCameraInfo as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getCameraControl = _class.instanceMethodId(
    r'getCameraControl',
    r'()Landroidx/camera/core/CameraControl;',
  );

  static final _getCameraControl =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.CameraControl getCameraControl()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCameraControl() {
    return _getCameraControl(
      reference.pointer,
      _id_getCameraControl as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setZoomRatio = _class.instanceMethodId(
    r'setZoomRatio',
    r'(F)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _setZoomRatio =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public com.google.common.util.concurrent.ListenableFuture<java.lang.Void> setZoomRatio(float f)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? setZoomRatio(double f) {
    return _setZoomRatio(
      reference.pointer,
      _id_setZoomRatio as jni$_.JMethodIDPtr,
      f,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setLinearZoom = _class.instanceMethodId(
    r'setLinearZoom',
    r'(F)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _setLinearZoom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public com.google.common.util.concurrent.ListenableFuture<java.lang.Void> setLinearZoom(float f)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? setLinearZoom(double f) {
    return _setLinearZoom(
      reference.pointer,
      _id_setLinearZoom as jni$_.JMethodIDPtr,
      f,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getTorchState = _class.instanceMethodId(
    r'getTorchState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getTorchState =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.lifecycle.LiveData<java.lang.Integer> getTorchState()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTorchState() {
    return _getTorchState(
      reference.pointer,
      _id_getTorchState as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_enableTorch = _class.instanceMethodId(
    r'enableTorch',
    r'(Z)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _enableTorch =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public com.google.common.util.concurrent.ListenableFuture<java.lang.Void> enableTorch(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? enableTorch(bool z) {
    return _enableTorch(
      reference.pointer,
      _id_enableTorch as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setEffects = _class.instanceMethodId(
    r'setEffects',
    r'(Ljava/util/Set;)V',
  );

  static final _setEffects =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setEffects(java.util.Set<androidx.camera.core.CameraEffect> set)`
  void setEffects(jni$_.JSet<jni$_.JObject?>? set) {
    final _$set = set?.reference ?? jni$_.jNullReference;
    _setEffects(
      reference.pointer,
      _id_setEffects as jni$_.JMethodIDPtr,
      _$set.pointer,
    ).check();
  }

  static final _id_clearEffects = _class.instanceMethodId(
    r'clearEffects',
    r'()V',
  );

  static final _clearEffects =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clearEffects()`
  void clearEffects() {
    _clearEffects(
      reference.pointer,
      _id_clearEffects as jni$_.JMethodIDPtr,
    ).check();
  }
}

final class $CameraController$NullableType$
    extends jni$_.JType<CameraController?> {
  @jni$_.internal
  const $CameraController$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/view/CameraController;';

  @jni$_.internal
  @core$_.override
  CameraController? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CameraController.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CameraController?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CameraController$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController$NullableType$) &&
        other is $CameraController$NullableType$;
  }
}

final class $CameraController$Type$ extends jni$_.JType<CameraController> {
  @jni$_.internal
  const $CameraController$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/view/CameraController;';

  @jni$_.internal
  @core$_.override
  CameraController fromReference(jni$_.JReference reference) =>
      CameraController.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CameraController?> get nullableType =>
      const $CameraController$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CameraController$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController$Type$) &&
        other is $CameraController$Type$;
  }
}
