// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../../lang/Runnable.dart' as runnable$_;

/// from: `java.util.concurrent.Executors`
class Executors extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Executors> $type;

  @jni$_.internal
  Executors.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/concurrent/Executors');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Executors$NullableType();
  static const type = $Executors$Type();
  static final _id_newFixedThreadPool = _class.staticMethodId(
    r'newFixedThreadPool',
    r'(I)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newFixedThreadPool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.util.concurrent.ExecutorService newFixedThreadPool(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newFixedThreadPool(
    int i,
  ) {
    return _newFixedThreadPool(_class.reference.pointer,
            _id_newFixedThreadPool as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newWorkStealingPool = _class.staticMethodId(
    r'newWorkStealingPool',
    r'(I)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newWorkStealingPool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.util.concurrent.ExecutorService newWorkStealingPool(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newWorkStealingPool(
    int i,
  ) {
    return _newWorkStealingPool(_class.reference.pointer,
            _id_newWorkStealingPool as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newWorkStealingPool$1 = _class.staticMethodId(
    r'newWorkStealingPool',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newWorkStealingPool$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ExecutorService newWorkStealingPool()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newWorkStealingPool$1() {
    return _newWorkStealingPool$1(_class.reference.pointer,
            _id_newWorkStealingPool$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newFixedThreadPool$1 = _class.staticMethodId(
    r'newFixedThreadPool',
    r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newFixedThreadPool$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ExecutorService newFixedThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newFixedThreadPool$1(
    int i,
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newFixedThreadPool$1(
            _class.reference.pointer,
            _id_newFixedThreadPool$1 as jni$_.JMethodIDPtr,
            i,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newSingleThreadExecutor = _class.staticMethodId(
    r'newSingleThreadExecutor',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newSingleThreadExecutor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ExecutorService newSingleThreadExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newSingleThreadExecutor() {
    return _newSingleThreadExecutor(_class.reference.pointer,
            _id_newSingleThreadExecutor as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newSingleThreadExecutor$1 = _class.staticMethodId(
    r'newSingleThreadExecutor',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newSingleThreadExecutor$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ExecutorService newSingleThreadExecutor(java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newSingleThreadExecutor$1(
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newSingleThreadExecutor$1(
            _class.reference.pointer,
            _id_newSingleThreadExecutor$1 as jni$_.JMethodIDPtr,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newCachedThreadPool = _class.staticMethodId(
    r'newCachedThreadPool',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newCachedThreadPool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ExecutorService newCachedThreadPool()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newCachedThreadPool() {
    return _newCachedThreadPool(_class.reference.pointer,
            _id_newCachedThreadPool as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newCachedThreadPool$1 = _class.staticMethodId(
    r'newCachedThreadPool',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newCachedThreadPool$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ExecutorService newCachedThreadPool(java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newCachedThreadPool$1(
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newCachedThreadPool$1(
            _class.reference.pointer,
            _id_newCachedThreadPool$1 as jni$_.JMethodIDPtr,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newSingleThreadScheduledExecutor = _class.staticMethodId(
    r'newSingleThreadScheduledExecutor',
    r'()Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newSingleThreadScheduledExecutor =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newSingleThreadScheduledExecutor() {
    return _newSingleThreadScheduledExecutor(_class.reference.pointer,
            _id_newSingleThreadScheduledExecutor as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newSingleThreadScheduledExecutor$1 = _class.staticMethodId(
    r'newSingleThreadScheduledExecutor',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newSingleThreadScheduledExecutor$1 =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newSingleThreadScheduledExecutor$1(
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newSingleThreadScheduledExecutor$1(
            _class.reference.pointer,
            _id_newSingleThreadScheduledExecutor$1 as jni$_.JMethodIDPtr,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newScheduledThreadPool = _class.staticMethodId(
    r'newScheduledThreadPool',
    r'(I)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newScheduledThreadPool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newScheduledThreadPool(
    int i,
  ) {
    return _newScheduledThreadPool(_class.reference.pointer,
            _id_newScheduledThreadPool as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newScheduledThreadPool$1 = _class.staticMethodId(
    r'newScheduledThreadPool',
    r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newScheduledThreadPool$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newScheduledThreadPool$1(
    int i,
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newScheduledThreadPool$1(
            _class.reference.pointer,
            _id_newScheduledThreadPool$1 as jni$_.JMethodIDPtr,
            i,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_unconfigurableExecutorService = _class.staticMethodId(
    r'unconfigurableExecutorService',
    r'(Ljava/util/concurrent/ExecutorService;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _unconfigurableExecutorService =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService executorService)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? unconfigurableExecutorService(
    jni$_.JObject? executorService,
  ) {
    final _$executorService =
        executorService?.reference ?? jni$_.jNullReference;
    return _unconfigurableExecutorService(
            _class.reference.pointer,
            _id_unconfigurableExecutorService as jni$_.JMethodIDPtr,
            _$executorService.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_unconfigurableScheduledExecutorService =
      _class.staticMethodId(
    r'unconfigurableScheduledExecutorService',
    r'(Ljava/util/concurrent/ScheduledExecutorService;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _unconfigurableScheduledExecutorService =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService scheduledExecutorService)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? unconfigurableScheduledExecutorService(
    jni$_.JObject? scheduledExecutorService,
  ) {
    final _$scheduledExecutorService =
        scheduledExecutorService?.reference ?? jni$_.jNullReference;
    return _unconfigurableScheduledExecutorService(
            _class.reference.pointer,
            _id_unconfigurableScheduledExecutorService as jni$_.JMethodIDPtr,
            _$scheduledExecutorService.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_defaultThreadFactory = _class.staticMethodId(
    r'defaultThreadFactory',
    r'()Ljava/util/concurrent/ThreadFactory;',
  );

  static final _defaultThreadFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ThreadFactory defaultThreadFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? defaultThreadFactory() {
    return _defaultThreadFactory(_class.reference.pointer,
            _id_defaultThreadFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_privilegedThreadFactory = _class.staticMethodId(
    r'privilegedThreadFactory',
    r'()Ljava/util/concurrent/ThreadFactory;',
  );

  static final _privilegedThreadFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ThreadFactory privilegedThreadFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? privilegedThreadFactory() {
    return _privilegedThreadFactory(_class.reference.pointer,
            _id_privilegedThreadFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_callable = _class.staticMethodId(
    r'callable',
    r'(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;',
  );

  static final _callable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable callable(java.lang.Runnable runnable, T object)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? callable<$T extends jni$_.JObject?>(
    runnable$_.Runnable? runnable,
    $T? object, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$runnable = runnable?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _callable(
            _class.reference.pointer,
            _id_callable as jni$_.JMethodIDPtr,
            _$runnable.pointer,
            _$object.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_callable$1 = _class.staticMethodId(
    r'callable',
    r'(Ljava/lang/Runnable;)Ljava/util/concurrent/Callable;',
  );

  static final _callable$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable callable(java.lang.Runnable runnable)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? callable$1(
    runnable$_.Runnable? runnable,
  ) {
    final _$runnable = runnable?.reference ?? jni$_.jNullReference;
    return _callable$1(_class.reference.pointer,
            _id_callable$1 as jni$_.JMethodIDPtr, _$runnable.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_callable$2 = _class.staticMethodId(
    r'callable',
    r'(Ljava/security/PrivilegedAction;)Ljava/util/concurrent/Callable;',
  );

  static final _callable$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable callable(java.security.PrivilegedAction privilegedAction)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? callable$2(
    jni$_.JObject? privilegedAction,
  ) {
    final _$privilegedAction =
        privilegedAction?.reference ?? jni$_.jNullReference;
    return _callable$2(_class.reference.pointer,
            _id_callable$2 as jni$_.JMethodIDPtr, _$privilegedAction.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_callable$3 = _class.staticMethodId(
    r'callable',
    r'(Ljava/security/PrivilegedExceptionAction;)Ljava/util/concurrent/Callable;',
  );

  static final _callable$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction privilegedExceptionAction)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? callable$3(
    jni$_.JObject? privilegedExceptionAction,
  ) {
    final _$privilegedExceptionAction =
        privilegedExceptionAction?.reference ?? jni$_.jNullReference;
    return _callable$3(
            _class.reference.pointer,
            _id_callable$3 as jni$_.JMethodIDPtr,
            _$privilegedExceptionAction.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_privilegedCallable = _class.staticMethodId(
    r'privilegedCallable',
    r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;',
  );

  static final _privilegedCallable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable callable)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? privilegedCallable<$T extends jni$_.JObject?>(
    jni$_.JObject? callable, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$callable = callable?.reference ?? jni$_.jNullReference;
    return _privilegedCallable(_class.reference.pointer,
            _id_privilegedCallable as jni$_.JMethodIDPtr, _$callable.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_privilegedCallableUsingCurrentClassLoader =
      _class.staticMethodId(
    r'privilegedCallableUsingCurrentClassLoader',
    r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;',
  );

  static final _privilegedCallableUsingCurrentClassLoader =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable callable)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject?
      privilegedCallableUsingCurrentClassLoader<$T extends jni$_.JObject?>(
    jni$_.JObject? callable, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$callable = callable?.reference ?? jni$_.jNullReference;
    return _privilegedCallableUsingCurrentClassLoader(
            _class.reference.pointer,
            _id_privilegedCallableUsingCurrentClassLoader as jni$_.JMethodIDPtr,
            _$callable.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $Executors$NullableType extends jni$_.JObjType<Executors?> {
  @jni$_.internal
  const $Executors$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/concurrent/Executors;';

  @jni$_.internal
  @core$_.override
  Executors? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Executors.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Executors?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Executors$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Executors$NullableType) &&
        other is $Executors$NullableType;
  }
}

final class $Executors$Type extends jni$_.JObjType<Executors> {
  @jni$_.internal
  const $Executors$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/concurrent/Executors;';

  @jni$_.internal
  @core$_.override
  Executors fromReference(jni$_.JReference reference) =>
      Executors.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Executors?> get nullableType =>
      const $Executors$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Executors$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Executors$Type) && other is $Executors$Type;
  }
}
