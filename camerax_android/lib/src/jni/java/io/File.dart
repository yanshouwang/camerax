// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.io.File`
class File extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<File> $type;

  @jni$_.internal
  File.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/File');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $File$NullableType();
  static const type = $File$Type();
  static final _id_pathSeparator = _class.staticFieldId(
    r'pathSeparator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String pathSeparator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get pathSeparator =>
      _id_pathSeparator.get(_class, const jni$_.JStringNullableType());

  static final _id_pathSeparatorChar = _class.staticFieldId(
    r'pathSeparatorChar',
    r'C',
  );

  /// from: `static public final char pathSeparatorChar`
  static int get pathSeparatorChar =>
      _id_pathSeparatorChar.get(_class, const jni$_.jcharType());

  static final _id_separator = _class.staticFieldId(
    r'separator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String separator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get separator =>
      _id_separator.get(_class, const jni$_.JStringNullableType());

  static final _id_separatorChar = _class.staticFieldId(
    r'separatorChar',
    r'C',
  );

  /// from: `static public final char separatorChar`
  static int get separatorChar =>
      _id_separatorChar.get(_class, const jni$_.jcharType());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return File.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$2(
    File? file,
    jni$_.JString? string,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr, _$file.pointer, _$string.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/net/URI;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$3(
    jni$_.JObject? uRI,
  ) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return File.fromReference(_new$3(_class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr, _$uRI.pointer)
        .reference);
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParent = _class.instanceMethodId(
    r'getParent',
    r'()Ljava/lang/String;',
  );

  static final _getParent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getParent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getParent() {
    return _getParent(reference.pointer, _id_getParent as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParentFile = _class.instanceMethodId(
    r'getParentFile',
    r'()Ljava/io/File;',
  );

  static final _getParentFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File getParentFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getParentFile() {
    return _getParentFile(
            reference.pointer, _id_getParentFile as jni$_.JMethodIDPtr)
        .object<File?>(const $File$NullableType());
  }

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() {
    return _getPath(reference.pointer, _id_getPath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isAbsolute = _class.instanceMethodId(
    r'isAbsolute',
    r'()Z',
  );

  static final _isAbsolute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAbsolute()`
  bool isAbsolute() {
    return _isAbsolute(reference.pointer, _id_isAbsolute as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAbsolutePath = _class.instanceMethodId(
    r'getAbsolutePath',
    r'()Ljava/lang/String;',
  );

  static final _getAbsolutePath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAbsolutePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAbsolutePath() {
    return _getAbsolutePath(
            reference.pointer, _id_getAbsolutePath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getAbsoluteFile = _class.instanceMethodId(
    r'getAbsoluteFile',
    r'()Ljava/io/File;',
  );

  static final _getAbsoluteFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File getAbsoluteFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getAbsoluteFile() {
    return _getAbsoluteFile(
            reference.pointer, _id_getAbsoluteFile as jni$_.JMethodIDPtr)
        .object<File?>(const $File$NullableType());
  }

  static final _id_getCanonicalPath = _class.instanceMethodId(
    r'getCanonicalPath',
    r'()Ljava/lang/String;',
  );

  static final _getCanonicalPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCanonicalPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCanonicalPath() {
    return _getCanonicalPath(
            reference.pointer, _id_getCanonicalPath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getCanonicalFile = _class.instanceMethodId(
    r'getCanonicalFile',
    r'()Ljava/io/File;',
  );

  static final _getCanonicalFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File getCanonicalFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getCanonicalFile() {
    return _getCanonicalFile(
            reference.pointer, _id_getCanonicalFile as jni$_.JMethodIDPtr)
        .object<File?>(const $File$NullableType());
  }

  static final _id_toURL = _class.instanceMethodId(
    r'toURL',
    r'()Ljava/net/URL;',
  );

  static final _toURL = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.URL toURL()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURL() {
    return _toURL(reference.pointer, _id_toURL as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toURI = _class.instanceMethodId(
    r'toURI',
    r'()Ljava/net/URI;',
  );

  static final _toURI = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.URI toURI()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURI() {
    return _toURI(reference.pointer, _id_toURI as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_canRead = _class.instanceMethodId(
    r'canRead',
    r'()Z',
  );

  static final _canRead = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean canRead()`
  bool canRead() {
    return _canRead(reference.pointer, _id_canRead as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_canWrite = _class.instanceMethodId(
    r'canWrite',
    r'()Z',
  );

  static final _canWrite = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean canWrite()`
  bool canWrite() {
    return _canWrite(reference.pointer, _id_canWrite as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_exists = _class.instanceMethodId(
    r'exists',
    r'()Z',
  );

  static final _exists = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean exists()`
  bool exists() {
    return _exists(reference.pointer, _id_exists as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isDirectory = _class.instanceMethodId(
    r'isDirectory',
    r'()Z',
  );

  static final _isDirectory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isDirectory()`
  bool isDirectory() {
    return _isDirectory(
            reference.pointer, _id_isDirectory as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isFile = _class.instanceMethodId(
    r'isFile',
    r'()Z',
  );

  static final _isFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isFile()`
  bool isFile() {
    return _isFile(reference.pointer, _id_isFile as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isHidden = _class.instanceMethodId(
    r'isHidden',
    r'()Z',
  );

  static final _isHidden = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isHidden()`
  bool isHidden() {
    return _isHidden(reference.pointer, _id_isHidden as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_lastModified = _class.instanceMethodId(
    r'lastModified',
    r'()J',
  );

  static final _lastModified = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long lastModified()`
  int lastModified() {
    return _lastModified(
            reference.pointer, _id_lastModified as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_length = _class.instanceMethodId(
    r'length',
    r'()J',
  );

  static final _length = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long length()`
  int length() {
    return _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).long;
  }

  static final _id_createNewFile = _class.instanceMethodId(
    r'createNewFile',
    r'()Z',
  );

  static final _createNewFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean createNewFile()`
  bool createNewFile() {
    return _createNewFile(
            reference.pointer, _id_createNewFile as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'()Z',
  );

  static final _delete = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean delete()`
  bool delete() {
    return _delete(reference.pointer, _id_delete as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_deleteOnExit = _class.instanceMethodId(
    r'deleteOnExit',
    r'()V',
  );

  static final _deleteOnExit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void deleteOnExit()`
  void deleteOnExit() {
    _deleteOnExit(reference.pointer, _id_deleteOnExit as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_list = _class.instanceMethodId(
    r'list',
    r'()[Ljava/lang/String;',
  );

  static final _list = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String[] list()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list() {
    return _list(reference.pointer, _id_list as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString?>?>(
            const jni$_.JArrayNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_list$1 = _class.instanceMethodId(
    r'list',
    r'(Ljava/io/FilenameFilter;)[Ljava/lang/String;',
  );

  static final _list$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String[] list(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list$1(
    jni$_.JObject? filenameFilter,
  ) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _list$1(reference.pointer, _id_list$1 as jni$_.JMethodIDPtr,
            _$filenameFilter.pointer)
        .object<jni$_.JArray<jni$_.JString?>?>(
            const jni$_.JArrayNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_listFiles = _class.instanceMethodId(
    r'listFiles',
    r'()[Ljava/io/File;',
  );

  static final _listFiles = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File[] listFiles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles() {
    return _listFiles(reference.pointer, _id_listFiles as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<File?>?>(
            const jni$_.JArrayNullableType<File?>($File$NullableType()));
  }

  static final _id_listFiles$1 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FilenameFilter;)[Ljava/io/File;',
  );

  static final _listFiles$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.io.File[] listFiles(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$1(
    jni$_.JObject? filenameFilter,
  ) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$1(reference.pointer,
            _id_listFiles$1 as jni$_.JMethodIDPtr, _$filenameFilter.pointer)
        .object<jni$_.JArray<File?>?>(
            const jni$_.JArrayNullableType<File?>($File$NullableType()));
  }

  static final _id_listFiles$2 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FileFilter;)[Ljava/io/File;',
  );

  static final _listFiles$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.io.File[] listFiles(java.io.FileFilter fileFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$2(
    jni$_.JObject? fileFilter,
  ) {
    final _$fileFilter = fileFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$2(reference.pointer,
            _id_listFiles$2 as jni$_.JMethodIDPtr, _$fileFilter.pointer)
        .object<jni$_.JArray<File?>?>(
            const jni$_.JArrayNullableType<File?>($File$NullableType()));
  }

  static final _id_mkdir = _class.instanceMethodId(
    r'mkdir',
    r'()Z',
  );

  static final _mkdir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean mkdir()`
  bool mkdir() {
    return _mkdir(reference.pointer, _id_mkdir as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_mkdirs = _class.instanceMethodId(
    r'mkdirs',
    r'()Z',
  );

  static final _mkdirs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean mkdirs()`
  bool mkdirs() {
    return _mkdirs(reference.pointer, _id_mkdirs as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_renameTo = _class.instanceMethodId(
    r'renameTo',
    r'(Ljava/io/File;)Z',
  );

  static final _renameTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean renameTo(java.io.File file)`
  bool renameTo(
    File? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _renameTo(reference.pointer, _id_renameTo as jni$_.JMethodIDPtr,
            _$file.pointer)
        .boolean;
  }

  static final _id_setLastModified = _class.instanceMethodId(
    r'setLastModified',
    r'(J)Z',
  );

  static final _setLastModified = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean setLastModified(long j)`
  bool setLastModified(
    int j,
  ) {
    return _setLastModified(
            reference.pointer, _id_setLastModified as jni$_.JMethodIDPtr, j)
        .boolean;
  }

  static final _id_setReadOnly = _class.instanceMethodId(
    r'setReadOnly',
    r'()Z',
  );

  static final _setReadOnly = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean setReadOnly()`
  bool setReadOnly() {
    return _setReadOnly(
            reference.pointer, _id_setReadOnly as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setWritable = _class.instanceMethodId(
    r'setWritable',
    r'(ZZ)Z',
  );

  static final _setWritable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public boolean setWritable(boolean z, boolean z1)`
  bool setWritable(
    bool z,
    bool z1,
  ) {
    return _setWritable(reference.pointer,
            _id_setWritable as jni$_.JMethodIDPtr, z ? 1 : 0, z1 ? 1 : 0)
        .boolean;
  }

  static final _id_setWritable$1 = _class.instanceMethodId(
    r'setWritable',
    r'(Z)Z',
  );

  static final _setWritable$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean setWritable(boolean z)`
  bool setWritable$1(
    bool z,
  ) {
    return _setWritable$1(reference.pointer,
            _id_setWritable$1 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_setReadable = _class.instanceMethodId(
    r'setReadable',
    r'(ZZ)Z',
  );

  static final _setReadable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public boolean setReadable(boolean z, boolean z1)`
  bool setReadable(
    bool z,
    bool z1,
  ) {
    return _setReadable(reference.pointer,
            _id_setReadable as jni$_.JMethodIDPtr, z ? 1 : 0, z1 ? 1 : 0)
        .boolean;
  }

  static final _id_setReadable$1 = _class.instanceMethodId(
    r'setReadable',
    r'(Z)Z',
  );

  static final _setReadable$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean setReadable(boolean z)`
  bool setReadable$1(
    bool z,
  ) {
    return _setReadable$1(reference.pointer,
            _id_setReadable$1 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_setExecutable = _class.instanceMethodId(
    r'setExecutable',
    r'(ZZ)Z',
  );

  static final _setExecutable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public boolean setExecutable(boolean z, boolean z1)`
  bool setExecutable(
    bool z,
    bool z1,
  ) {
    return _setExecutable(reference.pointer,
            _id_setExecutable as jni$_.JMethodIDPtr, z ? 1 : 0, z1 ? 1 : 0)
        .boolean;
  }

  static final _id_setExecutable$1 = _class.instanceMethodId(
    r'setExecutable',
    r'(Z)Z',
  );

  static final _setExecutable$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean setExecutable(boolean z)`
  bool setExecutable$1(
    bool z,
  ) {
    return _setExecutable$1(reference.pointer,
            _id_setExecutable$1 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_canExecute = _class.instanceMethodId(
    r'canExecute',
    r'()Z',
  );

  static final _canExecute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean canExecute()`
  bool canExecute() {
    return _canExecute(reference.pointer, _id_canExecute as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_listRoots = _class.staticMethodId(
    r'listRoots',
    r'()[Ljava/io/File;',
  );

  static final _listRoots = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.io.File[] listRoots()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<File?>? listRoots() {
    return _listRoots(
            _class.reference.pointer, _id_listRoots as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<File?>?>(
            const jni$_.JArrayNullableType<File?>($File$NullableType()));
  }

  static final _id_getTotalSpace = _class.instanceMethodId(
    r'getTotalSpace',
    r'()J',
  );

  static final _getTotalSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getTotalSpace()`
  int getTotalSpace() {
    return _getTotalSpace(
            reference.pointer, _id_getTotalSpace as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getFreeSpace = _class.instanceMethodId(
    r'getFreeSpace',
    r'()J',
  );

  static final _getFreeSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getFreeSpace()`
  int getFreeSpace() {
    return _getFreeSpace(
            reference.pointer, _id_getFreeSpace as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getUsableSpace = _class.instanceMethodId(
    r'getUsableSpace',
    r'()J',
  );

  static final _getUsableSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getUsableSpace()`
  int getUsableSpace() {
    return _getUsableSpace(
            reference.pointer, _id_getUsableSpace as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_createTempFile = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;',
  );

  static final _createTempFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1, java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile(
    jni$_.JString? string,
    jni$_.JString? string1,
    File? file,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _createTempFile(
            _class.reference.pointer,
            _id_createTempFile as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$file.pointer)
        .object<File?>(const $File$NullableType());
  }

  static final _id_createTempFile$1 = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;',
  );

  static final _createTempFile$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _createTempFile$1(
            _class.reference.pointer,
            _id_createTempFile$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .object<File?>(const $File$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/io/File;)I',
  );

  static final _compareTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int compareTo(java.io.File file)`
  int compareTo(
    File? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr,
            _$file.pointer)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toPath = _class.instanceMethodId(
    r'toPath',
    r'()Ljava/nio/file/Path;',
  );

  static final _toPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.nio.file.Path toPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toPath() {
    return _toPath(reference.pointer, _id_toPath as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $File$NullableType extends jni$_.JObjType<File?> {
  @jni$_.internal
  const $File$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : File.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($File$NullableType) &&
        other is $File$NullableType;
  }
}

final class $File$Type extends jni$_.JObjType<File> {
  @jni$_.internal
  const $File$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File fromReference(jni$_.JReference reference) => File.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => const $File$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($File$Type) && other is $File$Type;
  }
}
