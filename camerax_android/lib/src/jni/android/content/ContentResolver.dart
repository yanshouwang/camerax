// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../database/Cursor.dart' as cursor$_;

import '../net/Uri.dart' as uri$_;

import '../util/Size.dart' as size$_;

import 'ContentValues.dart' as contentvalues$_;

/// from: `android.content.ContentResolver$MimeTypeInfo`
class ContentResolver$MimeTypeInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ContentResolver$MimeTypeInfo> $type;

  @jni$_.internal
  ContentResolver$MimeTypeInfo.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'android/content/ContentResolver$MimeTypeInfo');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ContentResolver$MimeTypeInfo$NullableType();
  static const type = $ContentResolver$MimeTypeInfo$Type();
  static final _id_getIcon = _class.instanceMethodId(
    r'getIcon',
    r'()Landroid/graphics/drawable/Icon;',
  );

  static final _getIcon = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.drawable.Icon getIcon()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getIcon() {
    return _getIcon(reference.pointer, _id_getIcon as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getLabel = _class.instanceMethodId(
    r'getLabel',
    r'()Ljava/lang/CharSequence;',
  );

  static final _getLabel = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.CharSequence getLabel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLabel() {
    return _getLabel(reference.pointer, _id_getLabel as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getContentDescription = _class.instanceMethodId(
    r'getContentDescription',
    r'()Ljava/lang/CharSequence;',
  );

  static final _getContentDescription = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.CharSequence getContentDescription()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContentDescription() {
    return _getContentDescription(
            reference.pointer, _id_getContentDescription as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $ContentResolver$MimeTypeInfo$NullableType
    extends jni$_.JObjType<ContentResolver$MimeTypeInfo?> {
  @jni$_.internal
  const $ContentResolver$MimeTypeInfo$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/ContentResolver$MimeTypeInfo;';

  @jni$_.internal
  @core$_.override
  ContentResolver$MimeTypeInfo? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ContentResolver$MimeTypeInfo.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ContentResolver$MimeTypeInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContentResolver$MimeTypeInfo$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContentResolver$MimeTypeInfo$NullableType) &&
        other is $ContentResolver$MimeTypeInfo$NullableType;
  }
}

final class $ContentResolver$MimeTypeInfo$Type
    extends jni$_.JObjType<ContentResolver$MimeTypeInfo> {
  @jni$_.internal
  const $ContentResolver$MimeTypeInfo$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/ContentResolver$MimeTypeInfo;';

  @jni$_.internal
  @core$_.override
  ContentResolver$MimeTypeInfo fromReference(jni$_.JReference reference) =>
      ContentResolver$MimeTypeInfo.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ContentResolver$MimeTypeInfo?> get nullableType =>
      const $ContentResolver$MimeTypeInfo$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContentResolver$MimeTypeInfo$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContentResolver$MimeTypeInfo$Type) &&
        other is $ContentResolver$MimeTypeInfo$Type;
  }
}

/// from: `android.content.ContentResolver`
class ContentResolver extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ContentResolver> $type;

  @jni$_.internal
  ContentResolver.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'android/content/ContentResolver');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ContentResolver$NullableType();
  static const type = $ContentResolver$Type();
  static final _id_ANY_CURSOR_ITEM_TYPE = _class.staticFieldId(
    r'ANY_CURSOR_ITEM_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANY_CURSOR_ITEM_TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ANY_CURSOR_ITEM_TYPE =>
      _id_ANY_CURSOR_ITEM_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_CURSOR_DIR_BASE_TYPE = _class.staticFieldId(
    r'CURSOR_DIR_BASE_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CURSOR_DIR_BASE_TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CURSOR_DIR_BASE_TYPE =>
      _id_CURSOR_DIR_BASE_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_CURSOR_ITEM_BASE_TYPE = _class.staticFieldId(
    r'CURSOR_ITEM_BASE_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CURSOR_ITEM_BASE_TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CURSOR_ITEM_BASE_TYPE =>
      _id_CURSOR_ITEM_BASE_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_EXTRA_HONORED_ARGS = _class.staticFieldId(
    r'EXTRA_HONORED_ARGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_HONORED_ARGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_HONORED_ARGS =>
      _id_EXTRA_HONORED_ARGS.get(_class, const jni$_.JStringNullableType());

  static final _id_EXTRA_REFRESH_SUPPORTED = _class.staticFieldId(
    r'EXTRA_REFRESH_SUPPORTED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_REFRESH_SUPPORTED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_REFRESH_SUPPORTED =>
      _id_EXTRA_REFRESH_SUPPORTED.get(
          _class, const jni$_.JStringNullableType());

  static final _id_EXTRA_SIZE = _class.staticFieldId(
    r'EXTRA_SIZE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_SIZE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_SIZE =>
      _id_EXTRA_SIZE.get(_class, const jni$_.JStringNullableType());

  static final _id_EXTRA_TOTAL_COUNT = _class.staticFieldId(
    r'EXTRA_TOTAL_COUNT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA_TOTAL_COUNT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA_TOTAL_COUNT =>
      _id_EXTRA_TOTAL_COUNT.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int NOTIFY_DELETE`
  static const NOTIFY_DELETE = 16;

  /// from: `static public final int NOTIFY_INSERT`
  static const NOTIFY_INSERT = 4;

  /// from: `static public final int NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS`
  static const NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS = 2;

  /// from: `static public final int NOTIFY_SYNC_TO_NETWORK`
  static const NOTIFY_SYNC_TO_NETWORK = 1;

  /// from: `static public final int NOTIFY_UPDATE`
  static const NOTIFY_UPDATE = 8;
  static final _id_QUERY_ARG_GROUP_COLUMNS = _class.staticFieldId(
    r'QUERY_ARG_GROUP_COLUMNS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_GROUP_COLUMNS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_GROUP_COLUMNS =>
      _id_QUERY_ARG_GROUP_COLUMNS.get(
          _class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_LIMIT = _class.staticFieldId(
    r'QUERY_ARG_LIMIT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_LIMIT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_LIMIT =>
      _id_QUERY_ARG_LIMIT.get(_class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_OFFSET = _class.staticFieldId(
    r'QUERY_ARG_OFFSET',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_OFFSET`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_OFFSET =>
      _id_QUERY_ARG_OFFSET.get(_class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SORT_COLLATION = _class.staticFieldId(
    r'QUERY_ARG_SORT_COLLATION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SORT_COLLATION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SORT_COLLATION =>
      _id_QUERY_ARG_SORT_COLLATION.get(
          _class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SORT_COLUMNS = _class.staticFieldId(
    r'QUERY_ARG_SORT_COLUMNS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SORT_COLUMNS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SORT_COLUMNS =>
      _id_QUERY_ARG_SORT_COLUMNS.get(_class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SORT_DIRECTION = _class.staticFieldId(
    r'QUERY_ARG_SORT_DIRECTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SORT_DIRECTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SORT_DIRECTION =>
      _id_QUERY_ARG_SORT_DIRECTION.get(
          _class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SORT_LOCALE = _class.staticFieldId(
    r'QUERY_ARG_SORT_LOCALE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SORT_LOCALE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SORT_LOCALE =>
      _id_QUERY_ARG_SORT_LOCALE.get(_class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SQL_GROUP_BY = _class.staticFieldId(
    r'QUERY_ARG_SQL_GROUP_BY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SQL_GROUP_BY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SQL_GROUP_BY =>
      _id_QUERY_ARG_SQL_GROUP_BY.get(_class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SQL_HAVING = _class.staticFieldId(
    r'QUERY_ARG_SQL_HAVING',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SQL_HAVING`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SQL_HAVING =>
      _id_QUERY_ARG_SQL_HAVING.get(_class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SQL_LIMIT = _class.staticFieldId(
    r'QUERY_ARG_SQL_LIMIT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SQL_LIMIT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SQL_LIMIT =>
      _id_QUERY_ARG_SQL_LIMIT.get(_class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SQL_SELECTION = _class.staticFieldId(
    r'QUERY_ARG_SQL_SELECTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SQL_SELECTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SQL_SELECTION =>
      _id_QUERY_ARG_SQL_SELECTION.get(
          _class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SQL_SELECTION_ARGS = _class.staticFieldId(
    r'QUERY_ARG_SQL_SELECTION_ARGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SQL_SELECTION_ARGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SQL_SELECTION_ARGS =>
      _id_QUERY_ARG_SQL_SELECTION_ARGS.get(
          _class, const jni$_.JStringNullableType());

  static final _id_QUERY_ARG_SQL_SORT_ORDER = _class.staticFieldId(
    r'QUERY_ARG_SQL_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String QUERY_ARG_SQL_SORT_ORDER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get QUERY_ARG_SQL_SORT_ORDER =>
      _id_QUERY_ARG_SQL_SORT_ORDER.get(
          _class, const jni$_.JStringNullableType());

  /// from: `static public final int QUERY_SORT_DIRECTION_ASCENDING`
  static const QUERY_SORT_DIRECTION_ASCENDING = 0;

  /// from: `static public final int QUERY_SORT_DIRECTION_DESCENDING`
  static const QUERY_SORT_DIRECTION_DESCENDING = 1;
  static final _id_SCHEME_ANDROID_RESOURCE = _class.staticFieldId(
    r'SCHEME_ANDROID_RESOURCE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SCHEME_ANDROID_RESOURCE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SCHEME_ANDROID_RESOURCE =>
      _id_SCHEME_ANDROID_RESOURCE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SCHEME_CONTENT = _class.staticFieldId(
    r'SCHEME_CONTENT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SCHEME_CONTENT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SCHEME_CONTENT =>
      _id_SCHEME_CONTENT.get(_class, const jni$_.JStringNullableType());

  static final _id_SCHEME_FILE = _class.staticFieldId(
    r'SCHEME_FILE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SCHEME_FILE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SCHEME_FILE =>
      _id_SCHEME_FILE.get(_class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_ACCOUNT = _class.staticFieldId(
    r'SYNC_EXTRAS_ACCOUNT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_ACCOUNT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_ACCOUNT =>
      _id_SYNC_EXTRAS_ACCOUNT.get(_class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS = _class.staticFieldId(
    r'SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS =>
      _id_SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_DO_NOT_RETRY = _class.staticFieldId(
    r'SYNC_EXTRAS_DO_NOT_RETRY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_DO_NOT_RETRY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_DO_NOT_RETRY =>
      _id_SYNC_EXTRAS_DO_NOT_RETRY.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_EXPEDITED = _class.staticFieldId(
    r'SYNC_EXTRAS_EXPEDITED',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_EXPEDITED`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_EXPEDITED =>
      _id_SYNC_EXTRAS_EXPEDITED.get(_class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_FORCE = _class.staticFieldId(
    r'SYNC_EXTRAS_FORCE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_FORCE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_FORCE =>
      _id_SYNC_EXTRAS_FORCE.get(_class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_IGNORE_BACKOFF = _class.staticFieldId(
    r'SYNC_EXTRAS_IGNORE_BACKOFF',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_IGNORE_BACKOFF`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_IGNORE_BACKOFF =>
      _id_SYNC_EXTRAS_IGNORE_BACKOFF.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_IGNORE_SETTINGS = _class.staticFieldId(
    r'SYNC_EXTRAS_IGNORE_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_IGNORE_SETTINGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_IGNORE_SETTINGS =>
      _id_SYNC_EXTRAS_IGNORE_SETTINGS.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_INITIALIZE = _class.staticFieldId(
    r'SYNC_EXTRAS_INITIALIZE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_INITIALIZE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_INITIALIZE =>
      _id_SYNC_EXTRAS_INITIALIZE.get(_class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_MANUAL = _class.staticFieldId(
    r'SYNC_EXTRAS_MANUAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_MANUAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_MANUAL =>
      _id_SYNC_EXTRAS_MANUAL.get(_class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS =
      _class.staticFieldId(
    r'SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS =>
      _id_SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_REQUIRE_CHARGING = _class.staticFieldId(
    r'SYNC_EXTRAS_REQUIRE_CHARGING',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_REQUIRE_CHARGING`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_REQUIRE_CHARGING =>
      _id_SYNC_EXTRAS_REQUIRE_CHARGING.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB = _class.staticFieldId(
    r'SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB =>
      _id_SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SYNC_EXTRAS_UPLOAD = _class.staticFieldId(
    r'SYNC_EXTRAS_UPLOAD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYNC_EXTRAS_UPLOAD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYNC_EXTRAS_UPLOAD =>
      _id_SYNC_EXTRAS_UPLOAD.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int SYNC_OBSERVER_TYPE_ACTIVE`
  static const SYNC_OBSERVER_TYPE_ACTIVE = 4;

  /// from: `static public final int SYNC_OBSERVER_TYPE_PENDING`
  static const SYNC_OBSERVER_TYPE_PENDING = 2;

  /// from: `static public final int SYNC_OBSERVER_TYPE_SETTINGS`
  static const SYNC_OBSERVER_TYPE_SETTINGS = 1;
  static final _id_wrap = _class.staticMethodId(
    r'wrap',
    r'(Landroid/content/ContentProvider;)Landroid/content/ContentResolver;',
  );

  static final _wrap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.content.ContentResolver wrap(android.content.ContentProvider contentProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  static ContentResolver? wrap(
    jni$_.JObject? contentProvider,
  ) {
    final _$contentProvider =
        contentProvider?.reference ?? jni$_.jNullReference;
    return _wrap(_class.reference.pointer, _id_wrap as jni$_.JMethodIDPtr,
            _$contentProvider.pointer)
        .object<ContentResolver?>(const $ContentResolver$NullableType());
  }

  static final _id_wrap$1 = _class.staticMethodId(
    r'wrap',
    r'(Landroid/content/ContentProviderClient;)Landroid/content/ContentResolver;',
  );

  static final _wrap$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.content.ContentResolver wrap(android.content.ContentProviderClient contentProviderClient)`
  /// The returned object must be released after use, by calling the [release] method.
  static ContentResolver? wrap$1(
    jni$_.JObject? contentProviderClient,
  ) {
    final _$contentProviderClient =
        contentProviderClient?.reference ?? jni$_.jNullReference;
    return _wrap$1(_class.reference.pointer, _id_wrap$1 as jni$_.JMethodIDPtr,
            _$contentProviderClient.pointer)
        .object<ContentResolver?>(const $ContentResolver$NullableType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'(Landroid/net/Uri;)Ljava/lang/String;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.lang.String getType(android.net.Uri uri)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getType(
    uri$_.Uri? uri,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _getType(
            reference.pointer, _id_getType as jni$_.JMethodIDPtr, _$uri.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getStreamTypes = _class.instanceMethodId(
    r'getStreamTypes',
    r'(Landroid/net/Uri;Ljava/lang/String;)[Ljava/lang/String;',
  );

  static final _getStreamTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String[] getStreamTypes(android.net.Uri uri, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? getStreamTypes(
    uri$_.Uri? uri,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getStreamTypes(
            reference.pointer,
            _id_getStreamTypes as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer)
        .object<jni$_.JArray<jni$_.JString?>?>(
            const jni$_.JArrayNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] strings, java.lang.String string, java.lang.String[] strings1, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  cursor$_.Cursor? query(
    uri$_.Uri? uri,
    jni$_.JArray<jni$_.JString?>? strings,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JString?>? strings1,
    jni$_.JString? string1,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$strings1 = strings1?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _query(
            reference.pointer,
            _id_query as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$strings.pointer,
            _$string.pointer,
            _$strings1.pointer,
            _$string1.pointer)
        .object<cursor$_.Cursor?>(const cursor$_.$Cursor$NullableType());
  }

  static final _id_query$1 = _class.instanceMethodId(
    r'query',
    r'(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;',
  );

  static final _query$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] strings, java.lang.String string, java.lang.String[] strings1, java.lang.String string1, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  cursor$_.Cursor? query$1(
    uri$_.Uri? uri,
    jni$_.JArray<jni$_.JString?>? strings,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JString?>? strings1,
    jni$_.JString? string1,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$strings1 = strings1?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _query$1(
            reference.pointer,
            _id_query$1 as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$strings.pointer,
            _$string.pointer,
            _$strings1.pointer,
            _$string1.pointer,
            _$cancellationSignal.pointer)
        .object<cursor$_.Cursor?>(const cursor$_.$Cursor$NullableType());
  }

  static final _id_query$2 = _class.instanceMethodId(
    r'query',
    r'(Landroid/net/Uri;[Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/database/Cursor;',
  );

  static final _query$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] strings, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  cursor$_.Cursor? query$2(
    uri$_.Uri? uri,
    jni$_.JArray<jni$_.JString?>? strings,
    jni$_.JObject? bundle,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _query$2(
            reference.pointer,
            _id_query$2 as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$strings.pointer,
            _$bundle.pointer,
            _$cancellationSignal.pointer)
        .object<cursor$_.Cursor?>(const cursor$_.$Cursor$NullableType());
  }

  static final _id_canonicalize = _class.instanceMethodId(
    r'canonicalize',
    r'(Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _canonicalize = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.net.Uri canonicalize(android.net.Uri uri)`
  /// The returned object must be released after use, by calling the [release] method.
  uri$_.Uri? canonicalize(
    uri$_.Uri? uri,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _canonicalize(reference.pointer,
            _id_canonicalize as jni$_.JMethodIDPtr, _$uri.pointer)
        .object<uri$_.Uri?>(const uri$_.$Uri$NullableType());
  }

  static final _id_uncanonicalize = _class.instanceMethodId(
    r'uncanonicalize',
    r'(Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _uncanonicalize = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.net.Uri uncanonicalize(android.net.Uri uri)`
  /// The returned object must be released after use, by calling the [release] method.
  uri$_.Uri? uncanonicalize(
    uri$_.Uri? uri,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _uncanonicalize(reference.pointer,
            _id_uncanonicalize as jni$_.JMethodIDPtr, _$uri.pointer)
        .object<uri$_.Uri?>(const uri$_.$Uri$NullableType());
  }

  static final _id_refresh = _class.instanceMethodId(
    r'refresh',
    r'(Landroid/net/Uri;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Z',
  );

  static final _refresh = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final boolean refresh(android.net.Uri uri, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal)`
  bool refresh(
    uri$_.Uri? uri,
    jni$_.JObject? bundle,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _refresh(reference.pointer, _id_refresh as jni$_.JMethodIDPtr,
            _$uri.pointer, _$bundle.pointer, _$cancellationSignal.pointer)
        .boolean;
  }

  static final _id_openInputStream = _class.instanceMethodId(
    r'openInputStream',
    r'(Landroid/net/Uri;)Ljava/io/InputStream;',
  );

  static final _openInputStream = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.io.InputStream openInputStream(android.net.Uri uri)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openInputStream(
    uri$_.Uri? uri,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _openInputStream(reference.pointer,
            _id_openInputStream as jni$_.JMethodIDPtr, _$uri.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openOutputStream = _class.instanceMethodId(
    r'openOutputStream',
    r'(Landroid/net/Uri;)Ljava/io/OutputStream;',
  );

  static final _openOutputStream = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.io.OutputStream openOutputStream(android.net.Uri uri)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openOutputStream(
    uri$_.Uri? uri,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _openOutputStream(reference.pointer,
            _id_openOutputStream as jni$_.JMethodIDPtr, _$uri.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openOutputStream$1 = _class.instanceMethodId(
    r'openOutputStream',
    r'(Landroid/net/Uri;Ljava/lang/String;)Ljava/io/OutputStream;',
  );

  static final _openOutputStream$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.io.OutputStream openOutputStream(android.net.Uri uri, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openOutputStream$1(
    uri$_.Uri? uri,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _openOutputStream$1(
            reference.pointer,
            _id_openOutputStream$1 as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openFile = _class.instanceMethodId(
    r'openFile',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/os/ParcelFileDescriptor;',
  );

  static final _openFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String string, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openFile(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _openFile(reference.pointer, _id_openFile as jni$_.JMethodIDPtr,
            _$uri.pointer, _$string.pointer, _$cancellationSignal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openFileDescriptor = _class.instanceMethodId(
    r'openFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;',
  );

  static final _openFileDescriptor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.os.ParcelFileDescriptor openFileDescriptor(android.net.Uri uri, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openFileDescriptor(
    uri$_.Uri? uri,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _openFileDescriptor(
            reference.pointer,
            _id_openFileDescriptor as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openFileDescriptor$1 = _class.instanceMethodId(
    r'openFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/os/ParcelFileDescriptor;',
  );

  static final _openFileDescriptor$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.os.ParcelFileDescriptor openFileDescriptor(android.net.Uri uri, java.lang.String string, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openFileDescriptor$1(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _openFileDescriptor$1(
            reference.pointer,
            _id_openFileDescriptor$1 as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$cancellationSignal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openAssetFile = _class.instanceMethodId(
    r'openAssetFile',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openAssetFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri uri, java.lang.String string, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openAssetFile(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _openAssetFile(
            reference.pointer,
            _id_openAssetFile as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$cancellationSignal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openAssetFileDescriptor = _class.instanceMethodId(
    r'openAssetFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openAssetFileDescriptor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.AssetFileDescriptor openAssetFileDescriptor(android.net.Uri uri, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openAssetFileDescriptor(
    uri$_.Uri? uri,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _openAssetFileDescriptor(
            reference.pointer,
            _id_openAssetFileDescriptor as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openAssetFileDescriptor$1 = _class.instanceMethodId(
    r'openAssetFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openAssetFileDescriptor$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.AssetFileDescriptor openAssetFileDescriptor(android.net.Uri uri, java.lang.String string, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openAssetFileDescriptor$1(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _openAssetFileDescriptor$1(
            reference.pointer,
            _id_openAssetFileDescriptor$1 as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$cancellationSignal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openTypedAssetFile = _class.instanceMethodId(
    r'openTypedAssetFile',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openTypedAssetFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.AssetFileDescriptor openTypedAssetFile(android.net.Uri uri, java.lang.String string, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openTypedAssetFile(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JObject? bundle,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _openTypedAssetFile(
            reference.pointer,
            _id_openTypedAssetFile as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$bundle.pointer,
            _$cancellationSignal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openTypedAssetFileDescriptor = _class.instanceMethodId(
    r'openTypedAssetFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openTypedAssetFileDescriptor =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String string, android.os.Bundle bundle)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openTypedAssetFileDescriptor(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _openTypedAssetFileDescriptor(
            reference.pointer,
            _id_openTypedAssetFileDescriptor as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$bundle.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openTypedAssetFileDescriptor$1 = _class.instanceMethodId(
    r'openTypedAssetFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openTypedAssetFileDescriptor$1 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String string, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openTypedAssetFileDescriptor$1(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JObject? bundle,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _openTypedAssetFileDescriptor$1(
            reference.pointer,
            _id_openTypedAssetFileDescriptor$1 as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$bundle.pointer,
            _$cancellationSignal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_insert = _class.instanceMethodId(
    r'insert',
    r'(Landroid/net/Uri;Landroid/content/ContentValues;)Landroid/net/Uri;',
  );

  static final _insert = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.net.Uri insert(android.net.Uri uri, android.content.ContentValues contentValues)`
  /// The returned object must be released after use, by calling the [release] method.
  uri$_.Uri? insert(
    uri$_.Uri? uri,
    contentvalues$_.ContentValues? contentValues,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentValues = contentValues?.reference ?? jni$_.jNullReference;
    return _insert(reference.pointer, _id_insert as jni$_.JMethodIDPtr,
            _$uri.pointer, _$contentValues.pointer)
        .object<uri$_.Uri?>(const uri$_.$Uri$NullableType());
  }

  static final _id_insert$1 = _class.instanceMethodId(
    r'insert',
    r'(Landroid/net/Uri;Landroid/content/ContentValues;Landroid/os/Bundle;)Landroid/net/Uri;',
  );

  static final _insert$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.net.Uri insert(android.net.Uri uri, android.content.ContentValues contentValues, android.os.Bundle bundle)`
  /// The returned object must be released after use, by calling the [release] method.
  uri$_.Uri? insert$1(
    uri$_.Uri? uri,
    contentvalues$_.ContentValues? contentValues,
    jni$_.JObject? bundle,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentValues = contentValues?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _insert$1(reference.pointer, _id_insert$1 as jni$_.JMethodIDPtr,
            _$uri.pointer, _$contentValues.pointer, _$bundle.pointer)
        .object<uri$_.Uri?>(const uri$_.$Uri$NullableType());
  }

  static final _id_applyBatch = _class.instanceMethodId(
    r'applyBatch',
    r'(Ljava/lang/String;Ljava/util/ArrayList;)[Landroid/content/ContentProviderResult;',
  );

  static final _applyBatch = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object[] applyBatch(java.lang.String string, java.util.ArrayList arrayList)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? applyBatch(
    jni$_.JString? string,
    jni$_.JObject? arrayList,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$arrayList = arrayList?.reference ?? jni$_.jNullReference;
    return _applyBatch(reference.pointer, _id_applyBatch as jni$_.JMethodIDPtr,
            _$string.pointer, _$arrayList.pointer)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_bulkInsert = _class.instanceMethodId(
    r'bulkInsert',
    r'(Landroid/net/Uri;[Landroid/content/ContentValues;)I',
  );

  static final _bulkInsert = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final int bulkInsert(android.net.Uri uri, android.content.ContentValues[] contentValuess)`
  int bulkInsert(
    uri$_.Uri? uri,
    jni$_.JArray<contentvalues$_.ContentValues?>? contentValuess,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentValuess = contentValuess?.reference ?? jni$_.jNullReference;
    return _bulkInsert(reference.pointer, _id_bulkInsert as jni$_.JMethodIDPtr,
            _$uri.pointer, _$contentValuess.pointer)
        .integer;
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'(Landroid/net/Uri;Ljava/lang/String;[Ljava/lang/String;)I',
  );

  static final _delete = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final int delete(android.net.Uri uri, java.lang.String string, java.lang.String[] strings)`
  int delete(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return _delete(reference.pointer, _id_delete as jni$_.JMethodIDPtr,
            _$uri.pointer, _$string.pointer, _$strings.pointer)
        .integer;
  }

  static final _id_delete$1 = _class.instanceMethodId(
    r'delete',
    r'(Landroid/net/Uri;Landroid/os/Bundle;)I',
  );

  static final _delete$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final int delete(android.net.Uri uri, android.os.Bundle bundle)`
  int delete$1(
    uri$_.Uri? uri,
    jni$_.JObject? bundle,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _delete$1(reference.pointer, _id_delete$1 as jni$_.JMethodIDPtr,
            _$uri.pointer, _$bundle.pointer)
        .integer;
  }

  static final _id_update = _class.instanceMethodId(
    r'update',
    r'(Landroid/net/Uri;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;)I',
  );

  static final _update = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final int update(android.net.Uri uri, android.content.ContentValues contentValues, java.lang.String string, java.lang.String[] strings)`
  int update(
    uri$_.Uri? uri,
    contentvalues$_.ContentValues? contentValues,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentValues = contentValues?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return _update(
            reference.pointer,
            _id_update as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$contentValues.pointer,
            _$string.pointer,
            _$strings.pointer)
        .integer;
  }

  static final _id_update$1 = _class.instanceMethodId(
    r'update',
    r'(Landroid/net/Uri;Landroid/content/ContentValues;Landroid/os/Bundle;)I',
  );

  static final _update$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final int update(android.net.Uri uri, android.content.ContentValues contentValues, android.os.Bundle bundle)`
  int update$1(
    uri$_.Uri? uri,
    contentvalues$_.ContentValues? contentValues,
    jni$_.JObject? bundle,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentValues = contentValues?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _update$1(reference.pointer, _id_update$1 as jni$_.JMethodIDPtr,
            _$uri.pointer, _$contentValues.pointer, _$bundle.pointer)
        .integer;
  }

  static final _id_call = _class.instanceMethodId(
    r'call',
    r'(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Landroid/os/Bundle;',
  );

  static final _call = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.os.Bundle call(android.net.Uri uri, java.lang.String string, java.lang.String string1, android.os.Bundle bundle)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? call(
    uri$_.Uri? uri,
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JObject? bundle,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _call(
            reference.pointer,
            _id_call as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$string1.pointer,
            _$bundle.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_call$1 = _class.instanceMethodId(
    r'call',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Landroid/os/Bundle;',
  );

  static final _call$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.os.Bundle call(java.lang.String string, java.lang.String string1, java.lang.String string2, android.os.Bundle bundle)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? call$1(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JObject? bundle,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _call$1(
            reference.pointer,
            _id_call$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$bundle.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_acquireContentProviderClient = _class.instanceMethodId(
    r'acquireContentProviderClient',
    r'(Landroid/net/Uri;)Landroid/content/ContentProviderClient;',
  );

  static final _acquireContentProviderClient =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.ContentProviderClient acquireContentProviderClient(android.net.Uri uri)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? acquireContentProviderClient(
    uri$_.Uri? uri,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _acquireContentProviderClient(
            reference.pointer,
            _id_acquireContentProviderClient as jni$_.JMethodIDPtr,
            _$uri.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_acquireContentProviderClient$1 = _class.instanceMethodId(
    r'acquireContentProviderClient',
    r'(Ljava/lang/String;)Landroid/content/ContentProviderClient;',
  );

  static final _acquireContentProviderClient$1 =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.ContentProviderClient acquireContentProviderClient(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? acquireContentProviderClient$1(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _acquireContentProviderClient$1(
            reference.pointer,
            _id_acquireContentProviderClient$1 as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_acquireUnstableContentProviderClient =
      _class.instanceMethodId(
    r'acquireUnstableContentProviderClient',
    r'(Landroid/net/Uri;)Landroid/content/ContentProviderClient;',
  );

  static final _acquireUnstableContentProviderClient =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.ContentProviderClient acquireUnstableContentProviderClient(android.net.Uri uri)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? acquireUnstableContentProviderClient(
    uri$_.Uri? uri,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _acquireUnstableContentProviderClient(
            reference.pointer,
            _id_acquireUnstableContentProviderClient as jni$_.JMethodIDPtr,
            _$uri.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_acquireUnstableContentProviderClient$1 =
      _class.instanceMethodId(
    r'acquireUnstableContentProviderClient',
    r'(Ljava/lang/String;)Landroid/content/ContentProviderClient;',
  );

  static final _acquireUnstableContentProviderClient$1 =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.ContentProviderClient acquireUnstableContentProviderClient(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? acquireUnstableContentProviderClient$1(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _acquireUnstableContentProviderClient$1(
            reference.pointer,
            _id_acquireUnstableContentProviderClient$1 as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_registerContentObserver = _class.instanceMethodId(
    r'registerContentObserver',
    r'(Landroid/net/Uri;ZLandroid/database/ContentObserver;)V',
  );

  static final _registerContentObserver = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void registerContentObserver(android.net.Uri uri, boolean z, android.database.ContentObserver contentObserver)`
  void registerContentObserver(
    uri$_.Uri? uri,
    bool z,
    jni$_.JObject? contentObserver,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentObserver =
        contentObserver?.reference ?? jni$_.jNullReference;
    _registerContentObserver(
            reference.pointer,
            _id_registerContentObserver as jni$_.JMethodIDPtr,
            _$uri.pointer,
            z ? 1 : 0,
            _$contentObserver.pointer)
        .check();
  }

  static final _id_unregisterContentObserver = _class.instanceMethodId(
    r'unregisterContentObserver',
    r'(Landroid/database/ContentObserver;)V',
  );

  static final _unregisterContentObserver = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void unregisterContentObserver(android.database.ContentObserver contentObserver)`
  void unregisterContentObserver(
    jni$_.JObject? contentObserver,
  ) {
    final _$contentObserver =
        contentObserver?.reference ?? jni$_.jNullReference;
    _unregisterContentObserver(
            reference.pointer,
            _id_unregisterContentObserver as jni$_.JMethodIDPtr,
            _$contentObserver.pointer)
        .check();
  }

  static final _id_notifyChange = _class.instanceMethodId(
    r'notifyChange',
    r'(Landroid/net/Uri;Landroid/database/ContentObserver;)V',
  );

  static final _notifyChange = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void notifyChange(android.net.Uri uri, android.database.ContentObserver contentObserver)`
  void notifyChange(
    uri$_.Uri? uri,
    jni$_.JObject? contentObserver,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentObserver =
        contentObserver?.reference ?? jni$_.jNullReference;
    _notifyChange(reference.pointer, _id_notifyChange as jni$_.JMethodIDPtr,
            _$uri.pointer, _$contentObserver.pointer)
        .check();
  }

  static final _id_notifyChange$1 = _class.instanceMethodId(
    r'notifyChange',
    r'(Landroid/net/Uri;Landroid/database/ContentObserver;Z)V',
  );

  static final _notifyChange$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public void notifyChange(android.net.Uri uri, android.database.ContentObserver contentObserver, boolean z)`
  void notifyChange$1(
    uri$_.Uri? uri,
    jni$_.JObject? contentObserver,
    bool z,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentObserver =
        contentObserver?.reference ?? jni$_.jNullReference;
    _notifyChange$1(reference.pointer, _id_notifyChange$1 as jni$_.JMethodIDPtr,
            _$uri.pointer, _$contentObserver.pointer, z ? 1 : 0)
        .check();
  }

  static final _id_notifyChange$2 = _class.instanceMethodId(
    r'notifyChange',
    r'(Landroid/net/Uri;Landroid/database/ContentObserver;I)V',
  );

  static final _notifyChange$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public void notifyChange(android.net.Uri uri, android.database.ContentObserver contentObserver, int i)`
  void notifyChange$2(
    uri$_.Uri? uri,
    jni$_.JObject? contentObserver,
    int i,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$contentObserver =
        contentObserver?.reference ?? jni$_.jNullReference;
    _notifyChange$2(reference.pointer, _id_notifyChange$2 as jni$_.JMethodIDPtr,
            _$uri.pointer, _$contentObserver.pointer, i)
        .check();
  }

  static final _id_notifyChange$3 = _class.instanceMethodId(
    r'notifyChange',
    r'(Ljava/util/Collection;Landroid/database/ContentObserver;I)V',
  );

  static final _notifyChange$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public void notifyChange(java.util.Collection collection, android.database.ContentObserver contentObserver, int i)`
  void notifyChange$3(
    jni$_.JObject? collection,
    jni$_.JObject? contentObserver,
    int i,
  ) {
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    final _$contentObserver =
        contentObserver?.reference ?? jni$_.jNullReference;
    _notifyChange$3(reference.pointer, _id_notifyChange$3 as jni$_.JMethodIDPtr,
            _$collection.pointer, _$contentObserver.pointer, i)
        .check();
  }

  static final _id_takePersistableUriPermission = _class.instanceMethodId(
    r'takePersistableUriPermission',
    r'(Landroid/net/Uri;I)V',
  );

  static final _takePersistableUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void takePersistableUriPermission(android.net.Uri uri, int i)`
  void takePersistableUriPermission(
    uri$_.Uri? uri,
    int i,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _takePersistableUriPermission(
            reference.pointer,
            _id_takePersistableUriPermission as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i)
        .check();
  }

  static final _id_releasePersistableUriPermission = _class.instanceMethodId(
    r'releasePersistableUriPermission',
    r'(Landroid/net/Uri;I)V',
  );

  static final _releasePersistableUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void releasePersistableUriPermission(android.net.Uri uri, int i)`
  void releasePersistableUriPermission(
    uri$_.Uri? uri,
    int i,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _releasePersistableUriPermission(
            reference.pointer,
            _id_releasePersistableUriPermission as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i)
        .check();
  }

  static final _id_getPersistedUriPermissions = _class.instanceMethodId(
    r'getPersistedUriPermissions',
    r'()Ljava/util/List;',
  );

  static final _getPersistedUriPermissions =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List getPersistedUriPermissions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getPersistedUriPermissions() {
    return _getPersistedUriPermissions(reference.pointer,
            _id_getPersistedUriPermissions as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getOutgoingPersistedUriPermissions = _class.instanceMethodId(
    r'getOutgoingPersistedUriPermissions',
    r'()Ljava/util/List;',
  );

  static final _getOutgoingPersistedUriPermissions =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List getOutgoingPersistedUriPermissions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getOutgoingPersistedUriPermissions() {
    return _getOutgoingPersistedUriPermissions(reference.pointer,
            _id_getOutgoingPersistedUriPermissions as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_startSync = _class.instanceMethodId(
    r'startSync',
    r'(Landroid/net/Uri;Landroid/os/Bundle;)V',
  );

  static final _startSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void startSync(android.net.Uri uri, android.os.Bundle bundle)`
  void startSync(
    uri$_.Uri? uri,
    jni$_.JObject? bundle,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startSync(reference.pointer, _id_startSync as jni$_.JMethodIDPtr,
            _$uri.pointer, _$bundle.pointer)
        .check();
  }

  static final _id_requestSync = _class.staticMethodId(
    r'requestSync',
    r'(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _requestSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void requestSync(android.accounts.Account account, java.lang.String string, android.os.Bundle bundle)`
  static void requestSync(
    jni$_.JObject? account,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _requestSync(
            _class.reference.pointer,
            _id_requestSync as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_requestSync$1 = _class.staticMethodId(
    r'requestSync',
    r'(Landroid/content/SyncRequest;)V',
  );

  static final _requestSync$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void requestSync(android.content.SyncRequest syncRequest)`
  static void requestSync$1(
    jni$_.JObject? syncRequest,
  ) {
    final _$syncRequest = syncRequest?.reference ?? jni$_.jNullReference;
    _requestSync$1(_class.reference.pointer,
            _id_requestSync$1 as jni$_.JMethodIDPtr, _$syncRequest.pointer)
        .check();
  }

  static final _id_validateSyncExtrasBundle = _class.staticMethodId(
    r'validateSyncExtrasBundle',
    r'(Landroid/os/Bundle;)V',
  );

  static final _validateSyncExtrasBundle = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void validateSyncExtrasBundle(android.os.Bundle bundle)`
  static void validateSyncExtrasBundle(
    jni$_.JObject? bundle,
  ) {
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _validateSyncExtrasBundle(
            _class.reference.pointer,
            _id_validateSyncExtrasBundle as jni$_.JMethodIDPtr,
            _$bundle.pointer)
        .check();
  }

  static final _id_cancelSync = _class.instanceMethodId(
    r'cancelSync',
    r'(Landroid/net/Uri;)V',
  );

  static final _cancelSync = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void cancelSync(android.net.Uri uri)`
  void cancelSync(
    uri$_.Uri? uri,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _cancelSync(reference.pointer, _id_cancelSync as jni$_.JMethodIDPtr,
            _$uri.pointer)
        .check();
  }

  static final _id_cancelSync$1 = _class.staticMethodId(
    r'cancelSync',
    r'(Landroid/accounts/Account;Ljava/lang/String;)V',
  );

  static final _cancelSync$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void cancelSync(android.accounts.Account account, java.lang.String string)`
  static void cancelSync$1(
    jni$_.JObject? account,
    jni$_.JString? string,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _cancelSync$1(
            _class.reference.pointer,
            _id_cancelSync$1 as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_getSyncAdapterTypes = _class.staticMethodId(
    r'getSyncAdapterTypes',
    r'()[Landroid/content/SyncAdapterType;',
  );

  static final _getSyncAdapterTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.content.SyncAdapterType[] getSyncAdapterTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? getSyncAdapterTypes() {
    return _getSyncAdapterTypes(_class.reference.pointer,
            _id_getSyncAdapterTypes as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getSyncAutomatically = _class.staticMethodId(
    r'getSyncAutomatically',
    r'(Landroid/accounts/Account;Ljava/lang/String;)Z',
  );

  static final _getSyncAutomatically = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public boolean getSyncAutomatically(android.accounts.Account account, java.lang.String string)`
  static bool getSyncAutomatically(
    jni$_.JObject? account,
    jni$_.JString? string,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getSyncAutomatically(
            _class.reference.pointer,
            _id_getSyncAutomatically as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer)
        .boolean;
  }

  static final _id_setSyncAutomatically = _class.staticMethodId(
    r'setSyncAutomatically',
    r'(Landroid/accounts/Account;Ljava/lang/String;Z)V',
  );

  static final _setSyncAutomatically = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public void setSyncAutomatically(android.accounts.Account account, java.lang.String string, boolean z)`
  static void setSyncAutomatically(
    jni$_.JObject? account,
    jni$_.JString? string,
    bool z,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSyncAutomatically(
            _class.reference.pointer,
            _id_setSyncAutomatically as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer,
            z ? 1 : 0)
        .check();
  }

  static final _id_addPeriodicSync = _class.staticMethodId(
    r'addPeriodicSync',
    r'(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;J)V',
  );

  static final _addPeriodicSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int64
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public void addPeriodicSync(android.accounts.Account account, java.lang.String string, android.os.Bundle bundle, long j)`
  static void addPeriodicSync(
    jni$_.JObject? account,
    jni$_.JString? string,
    jni$_.JObject? bundle,
    int j,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _addPeriodicSync(
            _class.reference.pointer,
            _id_addPeriodicSync as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer,
            _$bundle.pointer,
            j)
        .check();
  }

  static final _id_removePeriodicSync = _class.staticMethodId(
    r'removePeriodicSync',
    r'(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _removePeriodicSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void removePeriodicSync(android.accounts.Account account, java.lang.String string, android.os.Bundle bundle)`
  static void removePeriodicSync(
    jni$_.JObject? account,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _removePeriodicSync(
            _class.reference.pointer,
            _id_removePeriodicSync as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_cancelSync$2 = _class.staticMethodId(
    r'cancelSync',
    r'(Landroid/content/SyncRequest;)V',
  );

  static final _cancelSync$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void cancelSync(android.content.SyncRequest syncRequest)`
  static void cancelSync$2(
    jni$_.JObject? syncRequest,
  ) {
    final _$syncRequest = syncRequest?.reference ?? jni$_.jNullReference;
    _cancelSync$2(_class.reference.pointer,
            _id_cancelSync$2 as jni$_.JMethodIDPtr, _$syncRequest.pointer)
        .check();
  }

  static final _id_getPeriodicSyncs = _class.staticMethodId(
    r'getPeriodicSyncs',
    r'(Landroid/accounts/Account;Ljava/lang/String;)Ljava/util/List;',
  );

  static final _getPeriodicSyncs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.List getPeriodicSyncs(android.accounts.Account account, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<jni$_.JObject?>? getPeriodicSyncs(
    jni$_.JObject? account,
    jni$_.JString? string,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getPeriodicSyncs(
            _class.reference.pointer,
            _id_getPeriodicSyncs as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getIsSyncable = _class.staticMethodId(
    r'getIsSyncable',
    r'(Landroid/accounts/Account;Ljava/lang/String;)I',
  );

  static final _getIsSyncable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public int getIsSyncable(android.accounts.Account account, java.lang.String string)`
  static int getIsSyncable(
    jni$_.JObject? account,
    jni$_.JString? string,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getIsSyncable(
            _class.reference.pointer,
            _id_getIsSyncable as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer)
        .integer;
  }

  static final _id_setIsSyncable = _class.staticMethodId(
    r'setIsSyncable',
    r'(Landroid/accounts/Account;Ljava/lang/String;I)V',
  );

  static final _setIsSyncable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public void setIsSyncable(android.accounts.Account account, java.lang.String string, int i)`
  static void setIsSyncable(
    jni$_.JObject? account,
    jni$_.JString? string,
    int i,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setIsSyncable(
            _class.reference.pointer,
            _id_setIsSyncable as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer,
            i)
        .check();
  }

  static final _id_getMasterSyncAutomatically = _class.staticMethodId(
    r'getMasterSyncAutomatically',
    r'()Z',
  );

  static final _getMasterSyncAutomatically =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public boolean getMasterSyncAutomatically()`
  static bool getMasterSyncAutomatically() {
    return _getMasterSyncAutomatically(_class.reference.pointer,
            _id_getMasterSyncAutomatically as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setMasterSyncAutomatically = _class.staticMethodId(
    r'setMasterSyncAutomatically',
    r'(Z)V',
  );

  static final _setMasterSyncAutomatically =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallStaticVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public void setMasterSyncAutomatically(boolean z)`
  static void setMasterSyncAutomatically(
    bool z,
  ) {
    _setMasterSyncAutomatically(_class.reference.pointer,
            _id_setMasterSyncAutomatically as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isSyncActive = _class.staticMethodId(
    r'isSyncActive',
    r'(Landroid/accounts/Account;Ljava/lang/String;)Z',
  );

  static final _isSyncActive = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public boolean isSyncActive(android.accounts.Account account, java.lang.String string)`
  static bool isSyncActive(
    jni$_.JObject? account,
    jni$_.JString? string,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _isSyncActive(
            _class.reference.pointer,
            _id_isSyncActive as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer)
        .boolean;
  }

  static final _id_getCurrentSync = _class.staticMethodId(
    r'getCurrentSync',
    r'()Landroid/content/SyncInfo;',
  );

  static final _getCurrentSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.content.SyncInfo getCurrentSync()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getCurrentSync() {
    return _getCurrentSync(
            _class.reference.pointer, _id_getCurrentSync as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getCurrentSyncs = _class.staticMethodId(
    r'getCurrentSyncs',
    r'()Ljava/util/List;',
  );

  static final _getCurrentSyncs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.List getCurrentSyncs()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<jni$_.JObject?>? getCurrentSyncs() {
    return _getCurrentSyncs(
            _class.reference.pointer, _id_getCurrentSyncs as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_isSyncPending = _class.staticMethodId(
    r'isSyncPending',
    r'(Landroid/accounts/Account;Ljava/lang/String;)Z',
  );

  static final _isSyncPending = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public boolean isSyncPending(android.accounts.Account account, java.lang.String string)`
  static bool isSyncPending(
    jni$_.JObject? account,
    jni$_.JString? string,
  ) {
    final _$account = account?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _isSyncPending(
            _class.reference.pointer,
            _id_isSyncPending as jni$_.JMethodIDPtr,
            _$account.pointer,
            _$string.pointer)
        .boolean;
  }

  static final _id_addStatusChangeListener = _class.staticMethodId(
    r'addStatusChangeListener',
    r'(ILandroid/content/SyncStatusObserver;)Ljava/lang/Object;',
  );

  static final _addStatusChangeListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.lang.Object addStatusChangeListener(int i, android.content.SyncStatusObserver syncStatusObserver)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? addStatusChangeListener(
    int i,
    jni$_.JObject? syncStatusObserver,
  ) {
    final _$syncStatusObserver =
        syncStatusObserver?.reference ?? jni$_.jNullReference;
    return _addStatusChangeListener(
            _class.reference.pointer,
            _id_addStatusChangeListener as jni$_.JMethodIDPtr,
            i,
            _$syncStatusObserver.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_removeStatusChangeListener = _class.staticMethodId(
    r'removeStatusChangeListener',
    r'(Ljava/lang/Object;)V',
  );

  static final _removeStatusChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void removeStatusChangeListener(java.lang.Object object)`
  static void removeStatusChangeListener(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _removeStatusChangeListener(
            _class.reference.pointer,
            _id_removeStatusChangeListener as jni$_.JMethodIDPtr,
            _$object.pointer)
        .check();
  }

  static final _id_getTypeInfo = _class.instanceMethodId(
    r'getTypeInfo',
    r'(Ljava/lang/String;)Landroid/content/ContentResolver$MimeTypeInfo;',
  );

  static final _getTypeInfo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.ContentResolver$MimeTypeInfo getTypeInfo(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ContentResolver$MimeTypeInfo? getTypeInfo(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getTypeInfo(reference.pointer,
            _id_getTypeInfo as jni$_.JMethodIDPtr, _$string.pointer)
        .object<ContentResolver$MimeTypeInfo?>(
            const $ContentResolver$MimeTypeInfo$NullableType());
  }

  static final _id_loadThumbnail = _class.instanceMethodId(
    r'loadThumbnail',
    r'(Landroid/net/Uri;Landroid/util/Size;Landroid/os/CancellationSignal;)Landroid/graphics/Bitmap;',
  );

  static final _loadThumbnail = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.graphics.Bitmap loadThumbnail(android.net.Uri uri, android.util.Size size, android.os.CancellationSignal cancellationSignal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? loadThumbnail(
    uri$_.Uri? uri,
    size$_.Size? size,
    jni$_.JObject? cancellationSignal,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$size = size?.reference ?? jni$_.jNullReference;
    final _$cancellationSignal =
        cancellationSignal?.reference ?? jni$_.jNullReference;
    return _loadThumbnail(
            reference.pointer,
            _id_loadThumbnail as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$size.pointer,
            _$cancellationSignal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $ContentResolver$NullableType
    extends jni$_.JObjType<ContentResolver?> {
  @jni$_.internal
  const $ContentResolver$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/ContentResolver;';

  @jni$_.internal
  @core$_.override
  ContentResolver? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ContentResolver.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ContentResolver?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContentResolver$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContentResolver$NullableType) &&
        other is $ContentResolver$NullableType;
  }
}

final class $ContentResolver$Type extends jni$_.JObjType<ContentResolver> {
  @jni$_.internal
  const $ContentResolver$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/ContentResolver;';

  @jni$_.internal
  @core$_.override
  ContentResolver fromReference(jni$_.JReference reference) =>
      ContentResolver.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ContentResolver?> get nullableType =>
      const $ContentResolver$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContentResolver$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContentResolver$Type) &&
        other is $ContentResolver$Type;
  }
}
