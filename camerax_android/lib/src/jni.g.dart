// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: android.Manifest$permission
class Manifest_permission extends jni.JObject {
  @override
  late final jni.JObjType<Manifest_permission> $type = type;

  Manifest_permission.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/Manifest$permission');

  /// The type which includes information such as the signature of this class.
  static const type = $Manifest_permissionType();
  static final _id_ACCEPT_HANDOVER = _class.staticFieldId(
    r'ACCEPT_HANDOVER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCEPT_HANDOVER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCEPT_HANDOVER =>
      _id_ACCEPT_HANDOVER.get(_class, const jni.JStringType());

  static final _id_ACCESS_BACKGROUND_LOCATION = _class.staticFieldId(
    r'ACCESS_BACKGROUND_LOCATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_BACKGROUND_LOCATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_BACKGROUND_LOCATION =>
      _id_ACCESS_BACKGROUND_LOCATION.get(_class, const jni.JStringType());

  static final _id_ACCESS_BLOBS_ACROSS_USERS = _class.staticFieldId(
    r'ACCESS_BLOBS_ACROSS_USERS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_BLOBS_ACROSS_USERS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_BLOBS_ACROSS_USERS =>
      _id_ACCESS_BLOBS_ACROSS_USERS.get(_class, const jni.JStringType());

  static final _id_ACCESS_CHECKIN_PROPERTIES = _class.staticFieldId(
    r'ACCESS_CHECKIN_PROPERTIES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_CHECKIN_PROPERTIES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_CHECKIN_PROPERTIES =>
      _id_ACCESS_CHECKIN_PROPERTIES.get(_class, const jni.JStringType());

  static final _id_ACCESS_COARSE_LOCATION = _class.staticFieldId(
    r'ACCESS_COARSE_LOCATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_COARSE_LOCATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_COARSE_LOCATION =>
      _id_ACCESS_COARSE_LOCATION.get(_class, const jni.JStringType());

  static final _id_ACCESS_FINE_LOCATION = _class.staticFieldId(
    r'ACCESS_FINE_LOCATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_FINE_LOCATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_FINE_LOCATION =>
      _id_ACCESS_FINE_LOCATION.get(_class, const jni.JStringType());

  static final _id_ACCESS_LOCATION_EXTRA_COMMANDS = _class.staticFieldId(
    r'ACCESS_LOCATION_EXTRA_COMMANDS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_LOCATION_EXTRA_COMMANDS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_LOCATION_EXTRA_COMMANDS =>
      _id_ACCESS_LOCATION_EXTRA_COMMANDS.get(_class, const jni.JStringType());

  static final _id_ACCESS_MEDIA_LOCATION = _class.staticFieldId(
    r'ACCESS_MEDIA_LOCATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_MEDIA_LOCATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_MEDIA_LOCATION =>
      _id_ACCESS_MEDIA_LOCATION.get(_class, const jni.JStringType());

  static final _id_ACCESS_NETWORK_STATE = _class.staticFieldId(
    r'ACCESS_NETWORK_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_NETWORK_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_NETWORK_STATE =>
      _id_ACCESS_NETWORK_STATE.get(_class, const jni.JStringType());

  static final _id_ACCESS_NOTIFICATION_POLICY = _class.staticFieldId(
    r'ACCESS_NOTIFICATION_POLICY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_NOTIFICATION_POLICY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_NOTIFICATION_POLICY =>
      _id_ACCESS_NOTIFICATION_POLICY.get(_class, const jni.JStringType());

  static final _id_ACCESS_WIFI_STATE = _class.staticFieldId(
    r'ACCESS_WIFI_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESS_WIFI_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESS_WIFI_STATE =>
      _id_ACCESS_WIFI_STATE.get(_class, const jni.JStringType());

  static final _id_ACCOUNT_MANAGER = _class.staticFieldId(
    r'ACCOUNT_MANAGER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCOUNT_MANAGER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCOUNT_MANAGER =>
      _id_ACCOUNT_MANAGER.get(_class, const jni.JStringType());

  static final _id_ACTIVITY_RECOGNITION = _class.staticFieldId(
    r'ACTIVITY_RECOGNITION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTIVITY_RECOGNITION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTIVITY_RECOGNITION =>
      _id_ACTIVITY_RECOGNITION.get(_class, const jni.JStringType());

  static final _id_ADD_VOICEMAIL = _class.staticFieldId(
    r'ADD_VOICEMAIL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ADD_VOICEMAIL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ADD_VOICEMAIL =>
      _id_ADD_VOICEMAIL.get(_class, const jni.JStringType());

  static final _id_ANSWER_PHONE_CALLS = _class.staticFieldId(
    r'ANSWER_PHONE_CALLS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ANSWER_PHONE_CALLS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ANSWER_PHONE_CALLS =>
      _id_ANSWER_PHONE_CALLS.get(_class, const jni.JStringType());

  static final _id_BATTERY_STATS = _class.staticFieldId(
    r'BATTERY_STATS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BATTERY_STATS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BATTERY_STATS =>
      _id_BATTERY_STATS.get(_class, const jni.JStringType());

  static final _id_BIND_ACCESSIBILITY_SERVICE = _class.staticFieldId(
    r'BIND_ACCESSIBILITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_ACCESSIBILITY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_ACCESSIBILITY_SERVICE =>
      _id_BIND_ACCESSIBILITY_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_APPWIDGET = _class.staticFieldId(
    r'BIND_APPWIDGET',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_APPWIDGET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_APPWIDGET =>
      _id_BIND_APPWIDGET.get(_class, const jni.JStringType());

  static final _id_BIND_AUTOFILL_SERVICE = _class.staticFieldId(
    r'BIND_AUTOFILL_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_AUTOFILL_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_AUTOFILL_SERVICE =>
      _id_BIND_AUTOFILL_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_CALL_REDIRECTION_SERVICE = _class.staticFieldId(
    r'BIND_CALL_REDIRECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_CALL_REDIRECTION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_CALL_REDIRECTION_SERVICE =>
      _id_BIND_CALL_REDIRECTION_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_CARRIER_MESSAGING_CLIENT_SERVICE = _class.staticFieldId(
    r'BIND_CARRIER_MESSAGING_CLIENT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_CARRIER_MESSAGING_CLIENT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_CARRIER_MESSAGING_CLIENT_SERVICE =>
      _id_BIND_CARRIER_MESSAGING_CLIENT_SERVICE.get(
          _class, const jni.JStringType());

  static final _id_BIND_CARRIER_MESSAGING_SERVICE = _class.staticFieldId(
    r'BIND_CARRIER_MESSAGING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_CARRIER_MESSAGING_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_CARRIER_MESSAGING_SERVICE =>
      _id_BIND_CARRIER_MESSAGING_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_CARRIER_SERVICES = _class.staticFieldId(
    r'BIND_CARRIER_SERVICES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_CARRIER_SERVICES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_CARRIER_SERVICES =>
      _id_BIND_CARRIER_SERVICES.get(_class, const jni.JStringType());

  static final _id_BIND_CHOOSER_TARGET_SERVICE = _class.staticFieldId(
    r'BIND_CHOOSER_TARGET_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_CHOOSER_TARGET_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_CHOOSER_TARGET_SERVICE =>
      _id_BIND_CHOOSER_TARGET_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_COMPANION_DEVICE_SERVICE = _class.staticFieldId(
    r'BIND_COMPANION_DEVICE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_COMPANION_DEVICE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_COMPANION_DEVICE_SERVICE =>
      _id_BIND_COMPANION_DEVICE_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_CONDITION_PROVIDER_SERVICE = _class.staticFieldId(
    r'BIND_CONDITION_PROVIDER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_CONDITION_PROVIDER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_CONDITION_PROVIDER_SERVICE =>
      _id_BIND_CONDITION_PROVIDER_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_CONTROLS = _class.staticFieldId(
    r'BIND_CONTROLS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_CONTROLS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_CONTROLS =>
      _id_BIND_CONTROLS.get(_class, const jni.JStringType());

  static final _id_BIND_CREDENTIAL_PROVIDER_SERVICE = _class.staticFieldId(
    r'BIND_CREDENTIAL_PROVIDER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_CREDENTIAL_PROVIDER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_CREDENTIAL_PROVIDER_SERVICE =>
      _id_BIND_CREDENTIAL_PROVIDER_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_DEVICE_ADMIN = _class.staticFieldId(
    r'BIND_DEVICE_ADMIN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_DEVICE_ADMIN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_DEVICE_ADMIN =>
      _id_BIND_DEVICE_ADMIN.get(_class, const jni.JStringType());

  static final _id_BIND_DREAM_SERVICE = _class.staticFieldId(
    r'BIND_DREAM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_DREAM_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_DREAM_SERVICE =>
      _id_BIND_DREAM_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_INCALL_SERVICE = _class.staticFieldId(
    r'BIND_INCALL_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_INCALL_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_INCALL_SERVICE =>
      _id_BIND_INCALL_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_INPUT_METHOD = _class.staticFieldId(
    r'BIND_INPUT_METHOD',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_INPUT_METHOD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_INPUT_METHOD =>
      _id_BIND_INPUT_METHOD.get(_class, const jni.JStringType());

  static final _id_BIND_MIDI_DEVICE_SERVICE = _class.staticFieldId(
    r'BIND_MIDI_DEVICE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_MIDI_DEVICE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_MIDI_DEVICE_SERVICE =>
      _id_BIND_MIDI_DEVICE_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_NFC_SERVICE = _class.staticFieldId(
    r'BIND_NFC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_NFC_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_NFC_SERVICE =>
      _id_BIND_NFC_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_NOTIFICATION_LISTENER_SERVICE = _class.staticFieldId(
    r'BIND_NOTIFICATION_LISTENER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_NOTIFICATION_LISTENER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_NOTIFICATION_LISTENER_SERVICE =>
      _id_BIND_NOTIFICATION_LISTENER_SERVICE.get(
          _class, const jni.JStringType());

  static final _id_BIND_PRINT_SERVICE = _class.staticFieldId(
    r'BIND_PRINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_PRINT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_PRINT_SERVICE =>
      _id_BIND_PRINT_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_QUICK_ACCESS_WALLET_SERVICE = _class.staticFieldId(
    r'BIND_QUICK_ACCESS_WALLET_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_QUICK_ACCESS_WALLET_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_QUICK_ACCESS_WALLET_SERVICE =>
      _id_BIND_QUICK_ACCESS_WALLET_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_QUICK_SETTINGS_TILE = _class.staticFieldId(
    r'BIND_QUICK_SETTINGS_TILE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_QUICK_SETTINGS_TILE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_QUICK_SETTINGS_TILE =>
      _id_BIND_QUICK_SETTINGS_TILE.get(_class, const jni.JStringType());

  static final _id_BIND_REMOTEVIEWS = _class.staticFieldId(
    r'BIND_REMOTEVIEWS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_REMOTEVIEWS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_REMOTEVIEWS =>
      _id_BIND_REMOTEVIEWS.get(_class, const jni.JStringType());

  static final _id_BIND_SCREENING_SERVICE = _class.staticFieldId(
    r'BIND_SCREENING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_SCREENING_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_SCREENING_SERVICE =>
      _id_BIND_SCREENING_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_TELECOM_CONNECTION_SERVICE = _class.staticFieldId(
    r'BIND_TELECOM_CONNECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_TELECOM_CONNECTION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_TELECOM_CONNECTION_SERVICE =>
      _id_BIND_TELECOM_CONNECTION_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_TEXT_SERVICE = _class.staticFieldId(
    r'BIND_TEXT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_TEXT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_TEXT_SERVICE =>
      _id_BIND_TEXT_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_TV_INPUT = _class.staticFieldId(
    r'BIND_TV_INPUT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_TV_INPUT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_TV_INPUT =>
      _id_BIND_TV_INPUT.get(_class, const jni.JStringType());

  static final _id_BIND_TV_INTERACTIVE_APP = _class.staticFieldId(
    r'BIND_TV_INTERACTIVE_APP',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_TV_INTERACTIVE_APP
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_TV_INTERACTIVE_APP =>
      _id_BIND_TV_INTERACTIVE_APP.get(_class, const jni.JStringType());

  static final _id_BIND_VISUAL_VOICEMAIL_SERVICE = _class.staticFieldId(
    r'BIND_VISUAL_VOICEMAIL_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_VISUAL_VOICEMAIL_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_VISUAL_VOICEMAIL_SERVICE =>
      _id_BIND_VISUAL_VOICEMAIL_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_VOICE_INTERACTION = _class.staticFieldId(
    r'BIND_VOICE_INTERACTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_VOICE_INTERACTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_VOICE_INTERACTION =>
      _id_BIND_VOICE_INTERACTION.get(_class, const jni.JStringType());

  static final _id_BIND_VPN_SERVICE = _class.staticFieldId(
    r'BIND_VPN_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_VPN_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_VPN_SERVICE =>
      _id_BIND_VPN_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_VR_LISTENER_SERVICE = _class.staticFieldId(
    r'BIND_VR_LISTENER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_VR_LISTENER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_VR_LISTENER_SERVICE =>
      _id_BIND_VR_LISTENER_SERVICE.get(_class, const jni.JStringType());

  static final _id_BIND_WALLPAPER = _class.staticFieldId(
    r'BIND_WALLPAPER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIND_WALLPAPER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIND_WALLPAPER =>
      _id_BIND_WALLPAPER.get(_class, const jni.JStringType());

  static final _id_BLUETOOTH = _class.staticFieldId(
    r'BLUETOOTH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BLUETOOTH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BLUETOOTH =>
      _id_BLUETOOTH.get(_class, const jni.JStringType());

  static final _id_BLUETOOTH_ADMIN = _class.staticFieldId(
    r'BLUETOOTH_ADMIN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BLUETOOTH_ADMIN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BLUETOOTH_ADMIN =>
      _id_BLUETOOTH_ADMIN.get(_class, const jni.JStringType());

  static final _id_BLUETOOTH_ADVERTISE = _class.staticFieldId(
    r'BLUETOOTH_ADVERTISE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BLUETOOTH_ADVERTISE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BLUETOOTH_ADVERTISE =>
      _id_BLUETOOTH_ADVERTISE.get(_class, const jni.JStringType());

  static final _id_BLUETOOTH_CONNECT = _class.staticFieldId(
    r'BLUETOOTH_CONNECT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BLUETOOTH_CONNECT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BLUETOOTH_CONNECT =>
      _id_BLUETOOTH_CONNECT.get(_class, const jni.JStringType());

  static final _id_BLUETOOTH_PRIVILEGED = _class.staticFieldId(
    r'BLUETOOTH_PRIVILEGED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BLUETOOTH_PRIVILEGED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BLUETOOTH_PRIVILEGED =>
      _id_BLUETOOTH_PRIVILEGED.get(_class, const jni.JStringType());

  static final _id_BLUETOOTH_SCAN = _class.staticFieldId(
    r'BLUETOOTH_SCAN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BLUETOOTH_SCAN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BLUETOOTH_SCAN =>
      _id_BLUETOOTH_SCAN.get(_class, const jni.JStringType());

  static final _id_BODY_SENSORS = _class.staticFieldId(
    r'BODY_SENSORS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BODY_SENSORS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BODY_SENSORS =>
      _id_BODY_SENSORS.get(_class, const jni.JStringType());

  static final _id_BODY_SENSORS_BACKGROUND = _class.staticFieldId(
    r'BODY_SENSORS_BACKGROUND',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BODY_SENSORS_BACKGROUND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BODY_SENSORS_BACKGROUND =>
      _id_BODY_SENSORS_BACKGROUND.get(_class, const jni.JStringType());

  static final _id_BROADCAST_PACKAGE_REMOVED = _class.staticFieldId(
    r'BROADCAST_PACKAGE_REMOVED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BROADCAST_PACKAGE_REMOVED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BROADCAST_PACKAGE_REMOVED =>
      _id_BROADCAST_PACKAGE_REMOVED.get(_class, const jni.JStringType());

  static final _id_BROADCAST_SMS = _class.staticFieldId(
    r'BROADCAST_SMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BROADCAST_SMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BROADCAST_SMS =>
      _id_BROADCAST_SMS.get(_class, const jni.JStringType());

  static final _id_BROADCAST_STICKY = _class.staticFieldId(
    r'BROADCAST_STICKY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BROADCAST_STICKY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BROADCAST_STICKY =>
      _id_BROADCAST_STICKY.get(_class, const jni.JStringType());

  static final _id_BROADCAST_WAP_PUSH = _class.staticFieldId(
    r'BROADCAST_WAP_PUSH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BROADCAST_WAP_PUSH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BROADCAST_WAP_PUSH =>
      _id_BROADCAST_WAP_PUSH.get(_class, const jni.JStringType());

  static final _id_CALL_COMPANION_APP = _class.staticFieldId(
    r'CALL_COMPANION_APP',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CALL_COMPANION_APP
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CALL_COMPANION_APP =>
      _id_CALL_COMPANION_APP.get(_class, const jni.JStringType());

  static final _id_CALL_PHONE = _class.staticFieldId(
    r'CALL_PHONE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CALL_PHONE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CALL_PHONE =>
      _id_CALL_PHONE.get(_class, const jni.JStringType());

  static final _id_CALL_PRIVILEGED = _class.staticFieldId(
    r'CALL_PRIVILEGED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CALL_PRIVILEGED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CALL_PRIVILEGED =>
      _id_CALL_PRIVILEGED.get(_class, const jni.JStringType());

  static final _id_CAMERA = _class.staticFieldId(
    r'CAMERA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CAMERA =>
      _id_CAMERA.get(_class, const jni.JStringType());

  static final _id_CAPTURE_AUDIO_OUTPUT = _class.staticFieldId(
    r'CAPTURE_AUDIO_OUTPUT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CAPTURE_AUDIO_OUTPUT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CAPTURE_AUDIO_OUTPUT =>
      _id_CAPTURE_AUDIO_OUTPUT.get(_class, const jni.JStringType());

  static final _id_CHANGE_COMPONENT_ENABLED_STATE = _class.staticFieldId(
    r'CHANGE_COMPONENT_ENABLED_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CHANGE_COMPONENT_ENABLED_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CHANGE_COMPONENT_ENABLED_STATE =>
      _id_CHANGE_COMPONENT_ENABLED_STATE.get(_class, const jni.JStringType());

  static final _id_CHANGE_CONFIGURATION = _class.staticFieldId(
    r'CHANGE_CONFIGURATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CHANGE_CONFIGURATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CHANGE_CONFIGURATION =>
      _id_CHANGE_CONFIGURATION.get(_class, const jni.JStringType());

  static final _id_CHANGE_NETWORK_STATE = _class.staticFieldId(
    r'CHANGE_NETWORK_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CHANGE_NETWORK_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CHANGE_NETWORK_STATE =>
      _id_CHANGE_NETWORK_STATE.get(_class, const jni.JStringType());

  static final _id_CHANGE_WIFI_MULTICAST_STATE = _class.staticFieldId(
    r'CHANGE_WIFI_MULTICAST_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CHANGE_WIFI_MULTICAST_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CHANGE_WIFI_MULTICAST_STATE =>
      _id_CHANGE_WIFI_MULTICAST_STATE.get(_class, const jni.JStringType());

  static final _id_CHANGE_WIFI_STATE = _class.staticFieldId(
    r'CHANGE_WIFI_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CHANGE_WIFI_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CHANGE_WIFI_STATE =>
      _id_CHANGE_WIFI_STATE.get(_class, const jni.JStringType());

  static final _id_CLEAR_APP_CACHE = _class.staticFieldId(
    r'CLEAR_APP_CACHE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CLEAR_APP_CACHE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CLEAR_APP_CACHE =>
      _id_CLEAR_APP_CACHE.get(_class, const jni.JStringType());

  static final _id_CONFIGURE_WIFI_DISPLAY = _class.staticFieldId(
    r'CONFIGURE_WIFI_DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONFIGURE_WIFI_DISPLAY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONFIGURE_WIFI_DISPLAY =>
      _id_CONFIGURE_WIFI_DISPLAY.get(_class, const jni.JStringType());

  static final _id_CONTROL_LOCATION_UPDATES = _class.staticFieldId(
    r'CONTROL_LOCATION_UPDATES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTROL_LOCATION_UPDATES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTROL_LOCATION_UPDATES =>
      _id_CONTROL_LOCATION_UPDATES.get(_class, const jni.JStringType());

  static final _id_CREDENTIAL_MANAGER_QUERY_CANDIDATE_CREDENTIALS =
      _class.staticFieldId(
    r'CREDENTIAL_MANAGER_QUERY_CANDIDATE_CREDENTIALS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CREDENTIAL_MANAGER_QUERY_CANDIDATE_CREDENTIALS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CREDENTIAL_MANAGER_QUERY_CANDIDATE_CREDENTIALS =>
      _id_CREDENTIAL_MANAGER_QUERY_CANDIDATE_CREDENTIALS.get(
          _class, const jni.JStringType());

  static final _id_CREDENTIAL_MANAGER_SET_ALLOWED_PROVIDERS =
      _class.staticFieldId(
    r'CREDENTIAL_MANAGER_SET_ALLOWED_PROVIDERS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CREDENTIAL_MANAGER_SET_ALLOWED_PROVIDERS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CREDENTIAL_MANAGER_SET_ALLOWED_PROVIDERS =>
      _id_CREDENTIAL_MANAGER_SET_ALLOWED_PROVIDERS.get(
          _class, const jni.JStringType());

  static final _id_CREDENTIAL_MANAGER_SET_ORIGIN = _class.staticFieldId(
    r'CREDENTIAL_MANAGER_SET_ORIGIN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CREDENTIAL_MANAGER_SET_ORIGIN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CREDENTIAL_MANAGER_SET_ORIGIN =>
      _id_CREDENTIAL_MANAGER_SET_ORIGIN.get(_class, const jni.JStringType());

  static final _id_DELETE_CACHE_FILES = _class.staticFieldId(
    r'DELETE_CACHE_FILES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DELETE_CACHE_FILES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DELETE_CACHE_FILES =>
      _id_DELETE_CACHE_FILES.get(_class, const jni.JStringType());

  static final _id_DELETE_PACKAGES = _class.staticFieldId(
    r'DELETE_PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DELETE_PACKAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DELETE_PACKAGES =>
      _id_DELETE_PACKAGES.get(_class, const jni.JStringType());

  static final _id_DELIVER_COMPANION_MESSAGES = _class.staticFieldId(
    r'DELIVER_COMPANION_MESSAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DELIVER_COMPANION_MESSAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DELIVER_COMPANION_MESSAGES =>
      _id_DELIVER_COMPANION_MESSAGES.get(_class, const jni.JStringType());

  static final _id_DETECT_SCREEN_CAPTURE = _class.staticFieldId(
    r'DETECT_SCREEN_CAPTURE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DETECT_SCREEN_CAPTURE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DETECT_SCREEN_CAPTURE =>
      _id_DETECT_SCREEN_CAPTURE.get(_class, const jni.JStringType());

  static final _id_DIAGNOSTIC = _class.staticFieldId(
    r'DIAGNOSTIC',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DIAGNOSTIC
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIAGNOSTIC =>
      _id_DIAGNOSTIC.get(_class, const jni.JStringType());

  static final _id_DISABLE_KEYGUARD = _class.staticFieldId(
    r'DISABLE_KEYGUARD',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DISABLE_KEYGUARD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DISABLE_KEYGUARD =>
      _id_DISABLE_KEYGUARD.get(_class, const jni.JStringType());

  static final _id_DUMP = _class.staticFieldId(
    r'DUMP',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DUMP
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DUMP => _id_DUMP.get(_class, const jni.JStringType());

  static final _id_ENFORCE_UPDATE_OWNERSHIP = _class.staticFieldId(
    r'ENFORCE_UPDATE_OWNERSHIP',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ENFORCE_UPDATE_OWNERSHIP
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ENFORCE_UPDATE_OWNERSHIP =>
      _id_ENFORCE_UPDATE_OWNERSHIP.get(_class, const jni.JStringType());

  static final _id_EXECUTE_APP_ACTION = _class.staticFieldId(
    r'EXECUTE_APP_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXECUTE_APP_ACTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXECUTE_APP_ACTION =>
      _id_EXECUTE_APP_ACTION.get(_class, const jni.JStringType());

  static final _id_EXPAND_STATUS_BAR = _class.staticFieldId(
    r'EXPAND_STATUS_BAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXPAND_STATUS_BAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXPAND_STATUS_BAR =>
      _id_EXPAND_STATUS_BAR.get(_class, const jni.JStringType());

  static final _id_FACTORY_TEST = _class.staticFieldId(
    r'FACTORY_TEST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FACTORY_TEST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FACTORY_TEST =>
      _id_FACTORY_TEST.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE = _class.staticFieldId(
    r'FOREGROUND_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE =>
      _id_FOREGROUND_SERVICE.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_CAMERA = _class.staticFieldId(
    r'FOREGROUND_SERVICE_CAMERA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_CAMERA =>
      _id_FOREGROUND_SERVICE_CAMERA.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_CONNECTED_DEVICE = _class.staticFieldId(
    r'FOREGROUND_SERVICE_CONNECTED_DEVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_CONNECTED_DEVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_CONNECTED_DEVICE =>
      _id_FOREGROUND_SERVICE_CONNECTED_DEVICE.get(
          _class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_DATA_SYNC = _class.staticFieldId(
    r'FOREGROUND_SERVICE_DATA_SYNC',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_DATA_SYNC
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_DATA_SYNC =>
      _id_FOREGROUND_SERVICE_DATA_SYNC.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_HEALTH = _class.staticFieldId(
    r'FOREGROUND_SERVICE_HEALTH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_HEALTH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_HEALTH =>
      _id_FOREGROUND_SERVICE_HEALTH.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_LOCATION = _class.staticFieldId(
    r'FOREGROUND_SERVICE_LOCATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_LOCATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_LOCATION =>
      _id_FOREGROUND_SERVICE_LOCATION.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_MEDIA_PLAYBACK = _class.staticFieldId(
    r'FOREGROUND_SERVICE_MEDIA_PLAYBACK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_MEDIA_PLAYBACK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_MEDIA_PLAYBACK =>
      _id_FOREGROUND_SERVICE_MEDIA_PLAYBACK.get(
          _class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_MEDIA_PROJECTION = _class.staticFieldId(
    r'FOREGROUND_SERVICE_MEDIA_PROJECTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_MEDIA_PROJECTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_MEDIA_PROJECTION =>
      _id_FOREGROUND_SERVICE_MEDIA_PROJECTION.get(
          _class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_MICROPHONE = _class.staticFieldId(
    r'FOREGROUND_SERVICE_MICROPHONE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_MICROPHONE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_MICROPHONE =>
      _id_FOREGROUND_SERVICE_MICROPHONE.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_PHONE_CALL = _class.staticFieldId(
    r'FOREGROUND_SERVICE_PHONE_CALL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_PHONE_CALL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_PHONE_CALL =>
      _id_FOREGROUND_SERVICE_PHONE_CALL.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_REMOTE_MESSAGING = _class.staticFieldId(
    r'FOREGROUND_SERVICE_REMOTE_MESSAGING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_REMOTE_MESSAGING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_REMOTE_MESSAGING =>
      _id_FOREGROUND_SERVICE_REMOTE_MESSAGING.get(
          _class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_SPECIAL_USE = _class.staticFieldId(
    r'FOREGROUND_SERVICE_SPECIAL_USE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_SPECIAL_USE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_SPECIAL_USE =>
      _id_FOREGROUND_SERVICE_SPECIAL_USE.get(_class, const jni.JStringType());

  static final _id_FOREGROUND_SERVICE_SYSTEM_EXEMPTED = _class.staticFieldId(
    r'FOREGROUND_SERVICE_SYSTEM_EXEMPTED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FOREGROUND_SERVICE_SYSTEM_EXEMPTED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FOREGROUND_SERVICE_SYSTEM_EXEMPTED =>
      _id_FOREGROUND_SERVICE_SYSTEM_EXEMPTED.get(
          _class, const jni.JStringType());

  static final _id_GET_ACCOUNTS = _class.staticFieldId(
    r'GET_ACCOUNTS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GET_ACCOUNTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GET_ACCOUNTS =>
      _id_GET_ACCOUNTS.get(_class, const jni.JStringType());

  static final _id_GET_ACCOUNTS_PRIVILEGED = _class.staticFieldId(
    r'GET_ACCOUNTS_PRIVILEGED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GET_ACCOUNTS_PRIVILEGED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GET_ACCOUNTS_PRIVILEGED =>
      _id_GET_ACCOUNTS_PRIVILEGED.get(_class, const jni.JStringType());

  static final _id_GET_PACKAGE_SIZE = _class.staticFieldId(
    r'GET_PACKAGE_SIZE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GET_PACKAGE_SIZE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GET_PACKAGE_SIZE =>
      _id_GET_PACKAGE_SIZE.get(_class, const jni.JStringType());

  static final _id_GET_TASKS = _class.staticFieldId(
    r'GET_TASKS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GET_TASKS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GET_TASKS =>
      _id_GET_TASKS.get(_class, const jni.JStringType());

  static final _id_GLOBAL_SEARCH = _class.staticFieldId(
    r'GLOBAL_SEARCH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GLOBAL_SEARCH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GLOBAL_SEARCH =>
      _id_GLOBAL_SEARCH.get(_class, const jni.JStringType());

  static final _id_HIDE_OVERLAY_WINDOWS = _class.staticFieldId(
    r'HIDE_OVERLAY_WINDOWS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String HIDE_OVERLAY_WINDOWS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HIDE_OVERLAY_WINDOWS =>
      _id_HIDE_OVERLAY_WINDOWS.get(_class, const jni.JStringType());

  static final _id_HIGH_SAMPLING_RATE_SENSORS = _class.staticFieldId(
    r'HIGH_SAMPLING_RATE_SENSORS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String HIGH_SAMPLING_RATE_SENSORS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HIGH_SAMPLING_RATE_SENSORS =>
      _id_HIGH_SAMPLING_RATE_SENSORS.get(_class, const jni.JStringType());

  static final _id_INSTALL_LOCATION_PROVIDER = _class.staticFieldId(
    r'INSTALL_LOCATION_PROVIDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INSTALL_LOCATION_PROVIDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INSTALL_LOCATION_PROVIDER =>
      _id_INSTALL_LOCATION_PROVIDER.get(_class, const jni.JStringType());

  static final _id_INSTALL_PACKAGES = _class.staticFieldId(
    r'INSTALL_PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INSTALL_PACKAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INSTALL_PACKAGES =>
      _id_INSTALL_PACKAGES.get(_class, const jni.JStringType());

  static final _id_INSTALL_SHORTCUT = _class.staticFieldId(
    r'INSTALL_SHORTCUT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INSTALL_SHORTCUT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INSTALL_SHORTCUT =>
      _id_INSTALL_SHORTCUT.get(_class, const jni.JStringType());

  static final _id_INSTANT_APP_FOREGROUND_SERVICE = _class.staticFieldId(
    r'INSTANT_APP_FOREGROUND_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INSTANT_APP_FOREGROUND_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INSTANT_APP_FOREGROUND_SERVICE =>
      _id_INSTANT_APP_FOREGROUND_SERVICE.get(_class, const jni.JStringType());

  static final _id_INTERACT_ACROSS_PROFILES = _class.staticFieldId(
    r'INTERACT_ACROSS_PROFILES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTERACT_ACROSS_PROFILES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTERACT_ACROSS_PROFILES =>
      _id_INTERACT_ACROSS_PROFILES.get(_class, const jni.JStringType());

  static final _id_INTERNET = _class.staticFieldId(
    r'INTERNET',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTERNET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTERNET =>
      _id_INTERNET.get(_class, const jni.JStringType());

  static final _id_KILL_BACKGROUND_PROCESSES = _class.staticFieldId(
    r'KILL_BACKGROUND_PROCESSES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String KILL_BACKGROUND_PROCESSES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get KILL_BACKGROUND_PROCESSES =>
      _id_KILL_BACKGROUND_PROCESSES.get(_class, const jni.JStringType());

  static final _id_LAUNCH_CAPTURE_CONTENT_ACTIVITY_FOR_NOTE =
      _class.staticFieldId(
    r'LAUNCH_CAPTURE_CONTENT_ACTIVITY_FOR_NOTE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LAUNCH_CAPTURE_CONTENT_ACTIVITY_FOR_NOTE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LAUNCH_CAPTURE_CONTENT_ACTIVITY_FOR_NOTE =>
      _id_LAUNCH_CAPTURE_CONTENT_ACTIVITY_FOR_NOTE.get(
          _class, const jni.JStringType());

  static final _id_LAUNCH_MULTI_PANE_SETTINGS_DEEP_LINK = _class.staticFieldId(
    r'LAUNCH_MULTI_PANE_SETTINGS_DEEP_LINK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LAUNCH_MULTI_PANE_SETTINGS_DEEP_LINK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LAUNCH_MULTI_PANE_SETTINGS_DEEP_LINK =>
      _id_LAUNCH_MULTI_PANE_SETTINGS_DEEP_LINK.get(
          _class, const jni.JStringType());

  static final _id_LOADER_USAGE_STATS = _class.staticFieldId(
    r'LOADER_USAGE_STATS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LOADER_USAGE_STATS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LOADER_USAGE_STATS =>
      _id_LOADER_USAGE_STATS.get(_class, const jni.JStringType());

  static final _id_LOCATION_HARDWARE = _class.staticFieldId(
    r'LOCATION_HARDWARE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LOCATION_HARDWARE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LOCATION_HARDWARE =>
      _id_LOCATION_HARDWARE.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_LOCK_STATE = _class.staticFieldId(
    r'MANAGE_DEVICE_LOCK_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_LOCK_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_LOCK_STATE =>
      _id_MANAGE_DEVICE_LOCK_STATE.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_ACCESSIBILITY = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_ACCESSIBILITY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_ACCESSIBILITY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_ACCESSIBILITY =>
      _id_MANAGE_DEVICE_POLICY_ACCESSIBILITY.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT =>
      _id_MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_ACROSS_USERS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_ACROSS_USERS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_ACROSS_USERS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_ACROSS_USERS =>
      _id_MANAGE_DEVICE_POLICY_ACROSS_USERS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL =>
      _id_MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL =>
      _id_MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_AIRPLANE_MODE = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_AIRPLANE_MODE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_AIRPLANE_MODE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_AIRPLANE_MODE =>
      _id_MANAGE_DEVICE_POLICY_AIRPLANE_MODE.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_APPS_CONTROL = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_APPS_CONTROL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_APPS_CONTROL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_APPS_CONTROL =>
      _id_MANAGE_DEVICE_POLICY_APPS_CONTROL.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_APP_RESTRICTIONS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_APP_RESTRICTIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_APP_RESTRICTIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_APP_RESTRICTIONS =>
      _id_MANAGE_DEVICE_POLICY_APP_RESTRICTIONS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_APP_USER_DATA = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_APP_USER_DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_APP_USER_DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_APP_USER_DATA =>
      _id_MANAGE_DEVICE_POLICY_APP_USER_DATA.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_AUDIO_OUTPUT = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_AUDIO_OUTPUT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_AUDIO_OUTPUT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_AUDIO_OUTPUT =>
      _id_MANAGE_DEVICE_POLICY_AUDIO_OUTPUT.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_AUTOFILL = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_AUTOFILL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_AUTOFILL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_AUTOFILL =>
      _id_MANAGE_DEVICE_POLICY_AUTOFILL.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_BACKUP_SERVICE = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_BACKUP_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_BACKUP_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_BACKUP_SERVICE =>
      _id_MANAGE_DEVICE_POLICY_BACKUP_SERVICE.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_BLUETOOTH = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_BLUETOOTH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_BLUETOOTH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_BLUETOOTH =>
      _id_MANAGE_DEVICE_POLICY_BLUETOOTH.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_BUGREPORT = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_BUGREPORT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_BUGREPORT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_BUGREPORT =>
      _id_MANAGE_DEVICE_POLICY_BUGREPORT.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_CALLS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_CALLS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_CALLS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_CALLS =>
      _id_MANAGE_DEVICE_POLICY_CALLS.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_CAMERA = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_CAMERA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_CAMERA =>
      _id_MANAGE_DEVICE_POLICY_CAMERA.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_CERTIFICATES = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_CERTIFICATES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_CERTIFICATES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_CERTIFICATES =>
      _id_MANAGE_DEVICE_POLICY_CERTIFICATES.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE =>
      _id_MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES =>
      _id_MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_DEFAULT_SMS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_DEFAULT_SMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_DEFAULT_SMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_DEFAULT_SMS =>
      _id_MANAGE_DEVICE_POLICY_DEFAULT_SMS.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_DEVICE_IDENTIFIERS =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_DEVICE_IDENTIFIERS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_DEVICE_IDENTIFIERS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_DEVICE_IDENTIFIERS =>
      _id_MANAGE_DEVICE_POLICY_DEVICE_IDENTIFIERS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_DISPLAY = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_DISPLAY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_DISPLAY =>
      _id_MANAGE_DEVICE_POLICY_DISPLAY.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_FACTORY_RESET = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_FACTORY_RESET',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_FACTORY_RESET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_FACTORY_RESET =>
      _id_MANAGE_DEVICE_POLICY_FACTORY_RESET.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_FUN = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_FUN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_FUN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_FUN =>
      _id_MANAGE_DEVICE_POLICY_FUN.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_INPUT_METHODS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_INPUT_METHODS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_INPUT_METHODS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_INPUT_METHODS =>
      _id_MANAGE_DEVICE_POLICY_INPUT_METHODS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES =>
      _id_MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_KEEP_UNINSTALLED_PACKAGES =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_KEEP_UNINSTALLED_PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_KEEP_UNINSTALLED_PACKAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_KEEP_UNINSTALLED_PACKAGES =>
      _id_MANAGE_DEVICE_POLICY_KEEP_UNINSTALLED_PACKAGES.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_KEYGUARD = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_KEYGUARD',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_KEYGUARD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_KEYGUARD =>
      _id_MANAGE_DEVICE_POLICY_KEYGUARD.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_LOCALE = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_LOCALE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_LOCALE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_LOCALE =>
      _id_MANAGE_DEVICE_POLICY_LOCALE.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_LOCATION = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_LOCATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_LOCATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_LOCATION =>
      _id_MANAGE_DEVICE_POLICY_LOCATION.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_LOCK = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_LOCK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_LOCK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_LOCK =>
      _id_MANAGE_DEVICE_POLICY_LOCK.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS =>
      _id_MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_LOCK_TASK = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_LOCK_TASK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_LOCK_TASK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_LOCK_TASK =>
      _id_MANAGE_DEVICE_POLICY_LOCK_TASK.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_METERED_DATA = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_METERED_DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_METERED_DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_METERED_DATA =>
      _id_MANAGE_DEVICE_POLICY_METERED_DATA.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_MICROPHONE = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_MICROPHONE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_MICROPHONE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_MICROPHONE =>
      _id_MANAGE_DEVICE_POLICY_MICROPHONE.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_MOBILE_NETWORK = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_MOBILE_NETWORK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_MOBILE_NETWORK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_MOBILE_NETWORK =>
      _id_MANAGE_DEVICE_POLICY_MOBILE_NETWORK.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_MODIFY_USERS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_MODIFY_USERS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_MODIFY_USERS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_MODIFY_USERS =>
      _id_MANAGE_DEVICE_POLICY_MODIFY_USERS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_MTE = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_MTE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_MTE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_MTE =>
      _id_MANAGE_DEVICE_POLICY_MTE.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION =>
      _id_MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_NETWORK_LOGGING = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_NETWORK_LOGGING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_NETWORK_LOGGING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_NETWORK_LOGGING =>
      _id_MANAGE_DEVICE_POLICY_NETWORK_LOGGING.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY =>
      _id_MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_OVERRIDE_APN = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_OVERRIDE_APN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_OVERRIDE_APN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_OVERRIDE_APN =>
      _id_MANAGE_DEVICE_POLICY_OVERRIDE_APN.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_PACKAGE_STATE = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_PACKAGE_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_PACKAGE_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_PACKAGE_STATE =>
      _id_MANAGE_DEVICE_POLICY_PACKAGE_STATE.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA =>
      _id_MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_PRINTING = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_PRINTING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_PRINTING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_PRINTING =>
      _id_MANAGE_DEVICE_POLICY_PRINTING.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_PRIVATE_DNS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_PRIVATE_DNS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_PRIVATE_DNS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_PRIVATE_DNS =>
      _id_MANAGE_DEVICE_POLICY_PRIVATE_DNS.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_PROFILES = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_PROFILES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_PROFILES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_PROFILES =>
      _id_MANAGE_DEVICE_POLICY_PROFILES.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_PROFILE_INTERACTION =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_PROFILE_INTERACTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_PROFILE_INTERACTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_PROFILE_INTERACTION =>
      _id_MANAGE_DEVICE_POLICY_PROFILE_INTERACTION.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_PROXY = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_PROXY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_PROXY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_PROXY =>
      _id_MANAGE_DEVICE_POLICY_PROXY.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES =>
      _id_MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_RESET_PASSWORD = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_RESET_PASSWORD',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_RESET_PASSWORD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_RESET_PASSWORD =>
      _id_MANAGE_DEVICE_POLICY_RESET_PASSWORD.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS =>
      _id_MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS =>
      _id_MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND =>
      _id_MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SAFE_BOOT = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SAFE_BOOT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SAFE_BOOT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SAFE_BOOT =>
      _id_MANAGE_DEVICE_POLICY_SAFE_BOOT.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SCREEN_CAPTURE = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SCREEN_CAPTURE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SCREEN_CAPTURE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SCREEN_CAPTURE =>
      _id_MANAGE_DEVICE_POLICY_SCREEN_CAPTURE.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SCREEN_CONTENT = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SCREEN_CONTENT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SCREEN_CONTENT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SCREEN_CONTENT =>
      _id_MANAGE_DEVICE_POLICY_SCREEN_CONTENT.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SECURITY_LOGGING = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SECURITY_LOGGING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SECURITY_LOGGING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SECURITY_LOGGING =>
      _id_MANAGE_DEVICE_POLICY_SECURITY_LOGGING.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SETTINGS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SETTINGS =>
      _id_MANAGE_DEVICE_POLICY_SETTINGS.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SMS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SMS =>
      _id_MANAGE_DEVICE_POLICY_SMS.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_STATUS_BAR = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_STATUS_BAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_STATUS_BAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_STATUS_BAR =>
      _id_MANAGE_DEVICE_POLICY_STATUS_BAR.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE =>
      _id_MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SUSPEND_PERSONAL_APPS =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SUSPEND_PERSONAL_APPS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SUSPEND_PERSONAL_APPS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SUSPEND_PERSONAL_APPS =>
      _id_MANAGE_DEVICE_POLICY_SUSPEND_PERSONAL_APPS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SYSTEM_APPS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SYSTEM_APPS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SYSTEM_APPS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SYSTEM_APPS =>
      _id_MANAGE_DEVICE_POLICY_SYSTEM_APPS.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS =>
      _id_MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_SYSTEM_UPDATES = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_SYSTEM_UPDATES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_SYSTEM_UPDATES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_SYSTEM_UPDATES =>
      _id_MANAGE_DEVICE_POLICY_SYSTEM_UPDATES.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_TIME = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_TIME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_TIME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_TIME =>
      _id_MANAGE_DEVICE_POLICY_TIME.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING =>
      _id_MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER =
      _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER =>
      _id_MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER.get(
          _class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_USERS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_USERS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_USERS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_USERS =>
      _id_MANAGE_DEVICE_POLICY_USERS.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_VPN = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_VPN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_VPN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_VPN =>
      _id_MANAGE_DEVICE_POLICY_VPN.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_WALLPAPER = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_WALLPAPER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_WALLPAPER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_WALLPAPER =>
      _id_MANAGE_DEVICE_POLICY_WALLPAPER.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_WIFI = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_WIFI',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_WIFI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_WIFI =>
      _id_MANAGE_DEVICE_POLICY_WIFI.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_WINDOWS = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_WINDOWS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_WINDOWS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_WINDOWS =>
      _id_MANAGE_DEVICE_POLICY_WINDOWS.get(_class, const jni.JStringType());

  static final _id_MANAGE_DEVICE_POLICY_WIPE_DATA = _class.staticFieldId(
    r'MANAGE_DEVICE_POLICY_WIPE_DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DEVICE_POLICY_WIPE_DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DEVICE_POLICY_WIPE_DATA =>
      _id_MANAGE_DEVICE_POLICY_WIPE_DATA.get(_class, const jni.JStringType());

  static final _id_MANAGE_DOCUMENTS = _class.staticFieldId(
    r'MANAGE_DOCUMENTS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_DOCUMENTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_DOCUMENTS =>
      _id_MANAGE_DOCUMENTS.get(_class, const jni.JStringType());

  static final _id_MANAGE_EXTERNAL_STORAGE = _class.staticFieldId(
    r'MANAGE_EXTERNAL_STORAGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_EXTERNAL_STORAGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_EXTERNAL_STORAGE =>
      _id_MANAGE_EXTERNAL_STORAGE.get(_class, const jni.JStringType());

  static final _id_MANAGE_MEDIA = _class.staticFieldId(
    r'MANAGE_MEDIA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_MEDIA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_MEDIA =>
      _id_MANAGE_MEDIA.get(_class, const jni.JStringType());

  static final _id_MANAGE_ONGOING_CALLS = _class.staticFieldId(
    r'MANAGE_ONGOING_CALLS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_ONGOING_CALLS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_ONGOING_CALLS =>
      _id_MANAGE_ONGOING_CALLS.get(_class, const jni.JStringType());

  static final _id_MANAGE_OWN_CALLS = _class.staticFieldId(
    r'MANAGE_OWN_CALLS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_OWN_CALLS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_OWN_CALLS =>
      _id_MANAGE_OWN_CALLS.get(_class, const jni.JStringType());

  static final _id_MANAGE_WIFI_INTERFACES = _class.staticFieldId(
    r'MANAGE_WIFI_INTERFACES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_WIFI_INTERFACES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_WIFI_INTERFACES =>
      _id_MANAGE_WIFI_INTERFACES.get(_class, const jni.JStringType());

  static final _id_MANAGE_WIFI_NETWORK_SELECTION = _class.staticFieldId(
    r'MANAGE_WIFI_NETWORK_SELECTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MANAGE_WIFI_NETWORK_SELECTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANAGE_WIFI_NETWORK_SELECTION =>
      _id_MANAGE_WIFI_NETWORK_SELECTION.get(_class, const jni.JStringType());

  static final _id_MASTER_CLEAR = _class.staticFieldId(
    r'MASTER_CLEAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MASTER_CLEAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MASTER_CLEAR =>
      _id_MASTER_CLEAR.get(_class, const jni.JStringType());

  static final _id_MEDIA_CONTENT_CONTROL = _class.staticFieldId(
    r'MEDIA_CONTENT_CONTROL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_CONTENT_CONTROL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_CONTENT_CONTROL =>
      _id_MEDIA_CONTENT_CONTROL.get(_class, const jni.JStringType());

  static final _id_MODIFY_AUDIO_SETTINGS = _class.staticFieldId(
    r'MODIFY_AUDIO_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MODIFY_AUDIO_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MODIFY_AUDIO_SETTINGS =>
      _id_MODIFY_AUDIO_SETTINGS.get(_class, const jni.JStringType());

  static final _id_MODIFY_PHONE_STATE = _class.staticFieldId(
    r'MODIFY_PHONE_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MODIFY_PHONE_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MODIFY_PHONE_STATE =>
      _id_MODIFY_PHONE_STATE.get(_class, const jni.JStringType());

  static final _id_MOUNT_FORMAT_FILESYSTEMS = _class.staticFieldId(
    r'MOUNT_FORMAT_FILESYSTEMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MOUNT_FORMAT_FILESYSTEMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MOUNT_FORMAT_FILESYSTEMS =>
      _id_MOUNT_FORMAT_FILESYSTEMS.get(_class, const jni.JStringType());

  static final _id_MOUNT_UNMOUNT_FILESYSTEMS = _class.staticFieldId(
    r'MOUNT_UNMOUNT_FILESYSTEMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MOUNT_UNMOUNT_FILESYSTEMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MOUNT_UNMOUNT_FILESYSTEMS =>
      _id_MOUNT_UNMOUNT_FILESYSTEMS.get(_class, const jni.JStringType());

  static final _id_NEARBY_WIFI_DEVICES = _class.staticFieldId(
    r'NEARBY_WIFI_DEVICES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NEARBY_WIFI_DEVICES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NEARBY_WIFI_DEVICES =>
      _id_NEARBY_WIFI_DEVICES.get(_class, const jni.JStringType());

  static final _id_NFC = _class.staticFieldId(
    r'NFC',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NFC
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NFC => _id_NFC.get(_class, const jni.JStringType());

  static final _id_NFC_PREFERRED_PAYMENT_INFO = _class.staticFieldId(
    r'NFC_PREFERRED_PAYMENT_INFO',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NFC_PREFERRED_PAYMENT_INFO
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NFC_PREFERRED_PAYMENT_INFO =>
      _id_NFC_PREFERRED_PAYMENT_INFO.get(_class, const jni.JStringType());

  static final _id_NFC_TRANSACTION_EVENT = _class.staticFieldId(
    r'NFC_TRANSACTION_EVENT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NFC_TRANSACTION_EVENT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NFC_TRANSACTION_EVENT =>
      _id_NFC_TRANSACTION_EVENT.get(_class, const jni.JStringType());

  static final _id_OVERRIDE_WIFI_CONFIG = _class.staticFieldId(
    r'OVERRIDE_WIFI_CONFIG',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String OVERRIDE_WIFI_CONFIG
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get OVERRIDE_WIFI_CONFIG =>
      _id_OVERRIDE_WIFI_CONFIG.get(_class, const jni.JStringType());

  static final _id_PACKAGE_USAGE_STATS = _class.staticFieldId(
    r'PACKAGE_USAGE_STATS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PACKAGE_USAGE_STATS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PACKAGE_USAGE_STATS =>
      _id_PACKAGE_USAGE_STATS.get(_class, const jni.JStringType());

  static final _id_PERSISTENT_ACTIVITY = _class.staticFieldId(
    r'PERSISTENT_ACTIVITY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PERSISTENT_ACTIVITY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PERSISTENT_ACTIVITY =>
      _id_PERSISTENT_ACTIVITY.get(_class, const jni.JStringType());

  static final _id_POST_NOTIFICATIONS = _class.staticFieldId(
    r'POST_NOTIFICATIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String POST_NOTIFICATIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get POST_NOTIFICATIONS =>
      _id_POST_NOTIFICATIONS.get(_class, const jni.JStringType());

  static final _id_PROCESS_OUTGOING_CALLS = _class.staticFieldId(
    r'PROCESS_OUTGOING_CALLS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PROCESS_OUTGOING_CALLS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PROCESS_OUTGOING_CALLS =>
      _id_PROCESS_OUTGOING_CALLS.get(_class, const jni.JStringType());

  static final _id_PROVIDE_OWN_AUTOFILL_SUGGESTIONS = _class.staticFieldId(
    r'PROVIDE_OWN_AUTOFILL_SUGGESTIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PROVIDE_OWN_AUTOFILL_SUGGESTIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PROVIDE_OWN_AUTOFILL_SUGGESTIONS =>
      _id_PROVIDE_OWN_AUTOFILL_SUGGESTIONS.get(_class, const jni.JStringType());

  static final _id_PROVIDE_REMOTE_CREDENTIALS = _class.staticFieldId(
    r'PROVIDE_REMOTE_CREDENTIALS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PROVIDE_REMOTE_CREDENTIALS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PROVIDE_REMOTE_CREDENTIALS =>
      _id_PROVIDE_REMOTE_CREDENTIALS.get(_class, const jni.JStringType());

  static final _id_QUERY_ALL_PACKAGES = _class.staticFieldId(
    r'QUERY_ALL_PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ALL_PACKAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ALL_PACKAGES =>
      _id_QUERY_ALL_PACKAGES.get(_class, const jni.JStringType());

  static final _id_READ_ASSISTANT_APP_SEARCH_DATA = _class.staticFieldId(
    r'READ_ASSISTANT_APP_SEARCH_DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_ASSISTANT_APP_SEARCH_DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_ASSISTANT_APP_SEARCH_DATA =>
      _id_READ_ASSISTANT_APP_SEARCH_DATA.get(_class, const jni.JStringType());

  static final _id_READ_BASIC_PHONE_STATE = _class.staticFieldId(
    r'READ_BASIC_PHONE_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_BASIC_PHONE_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_BASIC_PHONE_STATE =>
      _id_READ_BASIC_PHONE_STATE.get(_class, const jni.JStringType());

  static final _id_READ_CALENDAR = _class.staticFieldId(
    r'READ_CALENDAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_CALENDAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_CALENDAR =>
      _id_READ_CALENDAR.get(_class, const jni.JStringType());

  static final _id_READ_CALL_LOG = _class.staticFieldId(
    r'READ_CALL_LOG',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_CALL_LOG
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_CALL_LOG =>
      _id_READ_CALL_LOG.get(_class, const jni.JStringType());

  static final _id_READ_CONTACTS = _class.staticFieldId(
    r'READ_CONTACTS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_CONTACTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_CONTACTS =>
      _id_READ_CONTACTS.get(_class, const jni.JStringType());

  static final _id_READ_EXTERNAL_STORAGE = _class.staticFieldId(
    r'READ_EXTERNAL_STORAGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_EXTERNAL_STORAGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_EXTERNAL_STORAGE =>
      _id_READ_EXTERNAL_STORAGE.get(_class, const jni.JStringType());

  static final _id_READ_HOME_APP_SEARCH_DATA = _class.staticFieldId(
    r'READ_HOME_APP_SEARCH_DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_HOME_APP_SEARCH_DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_HOME_APP_SEARCH_DATA =>
      _id_READ_HOME_APP_SEARCH_DATA.get(_class, const jni.JStringType());

  static final _id_READ_INPUT_STATE = _class.staticFieldId(
    r'READ_INPUT_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_INPUT_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_INPUT_STATE =>
      _id_READ_INPUT_STATE.get(_class, const jni.JStringType());

  static final _id_READ_LOGS = _class.staticFieldId(
    r'READ_LOGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_LOGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_LOGS =>
      _id_READ_LOGS.get(_class, const jni.JStringType());

  static final _id_READ_MEDIA_AUDIO = _class.staticFieldId(
    r'READ_MEDIA_AUDIO',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_MEDIA_AUDIO
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_MEDIA_AUDIO =>
      _id_READ_MEDIA_AUDIO.get(_class, const jni.JStringType());

  static final _id_READ_MEDIA_IMAGES = _class.staticFieldId(
    r'READ_MEDIA_IMAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_MEDIA_IMAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_MEDIA_IMAGES =>
      _id_READ_MEDIA_IMAGES.get(_class, const jni.JStringType());

  static final _id_READ_MEDIA_VIDEO = _class.staticFieldId(
    r'READ_MEDIA_VIDEO',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_MEDIA_VIDEO
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_MEDIA_VIDEO =>
      _id_READ_MEDIA_VIDEO.get(_class, const jni.JStringType());

  static final _id_READ_MEDIA_VISUAL_USER_SELECTED = _class.staticFieldId(
    r'READ_MEDIA_VISUAL_USER_SELECTED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_MEDIA_VISUAL_USER_SELECTED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_MEDIA_VISUAL_USER_SELECTED =>
      _id_READ_MEDIA_VISUAL_USER_SELECTED.get(_class, const jni.JStringType());

  static final _id_READ_NEARBY_STREAMING_POLICY = _class.staticFieldId(
    r'READ_NEARBY_STREAMING_POLICY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_NEARBY_STREAMING_POLICY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_NEARBY_STREAMING_POLICY =>
      _id_READ_NEARBY_STREAMING_POLICY.get(_class, const jni.JStringType());

  static final _id_READ_PHONE_NUMBERS = _class.staticFieldId(
    r'READ_PHONE_NUMBERS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_PHONE_NUMBERS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_PHONE_NUMBERS =>
      _id_READ_PHONE_NUMBERS.get(_class, const jni.JStringType());

  static final _id_READ_PHONE_STATE = _class.staticFieldId(
    r'READ_PHONE_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_PHONE_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_PHONE_STATE =>
      _id_READ_PHONE_STATE.get(_class, const jni.JStringType());

  static final _id_READ_PRECISE_PHONE_STATE = _class.staticFieldId(
    r'READ_PRECISE_PHONE_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_PRECISE_PHONE_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_PRECISE_PHONE_STATE =>
      _id_READ_PRECISE_PHONE_STATE.get(_class, const jni.JStringType());

  static final _id_READ_SMS = _class.staticFieldId(
    r'READ_SMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_SMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_SMS =>
      _id_READ_SMS.get(_class, const jni.JStringType());

  static final _id_READ_SYNC_SETTINGS = _class.staticFieldId(
    r'READ_SYNC_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_SYNC_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_SYNC_SETTINGS =>
      _id_READ_SYNC_SETTINGS.get(_class, const jni.JStringType());

  static final _id_READ_SYNC_STATS = _class.staticFieldId(
    r'READ_SYNC_STATS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_SYNC_STATS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_SYNC_STATS =>
      _id_READ_SYNC_STATS.get(_class, const jni.JStringType());

  static final _id_READ_VOICEMAIL = _class.staticFieldId(
    r'READ_VOICEMAIL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_VOICEMAIL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_VOICEMAIL =>
      _id_READ_VOICEMAIL.get(_class, const jni.JStringType());

  static final _id_REBOOT = _class.staticFieldId(
    r'REBOOT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REBOOT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REBOOT =>
      _id_REBOOT.get(_class, const jni.JStringType());

  static final _id_RECEIVE_BOOT_COMPLETED = _class.staticFieldId(
    r'RECEIVE_BOOT_COMPLETED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RECEIVE_BOOT_COMPLETED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RECEIVE_BOOT_COMPLETED =>
      _id_RECEIVE_BOOT_COMPLETED.get(_class, const jni.JStringType());

  static final _id_RECEIVE_MMS = _class.staticFieldId(
    r'RECEIVE_MMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RECEIVE_MMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RECEIVE_MMS =>
      _id_RECEIVE_MMS.get(_class, const jni.JStringType());

  static final _id_RECEIVE_SMS = _class.staticFieldId(
    r'RECEIVE_SMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RECEIVE_SMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RECEIVE_SMS =>
      _id_RECEIVE_SMS.get(_class, const jni.JStringType());

  static final _id_RECEIVE_WAP_PUSH = _class.staticFieldId(
    r'RECEIVE_WAP_PUSH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RECEIVE_WAP_PUSH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RECEIVE_WAP_PUSH =>
      _id_RECEIVE_WAP_PUSH.get(_class, const jni.JStringType());

  static final _id_RECORD_AUDIO = _class.staticFieldId(
    r'RECORD_AUDIO',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RECORD_AUDIO
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RECORD_AUDIO =>
      _id_RECORD_AUDIO.get(_class, const jni.JStringType());

  static final _id_REORDER_TASKS = _class.staticFieldId(
    r'REORDER_TASKS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REORDER_TASKS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REORDER_TASKS =>
      _id_REORDER_TASKS.get(_class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_PROFILE_APP_STREAMING =
      _class.staticFieldId(
    r'REQUEST_COMPANION_PROFILE_APP_STREAMING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_PROFILE_APP_STREAMING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_PROFILE_APP_STREAMING =>
      _id_REQUEST_COMPANION_PROFILE_APP_STREAMING.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_PROFILE_AUTOMOTIVE_PROJECTION =
      _class.staticFieldId(
    r'REQUEST_COMPANION_PROFILE_AUTOMOTIVE_PROJECTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_PROFILE_AUTOMOTIVE_PROJECTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_PROFILE_AUTOMOTIVE_PROJECTION =>
      _id_REQUEST_COMPANION_PROFILE_AUTOMOTIVE_PROJECTION.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_PROFILE_COMPUTER = _class.staticFieldId(
    r'REQUEST_COMPANION_PROFILE_COMPUTER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_PROFILE_COMPUTER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_PROFILE_COMPUTER =>
      _id_REQUEST_COMPANION_PROFILE_COMPUTER.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_PROFILE_GLASSES = _class.staticFieldId(
    r'REQUEST_COMPANION_PROFILE_GLASSES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_PROFILE_GLASSES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_PROFILE_GLASSES =>
      _id_REQUEST_COMPANION_PROFILE_GLASSES.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_PROFILE_NEARBY_DEVICE_STREAMING =
      _class.staticFieldId(
    r'REQUEST_COMPANION_PROFILE_NEARBY_DEVICE_STREAMING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_PROFILE_NEARBY_DEVICE_STREAMING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_PROFILE_NEARBY_DEVICE_STREAMING =>
      _id_REQUEST_COMPANION_PROFILE_NEARBY_DEVICE_STREAMING.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_PROFILE_WATCH = _class.staticFieldId(
    r'REQUEST_COMPANION_PROFILE_WATCH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_PROFILE_WATCH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_PROFILE_WATCH =>
      _id_REQUEST_COMPANION_PROFILE_WATCH.get(_class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_RUN_IN_BACKGROUND = _class.staticFieldId(
    r'REQUEST_COMPANION_RUN_IN_BACKGROUND',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_RUN_IN_BACKGROUND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_RUN_IN_BACKGROUND =>
      _id_REQUEST_COMPANION_RUN_IN_BACKGROUND.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_SELF_MANAGED = _class.staticFieldId(
    r'REQUEST_COMPANION_SELF_MANAGED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_SELF_MANAGED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_SELF_MANAGED =>
      _id_REQUEST_COMPANION_SELF_MANAGED.get(_class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_START_FOREGROUND_SERVICES_FROM_BACKGROUND =
      _class.staticFieldId(
    r'REQUEST_COMPANION_START_FOREGROUND_SERVICES_FROM_BACKGROUND',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_START_FOREGROUND_SERVICES_FROM_BACKGROUND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString
      get REQUEST_COMPANION_START_FOREGROUND_SERVICES_FROM_BACKGROUND =>
          _id_REQUEST_COMPANION_START_FOREGROUND_SERVICES_FROM_BACKGROUND.get(
              _class, const jni.JStringType());

  static final _id_REQUEST_COMPANION_USE_DATA_IN_BACKGROUND =
      _class.staticFieldId(
    r'REQUEST_COMPANION_USE_DATA_IN_BACKGROUND',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_COMPANION_USE_DATA_IN_BACKGROUND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_COMPANION_USE_DATA_IN_BACKGROUND =>
      _id_REQUEST_COMPANION_USE_DATA_IN_BACKGROUND.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_DELETE_PACKAGES = _class.staticFieldId(
    r'REQUEST_DELETE_PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_DELETE_PACKAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_DELETE_PACKAGES =>
      _id_REQUEST_DELETE_PACKAGES.get(_class, const jni.JStringType());

  static final _id_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS = _class.staticFieldId(
    r'REQUEST_IGNORE_BATTERY_OPTIMIZATIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_IGNORE_BATTERY_OPTIMIZATIONS =>
      _id_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_INSTALL_PACKAGES = _class.staticFieldId(
    r'REQUEST_INSTALL_PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_INSTALL_PACKAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_INSTALL_PACKAGES =>
      _id_REQUEST_INSTALL_PACKAGES.get(_class, const jni.JStringType());

  static final _id_REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE =
      _class.staticFieldId(
    r'REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE =>
      _id_REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE.get(
          _class, const jni.JStringType());

  static final _id_REQUEST_PASSWORD_COMPLEXITY = _class.staticFieldId(
    r'REQUEST_PASSWORD_COMPLEXITY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REQUEST_PASSWORD_COMPLEXITY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REQUEST_PASSWORD_COMPLEXITY =>
      _id_REQUEST_PASSWORD_COMPLEXITY.get(_class, const jni.JStringType());

  static final _id_RESTART_PACKAGES = _class.staticFieldId(
    r'RESTART_PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RESTART_PACKAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RESTART_PACKAGES =>
      _id_RESTART_PACKAGES.get(_class, const jni.JStringType());

  static final _id_RUN_USER_INITIATED_JOBS = _class.staticFieldId(
    r'RUN_USER_INITIATED_JOBS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RUN_USER_INITIATED_JOBS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RUN_USER_INITIATED_JOBS =>
      _id_RUN_USER_INITIATED_JOBS.get(_class, const jni.JStringType());

  static final _id_SCHEDULE_EXACT_ALARM = _class.staticFieldId(
    r'SCHEDULE_EXACT_ALARM',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SCHEDULE_EXACT_ALARM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SCHEDULE_EXACT_ALARM =>
      _id_SCHEDULE_EXACT_ALARM.get(_class, const jni.JStringType());

  static final _id_SEND_RESPOND_VIA_MESSAGE = _class.staticFieldId(
    r'SEND_RESPOND_VIA_MESSAGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SEND_RESPOND_VIA_MESSAGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SEND_RESPOND_VIA_MESSAGE =>
      _id_SEND_RESPOND_VIA_MESSAGE.get(_class, const jni.JStringType());

  static final _id_SEND_SMS = _class.staticFieldId(
    r'SEND_SMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SEND_SMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SEND_SMS =>
      _id_SEND_SMS.get(_class, const jni.JStringType());

  static final _id_SET_ALARM = _class.staticFieldId(
    r'SET_ALARM',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_ALARM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_ALARM =>
      _id_SET_ALARM.get(_class, const jni.JStringType());

  static final _id_SET_ALWAYS_FINISH = _class.staticFieldId(
    r'SET_ALWAYS_FINISH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_ALWAYS_FINISH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_ALWAYS_FINISH =>
      _id_SET_ALWAYS_FINISH.get(_class, const jni.JStringType());

  static final _id_SET_ANIMATION_SCALE = _class.staticFieldId(
    r'SET_ANIMATION_SCALE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_ANIMATION_SCALE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_ANIMATION_SCALE =>
      _id_SET_ANIMATION_SCALE.get(_class, const jni.JStringType());

  static final _id_SET_DEBUG_APP = _class.staticFieldId(
    r'SET_DEBUG_APP',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_DEBUG_APP
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_DEBUG_APP =>
      _id_SET_DEBUG_APP.get(_class, const jni.JStringType());

  static final _id_SET_PREFERRED_APPLICATIONS = _class.staticFieldId(
    r'SET_PREFERRED_APPLICATIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_PREFERRED_APPLICATIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_PREFERRED_APPLICATIONS =>
      _id_SET_PREFERRED_APPLICATIONS.get(_class, const jni.JStringType());

  static final _id_SET_PROCESS_LIMIT = _class.staticFieldId(
    r'SET_PROCESS_LIMIT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_PROCESS_LIMIT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_PROCESS_LIMIT =>
      _id_SET_PROCESS_LIMIT.get(_class, const jni.JStringType());

  static final _id_SET_TIME = _class.staticFieldId(
    r'SET_TIME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_TIME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_TIME =>
      _id_SET_TIME.get(_class, const jni.JStringType());

  static final _id_SET_TIME_ZONE = _class.staticFieldId(
    r'SET_TIME_ZONE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_TIME_ZONE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_TIME_ZONE =>
      _id_SET_TIME_ZONE.get(_class, const jni.JStringType());

  static final _id_SET_WALLPAPER = _class.staticFieldId(
    r'SET_WALLPAPER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_WALLPAPER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_WALLPAPER =>
      _id_SET_WALLPAPER.get(_class, const jni.JStringType());

  static final _id_SET_WALLPAPER_HINTS = _class.staticFieldId(
    r'SET_WALLPAPER_HINTS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SET_WALLPAPER_HINTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SET_WALLPAPER_HINTS =>
      _id_SET_WALLPAPER_HINTS.get(_class, const jni.JStringType());

  static final _id_SIGNAL_PERSISTENT_PROCESSES = _class.staticFieldId(
    r'SIGNAL_PERSISTENT_PROCESSES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SIGNAL_PERSISTENT_PROCESSES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SIGNAL_PERSISTENT_PROCESSES =>
      _id_SIGNAL_PERSISTENT_PROCESSES.get(_class, const jni.JStringType());

  static final _id_SMS_FINANCIAL_TRANSACTIONS = _class.staticFieldId(
    r'SMS_FINANCIAL_TRANSACTIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SMS_FINANCIAL_TRANSACTIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SMS_FINANCIAL_TRANSACTIONS =>
      _id_SMS_FINANCIAL_TRANSACTIONS.get(_class, const jni.JStringType());

  static final _id_START_FOREGROUND_SERVICES_FROM_BACKGROUND =
      _class.staticFieldId(
    r'START_FOREGROUND_SERVICES_FROM_BACKGROUND',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String START_FOREGROUND_SERVICES_FROM_BACKGROUND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get START_FOREGROUND_SERVICES_FROM_BACKGROUND =>
      _id_START_FOREGROUND_SERVICES_FROM_BACKGROUND.get(
          _class, const jni.JStringType());

  static final _id_START_VIEW_APP_FEATURES = _class.staticFieldId(
    r'START_VIEW_APP_FEATURES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String START_VIEW_APP_FEATURES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get START_VIEW_APP_FEATURES =>
      _id_START_VIEW_APP_FEATURES.get(_class, const jni.JStringType());

  static final _id_START_VIEW_PERMISSION_USAGE = _class.staticFieldId(
    r'START_VIEW_PERMISSION_USAGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String START_VIEW_PERMISSION_USAGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get START_VIEW_PERMISSION_USAGE =>
      _id_START_VIEW_PERMISSION_USAGE.get(_class, const jni.JStringType());

  static final _id_STATUS_BAR = _class.staticFieldId(
    r'STATUS_BAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String STATUS_BAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get STATUS_BAR =>
      _id_STATUS_BAR.get(_class, const jni.JStringType());

  static final _id_SUBSCRIBE_TO_KEYGUARD_LOCKED_STATE = _class.staticFieldId(
    r'SUBSCRIBE_TO_KEYGUARD_LOCKED_STATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SUBSCRIBE_TO_KEYGUARD_LOCKED_STATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SUBSCRIBE_TO_KEYGUARD_LOCKED_STATE =>
      _id_SUBSCRIBE_TO_KEYGUARD_LOCKED_STATE.get(
          _class, const jni.JStringType());

  static final _id_SYSTEM_ALERT_WINDOW = _class.staticFieldId(
    r'SYSTEM_ALERT_WINDOW',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYSTEM_ALERT_WINDOW
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYSTEM_ALERT_WINDOW =>
      _id_SYSTEM_ALERT_WINDOW.get(_class, const jni.JStringType());

  static final _id_TRANSMIT_IR = _class.staticFieldId(
    r'TRANSMIT_IR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TRANSMIT_IR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TRANSMIT_IR =>
      _id_TRANSMIT_IR.get(_class, const jni.JStringType());

  static final _id_TURN_SCREEN_ON = _class.staticFieldId(
    r'TURN_SCREEN_ON',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TURN_SCREEN_ON
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TURN_SCREEN_ON =>
      _id_TURN_SCREEN_ON.get(_class, const jni.JStringType());

  static final _id_UNINSTALL_SHORTCUT = _class.staticFieldId(
    r'UNINSTALL_SHORTCUT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String UNINSTALL_SHORTCUT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get UNINSTALL_SHORTCUT =>
      _id_UNINSTALL_SHORTCUT.get(_class, const jni.JStringType());

  static final _id_UPDATE_DEVICE_STATS = _class.staticFieldId(
    r'UPDATE_DEVICE_STATS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String UPDATE_DEVICE_STATS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get UPDATE_DEVICE_STATS =>
      _id_UPDATE_DEVICE_STATS.get(_class, const jni.JStringType());

  static final _id_UPDATE_PACKAGES_WITHOUT_USER_ACTION = _class.staticFieldId(
    r'UPDATE_PACKAGES_WITHOUT_USER_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String UPDATE_PACKAGES_WITHOUT_USER_ACTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get UPDATE_PACKAGES_WITHOUT_USER_ACTION =>
      _id_UPDATE_PACKAGES_WITHOUT_USER_ACTION.get(
          _class, const jni.JStringType());

  static final _id_USE_BIOMETRIC = _class.staticFieldId(
    r'USE_BIOMETRIC',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USE_BIOMETRIC
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USE_BIOMETRIC =>
      _id_USE_BIOMETRIC.get(_class, const jni.JStringType());

  static final _id_USE_EXACT_ALARM = _class.staticFieldId(
    r'USE_EXACT_ALARM',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USE_EXACT_ALARM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USE_EXACT_ALARM =>
      _id_USE_EXACT_ALARM.get(_class, const jni.JStringType());

  static final _id_USE_FINGERPRINT = _class.staticFieldId(
    r'USE_FINGERPRINT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USE_FINGERPRINT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USE_FINGERPRINT =>
      _id_USE_FINGERPRINT.get(_class, const jni.JStringType());

  static final _id_USE_FULL_SCREEN_INTENT = _class.staticFieldId(
    r'USE_FULL_SCREEN_INTENT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USE_FULL_SCREEN_INTENT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USE_FULL_SCREEN_INTENT =>
      _id_USE_FULL_SCREEN_INTENT.get(_class, const jni.JStringType());

  static final _id_USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER = _class.staticFieldId(
    r'USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER =>
      _id_USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER.get(
          _class, const jni.JStringType());

  static final _id_USE_SIP = _class.staticFieldId(
    r'USE_SIP',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USE_SIP
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USE_SIP =>
      _id_USE_SIP.get(_class, const jni.JStringType());

  static final _id_UWB_RANGING = _class.staticFieldId(
    r'UWB_RANGING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String UWB_RANGING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get UWB_RANGING =>
      _id_UWB_RANGING.get(_class, const jni.JStringType());

  static final _id_VIBRATE = _class.staticFieldId(
    r'VIBRATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VIBRATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VIBRATE =>
      _id_VIBRATE.get(_class, const jni.JStringType());

  static final _id_WAKE_LOCK = _class.staticFieldId(
    r'WAKE_LOCK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WAKE_LOCK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WAKE_LOCK =>
      _id_WAKE_LOCK.get(_class, const jni.JStringType());

  static final _id_WRITE_APN_SETTINGS = _class.staticFieldId(
    r'WRITE_APN_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_APN_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_APN_SETTINGS =>
      _id_WRITE_APN_SETTINGS.get(_class, const jni.JStringType());

  static final _id_WRITE_CALENDAR = _class.staticFieldId(
    r'WRITE_CALENDAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_CALENDAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_CALENDAR =>
      _id_WRITE_CALENDAR.get(_class, const jni.JStringType());

  static final _id_WRITE_CALL_LOG = _class.staticFieldId(
    r'WRITE_CALL_LOG',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_CALL_LOG
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_CALL_LOG =>
      _id_WRITE_CALL_LOG.get(_class, const jni.JStringType());

  static final _id_WRITE_CONTACTS = _class.staticFieldId(
    r'WRITE_CONTACTS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_CONTACTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_CONTACTS =>
      _id_WRITE_CONTACTS.get(_class, const jni.JStringType());

  static final _id_WRITE_EXTERNAL_STORAGE = _class.staticFieldId(
    r'WRITE_EXTERNAL_STORAGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_EXTERNAL_STORAGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_EXTERNAL_STORAGE =>
      _id_WRITE_EXTERNAL_STORAGE.get(_class, const jni.JStringType());

  static final _id_WRITE_GSERVICES = _class.staticFieldId(
    r'WRITE_GSERVICES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_GSERVICES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_GSERVICES =>
      _id_WRITE_GSERVICES.get(_class, const jni.JStringType());

  static final _id_WRITE_SECURE_SETTINGS = _class.staticFieldId(
    r'WRITE_SECURE_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_SECURE_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_SECURE_SETTINGS =>
      _id_WRITE_SECURE_SETTINGS.get(_class, const jni.JStringType());

  static final _id_WRITE_SETTINGS = _class.staticFieldId(
    r'WRITE_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_SETTINGS =>
      _id_WRITE_SETTINGS.get(_class, const jni.JStringType());

  static final _id_WRITE_SYNC_SETTINGS = _class.staticFieldId(
    r'WRITE_SYNC_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_SYNC_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_SYNC_SETTINGS =>
      _id_WRITE_SYNC_SETTINGS.get(_class, const jni.JStringType());

  static final _id_WRITE_VOICEMAIL = _class.staticFieldId(
    r'WRITE_VOICEMAIL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITE_VOICEMAIL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITE_VOICEMAIL =>
      _id_WRITE_VOICEMAIL.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Manifest_permission() {
    return Manifest_permission.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $Manifest_permissionType extends jni.JObjType<Manifest_permission> {
  const $Manifest_permissionType();

  @override
  String get signature => r'Landroid/Manifest$permission;';

  @override
  Manifest_permission fromReference(jni.JReference reference) =>
      Manifest_permission.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Manifest_permissionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Manifest_permissionType) &&
        other is $Manifest_permissionType;
  }
}

/// from: android.Manifest$permission_group
class Manifest_permission_group extends jni.JObject {
  @override
  late final jni.JObjType<Manifest_permission_group> $type = type;

  Manifest_permission_group.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/Manifest$permission_group');

  /// The type which includes information such as the signature of this class.
  static const type = $Manifest_permission_groupType();
  static final _id_ACTIVITY_RECOGNITION = _class.staticFieldId(
    r'ACTIVITY_RECOGNITION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTIVITY_RECOGNITION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTIVITY_RECOGNITION =>
      _id_ACTIVITY_RECOGNITION.get(_class, const jni.JStringType());

  static final _id_CALENDAR = _class.staticFieldId(
    r'CALENDAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CALENDAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CALENDAR =>
      _id_CALENDAR.get(_class, const jni.JStringType());

  static final _id_CALL_LOG = _class.staticFieldId(
    r'CALL_LOG',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CALL_LOG
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CALL_LOG =>
      _id_CALL_LOG.get(_class, const jni.JStringType());

  static final _id_CAMERA = _class.staticFieldId(
    r'CAMERA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CAMERA =>
      _id_CAMERA.get(_class, const jni.JStringType());

  static final _id_CONTACTS = _class.staticFieldId(
    r'CONTACTS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTACTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTACTS =>
      _id_CONTACTS.get(_class, const jni.JStringType());

  static final _id_LOCATION = _class.staticFieldId(
    r'LOCATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LOCATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LOCATION =>
      _id_LOCATION.get(_class, const jni.JStringType());

  static final _id_MICROPHONE = _class.staticFieldId(
    r'MICROPHONE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MICROPHONE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MICROPHONE =>
      _id_MICROPHONE.get(_class, const jni.JStringType());

  static final _id_NEARBY_DEVICES = _class.staticFieldId(
    r'NEARBY_DEVICES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NEARBY_DEVICES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NEARBY_DEVICES =>
      _id_NEARBY_DEVICES.get(_class, const jni.JStringType());

  static final _id_NOTIFICATIONS = _class.staticFieldId(
    r'NOTIFICATIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NOTIFICATIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NOTIFICATIONS =>
      _id_NOTIFICATIONS.get(_class, const jni.JStringType());

  static final _id_PHONE = _class.staticFieldId(
    r'PHONE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PHONE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PHONE =>
      _id_PHONE.get(_class, const jni.JStringType());

  static final _id_READ_MEDIA_AURAL = _class.staticFieldId(
    r'READ_MEDIA_AURAL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_MEDIA_AURAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_MEDIA_AURAL =>
      _id_READ_MEDIA_AURAL.get(_class, const jni.JStringType());

  static final _id_READ_MEDIA_VISUAL = _class.staticFieldId(
    r'READ_MEDIA_VISUAL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String READ_MEDIA_VISUAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get READ_MEDIA_VISUAL =>
      _id_READ_MEDIA_VISUAL.get(_class, const jni.JStringType());

  static final _id_SENSORS = _class.staticFieldId(
    r'SENSORS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SENSORS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SENSORS =>
      _id_SENSORS.get(_class, const jni.JStringType());

  static final _id_SMS = _class.staticFieldId(
    r'SMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SMS => _id_SMS.get(_class, const jni.JStringType());

  static final _id_STORAGE = _class.staticFieldId(
    r'STORAGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String STORAGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get STORAGE =>
      _id_STORAGE.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Manifest_permission_group() {
    return Manifest_permission_group.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $Manifest_permission_groupType
    extends jni.JObjType<Manifest_permission_group> {
  const $Manifest_permission_groupType();

  @override
  String get signature => r'Landroid/Manifest$permission_group;';

  @override
  Manifest_permission_group fromReference(jni.JReference reference) =>
      Manifest_permission_group.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Manifest_permission_groupType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Manifest_permission_groupType) &&
        other is $Manifest_permission_groupType;
  }
}

/// from: android.Manifest
class Manifest extends jni.JObject {
  @override
  late final jni.JObjType<Manifest> $type = type;

  Manifest.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/Manifest');

  /// The type which includes information such as the signature of this class.
  static const type = $ManifestType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Manifest() {
    return Manifest.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $ManifestType extends jni.JObjType<Manifest> {
  const $ManifestType();

  @override
  String get signature => r'Landroid/Manifest;';

  @override
  Manifest fromReference(jni.JReference reference) =>
      Manifest.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ManifestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ManifestType) && other is $ManifestType;
  }
}

/// from: android.app.Activity$ScreenCaptureCallback
class Activity_ScreenCaptureCallback extends jni.JObject {
  @override
  late final jni.JObjType<Activity_ScreenCaptureCallback> $type = type;

  Activity_ScreenCaptureCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/app/Activity$ScreenCaptureCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $Activity_ScreenCaptureCallbackType();
  static final _id_onScreenCaptured = _class.instanceMethodId(
    r'onScreenCaptured',
    r'()V',
  );

  static final _onScreenCaptured = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void onScreenCaptured()
  void onScreenCaptured() {
    _onScreenCaptured(
            reference.pointer, _id_onScreenCaptured as jni.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Activity_ScreenCaptureCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onScreenCaptured()V') {
        _$impls[$p]!.onScreenCaptured();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Activity_ScreenCaptureCallback.implement(
    $Activity_ScreenCaptureCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Activity_ScreenCaptureCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.app.Activity$ScreenCaptureCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Activity_ScreenCaptureCallbackImpl {
  factory $Activity_ScreenCaptureCallbackImpl({
    required void Function() onScreenCaptured,
  }) = _$Activity_ScreenCaptureCallbackImpl;

  void onScreenCaptured();
}

class _$Activity_ScreenCaptureCallbackImpl
    implements $Activity_ScreenCaptureCallbackImpl {
  _$Activity_ScreenCaptureCallbackImpl({
    required void Function() onScreenCaptured,
  }) : _onScreenCaptured = onScreenCaptured;

  final void Function() _onScreenCaptured;

  void onScreenCaptured() {
    return _onScreenCaptured();
  }
}

final class $Activity_ScreenCaptureCallbackType
    extends jni.JObjType<Activity_ScreenCaptureCallback> {
  const $Activity_ScreenCaptureCallbackType();

  @override
  String get signature => r'Landroid/app/Activity$ScreenCaptureCallback;';

  @override
  Activity_ScreenCaptureCallback fromReference(jni.JReference reference) =>
      Activity_ScreenCaptureCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Activity_ScreenCaptureCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Activity_ScreenCaptureCallbackType) &&
        other is $Activity_ScreenCaptureCallbackType;
  }
}

/// from: android.app.Activity
class Activity extends jni.JObject {
  @override
  late final jni.JObjType<Activity> $type = type;

  Activity.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/app/Activity');

  /// The type which includes information such as the signature of this class.
  static const type = $ActivityType();

  /// from: static public final int DEFAULT_KEYS_DIALER
  static const DEFAULT_KEYS_DIALER = 1;

  /// from: static public final int DEFAULT_KEYS_DISABLE
  static const DEFAULT_KEYS_DISABLE = 0;

  /// from: static public final int DEFAULT_KEYS_SEARCH_GLOBAL
  static const DEFAULT_KEYS_SEARCH_GLOBAL = 4;

  /// from: static public final int DEFAULT_KEYS_SEARCH_LOCAL
  static const DEFAULT_KEYS_SEARCH_LOCAL = 3;

  /// from: static public final int DEFAULT_KEYS_SHORTCUT
  static const DEFAULT_KEYS_SHORTCUT = 2;
  static final _id_FOCUSED_STATE_SET = _class.staticFieldId(
    r'FOCUSED_STATE_SET',
    r'[I',
  );

  /// from: static protected final int[] FOCUSED_STATE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> get FOCUSED_STATE_SET =>
      _id_FOCUSED_STATE_SET.get(_class, const jni.JArrayType(jni.jintType()));

  /// from: static public final int FULLSCREEN_MODE_REQUEST_ENTER
  static const FULLSCREEN_MODE_REQUEST_ENTER = 1;

  /// from: static public final int FULLSCREEN_MODE_REQUEST_EXIT
  static const FULLSCREEN_MODE_REQUEST_EXIT = 0;

  /// from: static public final int OVERRIDE_TRANSITION_CLOSE
  static const OVERRIDE_TRANSITION_CLOSE = 1;

  /// from: static public final int OVERRIDE_TRANSITION_OPEN
  static const OVERRIDE_TRANSITION_OPEN = 0;

  /// from: static public final int RESULT_CANCELED
  static const RESULT_CANCELED = 0;

  /// from: static public final int RESULT_FIRST_USER
  static const RESULT_FIRST_USER = 1;

  /// from: static public final int RESULT_OK
  static const RESULT_OK = -1;
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Activity() {
    return Activity.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getIntent = _class.instanceMethodId(
    r'getIntent',
    r'()Landroid/content/Intent;',
  );

  static final _getIntent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.content.Intent getIntent()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getIntent() {
    return _getIntent(reference.pointer, _id_getIntent as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setIntent = _class.instanceMethodId(
    r'setIntent',
    r'(Landroid/content/Intent;)V',
  );

  static final _setIntent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setIntent(android.content.Intent intent)
  void setIntent(
    jni.JObject intent,
  ) {
    _setIntent(reference.pointer, _id_setIntent as jni.JMethodIDPtr,
            intent.reference.pointer)
        .check();
  }

  static final _id_setLocusContext = _class.instanceMethodId(
    r'setLocusContext',
    r'(Landroid/content/LocusId;Landroid/os/Bundle;)V',
  );

  static final _setLocusContext = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLocusContext(android.content.LocusId locusId, android.os.Bundle bundle)
  void setLocusContext(
    jni.JObject locusId,
    jni.JObject bundle,
  ) {
    _setLocusContext(reference.pointer, _id_setLocusContext as jni.JMethodIDPtr,
            locusId.reference.pointer, bundle.reference.pointer)
        .check();
  }

  static final _id_getApplication = _class.instanceMethodId(
    r'getApplication',
    r'()Landroid/app/Application;',
  );

  static final _getApplication = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.app.Application getApplication()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getApplication() {
    return _getApplication(
            reference.pointer, _id_getApplication as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_isChild = _class.instanceMethodId(
    r'isChild',
    r'()Z',
  );

  static final _isChild = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isChild()
  bool isChild() {
    return _isChild(reference.pointer, _id_isChild as jni.JMethodIDPtr).boolean;
  }

  static final _id_getParent = _class.instanceMethodId(
    r'getParent',
    r'()Landroid/app/Activity;',
  );

  static final _getParent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.app.Activity getParent()
  /// The returned object must be released after use, by calling the [release] method.
  Activity getParent() {
    return _getParent(reference.pointer, _id_getParent as jni.JMethodIDPtr)
        .object(const $ActivityType());
  }

  static final _id_getWindowManager = _class.instanceMethodId(
    r'getWindowManager',
    r'()Landroid/view/WindowManager;',
  );

  static final _getWindowManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.view.WindowManager getWindowManager()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWindowManager() {
    return _getWindowManager(
            reference.pointer, _id_getWindowManager as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getWindow = _class.instanceMethodId(
    r'getWindow',
    r'()Landroid/view/Window;',
  );

  static final _getWindow = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.view.Window getWindow()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWindow() {
    return _getWindow(reference.pointer, _id_getWindow as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getLoaderManager = _class.instanceMethodId(
    r'getLoaderManager',
    r'()Landroid/app/LoaderManager;',
  );

  static final _getLoaderManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.app.LoaderManager getLoaderManager()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLoaderManager() {
    return _getLoaderManager(
            reference.pointer, _id_getLoaderManager as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getCurrentFocus = _class.instanceMethodId(
    r'getCurrentFocus',
    r'()Landroid/view/View;',
  );

  static final _getCurrentFocus = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.view.View getCurrentFocus()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCurrentFocus() {
    return _getCurrentFocus(
            reference.pointer, _id_getCurrentFocus as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_attachBaseContext = _class.instanceMethodId(
    r'attachBaseContext',
    r'(Landroid/content/Context;)V',
  );

  static final _attachBaseContext = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void attachBaseContext(android.content.Context context)
  void attachBaseContext(
    Context context,
  ) {
    _attachBaseContext(
            reference.pointer,
            _id_attachBaseContext as jni.JMethodIDPtr,
            context.reference.pointer)
        .check();
  }

  static final _id_registerActivityLifecycleCallbacks = _class.instanceMethodId(
    r'registerActivityLifecycleCallbacks',
    r'(Landroid/app/Application$ActivityLifecycleCallbacks;)V',
  );

  static final _registerActivityLifecycleCallbacks =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerActivityLifecycleCallbacks(android.app.Application$ActivityLifecycleCallbacks activityLifecycleCallbacks)
  void registerActivityLifecycleCallbacks(
    jni.JObject activityLifecycleCallbacks,
  ) {
    _registerActivityLifecycleCallbacks(
            reference.pointer,
            _id_registerActivityLifecycleCallbacks as jni.JMethodIDPtr,
            activityLifecycleCallbacks.reference.pointer)
        .check();
  }

  static final _id_unregisterActivityLifecycleCallbacks =
      _class.instanceMethodId(
    r'unregisterActivityLifecycleCallbacks',
    r'(Landroid/app/Application$ActivityLifecycleCallbacks;)V',
  );

  static final _unregisterActivityLifecycleCallbacks =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterActivityLifecycleCallbacks(android.app.Application$ActivityLifecycleCallbacks activityLifecycleCallbacks)
  void unregisterActivityLifecycleCallbacks(
    jni.JObject activityLifecycleCallbacks,
  ) {
    _unregisterActivityLifecycleCallbacks(
            reference.pointer,
            _id_unregisterActivityLifecycleCallbacks as jni.JMethodIDPtr,
            activityLifecycleCallbacks.reference.pointer)
        .check();
  }

  static final _id_registerComponentCallbacks = _class.instanceMethodId(
    r'registerComponentCallbacks',
    r'(Landroid/content/ComponentCallbacks;)V',
  );

  static final _registerComponentCallbacks = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void registerComponentCallbacks(android.content.ComponentCallbacks componentCallbacks)
  void registerComponentCallbacks(
    jni.JObject componentCallbacks,
  ) {
    _registerComponentCallbacks(
            reference.pointer,
            _id_registerComponentCallbacks as jni.JMethodIDPtr,
            componentCallbacks.reference.pointer)
        .check();
  }

  static final _id_unregisterComponentCallbacks = _class.instanceMethodId(
    r'unregisterComponentCallbacks',
    r'(Landroid/content/ComponentCallbacks;)V',
  );

  static final _unregisterComponentCallbacks = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterComponentCallbacks(android.content.ComponentCallbacks componentCallbacks)
  void unregisterComponentCallbacks(
    jni.JObject componentCallbacks,
  ) {
    _unregisterComponentCallbacks(
            reference.pointer,
            _id_unregisterComponentCallbacks as jni.JMethodIDPtr,
            componentCallbacks.reference.pointer)
        .check();
  }

  static final _id_onCreate = _class.instanceMethodId(
    r'onCreate',
    r'(Landroid/os/Bundle;)V',
  );

  static final _onCreate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle bundle)
  void onCreate(
    jni.JObject bundle,
  ) {
    _onCreate(reference.pointer, _id_onCreate as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .check();
  }

  static final _id_getSplashScreen = _class.instanceMethodId(
    r'getSplashScreen',
    r'()Landroid/window/SplashScreen;',
  );

  static final _getSplashScreen = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.window.SplashScreen getSplashScreen()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSplashScreen() {
    return _getSplashScreen(
            reference.pointer, _id_getSplashScreen as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_onCreate1 = _class.instanceMethodId(
    r'onCreate',
    r'(Landroid/os/Bundle;Landroid/os/PersistableBundle;)V',
  );

  static final _onCreate1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle bundle, android.os.PersistableBundle persistableBundle)
  void onCreate1(
    jni.JObject bundle,
    jni.JObject persistableBundle,
  ) {
    _onCreate1(reference.pointer, _id_onCreate1 as jni.JMethodIDPtr,
            bundle.reference.pointer, persistableBundle.reference.pointer)
        .check();
  }

  static final _id_onRestoreInstanceState = _class.instanceMethodId(
    r'onRestoreInstanceState',
    r'(Landroid/os/Bundle;)V',
  );

  static final _onRestoreInstanceState = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle bundle)
  void onRestoreInstanceState(
    jni.JObject bundle,
  ) {
    _onRestoreInstanceState(
            reference.pointer,
            _id_onRestoreInstanceState as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .check();
  }

  static final _id_onRestoreInstanceState1 = _class.instanceMethodId(
    r'onRestoreInstanceState',
    r'(Landroid/os/Bundle;Landroid/os/PersistableBundle;)V',
  );

  static final _onRestoreInstanceState1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle bundle, android.os.PersistableBundle persistableBundle)
  void onRestoreInstanceState1(
    jni.JObject bundle,
    jni.JObject persistableBundle,
  ) {
    _onRestoreInstanceState1(
            reference.pointer,
            _id_onRestoreInstanceState1 as jni.JMethodIDPtr,
            bundle.reference.pointer,
            persistableBundle.reference.pointer)
        .check();
  }

  static final _id_onPostCreate = _class.instanceMethodId(
    r'onPostCreate',
    r'(Landroid/os/Bundle;)V',
  );

  static final _onPostCreate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPostCreate(android.os.Bundle bundle)
  void onPostCreate(
    jni.JObject bundle,
  ) {
    _onPostCreate(reference.pointer, _id_onPostCreate as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .check();
  }

  static final _id_onPostCreate1 = _class.instanceMethodId(
    r'onPostCreate',
    r'(Landroid/os/Bundle;Landroid/os/PersistableBundle;)V',
  );

  static final _onPostCreate1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPostCreate(android.os.Bundle bundle, android.os.PersistableBundle persistableBundle)
  void onPostCreate1(
    jni.JObject bundle,
    jni.JObject persistableBundle,
  ) {
    _onPostCreate1(reference.pointer, _id_onPostCreate1 as jni.JMethodIDPtr,
            bundle.reference.pointer, persistableBundle.reference.pointer)
        .check();
  }

  static final _id_onStart = _class.instanceMethodId(
    r'onStart',
    r'()V',
  );

  static final _onStart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onStart()
  void onStart() {
    _onStart(reference.pointer, _id_onStart as jni.JMethodIDPtr).check();
  }

  static final _id_onRestart = _class.instanceMethodId(
    r'onRestart',
    r'()V',
  );

  static final _onRestart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onRestart()
  void onRestart() {
    _onRestart(reference.pointer, _id_onRestart as jni.JMethodIDPtr).check();
  }

  static final _id_onStateNotSaved = _class.instanceMethodId(
    r'onStateNotSaved',
    r'()V',
  );

  static final _onStateNotSaved = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onStateNotSaved()
  void onStateNotSaved() {
    _onStateNotSaved(reference.pointer, _id_onStateNotSaved as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onResume = _class.instanceMethodId(
    r'onResume',
    r'()V',
  );

  static final _onResume = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onResume()
  void onResume() {
    _onResume(reference.pointer, _id_onResume as jni.JMethodIDPtr).check();
  }

  static final _id_onPostResume = _class.instanceMethodId(
    r'onPostResume',
    r'()V',
  );

  static final _onPostResume = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onPostResume()
  void onPostResume() {
    _onPostResume(reference.pointer, _id_onPostResume as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onTopResumedActivityChanged = _class.instanceMethodId(
    r'onTopResumedActivityChanged',
    r'(Z)V',
  );

  static final _onTopResumedActivityChanged = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onTopResumedActivityChanged(boolean z)
  void onTopResumedActivityChanged(
    bool z,
  ) {
    _onTopResumedActivityChanged(reference.pointer,
            _id_onTopResumedActivityChanged as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isVoiceInteraction = _class.instanceMethodId(
    r'isVoiceInteraction',
    r'()Z',
  );

  static final _isVoiceInteraction = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isVoiceInteraction()
  bool isVoiceInteraction() {
    return _isVoiceInteraction(
            reference.pointer, _id_isVoiceInteraction as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isVoiceInteractionRoot = _class.instanceMethodId(
    r'isVoiceInteractionRoot',
    r'()Z',
  );

  static final _isVoiceInteractionRoot = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isVoiceInteractionRoot()
  bool isVoiceInteractionRoot() {
    return _isVoiceInteractionRoot(
            reference.pointer, _id_isVoiceInteractionRoot as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getVoiceInteractor = _class.instanceMethodId(
    r'getVoiceInteractor',
    r'()Landroid/app/VoiceInteractor;',
  );

  static final _getVoiceInteractor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.app.VoiceInteractor getVoiceInteractor()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVoiceInteractor() {
    return _getVoiceInteractor(
            reference.pointer, _id_getVoiceInteractor as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_isLocalVoiceInteractionSupported = _class.instanceMethodId(
    r'isLocalVoiceInteractionSupported',
    r'()Z',
  );

  static final _isLocalVoiceInteractionSupported =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public boolean isLocalVoiceInteractionSupported()
  bool isLocalVoiceInteractionSupported() {
    return _isLocalVoiceInteractionSupported(reference.pointer,
            _id_isLocalVoiceInteractionSupported as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_startLocalVoiceInteraction = _class.instanceMethodId(
    r'startLocalVoiceInteraction',
    r'(Landroid/os/Bundle;)V',
  );

  static final _startLocalVoiceInteraction = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startLocalVoiceInteraction(android.os.Bundle bundle)
  void startLocalVoiceInteraction(
    jni.JObject bundle,
  ) {
    _startLocalVoiceInteraction(
            reference.pointer,
            _id_startLocalVoiceInteraction as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .check();
  }

  static final _id_onLocalVoiceInteractionStarted = _class.instanceMethodId(
    r'onLocalVoiceInteractionStarted',
    r'()V',
  );

  static final _onLocalVoiceInteractionStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onLocalVoiceInteractionStarted()
  void onLocalVoiceInteractionStarted() {
    _onLocalVoiceInteractionStarted(reference.pointer,
            _id_onLocalVoiceInteractionStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onLocalVoiceInteractionStopped = _class.instanceMethodId(
    r'onLocalVoiceInteractionStopped',
    r'()V',
  );

  static final _onLocalVoiceInteractionStopped = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onLocalVoiceInteractionStopped()
  void onLocalVoiceInteractionStopped() {
    _onLocalVoiceInteractionStopped(reference.pointer,
            _id_onLocalVoiceInteractionStopped as jni.JMethodIDPtr)
        .check();
  }

  static final _id_stopLocalVoiceInteraction = _class.instanceMethodId(
    r'stopLocalVoiceInteraction',
    r'()V',
  );

  static final _stopLocalVoiceInteraction = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void stopLocalVoiceInteraction()
  void stopLocalVoiceInteraction() {
    _stopLocalVoiceInteraction(reference.pointer,
            _id_stopLocalVoiceInteraction as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onNewIntent = _class.instanceMethodId(
    r'onNewIntent',
    r'(Landroid/content/Intent;)V',
  );

  static final _onNewIntent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onNewIntent(android.content.Intent intent)
  void onNewIntent(
    jni.JObject intent,
  ) {
    _onNewIntent(reference.pointer, _id_onNewIntent as jni.JMethodIDPtr,
            intent.reference.pointer)
        .check();
  }

  static final _id_onSaveInstanceState = _class.instanceMethodId(
    r'onSaveInstanceState',
    r'(Landroid/os/Bundle;)V',
  );

  static final _onSaveInstanceState = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle bundle)
  void onSaveInstanceState(
    jni.JObject bundle,
  ) {
    _onSaveInstanceState(
            reference.pointer,
            _id_onSaveInstanceState as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .check();
  }

  static final _id_onSaveInstanceState1 = _class.instanceMethodId(
    r'onSaveInstanceState',
    r'(Landroid/os/Bundle;Landroid/os/PersistableBundle;)V',
  );

  static final _onSaveInstanceState1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSaveInstanceState(android.os.Bundle bundle, android.os.PersistableBundle persistableBundle)
  void onSaveInstanceState1(
    jni.JObject bundle,
    jni.JObject persistableBundle,
  ) {
    _onSaveInstanceState1(
            reference.pointer,
            _id_onSaveInstanceState1 as jni.JMethodIDPtr,
            bundle.reference.pointer,
            persistableBundle.reference.pointer)
        .check();
  }

  static final _id_onPause = _class.instanceMethodId(
    r'onPause',
    r'()V',
  );

  static final _onPause = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onPause()
  void onPause() {
    _onPause(reference.pointer, _id_onPause as jni.JMethodIDPtr).check();
  }

  static final _id_onUserLeaveHint = _class.instanceMethodId(
    r'onUserLeaveHint',
    r'()V',
  );

  static final _onUserLeaveHint = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onUserLeaveHint()
  void onUserLeaveHint() {
    _onUserLeaveHint(reference.pointer, _id_onUserLeaveHint as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCreateThumbnail = _class.instanceMethodId(
    r'onCreateThumbnail',
    r'(Landroid/graphics/Bitmap;Landroid/graphics/Canvas;)Z',
  );

  static final _onCreateThumbnail = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreateThumbnail(android.graphics.Bitmap bitmap, android.graphics.Canvas canvas)
  bool onCreateThumbnail(
    jni.JObject bitmap,
    jni.JObject canvas,
  ) {
    return _onCreateThumbnail(
            reference.pointer,
            _id_onCreateThumbnail as jni.JMethodIDPtr,
            bitmap.reference.pointer,
            canvas.reference.pointer)
        .boolean;
  }

  static final _id_onCreateDescription = _class.instanceMethodId(
    r'onCreateDescription',
    r'()Ljava/lang/CharSequence;',
  );

  static final _onCreateDescription = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.CharSequence onCreateDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateDescription() {
    return _onCreateDescription(
            reference.pointer, _id_onCreateDescription as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_onProvideAssistData = _class.instanceMethodId(
    r'onProvideAssistData',
    r'(Landroid/os/Bundle;)V',
  );

  static final _onProvideAssistData = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onProvideAssistData(android.os.Bundle bundle)
  void onProvideAssistData(
    jni.JObject bundle,
  ) {
    _onProvideAssistData(
            reference.pointer,
            _id_onProvideAssistData as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .check();
  }

  static final _id_onProvideAssistContent = _class.instanceMethodId(
    r'onProvideAssistContent',
    r'(Landroid/app/assist/AssistContent;)V',
  );

  static final _onProvideAssistContent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onProvideAssistContent(android.app.assist.AssistContent assistContent)
  void onProvideAssistContent(
    jni.JObject assistContent,
  ) {
    _onProvideAssistContent(
            reference.pointer,
            _id_onProvideAssistContent as jni.JMethodIDPtr,
            assistContent.reference.pointer)
        .check();
  }

  static final _id_onGetDirectActions = _class.instanceMethodId(
    r'onGetDirectActions',
    r'(Landroid/os/CancellationSignal;Ljava/util/function/Consumer;)V',
  );

  static final _onGetDirectActions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onGetDirectActions(android.os.CancellationSignal cancellationSignal, java.util.function.Consumer consumer)
  void onGetDirectActions(
    jni.JObject cancellationSignal,
    jni.JObject consumer,
  ) {
    _onGetDirectActions(
            reference.pointer,
            _id_onGetDirectActions as jni.JMethodIDPtr,
            cancellationSignal.reference.pointer,
            consumer.reference.pointer)
        .check();
  }

  static final _id_onPerformDirectAction = _class.instanceMethodId(
    r'onPerformDirectAction',
    r'(Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;Ljava/util/function/Consumer;)V',
  );

  static final _onPerformDirectAction = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPerformDirectAction(java.lang.String string, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal, java.util.function.Consumer consumer)
  void onPerformDirectAction(
    jni.JString string,
    jni.JObject bundle,
    jni.JObject cancellationSignal,
    jni.JObject consumer,
  ) {
    _onPerformDirectAction(
            reference.pointer,
            _id_onPerformDirectAction as jni.JMethodIDPtr,
            string.reference.pointer,
            bundle.reference.pointer,
            cancellationSignal.reference.pointer,
            consumer.reference.pointer)
        .check();
  }

  static final _id_requestShowKeyboardShortcuts = _class.instanceMethodId(
    r'requestShowKeyboardShortcuts',
    r'()V',
  );

  static final _requestShowKeyboardShortcuts = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void requestShowKeyboardShortcuts()
  void requestShowKeyboardShortcuts() {
    _requestShowKeyboardShortcuts(reference.pointer,
            _id_requestShowKeyboardShortcuts as jni.JMethodIDPtr)
        .check();
  }

  static final _id_dismissKeyboardShortcutsHelper = _class.instanceMethodId(
    r'dismissKeyboardShortcutsHelper',
    r'()V',
  );

  static final _dismissKeyboardShortcutsHelper = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void dismissKeyboardShortcutsHelper()
  void dismissKeyboardShortcutsHelper() {
    _dismissKeyboardShortcutsHelper(reference.pointer,
            _id_dismissKeyboardShortcutsHelper as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onProvideKeyboardShortcuts = _class.instanceMethodId(
    r'onProvideKeyboardShortcuts',
    r'(Ljava/util/List;Landroid/view/Menu;I)V',
  );

  static final _onProvideKeyboardShortcuts = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onProvideKeyboardShortcuts(java.util.List list, android.view.Menu menu, int i)
  void onProvideKeyboardShortcuts(
    jni.JList<jni.JObject> list,
    jni.JObject menu,
    int i,
  ) {
    _onProvideKeyboardShortcuts(
            reference.pointer,
            _id_onProvideKeyboardShortcuts as jni.JMethodIDPtr,
            list.reference.pointer,
            menu.reference.pointer,
            i)
        .check();
  }

  static final _id_showAssist = _class.instanceMethodId(
    r'showAssist',
    r'(Landroid/os/Bundle;)Z',
  );

  static final _showAssist = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean showAssist(android.os.Bundle bundle)
  bool showAssist(
    jni.JObject bundle,
  ) {
    return _showAssist(reference.pointer, _id_showAssist as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .boolean;
  }

  static final _id_onStop = _class.instanceMethodId(
    r'onStop',
    r'()V',
  );

  static final _onStop = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onStop()
  void onStop() {
    _onStop(reference.pointer, _id_onStop as jni.JMethodIDPtr).check();
  }

  static final _id_onDestroy = _class.instanceMethodId(
    r'onDestroy',
    r'()V',
  );

  static final _onDestroy = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onDestroy()
  void onDestroy() {
    _onDestroy(reference.pointer, _id_onDestroy as jni.JMethodIDPtr).check();
  }

  static final _id_reportFullyDrawn = _class.instanceMethodId(
    r'reportFullyDrawn',
    r'()V',
  );

  static final _reportFullyDrawn = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void reportFullyDrawn()
  void reportFullyDrawn() {
    _reportFullyDrawn(
            reference.pointer, _id_reportFullyDrawn as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onMultiWindowModeChanged = _class.instanceMethodId(
    r'onMultiWindowModeChanged',
    r'(ZLandroid/content/res/Configuration;)V',
  );

  static final _onMultiWindowModeChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onMultiWindowModeChanged(boolean z, android.content.res.Configuration configuration)
  void onMultiWindowModeChanged(
    bool z,
    jni.JObject configuration,
  ) {
    _onMultiWindowModeChanged(
            reference.pointer,
            _id_onMultiWindowModeChanged as jni.JMethodIDPtr,
            z ? 1 : 0,
            configuration.reference.pointer)
        .check();
  }

  static final _id_onMultiWindowModeChanged1 = _class.instanceMethodId(
    r'onMultiWindowModeChanged',
    r'(Z)V',
  );

  static final _onMultiWindowModeChanged1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onMultiWindowModeChanged(boolean z)
  void onMultiWindowModeChanged1(
    bool z,
  ) {
    _onMultiWindowModeChanged1(reference.pointer,
            _id_onMultiWindowModeChanged1 as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isInMultiWindowMode = _class.instanceMethodId(
    r'isInMultiWindowMode',
    r'()Z',
  );

  static final _isInMultiWindowMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isInMultiWindowMode()
  bool isInMultiWindowMode() {
    return _isInMultiWindowMode(
            reference.pointer, _id_isInMultiWindowMode as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_onPictureInPictureModeChanged = _class.instanceMethodId(
    r'onPictureInPictureModeChanged',
    r'(ZLandroid/content/res/Configuration;)V',
  );

  static final _onPictureInPictureModeChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPictureInPictureModeChanged(boolean z, android.content.res.Configuration configuration)
  void onPictureInPictureModeChanged(
    bool z,
    jni.JObject configuration,
  ) {
    _onPictureInPictureModeChanged(
            reference.pointer,
            _id_onPictureInPictureModeChanged as jni.JMethodIDPtr,
            z ? 1 : 0,
            configuration.reference.pointer)
        .check();
  }

  static final _id_onPictureInPictureUiStateChanged = _class.instanceMethodId(
    r'onPictureInPictureUiStateChanged',
    r'(Landroid/app/PictureInPictureUiState;)V',
  );

  static final _onPictureInPictureUiStateChanged =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPictureInPictureUiStateChanged(android.app.PictureInPictureUiState pictureInPictureUiState)
  void onPictureInPictureUiStateChanged(
    jni.JObject pictureInPictureUiState,
  ) {
    _onPictureInPictureUiStateChanged(
            reference.pointer,
            _id_onPictureInPictureUiStateChanged as jni.JMethodIDPtr,
            pictureInPictureUiState.reference.pointer)
        .check();
  }

  static final _id_onPictureInPictureModeChanged1 = _class.instanceMethodId(
    r'onPictureInPictureModeChanged',
    r'(Z)V',
  );

  static final _onPictureInPictureModeChanged1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onPictureInPictureModeChanged(boolean z)
  void onPictureInPictureModeChanged1(
    bool z,
  ) {
    _onPictureInPictureModeChanged1(reference.pointer,
            _id_onPictureInPictureModeChanged1 as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isInPictureInPictureMode = _class.instanceMethodId(
    r'isInPictureInPictureMode',
    r'()Z',
  );

  static final _isInPictureInPictureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isInPictureInPictureMode()
  bool isInPictureInPictureMode() {
    return _isInPictureInPictureMode(
            reference.pointer, _id_isInPictureInPictureMode as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_enterPictureInPictureMode = _class.instanceMethodId(
    r'enterPictureInPictureMode',
    r'()V',
  );

  static final _enterPictureInPictureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void enterPictureInPictureMode()
  void enterPictureInPictureMode() {
    _enterPictureInPictureMode(reference.pointer,
            _id_enterPictureInPictureMode as jni.JMethodIDPtr)
        .check();
  }

  static final _id_enterPictureInPictureMode1 = _class.instanceMethodId(
    r'enterPictureInPictureMode',
    r'(Landroid/app/PictureInPictureParams;)Z',
  );

  static final _enterPictureInPictureMode1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean enterPictureInPictureMode(android.app.PictureInPictureParams pictureInPictureParams)
  bool enterPictureInPictureMode1(
    jni.JObject pictureInPictureParams,
  ) {
    return _enterPictureInPictureMode1(
            reference.pointer,
            _id_enterPictureInPictureMode1 as jni.JMethodIDPtr,
            pictureInPictureParams.reference.pointer)
        .boolean;
  }

  static final _id_setPictureInPictureParams = _class.instanceMethodId(
    r'setPictureInPictureParams',
    r'(Landroid/app/PictureInPictureParams;)V',
  );

  static final _setPictureInPictureParams = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setPictureInPictureParams(android.app.PictureInPictureParams pictureInPictureParams)
  void setPictureInPictureParams(
    jni.JObject pictureInPictureParams,
  ) {
    _setPictureInPictureParams(
            reference.pointer,
            _id_setPictureInPictureParams as jni.JMethodIDPtr,
            pictureInPictureParams.reference.pointer)
        .check();
  }

  static final _id_getMaxNumPictureInPictureActions = _class.instanceMethodId(
    r'getMaxNumPictureInPictureActions',
    r'()I',
  );

  static final _getMaxNumPictureInPictureActions =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public int getMaxNumPictureInPictureActions()
  int getMaxNumPictureInPictureActions() {
    return _getMaxNumPictureInPictureActions(reference.pointer,
            _id_getMaxNumPictureInPictureActions as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_onPictureInPictureRequested = _class.instanceMethodId(
    r'onPictureInPictureRequested',
    r'()Z',
  );

  static final _onPictureInPictureRequested = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean onPictureInPictureRequested()
  bool onPictureInPictureRequested() {
    return _onPictureInPictureRequested(reference.pointer,
            _id_onPictureInPictureRequested as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_requestFullscreenMode = _class.instanceMethodId(
    r'requestFullscreenMode',
    r'(ILandroid/os/OutcomeReceiver;)V',
  );

  static final _requestFullscreenMode = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void requestFullscreenMode(int i, android.os.OutcomeReceiver outcomeReceiver)
  void requestFullscreenMode(
    int i,
    jni.JObject outcomeReceiver,
  ) {
    _requestFullscreenMode(
            reference.pointer,
            _id_requestFullscreenMode as jni.JMethodIDPtr,
            i,
            outcomeReceiver.reference.pointer)
        .check();
  }

  static final _id_setShouldDockBigOverlays = _class.instanceMethodId(
    r'setShouldDockBigOverlays',
    r'(Z)V',
  );

  static final _setShouldDockBigOverlays = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setShouldDockBigOverlays(boolean z)
  void setShouldDockBigOverlays(
    bool z,
  ) {
    _setShouldDockBigOverlays(reference.pointer,
            _id_setShouldDockBigOverlays as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_shouldDockBigOverlays = _class.instanceMethodId(
    r'shouldDockBigOverlays',
    r'()Z',
  );

  static final _shouldDockBigOverlays = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean shouldDockBigOverlays()
  bool shouldDockBigOverlays() {
    return _shouldDockBigOverlays(
            reference.pointer, _id_shouldDockBigOverlays as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_onConfigurationChanged = _class.instanceMethodId(
    r'onConfigurationChanged',
    r'(Landroid/content/res/Configuration;)V',
  );

  static final _onConfigurationChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration configuration)
  void onConfigurationChanged(
    jni.JObject configuration,
  ) {
    _onConfigurationChanged(
            reference.pointer,
            _id_onConfigurationChanged as jni.JMethodIDPtr,
            configuration.reference.pointer)
        .check();
  }

  static final _id_getChangingConfigurations = _class.instanceMethodId(
    r'getChangingConfigurations',
    r'()I',
  );

  static final _getChangingConfigurations = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getChangingConfigurations()
  int getChangingConfigurations() {
    return _getChangingConfigurations(reference.pointer,
            _id_getChangingConfigurations as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getLastNonConfigurationInstance = _class.instanceMethodId(
    r'getLastNonConfigurationInstance',
    r'()Ljava/lang/Object;',
  );

  static final _getLastNonConfigurationInstance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Object getLastNonConfigurationInstance()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLastNonConfigurationInstance() {
    return _getLastNonConfigurationInstance(reference.pointer,
            _id_getLastNonConfigurationInstance as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_onRetainNonConfigurationInstance = _class.instanceMethodId(
    r'onRetainNonConfigurationInstance',
    r'()Ljava/lang/Object;',
  );

  static final _onRetainNonConfigurationInstance =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public java.lang.Object onRetainNonConfigurationInstance()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onRetainNonConfigurationInstance() {
    return _onRetainNonConfigurationInstance(reference.pointer,
            _id_onRetainNonConfigurationInstance as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_onLowMemory = _class.instanceMethodId(
    r'onLowMemory',
    r'()V',
  );

  static final _onLowMemory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onLowMemory()
  void onLowMemory() {
    _onLowMemory(reference.pointer, _id_onLowMemory as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onTrimMemory = _class.instanceMethodId(
    r'onTrimMemory',
    r'(I)V',
  );

  static final _onTrimMemory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onTrimMemory(int i)
  void onTrimMemory(
    int i,
  ) {
    _onTrimMemory(reference.pointer, _id_onTrimMemory as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getFragmentManager = _class.instanceMethodId(
    r'getFragmentManager',
    r'()Landroid/app/FragmentManager;',
  );

  static final _getFragmentManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.app.FragmentManager getFragmentManager()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFragmentManager() {
    return _getFragmentManager(
            reference.pointer, _id_getFragmentManager as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_onAttachFragment = _class.instanceMethodId(
    r'onAttachFragment',
    r'(Landroid/app/Fragment;)V',
  );

  static final _onAttachFragment = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachFragment(android.app.Fragment fragment)
  void onAttachFragment(
    jni.JObject fragment,
  ) {
    _onAttachFragment(
            reference.pointer,
            _id_onAttachFragment as jni.JMethodIDPtr,
            fragment.reference.pointer)
        .check();
  }

  static final _id_managedQuery = _class.instanceMethodId(
    r'managedQuery',
    r'(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _managedQuery = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor managedQuery(android.net.Uri uri, java.lang.String[] strings, java.lang.String string, java.lang.String[] strings1, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Cursor managedQuery(
    Uri uri,
    jni.JArray<jni.JString> strings,
    jni.JString string,
    jni.JArray<jni.JString> strings1,
    jni.JString string1,
  ) {
    return _managedQuery(
            reference.pointer,
            _id_managedQuery as jni.JMethodIDPtr,
            uri.reference.pointer,
            strings.reference.pointer,
            string.reference.pointer,
            strings1.reference.pointer,
            string1.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_startManagingCursor = _class.instanceMethodId(
    r'startManagingCursor',
    r'(Landroid/database/Cursor;)V',
  );

  static final _startManagingCursor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startManagingCursor(android.database.Cursor cursor)
  void startManagingCursor(
    Cursor cursor,
  ) {
    _startManagingCursor(
            reference.pointer,
            _id_startManagingCursor as jni.JMethodIDPtr,
            cursor.reference.pointer)
        .check();
  }

  static final _id_stopManagingCursor = _class.instanceMethodId(
    r'stopManagingCursor',
    r'(Landroid/database/Cursor;)V',
  );

  static final _stopManagingCursor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void stopManagingCursor(android.database.Cursor cursor)
  void stopManagingCursor(
    Cursor cursor,
  ) {
    _stopManagingCursor(
            reference.pointer,
            _id_stopManagingCursor as jni.JMethodIDPtr,
            cursor.reference.pointer)
        .check();
  }

  static final _id_findViewById = _class.instanceMethodId(
    r'findViewById',
    r'(I)Landroid/view/View;',
  );

  static final _findViewById = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public T findViewById(int i)
  /// The returned object must be released after use, by calling the [release] method.
  $T findViewById<$T extends jni.JObject>(
    int i, {
    required jni.JObjType<$T> T,
  }) {
    return _findViewById(
            reference.pointer, _id_findViewById as jni.JMethodIDPtr, i)
        .object(T);
  }

  static final _id_requireViewById = _class.instanceMethodId(
    r'requireViewById',
    r'(I)Landroid/view/View;',
  );

  static final _requireViewById = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final T requireViewById(int i)
  /// The returned object must be released after use, by calling the [release] method.
  $T requireViewById<$T extends jni.JObject>(
    int i, {
    required jni.JObjType<$T> T,
  }) {
    return _requireViewById(
            reference.pointer, _id_requireViewById as jni.JMethodIDPtr, i)
        .object(T);
  }

  static final _id_getActionBar = _class.instanceMethodId(
    r'getActionBar',
    r'()Landroid/app/ActionBar;',
  );

  static final _getActionBar = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.app.ActionBar getActionBar()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getActionBar() {
    return _getActionBar(
            reference.pointer, _id_getActionBar as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setActionBar = _class.instanceMethodId(
    r'setActionBar',
    r'(Landroid/widget/Toolbar;)V',
  );

  static final _setActionBar = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setActionBar(android.widget.Toolbar toolbar)
  void setActionBar(
    jni.JObject toolbar,
  ) {
    _setActionBar(reference.pointer, _id_setActionBar as jni.JMethodIDPtr,
            toolbar.reference.pointer)
        .check();
  }

  static final _id_setContentView = _class.instanceMethodId(
    r'setContentView',
    r'(I)V',
  );

  static final _setContentView = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setContentView(int i)
  void setContentView(
    int i,
  ) {
    _setContentView(
            reference.pointer, _id_setContentView as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setContentView1 = _class.instanceMethodId(
    r'setContentView',
    r'(Landroid/view/View;)V',
  );

  static final _setContentView1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view)
  void setContentView1(
    jni.JObject view,
  ) {
    _setContentView1(reference.pointer, _id_setContentView1 as jni.JMethodIDPtr,
            view.reference.pointer)
        .check();
  }

  static final _id_setContentView2 = _class.instanceMethodId(
    r'setContentView',
    r'(Landroid/view/View;Landroid/view/ViewGroup$LayoutParams;)V',
  );

  static final _setContentView2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view, android.view.ViewGroup$LayoutParams layoutParams)
  void setContentView2(
    jni.JObject view,
    jni.JObject layoutParams,
  ) {
    _setContentView2(reference.pointer, _id_setContentView2 as jni.JMethodIDPtr,
            view.reference.pointer, layoutParams.reference.pointer)
        .check();
  }

  static final _id_addContentView = _class.instanceMethodId(
    r'addContentView',
    r'(Landroid/view/View;Landroid/view/ViewGroup$LayoutParams;)V',
  );

  static final _addContentView = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addContentView(android.view.View view, android.view.ViewGroup$LayoutParams layoutParams)
  void addContentView(
    jni.JObject view,
    jni.JObject layoutParams,
  ) {
    _addContentView(reference.pointer, _id_addContentView as jni.JMethodIDPtr,
            view.reference.pointer, layoutParams.reference.pointer)
        .check();
  }

  static final _id_getContentTransitionManager = _class.instanceMethodId(
    r'getContentTransitionManager',
    r'()Landroid/transition/TransitionManager;',
  );

  static final _getContentTransitionManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.transition.TransitionManager getContentTransitionManager()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentTransitionManager() {
    return _getContentTransitionManager(reference.pointer,
            _id_getContentTransitionManager as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setContentTransitionManager = _class.instanceMethodId(
    r'setContentTransitionManager',
    r'(Landroid/transition/TransitionManager;)V',
  );

  static final _setContentTransitionManager = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentTransitionManager(android.transition.TransitionManager transitionManager)
  void setContentTransitionManager(
    jni.JObject transitionManager,
  ) {
    _setContentTransitionManager(
            reference.pointer,
            _id_setContentTransitionManager as jni.JMethodIDPtr,
            transitionManager.reference.pointer)
        .check();
  }

  static final _id_getContentScene = _class.instanceMethodId(
    r'getContentScene',
    r'()Landroid/transition/Scene;',
  );

  static final _getContentScene = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.transition.Scene getContentScene()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentScene() {
    return _getContentScene(
            reference.pointer, _id_getContentScene as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setFinishOnTouchOutside = _class.instanceMethodId(
    r'setFinishOnTouchOutside',
    r'(Z)V',
  );

  static final _setFinishOnTouchOutside = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setFinishOnTouchOutside(boolean z)
  void setFinishOnTouchOutside(
    bool z,
  ) {
    _setFinishOnTouchOutside(reference.pointer,
            _id_setFinishOnTouchOutside as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setDefaultKeyMode = _class.instanceMethodId(
    r'setDefaultKeyMode',
    r'(I)V',
  );

  static final _setDefaultKeyMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setDefaultKeyMode(int i)
  void setDefaultKeyMode(
    int i,
  ) {
    _setDefaultKeyMode(
            reference.pointer, _id_setDefaultKeyMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onKeyDown = _class.instanceMethodId(
    r'onKeyDown',
    r'(ILandroid/view/KeyEvent;)Z',
  );

  static final _onKeyDown = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyDown(int i, android.view.KeyEvent keyEvent)
  bool onKeyDown(
    int i,
    jni.JObject keyEvent,
  ) {
    return _onKeyDown(reference.pointer, _id_onKeyDown as jni.JMethodIDPtr, i,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_onKeyLongPress = _class.instanceMethodId(
    r'onKeyLongPress',
    r'(ILandroid/view/KeyEvent;)Z',
  );

  static final _onKeyLongPress = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyLongPress(int i, android.view.KeyEvent keyEvent)
  bool onKeyLongPress(
    int i,
    jni.JObject keyEvent,
  ) {
    return _onKeyLongPress(
            reference.pointer,
            _id_onKeyLongPress as jni.JMethodIDPtr,
            i,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_onKeyUp = _class.instanceMethodId(
    r'onKeyUp',
    r'(ILandroid/view/KeyEvent;)Z',
  );

  static final _onKeyUp = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyUp(int i, android.view.KeyEvent keyEvent)
  bool onKeyUp(
    int i,
    jni.JObject keyEvent,
  ) {
    return _onKeyUp(reference.pointer, _id_onKeyUp as jni.JMethodIDPtr, i,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_onKeyMultiple = _class.instanceMethodId(
    r'onKeyMultiple',
    r'(IILandroid/view/KeyEvent;)Z',
  );

  static final _onKeyMultiple = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyMultiple(int i, int i1, android.view.KeyEvent keyEvent)
  bool onKeyMultiple(
    int i,
    int i1,
    jni.JObject keyEvent,
  ) {
    return _onKeyMultiple(
            reference.pointer,
            _id_onKeyMultiple as jni.JMethodIDPtr,
            i,
            i1,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_onBackPressed = _class.instanceMethodId(
    r'onBackPressed',
    r'()V',
  );

  static final _onBackPressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onBackPressed()
  void onBackPressed() {
    _onBackPressed(reference.pointer, _id_onBackPressed as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onKeyShortcut = _class.instanceMethodId(
    r'onKeyShortcut',
    r'(ILandroid/view/KeyEvent;)Z',
  );

  static final _onKeyShortcut = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyShortcut(int i, android.view.KeyEvent keyEvent)
  bool onKeyShortcut(
    int i,
    jni.JObject keyEvent,
  ) {
    return _onKeyShortcut(
            reference.pointer,
            _id_onKeyShortcut as jni.JMethodIDPtr,
            i,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r'onTouchEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _onTouchEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTouchEvent(android.view.MotionEvent motionEvent)
  bool onTouchEvent(
    jni.JObject motionEvent,
  ) {
    return _onTouchEvent(reference.pointer,
            _id_onTouchEvent as jni.JMethodIDPtr, motionEvent.reference.pointer)
        .boolean;
  }

  static final _id_onTrackballEvent = _class.instanceMethodId(
    r'onTrackballEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _onTrackballEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTrackballEvent(android.view.MotionEvent motionEvent)
  bool onTrackballEvent(
    jni.JObject motionEvent,
  ) {
    return _onTrackballEvent(
            reference.pointer,
            _id_onTrackballEvent as jni.JMethodIDPtr,
            motionEvent.reference.pointer)
        .boolean;
  }

  static final _id_onGenericMotionEvent = _class.instanceMethodId(
    r'onGenericMotionEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _onGenericMotionEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent motionEvent)
  bool onGenericMotionEvent(
    jni.JObject motionEvent,
  ) {
    return _onGenericMotionEvent(
            reference.pointer,
            _id_onGenericMotionEvent as jni.JMethodIDPtr,
            motionEvent.reference.pointer)
        .boolean;
  }

  static final _id_onUserInteraction = _class.instanceMethodId(
    r'onUserInteraction',
    r'()V',
  );

  static final _onUserInteraction = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onUserInteraction()
  void onUserInteraction() {
    _onUserInteraction(
            reference.pointer, _id_onUserInteraction as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onWindowAttributesChanged = _class.instanceMethodId(
    r'onWindowAttributesChanged',
    r'(Landroid/view/WindowManager$LayoutParams;)V',
  );

  static final _onWindowAttributesChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onWindowAttributesChanged(android.view.WindowManager$LayoutParams layoutParams)
  void onWindowAttributesChanged(
    jni.JObject layoutParams,
  ) {
    _onWindowAttributesChanged(
            reference.pointer,
            _id_onWindowAttributesChanged as jni.JMethodIDPtr,
            layoutParams.reference.pointer)
        .check();
  }

  static final _id_onContentChanged = _class.instanceMethodId(
    r'onContentChanged',
    r'()V',
  );

  static final _onContentChanged = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onContentChanged()
  void onContentChanged() {
    _onContentChanged(
            reference.pointer, _id_onContentChanged as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onWindowFocusChanged = _class.instanceMethodId(
    r'onWindowFocusChanged',
    r'(Z)V',
  );

  static final _onWindowFocusChanged = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onWindowFocusChanged(boolean z)
  void onWindowFocusChanged(
    bool z,
  ) {
    _onWindowFocusChanged(reference.pointer,
            _id_onWindowFocusChanged as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_onAttachedToWindow = _class.instanceMethodId(
    r'onAttachedToWindow',
    r'()V',
  );

  static final _onAttachedToWindow = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onAttachedToWindow()
  void onAttachedToWindow() {
    _onAttachedToWindow(
            reference.pointer, _id_onAttachedToWindow as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onDetachedFromWindow = _class.instanceMethodId(
    r'onDetachedFromWindow',
    r'()V',
  );

  static final _onDetachedFromWindow = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onDetachedFromWindow()
  void onDetachedFromWindow() {
    _onDetachedFromWindow(
            reference.pointer, _id_onDetachedFromWindow as jni.JMethodIDPtr)
        .check();
  }

  static final _id_hasWindowFocus = _class.instanceMethodId(
    r'hasWindowFocus',
    r'()Z',
  );

  static final _hasWindowFocus = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean hasWindowFocus()
  bool hasWindowFocus() {
    return _hasWindowFocus(
            reference.pointer, _id_hasWindowFocus as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_dispatchKeyEvent = _class.instanceMethodId(
    r'dispatchKeyEvent',
    r'(Landroid/view/KeyEvent;)Z',
  );

  static final _dispatchKeyEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent keyEvent)
  bool dispatchKeyEvent(
    jni.JObject keyEvent,
  ) {
    return _dispatchKeyEvent(
            reference.pointer,
            _id_dispatchKeyEvent as jni.JMethodIDPtr,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_dispatchKeyShortcutEvent = _class.instanceMethodId(
    r'dispatchKeyShortcutEvent',
    r'(Landroid/view/KeyEvent;)Z',
  );

  static final _dispatchKeyShortcutEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent keyEvent)
  bool dispatchKeyShortcutEvent(
    jni.JObject keyEvent,
  ) {
    return _dispatchKeyShortcutEvent(
            reference.pointer,
            _id_dispatchKeyShortcutEvent as jni.JMethodIDPtr,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_dispatchTouchEvent = _class.instanceMethodId(
    r'dispatchTouchEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _dispatchTouchEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent motionEvent)
  bool dispatchTouchEvent(
    jni.JObject motionEvent,
  ) {
    return _dispatchTouchEvent(
            reference.pointer,
            _id_dispatchTouchEvent as jni.JMethodIDPtr,
            motionEvent.reference.pointer)
        .boolean;
  }

  static final _id_dispatchTrackballEvent = _class.instanceMethodId(
    r'dispatchTrackballEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _dispatchTrackballEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent motionEvent)
  bool dispatchTrackballEvent(
    jni.JObject motionEvent,
  ) {
    return _dispatchTrackballEvent(
            reference.pointer,
            _id_dispatchTrackballEvent as jni.JMethodIDPtr,
            motionEvent.reference.pointer)
        .boolean;
  }

  static final _id_dispatchGenericMotionEvent = _class.instanceMethodId(
    r'dispatchGenericMotionEvent',
    r'(Landroid/view/MotionEvent;)Z',
  );

  static final _dispatchGenericMotionEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent motionEvent)
  bool dispatchGenericMotionEvent(
    jni.JObject motionEvent,
  ) {
    return _dispatchGenericMotionEvent(
            reference.pointer,
            _id_dispatchGenericMotionEvent as jni.JMethodIDPtr,
            motionEvent.reference.pointer)
        .boolean;
  }

  static final _id_dispatchPopulateAccessibilityEvent = _class.instanceMethodId(
    r'dispatchPopulateAccessibilityEvent',
    r'(Landroid/view/accessibility/AccessibilityEvent;)Z',
  );

  static final _dispatchPopulateAccessibilityEvent =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallBooleanMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent accessibilityEvent)
  bool dispatchPopulateAccessibilityEvent(
    jni.JObject accessibilityEvent,
  ) {
    return _dispatchPopulateAccessibilityEvent(
            reference.pointer,
            _id_dispatchPopulateAccessibilityEvent as jni.JMethodIDPtr,
            accessibilityEvent.reference.pointer)
        .boolean;
  }

  static final _id_onCreatePanelView = _class.instanceMethodId(
    r'onCreatePanelView',
    r'(I)Landroid/view/View;',
  );

  static final _onCreatePanelView = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public android.view.View onCreatePanelView(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreatePanelView(
    int i,
  ) {
    return _onCreatePanelView(
            reference.pointer, _id_onCreatePanelView as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_onCreatePanelMenu = _class.instanceMethodId(
    r'onCreatePanelMenu',
    r'(ILandroid/view/Menu;)Z',
  );

  static final _onCreatePanelMenu = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreatePanelMenu(int i, android.view.Menu menu)
  bool onCreatePanelMenu(
    int i,
    jni.JObject menu,
  ) {
    return _onCreatePanelMenu(
            reference.pointer,
            _id_onCreatePanelMenu as jni.JMethodIDPtr,
            i,
            menu.reference.pointer)
        .boolean;
  }

  static final _id_onPreparePanel = _class.instanceMethodId(
    r'onPreparePanel',
    r'(ILandroid/view/View;Landroid/view/Menu;)Z',
  );

  static final _onPreparePanel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPreparePanel(int i, android.view.View view, android.view.Menu menu)
  bool onPreparePanel(
    int i,
    jni.JObject view,
    jni.JObject menu,
  ) {
    return _onPreparePanel(
            reference.pointer,
            _id_onPreparePanel as jni.JMethodIDPtr,
            i,
            view.reference.pointer,
            menu.reference.pointer)
        .boolean;
  }

  static final _id_onMenuOpened = _class.instanceMethodId(
    r'onMenuOpened',
    r'(ILandroid/view/Menu;)Z',
  );

  static final _onMenuOpened = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuOpened(int i, android.view.Menu menu)
  bool onMenuOpened(
    int i,
    jni.JObject menu,
  ) {
    return _onMenuOpened(reference.pointer,
            _id_onMenuOpened as jni.JMethodIDPtr, i, menu.reference.pointer)
        .boolean;
  }

  static final _id_onMenuItemSelected = _class.instanceMethodId(
    r'onMenuItemSelected',
    r'(ILandroid/view/MenuItem;)Z',
  );

  static final _onMenuItemSelected = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuItemSelected(int i, android.view.MenuItem menuItem)
  bool onMenuItemSelected(
    int i,
    jni.JObject menuItem,
  ) {
    return _onMenuItemSelected(
            reference.pointer,
            _id_onMenuItemSelected as jni.JMethodIDPtr,
            i,
            menuItem.reference.pointer)
        .boolean;
  }

  static final _id_onPanelClosed = _class.instanceMethodId(
    r'onPanelClosed',
    r'(ILandroid/view/Menu;)V',
  );

  static final _onPanelClosed = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPanelClosed(int i, android.view.Menu menu)
  void onPanelClosed(
    int i,
    jni.JObject menu,
  ) {
    _onPanelClosed(reference.pointer, _id_onPanelClosed as jni.JMethodIDPtr, i,
            menu.reference.pointer)
        .check();
  }

  static final _id_invalidateOptionsMenu = _class.instanceMethodId(
    r'invalidateOptionsMenu',
    r'()V',
  );

  static final _invalidateOptionsMenu = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void invalidateOptionsMenu()
  void invalidateOptionsMenu() {
    _invalidateOptionsMenu(
            reference.pointer, _id_invalidateOptionsMenu as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCreateOptionsMenu = _class.instanceMethodId(
    r'onCreateOptionsMenu',
    r'(Landroid/view/Menu;)Z',
  );

  static final _onCreateOptionsMenu = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreateOptionsMenu(android.view.Menu menu)
  bool onCreateOptionsMenu(
    jni.JObject menu,
  ) {
    return _onCreateOptionsMenu(reference.pointer,
            _id_onCreateOptionsMenu as jni.JMethodIDPtr, menu.reference.pointer)
        .boolean;
  }

  static final _id_onPrepareOptionsMenu = _class.instanceMethodId(
    r'onPrepareOptionsMenu',
    r'(Landroid/view/Menu;)Z',
  );

  static final _onPrepareOptionsMenu = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPrepareOptionsMenu(android.view.Menu menu)
  bool onPrepareOptionsMenu(
    jni.JObject menu,
  ) {
    return _onPrepareOptionsMenu(
            reference.pointer,
            _id_onPrepareOptionsMenu as jni.JMethodIDPtr,
            menu.reference.pointer)
        .boolean;
  }

  static final _id_onOptionsItemSelected = _class.instanceMethodId(
    r'onOptionsItemSelected',
    r'(Landroid/view/MenuItem;)Z',
  );

  static final _onOptionsItemSelected = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem menuItem)
  bool onOptionsItemSelected(
    jni.JObject menuItem,
  ) {
    return _onOptionsItemSelected(
            reference.pointer,
            _id_onOptionsItemSelected as jni.JMethodIDPtr,
            menuItem.reference.pointer)
        .boolean;
  }

  static final _id_onNavigateUp = _class.instanceMethodId(
    r'onNavigateUp',
    r'()Z',
  );

  static final _onNavigateUp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean onNavigateUp()
  bool onNavigateUp() {
    return _onNavigateUp(
            reference.pointer, _id_onNavigateUp as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_onNavigateUpFromChild = _class.instanceMethodId(
    r'onNavigateUpFromChild',
    r'(Landroid/app/Activity;)Z',
  );

  static final _onNavigateUpFromChild = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onNavigateUpFromChild(android.app.Activity activity)
  bool onNavigateUpFromChild(
    Activity activity,
  ) {
    return _onNavigateUpFromChild(
            reference.pointer,
            _id_onNavigateUpFromChild as jni.JMethodIDPtr,
            activity.reference.pointer)
        .boolean;
  }

  static final _id_onCreateNavigateUpTaskStack = _class.instanceMethodId(
    r'onCreateNavigateUpTaskStack',
    r'(Landroid/app/TaskStackBuilder;)V',
  );

  static final _onCreateNavigateUpTaskStack = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateNavigateUpTaskStack(android.app.TaskStackBuilder taskStackBuilder)
  void onCreateNavigateUpTaskStack(
    jni.JObject taskStackBuilder,
  ) {
    _onCreateNavigateUpTaskStack(
            reference.pointer,
            _id_onCreateNavigateUpTaskStack as jni.JMethodIDPtr,
            taskStackBuilder.reference.pointer)
        .check();
  }

  static final _id_onPrepareNavigateUpTaskStack = _class.instanceMethodId(
    r'onPrepareNavigateUpTaskStack',
    r'(Landroid/app/TaskStackBuilder;)V',
  );

  static final _onPrepareNavigateUpTaskStack = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPrepareNavigateUpTaskStack(android.app.TaskStackBuilder taskStackBuilder)
  void onPrepareNavigateUpTaskStack(
    jni.JObject taskStackBuilder,
  ) {
    _onPrepareNavigateUpTaskStack(
            reference.pointer,
            _id_onPrepareNavigateUpTaskStack as jni.JMethodIDPtr,
            taskStackBuilder.reference.pointer)
        .check();
  }

  static final _id_onOptionsMenuClosed = _class.instanceMethodId(
    r'onOptionsMenuClosed',
    r'(Landroid/view/Menu;)V',
  );

  static final _onOptionsMenuClosed = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  void onOptionsMenuClosed(
    jni.JObject menu,
  ) {
    _onOptionsMenuClosed(reference.pointer,
            _id_onOptionsMenuClosed as jni.JMethodIDPtr, menu.reference.pointer)
        .check();
  }

  static final _id_openOptionsMenu = _class.instanceMethodId(
    r'openOptionsMenu',
    r'()V',
  );

  static final _openOptionsMenu = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void openOptionsMenu()
  void openOptionsMenu() {
    _openOptionsMenu(reference.pointer, _id_openOptionsMenu as jni.JMethodIDPtr)
        .check();
  }

  static final _id_closeOptionsMenu = _class.instanceMethodId(
    r'closeOptionsMenu',
    r'()V',
  );

  static final _closeOptionsMenu = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void closeOptionsMenu()
  void closeOptionsMenu() {
    _closeOptionsMenu(
            reference.pointer, _id_closeOptionsMenu as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCreateContextMenu = _class.instanceMethodId(
    r'onCreateContextMenu',
    r'(Landroid/view/ContextMenu;Landroid/view/View;Landroid/view/ContextMenu$ContextMenuInfo;)V',
  );

  static final _onCreateContextMenu = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu contextMenu, android.view.View view, android.view.ContextMenu$ContextMenuInfo contextMenuInfo)
  void onCreateContextMenu(
    jni.JObject contextMenu,
    jni.JObject view,
    jni.JObject contextMenuInfo,
  ) {
    _onCreateContextMenu(
            reference.pointer,
            _id_onCreateContextMenu as jni.JMethodIDPtr,
            contextMenu.reference.pointer,
            view.reference.pointer,
            contextMenuInfo.reference.pointer)
        .check();
  }

  static final _id_registerForContextMenu = _class.instanceMethodId(
    r'registerForContextMenu',
    r'(Landroid/view/View;)V',
  );

  static final _registerForContextMenu = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void registerForContextMenu(android.view.View view)
  void registerForContextMenu(
    jni.JObject view,
  ) {
    _registerForContextMenu(
            reference.pointer,
            _id_registerForContextMenu as jni.JMethodIDPtr,
            view.reference.pointer)
        .check();
  }

  static final _id_unregisterForContextMenu = _class.instanceMethodId(
    r'unregisterForContextMenu',
    r'(Landroid/view/View;)V',
  );

  static final _unregisterForContextMenu = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterForContextMenu(android.view.View view)
  void unregisterForContextMenu(
    jni.JObject view,
  ) {
    _unregisterForContextMenu(
            reference.pointer,
            _id_unregisterForContextMenu as jni.JMethodIDPtr,
            view.reference.pointer)
        .check();
  }

  static final _id_openContextMenu = _class.instanceMethodId(
    r'openContextMenu',
    r'(Landroid/view/View;)V',
  );

  static final _openContextMenu = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void openContextMenu(android.view.View view)
  void openContextMenu(
    jni.JObject view,
  ) {
    _openContextMenu(reference.pointer, _id_openContextMenu as jni.JMethodIDPtr,
            view.reference.pointer)
        .check();
  }

  static final _id_closeContextMenu = _class.instanceMethodId(
    r'closeContextMenu',
    r'()V',
  );

  static final _closeContextMenu = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void closeContextMenu()
  void closeContextMenu() {
    _closeContextMenu(
            reference.pointer, _id_closeContextMenu as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onContextItemSelected = _class.instanceMethodId(
    r'onContextItemSelected',
    r'(Landroid/view/MenuItem;)Z',
  );

  static final _onContextItemSelected = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onContextItemSelected(android.view.MenuItem menuItem)
  bool onContextItemSelected(
    jni.JObject menuItem,
  ) {
    return _onContextItemSelected(
            reference.pointer,
            _id_onContextItemSelected as jni.JMethodIDPtr,
            menuItem.reference.pointer)
        .boolean;
  }

  static final _id_onContextMenuClosed = _class.instanceMethodId(
    r'onContextMenuClosed',
    r'(Landroid/view/Menu;)V',
  );

  static final _onContextMenuClosed = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onContextMenuClosed(android.view.Menu menu)
  void onContextMenuClosed(
    jni.JObject menu,
  ) {
    _onContextMenuClosed(reference.pointer,
            _id_onContextMenuClosed as jni.JMethodIDPtr, menu.reference.pointer)
        .check();
  }

  static final _id_onCreateDialog = _class.instanceMethodId(
    r'onCreateDialog',
    r'(I)Landroid/app/Dialog;',
  );

  static final _onCreateDialog = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: protected android.app.Dialog onCreateDialog(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateDialog(
    int i,
  ) {
    return _onCreateDialog(
            reference.pointer, _id_onCreateDialog as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_onCreateDialog1 = _class.instanceMethodId(
    r'onCreateDialog',
    r'(ILandroid/os/Bundle;)Landroid/app/Dialog;',
  );

  static final _onCreateDialog1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected android.app.Dialog onCreateDialog(int i, android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateDialog1(
    int i,
    jni.JObject bundle,
  ) {
    return _onCreateDialog1(
            reference.pointer,
            _id_onCreateDialog1 as jni.JMethodIDPtr,
            i,
            bundle.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_onPrepareDialog = _class.instanceMethodId(
    r'onPrepareDialog',
    r'(ILandroid/app/Dialog;)V',
  );

  static final _onPrepareDialog = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPrepareDialog(int i, android.app.Dialog dialog)
  void onPrepareDialog(
    int i,
    jni.JObject dialog,
  ) {
    _onPrepareDialog(reference.pointer, _id_onPrepareDialog as jni.JMethodIDPtr,
            i, dialog.reference.pointer)
        .check();
  }

  static final _id_onPrepareDialog1 = _class.instanceMethodId(
    r'onPrepareDialog',
    r'(ILandroid/app/Dialog;Landroid/os/Bundle;)V',
  );

  static final _onPrepareDialog1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPrepareDialog(int i, android.app.Dialog dialog, android.os.Bundle bundle)
  void onPrepareDialog1(
    int i,
    jni.JObject dialog,
    jni.JObject bundle,
  ) {
    _onPrepareDialog1(
            reference.pointer,
            _id_onPrepareDialog1 as jni.JMethodIDPtr,
            i,
            dialog.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_showDialog = _class.instanceMethodId(
    r'showDialog',
    r'(I)V',
  );

  static final _showDialog = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void showDialog(int i)
  void showDialog(
    int i,
  ) {
    _showDialog(reference.pointer, _id_showDialog as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_showDialog1 = _class.instanceMethodId(
    r'showDialog',
    r'(ILandroid/os/Bundle;)Z',
  );

  static final _showDialog1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean showDialog(int i, android.os.Bundle bundle)
  bool showDialog1(
    int i,
    jni.JObject bundle,
  ) {
    return _showDialog1(reference.pointer, _id_showDialog1 as jni.JMethodIDPtr,
            i, bundle.reference.pointer)
        .boolean;
  }

  static final _id_dismissDialog = _class.instanceMethodId(
    r'dismissDialog',
    r'(I)V',
  );

  static final _dismissDialog = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void dismissDialog(int i)
  void dismissDialog(
    int i,
  ) {
    _dismissDialog(reference.pointer, _id_dismissDialog as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_removeDialog = _class.instanceMethodId(
    r'removeDialog',
    r'(I)V',
  );

  static final _removeDialog = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void removeDialog(int i)
  void removeDialog(
    int i,
  ) {
    _removeDialog(reference.pointer, _id_removeDialog as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onSearchRequested = _class.instanceMethodId(
    r'onSearchRequested',
    r'(Landroid/view/SearchEvent;)Z',
  );

  static final _onSearchRequested = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested(android.view.SearchEvent searchEvent)
  bool onSearchRequested(
    jni.JObject searchEvent,
  ) {
    return _onSearchRequested(
            reference.pointer,
            _id_onSearchRequested as jni.JMethodIDPtr,
            searchEvent.reference.pointer)
        .boolean;
  }

  static final _id_onSearchRequested1 = _class.instanceMethodId(
    r'onSearchRequested',
    r'()Z',
  );

  static final _onSearchRequested1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean onSearchRequested()
  bool onSearchRequested1() {
    return _onSearchRequested1(
            reference.pointer, _id_onSearchRequested1 as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getSearchEvent = _class.instanceMethodId(
    r'getSearchEvent',
    r'()Landroid/view/SearchEvent;',
  );

  static final _getSearchEvent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.view.SearchEvent getSearchEvent()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSearchEvent() {
    return _getSearchEvent(
            reference.pointer, _id_getSearchEvent as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_startSearch = _class.instanceMethodId(
    r'startSearch',
    r'(Ljava/lang/String;ZLandroid/os/Bundle;Z)V',
  );

  static final _startSearch = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startSearch(java.lang.String string, boolean z, android.os.Bundle bundle, boolean z1)
  void startSearch(
    jni.JString string,
    bool z,
    jni.JObject bundle,
    bool z1,
  ) {
    _startSearch(
            reference.pointer,
            _id_startSearch as jni.JMethodIDPtr,
            string.reference.pointer,
            z ? 1 : 0,
            bundle.reference.pointer,
            z1 ? 1 : 0)
        .check();
  }

  static final _id_triggerSearch = _class.instanceMethodId(
    r'triggerSearch',
    r'(Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _triggerSearch = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void triggerSearch(java.lang.String string, android.os.Bundle bundle)
  void triggerSearch(
    jni.JString string,
    jni.JObject bundle,
  ) {
    _triggerSearch(reference.pointer, _id_triggerSearch as jni.JMethodIDPtr,
            string.reference.pointer, bundle.reference.pointer)
        .check();
  }

  static final _id_takeKeyEvents = _class.instanceMethodId(
    r'takeKeyEvents',
    r'(Z)V',
  );

  static final _takeKeyEvents = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void takeKeyEvents(boolean z)
  void takeKeyEvents(
    bool z,
  ) {
    _takeKeyEvents(
            reference.pointer, _id_takeKeyEvents as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_requestWindowFeature = _class.instanceMethodId(
    r'requestWindowFeature',
    r'(I)Z',
  );

  static final _requestWindowFeature = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final boolean requestWindowFeature(int i)
  bool requestWindowFeature(
    int i,
  ) {
    return _requestWindowFeature(
            reference.pointer, _id_requestWindowFeature as jni.JMethodIDPtr, i)
        .boolean;
  }

  static final _id_setFeatureDrawableResource = _class.instanceMethodId(
    r'setFeatureDrawableResource',
    r'(II)V',
  );

  static final _setFeatureDrawableResource = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public final void setFeatureDrawableResource(int i, int i1)
  void setFeatureDrawableResource(
    int i,
    int i1,
  ) {
    _setFeatureDrawableResource(reference.pointer,
            _id_setFeatureDrawableResource as jni.JMethodIDPtr, i, i1)
        .check();
  }

  static final _id_setFeatureDrawableUri = _class.instanceMethodId(
    r'setFeatureDrawableUri',
    r'(ILandroid/net/Uri;)V',
  );

  static final _setFeatureDrawableUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawableUri(int i, android.net.Uri uri)
  void setFeatureDrawableUri(
    int i,
    Uri uri,
  ) {
    _setFeatureDrawableUri(
            reference.pointer,
            _id_setFeatureDrawableUri as jni.JMethodIDPtr,
            i,
            uri.reference.pointer)
        .check();
  }

  static final _id_setFeatureDrawable = _class.instanceMethodId(
    r'setFeatureDrawable',
    r'(ILandroid/graphics/drawable/Drawable;)V',
  );

  static final _setFeatureDrawable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawable(int i, android.graphics.drawable.Drawable drawable)
  void setFeatureDrawable(
    int i,
    jni.JObject drawable,
  ) {
    _setFeatureDrawable(
            reference.pointer,
            _id_setFeatureDrawable as jni.JMethodIDPtr,
            i,
            drawable.reference.pointer)
        .check();
  }

  static final _id_setFeatureDrawableAlpha = _class.instanceMethodId(
    r'setFeatureDrawableAlpha',
    r'(II)V',
  );

  static final _setFeatureDrawableAlpha = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public final void setFeatureDrawableAlpha(int i, int i1)
  void setFeatureDrawableAlpha(
    int i,
    int i1,
  ) {
    _setFeatureDrawableAlpha(reference.pointer,
            _id_setFeatureDrawableAlpha as jni.JMethodIDPtr, i, i1)
        .check();
  }

  static final _id_getLayoutInflater = _class.instanceMethodId(
    r'getLayoutInflater',
    r'()Landroid/view/LayoutInflater;',
  );

  static final _getLayoutInflater = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLayoutInflater() {
    return _getLayoutInflater(
            reference.pointer, _id_getLayoutInflater as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getMenuInflater = _class.instanceMethodId(
    r'getMenuInflater',
    r'()Landroid/view/MenuInflater;',
  );

  static final _getMenuInflater = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.view.MenuInflater getMenuInflater()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getMenuInflater() {
    return _getMenuInflater(
            reference.pointer, _id_getMenuInflater as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setTheme = _class.instanceMethodId(
    r'setTheme',
    r'(I)V',
  );

  static final _setTheme = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setTheme(int i)
  void setTheme(
    int i,
  ) {
    _setTheme(reference.pointer, _id_setTheme as jni.JMethodIDPtr, i).check();
  }

  static final _id_onApplyThemeResource = _class.instanceMethodId(
    r'onApplyThemeResource',
    r'(Landroid/content/res/Resources$Theme;IZ)V',
  );

  static final _onApplyThemeResource = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onApplyThemeResource(android.content.res.Resources$Theme theme, int i, boolean z)
  void onApplyThemeResource(
    jni.JObject theme,
    int i,
    bool z,
  ) {
    _onApplyThemeResource(
            reference.pointer,
            _id_onApplyThemeResource as jni.JMethodIDPtr,
            theme.reference.pointer,
            i,
            z ? 1 : 0)
        .check();
  }

  static final _id_requestPermissions = _class.instanceMethodId(
    r'requestPermissions',
    r'([Ljava/lang/String;I)V',
  );

  static final _requestPermissions = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void requestPermissions(java.lang.String[] strings, int i)
  void requestPermissions(
    jni.JArray<jni.JString> strings,
    int i,
  ) {
    _requestPermissions(
            reference.pointer,
            _id_requestPermissions as jni.JMethodIDPtr,
            strings.reference.pointer,
            i)
        .check();
  }

  static final _id_onRequestPermissionsResult = _class.instanceMethodId(
    r'onRequestPermissionsResult',
    r'(I[Ljava/lang/String;[I)V',
  );

  static final _onRequestPermissionsResult = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRequestPermissionsResult(int i, java.lang.String[] strings, int[] is)
  void onRequestPermissionsResult(
    int i,
    jni.JArray<jni.JString> strings,
    jni.JArray<jni.jint> is0,
  ) {
    _onRequestPermissionsResult(
            reference.pointer,
            _id_onRequestPermissionsResult as jni.JMethodIDPtr,
            i,
            strings.reference.pointer,
            is0.reference.pointer)
        .check();
  }

  static final _id_shouldShowRequestPermissionRationale =
      _class.instanceMethodId(
    r'shouldShowRequestPermissionRationale',
    r'(Ljava/lang/String;)Z',
  );

  static final _shouldShowRequestPermissionRationale =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallBooleanMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowRequestPermissionRationale(java.lang.String string)
  bool shouldShowRequestPermissionRationale(
    jni.JString string,
  ) {
    return _shouldShowRequestPermissionRationale(
            reference.pointer,
            _id_shouldShowRequestPermissionRationale as jni.JMethodIDPtr,
            string.reference.pointer)
        .boolean;
  }

  static final _id_startActivityForResult = _class.instanceMethodId(
    r'startActivityForResult',
    r'(Landroid/content/Intent;I)V',
  );

  static final _startActivityForResult = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int i)
  void startActivityForResult(
    jni.JObject intent,
    int i,
  ) {
    _startActivityForResult(
            reference.pointer,
            _id_startActivityForResult as jni.JMethodIDPtr,
            intent.reference.pointer,
            i)
        .check();
  }

  static final _id_startActivityForResult1 = _class.instanceMethodId(
    r'startActivityForResult',
    r'(Landroid/content/Intent;ILandroid/os/Bundle;)V',
  );

  static final _startActivityForResult1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int i, android.os.Bundle bundle)
  void startActivityForResult1(
    jni.JObject intent,
    int i,
    jni.JObject bundle,
  ) {
    _startActivityForResult1(
            reference.pointer,
            _id_startActivityForResult1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            i,
            bundle.reference.pointer)
        .check();
  }

  static final _id_isActivityTransitionRunning = _class.instanceMethodId(
    r'isActivityTransitionRunning',
    r'()Z',
  );

  static final _isActivityTransitionRunning = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isActivityTransitionRunning()
  bool isActivityTransitionRunning() {
    return _isActivityTransitionRunning(reference.pointer,
            _id_isActivityTransitionRunning as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_startIntentSenderForResult = _class.instanceMethodId(
    r'startIntentSenderForResult',
    r'(Landroid/content/IntentSender;ILandroid/content/Intent;III)V',
  );

  static final _startIntentSenderForResult = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int)>();

  /// from: public void startIntentSenderForResult(android.content.IntentSender intentSender, int i, android.content.Intent intent, int i1, int i2, int i3)
  void startIntentSenderForResult(
    jni.JObject intentSender,
    int i,
    jni.JObject intent,
    int i1,
    int i2,
    int i3,
  ) {
    _startIntentSenderForResult(
            reference.pointer,
            _id_startIntentSenderForResult as jni.JMethodIDPtr,
            intentSender.reference.pointer,
            i,
            intent.reference.pointer,
            i1,
            i2,
            i3)
        .check();
  }

  static final _id_startIntentSenderForResult1 = _class.instanceMethodId(
    r'startIntentSenderForResult',
    r'(Landroid/content/IntentSender;ILandroid/content/Intent;IIILandroid/os/Bundle;)V',
  );

  static final _startIntentSenderForResult1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSenderForResult(android.content.IntentSender intentSender, int i, android.content.Intent intent, int i1, int i2, int i3, android.os.Bundle bundle)
  void startIntentSenderForResult1(
    jni.JObject intentSender,
    int i,
    jni.JObject intent,
    int i1,
    int i2,
    int i3,
    jni.JObject bundle,
  ) {
    _startIntentSenderForResult1(
            reference.pointer,
            _id_startIntentSenderForResult1 as jni.JMethodIDPtr,
            intentSender.reference.pointer,
            i,
            intent.reference.pointer,
            i1,
            i2,
            i3,
            bundle.reference.pointer)
        .check();
  }

  static final _id_startActivity = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Intent;)V',
  );

  static final _startActivity = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent)
  void startActivity(
    jni.JObject intent,
  ) {
    _startActivity(reference.pointer, _id_startActivity as jni.JMethodIDPtr,
            intent.reference.pointer)
        .check();
  }

  static final _id_startActivity1 = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivity1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent, android.os.Bundle bundle)
  void startActivity1(
    jni.JObject intent,
    jni.JObject bundle,
  ) {
    _startActivity1(reference.pointer, _id_startActivity1 as jni.JMethodIDPtr,
            intent.reference.pointer, bundle.reference.pointer)
        .check();
  }

  static final _id_startActivities = _class.instanceMethodId(
    r'startActivities',
    r'([Landroid/content/Intent;)V',
  );

  static final _startActivities = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.content.Intent[] intents)
  void startActivities(
    jni.JArray<jni.JObject> intents,
  ) {
    _startActivities(reference.pointer, _id_startActivities as jni.JMethodIDPtr,
            intents.reference.pointer)
        .check();
  }

  static final _id_startActivities1 = _class.instanceMethodId(
    r'startActivities',
    r'([Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivities1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.content.Intent[] intents, android.os.Bundle bundle)
  void startActivities1(
    jni.JArray<jni.JObject> intents,
    jni.JObject bundle,
  ) {
    _startActivities1(
            reference.pointer,
            _id_startActivities1 as jni.JMethodIDPtr,
            intents.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_startIntentSender = _class.instanceMethodId(
    r'startIntentSender',
    r'(Landroid/content/IntentSender;Landroid/content/Intent;III)V',
  );

  static final _startIntentSender = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void startIntentSender(android.content.IntentSender intentSender, android.content.Intent intent, int i, int i1, int i2)
  void startIntentSender(
    jni.JObject intentSender,
    jni.JObject intent,
    int i,
    int i1,
    int i2,
  ) {
    _startIntentSender(
            reference.pointer,
            _id_startIntentSender as jni.JMethodIDPtr,
            intentSender.reference.pointer,
            intent.reference.pointer,
            i,
            i1,
            i2)
        .check();
  }

  static final _id_startIntentSender1 = _class.instanceMethodId(
    r'startIntentSender',
    r'(Landroid/content/IntentSender;Landroid/content/Intent;IIILandroid/os/Bundle;)V',
  );

  static final _startIntentSender1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSender(android.content.IntentSender intentSender, android.content.Intent intent, int i, int i1, int i2, android.os.Bundle bundle)
  void startIntentSender1(
    jni.JObject intentSender,
    jni.JObject intent,
    int i,
    int i1,
    int i2,
    jni.JObject bundle,
  ) {
    _startIntentSender1(
            reference.pointer,
            _id_startIntentSender1 as jni.JMethodIDPtr,
            intentSender.reference.pointer,
            intent.reference.pointer,
            i,
            i1,
            i2,
            bundle.reference.pointer)
        .check();
  }

  static final _id_startActivityIfNeeded = _class.instanceMethodId(
    r'startActivityIfNeeded',
    r'(Landroid/content/Intent;I)Z',
  );

  static final _startActivityIfNeeded = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean startActivityIfNeeded(android.content.Intent intent, int i)
  bool startActivityIfNeeded(
    jni.JObject intent,
    int i,
  ) {
    return _startActivityIfNeeded(
            reference.pointer,
            _id_startActivityIfNeeded as jni.JMethodIDPtr,
            intent.reference.pointer,
            i)
        .boolean;
  }

  static final _id_startActivityIfNeeded1 = _class.instanceMethodId(
    r'startActivityIfNeeded',
    r'(Landroid/content/Intent;ILandroid/os/Bundle;)Z',
  );

  static final _startActivityIfNeeded1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startActivityIfNeeded(android.content.Intent intent, int i, android.os.Bundle bundle)
  bool startActivityIfNeeded1(
    jni.JObject intent,
    int i,
    jni.JObject bundle,
  ) {
    return _startActivityIfNeeded1(
            reference.pointer,
            _id_startActivityIfNeeded1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            i,
            bundle.reference.pointer)
        .boolean;
  }

  static final _id_startNextMatchingActivity = _class.instanceMethodId(
    r'startNextMatchingActivity',
    r'(Landroid/content/Intent;)Z',
  );

  static final _startNextMatchingActivity = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startNextMatchingActivity(android.content.Intent intent)
  bool startNextMatchingActivity(
    jni.JObject intent,
  ) {
    return _startNextMatchingActivity(
            reference.pointer,
            _id_startNextMatchingActivity as jni.JMethodIDPtr,
            intent.reference.pointer)
        .boolean;
  }

  static final _id_startNextMatchingActivity1 = _class.instanceMethodId(
    r'startNextMatchingActivity',
    r'(Landroid/content/Intent;Landroid/os/Bundle;)Z',
  );

  static final _startNextMatchingActivity1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startNextMatchingActivity(android.content.Intent intent, android.os.Bundle bundle)
  bool startNextMatchingActivity1(
    jni.JObject intent,
    jni.JObject bundle,
  ) {
    return _startNextMatchingActivity1(
            reference.pointer,
            _id_startNextMatchingActivity1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            bundle.reference.pointer)
        .boolean;
  }

  static final _id_startActivityFromChild = _class.instanceMethodId(
    r'startActivityFromChild',
    r'(Landroid/app/Activity;Landroid/content/Intent;I)V',
  );

  static final _startActivityFromChild = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityFromChild(android.app.Activity activity, android.content.Intent intent, int i)
  void startActivityFromChild(
    Activity activity,
    jni.JObject intent,
    int i,
  ) {
    _startActivityFromChild(
            reference.pointer,
            _id_startActivityFromChild as jni.JMethodIDPtr,
            activity.reference.pointer,
            intent.reference.pointer,
            i)
        .check();
  }

  static final _id_startActivityFromChild1 = _class.instanceMethodId(
    r'startActivityFromChild',
    r'(Landroid/app/Activity;Landroid/content/Intent;ILandroid/os/Bundle;)V',
  );

  static final _startActivityFromChild1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityFromChild(android.app.Activity activity, android.content.Intent intent, int i, android.os.Bundle bundle)
  void startActivityFromChild1(
    Activity activity,
    jni.JObject intent,
    int i,
    jni.JObject bundle,
  ) {
    _startActivityFromChild1(
            reference.pointer,
            _id_startActivityFromChild1 as jni.JMethodIDPtr,
            activity.reference.pointer,
            intent.reference.pointer,
            i,
            bundle.reference.pointer)
        .check();
  }

  static final _id_startActivityFromFragment = _class.instanceMethodId(
    r'startActivityFromFragment',
    r'(Landroid/app/Fragment;Landroid/content/Intent;I)V',
  );

  static final _startActivityFromFragment = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int i)
  void startActivityFromFragment(
    jni.JObject fragment,
    jni.JObject intent,
    int i,
  ) {
    _startActivityFromFragment(
            reference.pointer,
            _id_startActivityFromFragment as jni.JMethodIDPtr,
            fragment.reference.pointer,
            intent.reference.pointer,
            i)
        .check();
  }

  static final _id_startActivityFromFragment1 = _class.instanceMethodId(
    r'startActivityFromFragment',
    r'(Landroid/app/Fragment;Landroid/content/Intent;ILandroid/os/Bundle;)V',
  );

  static final _startActivityFromFragment1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int i, android.os.Bundle bundle)
  void startActivityFromFragment1(
    jni.JObject fragment,
    jni.JObject intent,
    int i,
    jni.JObject bundle,
  ) {
    _startActivityFromFragment1(
            reference.pointer,
            _id_startActivityFromFragment1 as jni.JMethodIDPtr,
            fragment.reference.pointer,
            intent.reference.pointer,
            i,
            bundle.reference.pointer)
        .check();
  }

  static final _id_startIntentSenderFromChild = _class.instanceMethodId(
    r'startIntentSenderFromChild',
    r'(Landroid/app/Activity;Landroid/content/IntentSender;ILandroid/content/Intent;III)V',
  );

  static final _startIntentSenderFromChild = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int)>();

  /// from: public void startIntentSenderFromChild(android.app.Activity activity, android.content.IntentSender intentSender, int i, android.content.Intent intent, int i1, int i2, int i3)
  void startIntentSenderFromChild(
    Activity activity,
    jni.JObject intentSender,
    int i,
    jni.JObject intent,
    int i1,
    int i2,
    int i3,
  ) {
    _startIntentSenderFromChild(
            reference.pointer,
            _id_startIntentSenderFromChild as jni.JMethodIDPtr,
            activity.reference.pointer,
            intentSender.reference.pointer,
            i,
            intent.reference.pointer,
            i1,
            i2,
            i3)
        .check();
  }

  static final _id_startIntentSenderFromChild1 = _class.instanceMethodId(
    r'startIntentSenderFromChild',
    r'(Landroid/app/Activity;Landroid/content/IntentSender;ILandroid/content/Intent;IIILandroid/os/Bundle;)V',
  );

  static final _startIntentSenderFromChild1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSenderFromChild(android.app.Activity activity, android.content.IntentSender intentSender, int i, android.content.Intent intent, int i1, int i2, int i3, android.os.Bundle bundle)
  void startIntentSenderFromChild1(
    Activity activity,
    jni.JObject intentSender,
    int i,
    jni.JObject intent,
    int i1,
    int i2,
    int i3,
    jni.JObject bundle,
  ) {
    _startIntentSenderFromChild1(
            reference.pointer,
            _id_startIntentSenderFromChild1 as jni.JMethodIDPtr,
            activity.reference.pointer,
            intentSender.reference.pointer,
            i,
            intent.reference.pointer,
            i1,
            i2,
            i3,
            bundle.reference.pointer)
        .check();
  }

  static final _id_overrideActivityTransition = _class.instanceMethodId(
    r'overrideActivityTransition',
    r'(III)V',
  );

  static final _overrideActivityTransition = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int)>();

  /// from: public void overrideActivityTransition(int i, int i1, int i2)
  void overrideActivityTransition(
    int i,
    int i1,
    int i2,
  ) {
    _overrideActivityTransition(reference.pointer,
            _id_overrideActivityTransition as jni.JMethodIDPtr, i, i1, i2)
        .check();
  }

  static final _id_overrideActivityTransition1 = _class.instanceMethodId(
    r'overrideActivityTransition',
    r'(IIII)V',
  );

  static final _overrideActivityTransition1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public void overrideActivityTransition(int i, int i1, int i2, int i3)
  void overrideActivityTransition1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _overrideActivityTransition1(reference.pointer,
            _id_overrideActivityTransition1 as jni.JMethodIDPtr, i, i1, i2, i3)
        .check();
  }

  static final _id_clearOverrideActivityTransition = _class.instanceMethodId(
    r'clearOverrideActivityTransition',
    r'(I)V',
  );

  static final _clearOverrideActivityTransition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void clearOverrideActivityTransition(int i)
  void clearOverrideActivityTransition(
    int i,
  ) {
    _clearOverrideActivityTransition(reference.pointer,
            _id_clearOverrideActivityTransition as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_overridePendingTransition = _class.instanceMethodId(
    r'overridePendingTransition',
    r'(II)V',
  );

  static final _overridePendingTransition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void overridePendingTransition(int i, int i1)
  void overridePendingTransition(
    int i,
    int i1,
  ) {
    _overridePendingTransition(reference.pointer,
            _id_overridePendingTransition as jni.JMethodIDPtr, i, i1)
        .check();
  }

  static final _id_overridePendingTransition1 = _class.instanceMethodId(
    r'overridePendingTransition',
    r'(III)V',
  );

  static final _overridePendingTransition1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int)>();

  /// from: public void overridePendingTransition(int i, int i1, int i2)
  void overridePendingTransition1(
    int i,
    int i1,
    int i2,
  ) {
    _overridePendingTransition1(reference.pointer,
            _id_overridePendingTransition1 as jni.JMethodIDPtr, i, i1, i2)
        .check();
  }

  static final _id_setResult = _class.instanceMethodId(
    r'setResult',
    r'(I)V',
  );

  static final _setResult = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setResult(int i)
  void setResult(
    int i,
  ) {
    _setResult(reference.pointer, _id_setResult as jni.JMethodIDPtr, i).check();
  }

  static final _id_setResult1 = _class.instanceMethodId(
    r'setResult',
    r'(ILandroid/content/Intent;)V',
  );

  static final _setResult1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResult(int i, android.content.Intent intent)
  void setResult1(
    int i,
    jni.JObject intent,
  ) {
    _setResult1(reference.pointer, _id_setResult1 as jni.JMethodIDPtr, i,
            intent.reference.pointer)
        .check();
  }

  static final _id_getReferrer = _class.instanceMethodId(
    r'getReferrer',
    r'()Landroid/net/Uri;',
  );

  static final _getReferrer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.net.Uri getReferrer()
  /// The returned object must be released after use, by calling the [release] method.
  Uri getReferrer() {
    return _getReferrer(reference.pointer, _id_getReferrer as jni.JMethodIDPtr)
        .object(const $UriType());
  }

  static final _id_onProvideReferrer = _class.instanceMethodId(
    r'onProvideReferrer',
    r'()Landroid/net/Uri;',
  );

  static final _onProvideReferrer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.net.Uri onProvideReferrer()
  /// The returned object must be released after use, by calling the [release] method.
  Uri onProvideReferrer() {
    return _onProvideReferrer(
            reference.pointer, _id_onProvideReferrer as jni.JMethodIDPtr)
        .object(const $UriType());
  }

  static final _id_getCallingPackage = _class.instanceMethodId(
    r'getCallingPackage',
    r'()Ljava/lang/String;',
  );

  static final _getCallingPackage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getCallingPackage()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getCallingPackage() {
    return _getCallingPackage(
            reference.pointer, _id_getCallingPackage as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getCallingActivity = _class.instanceMethodId(
    r'getCallingActivity',
    r'()Landroid/content/ComponentName;',
  );

  static final _getCallingActivity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.content.ComponentName getCallingActivity()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCallingActivity() {
    return _getCallingActivity(
            reference.pointer, _id_getCallingActivity as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getLaunchedFromUid = _class.instanceMethodId(
    r'getLaunchedFromUid',
    r'()I',
  );

  static final _getLaunchedFromUid = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getLaunchedFromUid()
  int getLaunchedFromUid() {
    return _getLaunchedFromUid(
            reference.pointer, _id_getLaunchedFromUid as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getLaunchedFromPackage = _class.instanceMethodId(
    r'getLaunchedFromPackage',
    r'()Ljava/lang/String;',
  );

  static final _getLaunchedFromPackage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLaunchedFromPackage()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLaunchedFromPackage() {
    return _getLaunchedFromPackage(
            reference.pointer, _id_getLaunchedFromPackage as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setVisible = _class.instanceMethodId(
    r'setVisible',
    r'(Z)V',
  );

  static final _setVisible = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setVisible(boolean z)
  void setVisible(
    bool z,
  ) {
    _setVisible(
            reference.pointer, _id_setVisible as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isFinishing = _class.instanceMethodId(
    r'isFinishing',
    r'()Z',
  );

  static final _isFinishing = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isFinishing()
  bool isFinishing() {
    return _isFinishing(reference.pointer, _id_isFinishing as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isDestroyed = _class.instanceMethodId(
    r'isDestroyed',
    r'()Z',
  );

  static final _isDestroyed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isDestroyed()
  bool isDestroyed() {
    return _isDestroyed(reference.pointer, _id_isDestroyed as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isChangingConfigurations = _class.instanceMethodId(
    r'isChangingConfigurations',
    r'()Z',
  );

  static final _isChangingConfigurations = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isChangingConfigurations()
  bool isChangingConfigurations() {
    return _isChangingConfigurations(
            reference.pointer, _id_isChangingConfigurations as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_recreate = _class.instanceMethodId(
    r'recreate',
    r'()V',
  );

  static final _recreate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void recreate()
  void recreate() {
    _recreate(reference.pointer, _id_recreate as jni.JMethodIDPtr).check();
  }

  static final _id_finish = _class.instanceMethodId(
    r'finish',
    r'()V',
  );

  static final _finish = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void finish()
  void finish() {
    _finish(reference.pointer, _id_finish as jni.JMethodIDPtr).check();
  }

  static final _id_finishAffinity = _class.instanceMethodId(
    r'finishAffinity',
    r'()V',
  );

  static final _finishAffinity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void finishAffinity()
  void finishAffinity() {
    _finishAffinity(reference.pointer, _id_finishAffinity as jni.JMethodIDPtr)
        .check();
  }

  static final _id_finishFromChild = _class.instanceMethodId(
    r'finishFromChild',
    r'(Landroid/app/Activity;)V',
  );

  static final _finishFromChild = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void finishFromChild(android.app.Activity activity)
  void finishFromChild(
    Activity activity,
  ) {
    _finishFromChild(reference.pointer, _id_finishFromChild as jni.JMethodIDPtr,
            activity.reference.pointer)
        .check();
  }

  static final _id_finishAfterTransition = _class.instanceMethodId(
    r'finishAfterTransition',
    r'()V',
  );

  static final _finishAfterTransition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void finishAfterTransition()
  void finishAfterTransition() {
    _finishAfterTransition(
            reference.pointer, _id_finishAfterTransition as jni.JMethodIDPtr)
        .check();
  }

  static final _id_finishActivity = _class.instanceMethodId(
    r'finishActivity',
    r'(I)V',
  );

  static final _finishActivity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void finishActivity(int i)
  void finishActivity(
    int i,
  ) {
    _finishActivity(
            reference.pointer, _id_finishActivity as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_finishActivityFromChild = _class.instanceMethodId(
    r'finishActivityFromChild',
    r'(Landroid/app/Activity;I)V',
  );

  static final _finishActivityFromChild = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void finishActivityFromChild(android.app.Activity activity, int i)
  void finishActivityFromChild(
    Activity activity,
    int i,
  ) {
    _finishActivityFromChild(
            reference.pointer,
            _id_finishActivityFromChild as jni.JMethodIDPtr,
            activity.reference.pointer,
            i)
        .check();
  }

  static final _id_finishAndRemoveTask = _class.instanceMethodId(
    r'finishAndRemoveTask',
    r'()V',
  );

  static final _finishAndRemoveTask = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void finishAndRemoveTask()
  void finishAndRemoveTask() {
    _finishAndRemoveTask(
            reference.pointer, _id_finishAndRemoveTask as jni.JMethodIDPtr)
        .check();
  }

  static final _id_releaseInstance = _class.instanceMethodId(
    r'releaseInstance',
    r'()Z',
  );

  static final _releaseInstance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean releaseInstance()
  bool releaseInstance() {
    return _releaseInstance(
            reference.pointer, _id_releaseInstance as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_onActivityResult = _class.instanceMethodId(
    r'onActivityResult',
    r'(IILandroid/content/Intent;)V',
  );

  static final _onActivityResult = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onActivityResult(int i, int i1, android.content.Intent intent)
  void onActivityResult(
    int i,
    int i1,
    jni.JObject intent,
  ) {
    _onActivityResult(
            reference.pointer,
            _id_onActivityResult as jni.JMethodIDPtr,
            i,
            i1,
            intent.reference.pointer)
        .check();
  }

  static final _id_onActivityReenter = _class.instanceMethodId(
    r'onActivityReenter',
    r'(ILandroid/content/Intent;)V',
  );

  static final _onActivityReenter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityReenter(int i, android.content.Intent intent)
  void onActivityReenter(
    int i,
    jni.JObject intent,
  ) {
    _onActivityReenter(
            reference.pointer,
            _id_onActivityReenter as jni.JMethodIDPtr,
            i,
            intent.reference.pointer)
        .check();
  }

  static final _id_createPendingResult = _class.instanceMethodId(
    r'createPendingResult',
    r'(ILandroid/content/Intent;I)Landroid/app/PendingIntent;',
  );

  static final _createPendingResult = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.PendingIntent createPendingResult(int i, android.content.Intent intent, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createPendingResult(
    int i,
    jni.JObject intent,
    int i1,
  ) {
    return _createPendingResult(
            reference.pointer,
            _id_createPendingResult as jni.JMethodIDPtr,
            i,
            intent.reference.pointer,
            i1)
        .object(const jni.JObjectType());
  }

  static final _id_setRequestedOrientation = _class.instanceMethodId(
    r'setRequestedOrientation',
    r'(I)V',
  );

  static final _setRequestedOrientation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setRequestedOrientation(int i)
  void setRequestedOrientation(
    int i,
  ) {
    _setRequestedOrientation(reference.pointer,
            _id_setRequestedOrientation as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getRequestedOrientation = _class.instanceMethodId(
    r'getRequestedOrientation',
    r'()I',
  );

  static final _getRequestedOrientation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getRequestedOrientation()
  int getRequestedOrientation() {
    return _getRequestedOrientation(
            reference.pointer, _id_getRequestedOrientation as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getTaskId = _class.instanceMethodId(
    r'getTaskId',
    r'()I',
  );

  static final _getTaskId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getTaskId()
  int getTaskId() {
    return _getTaskId(reference.pointer, _id_getTaskId as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_isTaskRoot = _class.instanceMethodId(
    r'isTaskRoot',
    r'()Z',
  );

  static final _isTaskRoot = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isTaskRoot()
  bool isTaskRoot() {
    return _isTaskRoot(reference.pointer, _id_isTaskRoot as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_moveTaskToBack = _class.instanceMethodId(
    r'moveTaskToBack',
    r'(Z)Z',
  );

  static final _moveTaskToBack = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public boolean moveTaskToBack(boolean z)
  bool moveTaskToBack(
    bool z,
  ) {
    return _moveTaskToBack(reference.pointer,
            _id_moveTaskToBack as jni.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_getLocalClassName = _class.instanceMethodId(
    r'getLocalClassName',
    r'()Ljava/lang/String;',
  );

  static final _getLocalClassName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLocalClassName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLocalClassName() {
    return _getLocalClassName(
            reference.pointer, _id_getLocalClassName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getComponentName = _class.instanceMethodId(
    r'getComponentName',
    r'()Landroid/content/ComponentName;',
  );

  static final _getComponentName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.content.ComponentName getComponentName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getComponentName() {
    return _getComponentName(
            reference.pointer, _id_getComponentName as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getPreferences = _class.instanceMethodId(
    r'getPreferences',
    r'(I)Landroid/content/SharedPreferences;',
  );

  static final _getPreferences = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public android.content.SharedPreferences getPreferences(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getPreferences(
    int i,
  ) {
    return _getPreferences(
            reference.pointer, _id_getPreferences as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_isLaunchedFromBubble = _class.instanceMethodId(
    r'isLaunchedFromBubble',
    r'()Z',
  );

  static final _isLaunchedFromBubble = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isLaunchedFromBubble()
  bool isLaunchedFromBubble() {
    return _isLaunchedFromBubble(
            reference.pointer, _id_isLaunchedFromBubble as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getSystemService = _class.instanceMethodId(
    r'getSystemService',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _getSystemService = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object getSystemService(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSystemService(
    jni.JString string,
  ) {
    return _getSystemService(reference.pointer,
            _id_getSystemService as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_setTitle = _class.instanceMethodId(
    r'setTitle',
    r'(Ljava/lang/CharSequence;)V',
  );

  static final _setTitle = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence charSequence)
  void setTitle(
    jni.JObject charSequence,
  ) {
    _setTitle(reference.pointer, _id_setTitle as jni.JMethodIDPtr,
            charSequence.reference.pointer)
        .check();
  }

  static final _id_setTitle1 = _class.instanceMethodId(
    r'setTitle',
    r'(I)V',
  );

  static final _setTitle1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setTitle(int i)
  void setTitle1(
    int i,
  ) {
    _setTitle1(reference.pointer, _id_setTitle1 as jni.JMethodIDPtr, i).check();
  }

  static final _id_setTitleColor = _class.instanceMethodId(
    r'setTitleColor',
    r'(I)V',
  );

  static final _setTitleColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setTitleColor(int i)
  void setTitleColor(
    int i,
  ) {
    _setTitleColor(reference.pointer, _id_setTitleColor as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/CharSequence;',
  );

  static final _getTitle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.CharSequence getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getTitleColor = _class.instanceMethodId(
    r'getTitleColor',
    r'()I',
  );

  static final _getTitleColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int getTitleColor()
  int getTitleColor() {
    return _getTitleColor(
            reference.pointer, _id_getTitleColor as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_onTitleChanged = _class.instanceMethodId(
    r'onTitleChanged',
    r'(Ljava/lang/CharSequence;I)V',
  );

  static final _onTitleChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void onTitleChanged(java.lang.CharSequence charSequence, int i)
  void onTitleChanged(
    jni.JObject charSequence,
    int i,
  ) {
    _onTitleChanged(reference.pointer, _id_onTitleChanged as jni.JMethodIDPtr,
            charSequence.reference.pointer, i)
        .check();
  }

  static final _id_onChildTitleChanged = _class.instanceMethodId(
    r'onChildTitleChanged',
    r'(Landroid/app/Activity;Ljava/lang/CharSequence;)V',
  );

  static final _onChildTitleChanged = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onChildTitleChanged(android.app.Activity activity, java.lang.CharSequence charSequence)
  void onChildTitleChanged(
    Activity activity,
    jni.JObject charSequence,
  ) {
    _onChildTitleChanged(
            reference.pointer,
            _id_onChildTitleChanged as jni.JMethodIDPtr,
            activity.reference.pointer,
            charSequence.reference.pointer)
        .check();
  }

  static final _id_setTaskDescription = _class.instanceMethodId(
    r'setTaskDescription',
    r'(Landroid/app/ActivityManager$TaskDescription;)V',
  );

  static final _setTaskDescription = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setTaskDescription(android.app.ActivityManager$TaskDescription taskDescription)
  void setTaskDescription(
    jni.JObject taskDescription,
  ) {
    _setTaskDescription(
            reference.pointer,
            _id_setTaskDescription as jni.JMethodIDPtr,
            taskDescription.reference.pointer)
        .check();
  }

  static final _id_setProgressBarVisibility = _class.instanceMethodId(
    r'setProgressBarVisibility',
    r'(Z)V',
  );

  static final _setProgressBarVisibility = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setProgressBarVisibility(boolean z)
  void setProgressBarVisibility(
    bool z,
  ) {
    _setProgressBarVisibility(reference.pointer,
            _id_setProgressBarVisibility as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setProgressBarIndeterminateVisibility =
      _class.instanceMethodId(
    r'setProgressBarIndeterminateVisibility',
    r'(Z)V',
  );

  static final _setProgressBarIndeterminateVisibility =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setProgressBarIndeterminateVisibility(boolean z)
  void setProgressBarIndeterminateVisibility(
    bool z,
  ) {
    _setProgressBarIndeterminateVisibility(
            reference.pointer,
            _id_setProgressBarIndeterminateVisibility as jni.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setProgressBarIndeterminate = _class.instanceMethodId(
    r'setProgressBarIndeterminate',
    r'(Z)V',
  );

  static final _setProgressBarIndeterminate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setProgressBarIndeterminate(boolean z)
  void setProgressBarIndeterminate(
    bool z,
  ) {
    _setProgressBarIndeterminate(reference.pointer,
            _id_setProgressBarIndeterminate as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setProgress = _class.instanceMethodId(
    r'setProgress',
    r'(I)V',
  );

  static final _setProgress = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setProgress(int i)
  void setProgress(
    int i,
  ) {
    _setProgress(reference.pointer, _id_setProgress as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setSecondaryProgress = _class.instanceMethodId(
    r'setSecondaryProgress',
    r'(I)V',
  );

  static final _setSecondaryProgress = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setSecondaryProgress(int i)
  void setSecondaryProgress(
    int i,
  ) {
    _setSecondaryProgress(
            reference.pointer, _id_setSecondaryProgress as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setVolumeControlStream = _class.instanceMethodId(
    r'setVolumeControlStream',
    r'(I)V',
  );

  static final _setVolumeControlStream = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setVolumeControlStream(int i)
  void setVolumeControlStream(
    int i,
  ) {
    _setVolumeControlStream(reference.pointer,
            _id_setVolumeControlStream as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getVolumeControlStream = _class.instanceMethodId(
    r'getVolumeControlStream',
    r'()I',
  );

  static final _getVolumeControlStream = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int getVolumeControlStream()
  int getVolumeControlStream() {
    return _getVolumeControlStream(
            reference.pointer, _id_getVolumeControlStream as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setMediaController = _class.instanceMethodId(
    r'setMediaController',
    r'(Landroid/media/session/MediaController;)V',
  );

  static final _setMediaController = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void setMediaController(android.media.session.MediaController mediaController)
  void setMediaController(
    jni.JObject mediaController,
  ) {
    _setMediaController(
            reference.pointer,
            _id_setMediaController as jni.JMethodIDPtr,
            mediaController.reference.pointer)
        .check();
  }

  static final _id_getMediaController = _class.instanceMethodId(
    r'getMediaController',
    r'()Landroid/media/session/MediaController;',
  );

  static final _getMediaController = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.media.session.MediaController getMediaController()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getMediaController() {
    return _getMediaController(
            reference.pointer, _id_getMediaController as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_runOnUiThread = _class.instanceMethodId(
    r'runOnUiThread',
    r'(Ljava/lang/Runnable;)V',
  );

  static final _runOnUiThread = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void runOnUiThread(java.lang.Runnable runnable)
  void runOnUiThread(
    Runnable runnable,
  ) {
    _runOnUiThread(reference.pointer, _id_runOnUiThread as jni.JMethodIDPtr,
            runnable.reference.pointer)
        .check();
  }

  static final _id_onCreateView = _class.instanceMethodId(
    r'onCreateView',
    r'(Ljava/lang/String;Landroid/content/Context;Landroid/util/AttributeSet;)Landroid/view/View;',
  );

  static final _onCreateView = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(java.lang.String string, android.content.Context context, android.util.AttributeSet attributeSet)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateView(
    jni.JString string,
    Context context,
    jni.JObject attributeSet,
  ) {
    return _onCreateView(
            reference.pointer,
            _id_onCreateView as jni.JMethodIDPtr,
            string.reference.pointer,
            context.reference.pointer,
            attributeSet.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_onCreateView1 = _class.instanceMethodId(
    r'onCreateView',
    r'(Landroid/view/View;Ljava/lang/String;Landroid/content/Context;Landroid/util/AttributeSet;)Landroid/view/View;',
  );

  static final _onCreateView1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.View view, java.lang.String string, android.content.Context context, android.util.AttributeSet attributeSet)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onCreateView1(
    jni.JObject view,
    jni.JString string,
    Context context,
    jni.JObject attributeSet,
  ) {
    return _onCreateView1(
            reference.pointer,
            _id_onCreateView1 as jni.JMethodIDPtr,
            view.reference.pointer,
            string.reference.pointer,
            context.reference.pointer,
            attributeSet.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_dump = _class.instanceMethodId(
    r'dump',
    r'(Ljava/lang/String;Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V',
  );

  static final _dump = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String string, java.io.FileDescriptor fileDescriptor, java.io.PrintWriter printWriter, java.lang.String[] strings)
  void dump(
    jni.JString string,
    jni.JObject fileDescriptor,
    jni.JObject printWriter,
    jni.JArray<jni.JString> strings,
  ) {
    _dump(
            reference.pointer,
            _id_dump as jni.JMethodIDPtr,
            string.reference.pointer,
            fileDescriptor.reference.pointer,
            printWriter.reference.pointer,
            strings.reference.pointer)
        .check();
  }

  static final _id_isImmersive = _class.instanceMethodId(
    r'isImmersive',
    r'()Z',
  );

  static final _isImmersive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isImmersive()
  bool isImmersive() {
    return _isImmersive(reference.pointer, _id_isImmersive as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setTranslucent = _class.instanceMethodId(
    r'setTranslucent',
    r'(Z)Z',
  );

  static final _setTranslucent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public boolean setTranslucent(boolean z)
  bool setTranslucent(
    bool z,
  ) {
    return _setTranslucent(reference.pointer,
            _id_setTranslucent as jni.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_requestVisibleBehind = _class.instanceMethodId(
    r'requestVisibleBehind',
    r'(Z)Z',
  );

  static final _requestVisibleBehind = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public boolean requestVisibleBehind(boolean z)
  bool requestVisibleBehind(
    bool z,
  ) {
    return _requestVisibleBehind(reference.pointer,
            _id_requestVisibleBehind as jni.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_onVisibleBehindCanceled = _class.instanceMethodId(
    r'onVisibleBehindCanceled',
    r'()V',
  );

  static final _onVisibleBehindCanceled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onVisibleBehindCanceled()
  void onVisibleBehindCanceled() {
    _onVisibleBehindCanceled(
            reference.pointer, _id_onVisibleBehindCanceled as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onEnterAnimationComplete = _class.instanceMethodId(
    r'onEnterAnimationComplete',
    r'()V',
  );

  static final _onEnterAnimationComplete = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onEnterAnimationComplete()
  void onEnterAnimationComplete() {
    _onEnterAnimationComplete(
            reference.pointer, _id_onEnterAnimationComplete as jni.JMethodIDPtr)
        .check();
  }

  static final _id_setImmersive = _class.instanceMethodId(
    r'setImmersive',
    r'(Z)V',
  );

  static final _setImmersive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImmersive(boolean z)
  void setImmersive(
    bool z,
  ) {
    _setImmersive(
            reference.pointer, _id_setImmersive as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setVrModeEnabled = _class.instanceMethodId(
    r'setVrModeEnabled',
    r'(ZLandroid/content/ComponentName;)V',
  );

  static final _setVrModeEnabled = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setVrModeEnabled(boolean z, android.content.ComponentName componentName)
  void setVrModeEnabled(
    bool z,
    jni.JObject componentName,
  ) {
    _setVrModeEnabled(
            reference.pointer,
            _id_setVrModeEnabled as jni.JMethodIDPtr,
            z ? 1 : 0,
            componentName.reference.pointer)
        .check();
  }

  static final _id_startActionMode = _class.instanceMethodId(
    r'startActionMode',
    r'(Landroid/view/ActionMode$Callback;)Landroid/view/ActionMode;',
  );

  static final _startActionMode = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode$Callback callback)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startActionMode(
    jni.JObject callback,
  ) {
    return _startActionMode(reference.pointer,
            _id_startActionMode as jni.JMethodIDPtr, callback.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_startActionMode1 = _class.instanceMethodId(
    r'startActionMode',
    r'(Landroid/view/ActionMode$Callback;I)Landroid/view/ActionMode;',
  );

  static final _startActionMode1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode$Callback callback, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startActionMode1(
    jni.JObject callback,
    int i,
  ) {
    return _startActionMode1(
            reference.pointer,
            _id_startActionMode1 as jni.JMethodIDPtr,
            callback.reference.pointer,
            i)
        .object(const jni.JObjectType());
  }

  static final _id_onWindowStartingActionMode = _class.instanceMethodId(
    r'onWindowStartingActionMode',
    r'(Landroid/view/ActionMode$Callback;)Landroid/view/ActionMode;',
  );

  static final _onWindowStartingActionMode = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode$Callback callback)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onWindowStartingActionMode(
    jni.JObject callback,
  ) {
    return _onWindowStartingActionMode(
            reference.pointer,
            _id_onWindowStartingActionMode as jni.JMethodIDPtr,
            callback.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_onWindowStartingActionMode1 = _class.instanceMethodId(
    r'onWindowStartingActionMode',
    r'(Landroid/view/ActionMode$Callback;I)Landroid/view/ActionMode;',
  );

  static final _onWindowStartingActionMode1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode$Callback callback, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject onWindowStartingActionMode1(
    jni.JObject callback,
    int i,
  ) {
    return _onWindowStartingActionMode1(
            reference.pointer,
            _id_onWindowStartingActionMode1 as jni.JMethodIDPtr,
            callback.reference.pointer,
            i)
        .object(const jni.JObjectType());
  }

  static final _id_onActionModeStarted = _class.instanceMethodId(
    r'onActionModeStarted',
    r'(Landroid/view/ActionMode;)V',
  );

  static final _onActionModeStarted = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeStarted(android.view.ActionMode actionMode)
  void onActionModeStarted(
    jni.JObject actionMode,
  ) {
    _onActionModeStarted(
            reference.pointer,
            _id_onActionModeStarted as jni.JMethodIDPtr,
            actionMode.reference.pointer)
        .check();
  }

  static final _id_onActionModeFinished = _class.instanceMethodId(
    r'onActionModeFinished',
    r'(Landroid/view/ActionMode;)V',
  );

  static final _onActionModeFinished = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeFinished(android.view.ActionMode actionMode)
  void onActionModeFinished(
    jni.JObject actionMode,
  ) {
    _onActionModeFinished(
            reference.pointer,
            _id_onActionModeFinished as jni.JMethodIDPtr,
            actionMode.reference.pointer)
        .check();
  }

  static final _id_shouldUpRecreateTask = _class.instanceMethodId(
    r'shouldUpRecreateTask',
    r'(Landroid/content/Intent;)Z',
  );

  static final _shouldUpRecreateTask = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldUpRecreateTask(android.content.Intent intent)
  bool shouldUpRecreateTask(
    jni.JObject intent,
  ) {
    return _shouldUpRecreateTask(
            reference.pointer,
            _id_shouldUpRecreateTask as jni.JMethodIDPtr,
            intent.reference.pointer)
        .boolean;
  }

  static final _id_navigateUpTo = _class.instanceMethodId(
    r'navigateUpTo',
    r'(Landroid/content/Intent;)Z',
  );

  static final _navigateUpTo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean navigateUpTo(android.content.Intent intent)
  bool navigateUpTo(
    jni.JObject intent,
  ) {
    return _navigateUpTo(reference.pointer,
            _id_navigateUpTo as jni.JMethodIDPtr, intent.reference.pointer)
        .boolean;
  }

  static final _id_navigateUpToFromChild = _class.instanceMethodId(
    r'navigateUpToFromChild',
    r'(Landroid/app/Activity;Landroid/content/Intent;)Z',
  );

  static final _navigateUpToFromChild = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean navigateUpToFromChild(android.app.Activity activity, android.content.Intent intent)
  bool navigateUpToFromChild(
    Activity activity,
    jni.JObject intent,
  ) {
    return _navigateUpToFromChild(
            reference.pointer,
            _id_navigateUpToFromChild as jni.JMethodIDPtr,
            activity.reference.pointer,
            intent.reference.pointer)
        .boolean;
  }

  static final _id_getParentActivityIntent = _class.instanceMethodId(
    r'getParentActivityIntent',
    r'()Landroid/content/Intent;',
  );

  static final _getParentActivityIntent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.content.Intent getParentActivityIntent()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getParentActivityIntent() {
    return _getParentActivityIntent(
            reference.pointer, _id_getParentActivityIntent as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setEnterSharedElementCallback = _class.instanceMethodId(
    r'setEnterSharedElementCallback',
    r'(Landroid/app/SharedElementCallback;)V',
  );

  static final _setEnterSharedElementCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setEnterSharedElementCallback(android.app.SharedElementCallback sharedElementCallback)
  void setEnterSharedElementCallback(
    jni.JObject sharedElementCallback,
  ) {
    _setEnterSharedElementCallback(
            reference.pointer,
            _id_setEnterSharedElementCallback as jni.JMethodIDPtr,
            sharedElementCallback.reference.pointer)
        .check();
  }

  static final _id_setExitSharedElementCallback = _class.instanceMethodId(
    r'setExitSharedElementCallback',
    r'(Landroid/app/SharedElementCallback;)V',
  );

  static final _setExitSharedElementCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setExitSharedElementCallback(android.app.SharedElementCallback sharedElementCallback)
  void setExitSharedElementCallback(
    jni.JObject sharedElementCallback,
  ) {
    _setExitSharedElementCallback(
            reference.pointer,
            _id_setExitSharedElementCallback as jni.JMethodIDPtr,
            sharedElementCallback.reference.pointer)
        .check();
  }

  static final _id_postponeEnterTransition = _class.instanceMethodId(
    r'postponeEnterTransition',
    r'()V',
  );

  static final _postponeEnterTransition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void postponeEnterTransition()
  void postponeEnterTransition() {
    _postponeEnterTransition(
            reference.pointer, _id_postponeEnterTransition as jni.JMethodIDPtr)
        .check();
  }

  static final _id_startPostponedEnterTransition = _class.instanceMethodId(
    r'startPostponedEnterTransition',
    r'()V',
  );

  static final _startPostponedEnterTransition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void startPostponedEnterTransition()
  void startPostponedEnterTransition() {
    _startPostponedEnterTransition(reference.pointer,
            _id_startPostponedEnterTransition as jni.JMethodIDPtr)
        .check();
  }

  static final _id_requestDragAndDropPermissions = _class.instanceMethodId(
    r'requestDragAndDropPermissions',
    r'(Landroid/view/DragEvent;)Landroid/view/DragAndDropPermissions;',
  );

  static final _requestDragAndDropPermissions = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.DragAndDropPermissions requestDragAndDropPermissions(android.view.DragEvent dragEvent)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject requestDragAndDropPermissions(
    jni.JObject dragEvent,
  ) {
    return _requestDragAndDropPermissions(
            reference.pointer,
            _id_requestDragAndDropPermissions as jni.JMethodIDPtr,
            dragEvent.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_startLockTask = _class.instanceMethodId(
    r'startLockTask',
    r'()V',
  );

  static final _startLockTask = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void startLockTask()
  void startLockTask() {
    _startLockTask(reference.pointer, _id_startLockTask as jni.JMethodIDPtr)
        .check();
  }

  static final _id_stopLockTask = _class.instanceMethodId(
    r'stopLockTask',
    r'()V',
  );

  static final _stopLockTask = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void stopLockTask()
  void stopLockTask() {
    _stopLockTask(reference.pointer, _id_stopLockTask as jni.JMethodIDPtr)
        .check();
  }

  static final _id_showLockTaskEscapeMessage = _class.instanceMethodId(
    r'showLockTaskEscapeMessage',
    r'()V',
  );

  static final _showLockTaskEscapeMessage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void showLockTaskEscapeMessage()
  void showLockTaskEscapeMessage() {
    _showLockTaskEscapeMessage(reference.pointer,
            _id_showLockTaskEscapeMessage as jni.JMethodIDPtr)
        .check();
  }

  static final _id_setRecentsScreenshotEnabled = _class.instanceMethodId(
    r'setRecentsScreenshotEnabled',
    r'(Z)V',
  );

  static final _setRecentsScreenshotEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setRecentsScreenshotEnabled(boolean z)
  void setRecentsScreenshotEnabled(
    bool z,
  ) {
    _setRecentsScreenshotEnabled(reference.pointer,
            _id_setRecentsScreenshotEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setShowWhenLocked = _class.instanceMethodId(
    r'setShowWhenLocked',
    r'(Z)V',
  );

  static final _setShowWhenLocked = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setShowWhenLocked(boolean z)
  void setShowWhenLocked(
    bool z,
  ) {
    _setShowWhenLocked(reference.pointer,
            _id_setShowWhenLocked as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setInheritShowWhenLocked = _class.instanceMethodId(
    r'setInheritShowWhenLocked',
    r'(Z)V',
  );

  static final _setInheritShowWhenLocked = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setInheritShowWhenLocked(boolean z)
  void setInheritShowWhenLocked(
    bool z,
  ) {
    _setInheritShowWhenLocked(reference.pointer,
            _id_setInheritShowWhenLocked as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setTurnScreenOn = _class.instanceMethodId(
    r'setTurnScreenOn',
    r'(Z)V',
  );

  static final _setTurnScreenOn = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setTurnScreenOn(boolean z)
  void setTurnScreenOn(
    bool z,
  ) {
    _setTurnScreenOn(reference.pointer, _id_setTurnScreenOn as jni.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_getOnBackInvokedDispatcher = _class.instanceMethodId(
    r'getOnBackInvokedDispatcher',
    r'()Landroid/window/OnBackInvokedDispatcher;',
  );

  static final _getOnBackInvokedDispatcher = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.window.OnBackInvokedDispatcher getOnBackInvokedDispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOnBackInvokedDispatcher() {
    return _getOnBackInvokedDispatcher(reference.pointer,
            _id_getOnBackInvokedDispatcher as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_registerScreenCaptureCallback = _class.instanceMethodId(
    r'registerScreenCaptureCallback',
    r'(Ljava/util/concurrent/Executor;Landroid/app/Activity$ScreenCaptureCallback;)V',
  );

  static final _registerScreenCaptureCallback = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerScreenCaptureCallback(java.util.concurrent.Executor executor, android.app.Activity$ScreenCaptureCallback screenCaptureCallback)
  void registerScreenCaptureCallback(
    Executor executor,
    Activity_ScreenCaptureCallback screenCaptureCallback,
  ) {
    _registerScreenCaptureCallback(
            reference.pointer,
            _id_registerScreenCaptureCallback as jni.JMethodIDPtr,
            executor.reference.pointer,
            screenCaptureCallback.reference.pointer)
        .check();
  }

  static final _id_unregisterScreenCaptureCallback = _class.instanceMethodId(
    r'unregisterScreenCaptureCallback',
    r'(Landroid/app/Activity$ScreenCaptureCallback;)V',
  );

  static final _unregisterScreenCaptureCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterScreenCaptureCallback(android.app.Activity$ScreenCaptureCallback screenCaptureCallback)
  void unregisterScreenCaptureCallback(
    Activity_ScreenCaptureCallback screenCaptureCallback,
  ) {
    _unregisterScreenCaptureCallback(
            reference.pointer,
            _id_unregisterScreenCaptureCallback as jni.JMethodIDPtr,
            screenCaptureCallback.reference.pointer)
        .check();
  }
}

final class $ActivityType extends jni.JObjType<Activity> {
  const $ActivityType();

  @override
  String get signature => r'Landroid/app/Activity;';

  @override
  Activity fromReference(jni.JReference reference) =>
      Activity.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ActivityType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityType) && other is $ActivityType;
  }
}

/// from: android.content.Context$BindServiceFlags
class Context_BindServiceFlags extends jni.JObject {
  @override
  late final jni.JObjType<Context_BindServiceFlags> $type = type;

  Context_BindServiceFlags.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/content/Context$BindServiceFlags');

  /// The type which includes information such as the signature of this class.
  static const type = $Context_BindServiceFlagsType();
  static final _id_of = _class.staticMethodId(
    r'of',
    r'(J)Landroid/content/Context$BindServiceFlags;',
  );

  static final _of = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr, ffi.VarArgs<(ffi.Int64,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public android.content.Context$BindServiceFlags of(long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Context_BindServiceFlags of(
    int j,
  ) {
    return _of(_class.reference.pointer, _id_of as jni.JMethodIDPtr, j)
        .object(const $Context_BindServiceFlagsType());
  }
}

final class $Context_BindServiceFlagsType
    extends jni.JObjType<Context_BindServiceFlags> {
  const $Context_BindServiceFlagsType();

  @override
  String get signature => r'Landroid/content/Context$BindServiceFlags;';

  @override
  Context_BindServiceFlags fromReference(jni.JReference reference) =>
      Context_BindServiceFlags.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Context_BindServiceFlagsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context_BindServiceFlagsType) &&
        other is $Context_BindServiceFlagsType;
  }
}

/// from: android.content.Context
class Context extends jni.JObject {
  @override
  late final jni.JObjType<Context> $type = type;

  Context.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/content/Context');

  /// The type which includes information such as the signature of this class.
  static const type = $ContextType();
  static final _id_ACCESSIBILITY_SERVICE = _class.staticFieldId(
    r'ACCESSIBILITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCESSIBILITY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCESSIBILITY_SERVICE =>
      _id_ACCESSIBILITY_SERVICE.get(_class, const jni.JStringType());

  static final _id_ACCOUNT_SERVICE = _class.staticFieldId(
    r'ACCOUNT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACCOUNT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACCOUNT_SERVICE =>
      _id_ACCOUNT_SERVICE.get(_class, const jni.JStringType());

  static final _id_ACTIVITY_SERVICE = _class.staticFieldId(
    r'ACTIVITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTIVITY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTIVITY_SERVICE =>
      _id_ACTIVITY_SERVICE.get(_class, const jni.JStringType());

  static final _id_ALARM_SERVICE = _class.staticFieldId(
    r'ALARM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALARM_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALARM_SERVICE =>
      _id_ALARM_SERVICE.get(_class, const jni.JStringType());

  static final _id_APPWIDGET_SERVICE = _class.staticFieldId(
    r'APPWIDGET_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String APPWIDGET_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get APPWIDGET_SERVICE =>
      _id_APPWIDGET_SERVICE.get(_class, const jni.JStringType());

  static final _id_APP_OPS_SERVICE = _class.staticFieldId(
    r'APP_OPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String APP_OPS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get APP_OPS_SERVICE =>
      _id_APP_OPS_SERVICE.get(_class, const jni.JStringType());

  static final _id_APP_SEARCH_SERVICE = _class.staticFieldId(
    r'APP_SEARCH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String APP_SEARCH_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get APP_SEARCH_SERVICE =>
      _id_APP_SEARCH_SERVICE.get(_class, const jni.JStringType());

  static final _id_AUDIO_SERVICE = _class.staticFieldId(
    r'AUDIO_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String AUDIO_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUDIO_SERVICE =>
      _id_AUDIO_SERVICE.get(_class, const jni.JStringType());

  static final _id_BATTERY_SERVICE = _class.staticFieldId(
    r'BATTERY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BATTERY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BATTERY_SERVICE =>
      _id_BATTERY_SERVICE.get(_class, const jni.JStringType());

  /// from: static public final int BIND_ABOVE_CLIENT
  static const BIND_ABOVE_CLIENT = 8;

  /// from: static public final int BIND_ADJUST_WITH_ACTIVITY
  static const BIND_ADJUST_WITH_ACTIVITY = 128;

  /// from: static public final int BIND_ALLOW_ACTIVITY_STARTS
  static const BIND_ALLOW_ACTIVITY_STARTS = 512;

  /// from: static public final int BIND_ALLOW_OOM_MANAGEMENT
  static const BIND_ALLOW_OOM_MANAGEMENT = 16;

  /// from: static public final int BIND_AUTO_CREATE
  static const BIND_AUTO_CREATE = 1;

  /// from: static public final int BIND_DEBUG_UNBIND
  static const BIND_DEBUG_UNBIND = 2;

  /// from: static public final int BIND_EXTERNAL_SERVICE
  static const BIND_EXTERNAL_SERVICE = -2147483648;

  /// from: static public final long BIND_EXTERNAL_SERVICE_LONG
  static const BIND_EXTERNAL_SERVICE_LONG = 4611686018427387904;

  /// from: static public final int BIND_IMPORTANT
  static const BIND_IMPORTANT = 64;

  /// from: static public final int BIND_INCLUDE_CAPABILITIES
  static const BIND_INCLUDE_CAPABILITIES = 4096;

  /// from: static public final int BIND_NOT_FOREGROUND
  static const BIND_NOT_FOREGROUND = 4;

  /// from: static public final int BIND_NOT_PERCEPTIBLE
  static const BIND_NOT_PERCEPTIBLE = 256;

  /// from: static public final int BIND_SHARED_ISOLATED_PROCESS
  static const BIND_SHARED_ISOLATED_PROCESS = 8192;

  /// from: static public final int BIND_WAIVE_PRIORITY
  static const BIND_WAIVE_PRIORITY = 32;
  static final _id_BIOMETRIC_SERVICE = _class.staticFieldId(
    r'BIOMETRIC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BIOMETRIC_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BIOMETRIC_SERVICE =>
      _id_BIOMETRIC_SERVICE.get(_class, const jni.JStringType());

  static final _id_BLOB_STORE_SERVICE = _class.staticFieldId(
    r'BLOB_STORE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BLOB_STORE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BLOB_STORE_SERVICE =>
      _id_BLOB_STORE_SERVICE.get(_class, const jni.JStringType());

  static final _id_BLUETOOTH_SERVICE = _class.staticFieldId(
    r'BLUETOOTH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BLUETOOTH_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BLUETOOTH_SERVICE =>
      _id_BLUETOOTH_SERVICE.get(_class, const jni.JStringType());

  static final _id_BUGREPORT_SERVICE = _class.staticFieldId(
    r'BUGREPORT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BUGREPORT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BUGREPORT_SERVICE =>
      _id_BUGREPORT_SERVICE.get(_class, const jni.JStringType());

  static final _id_CAMERA_SERVICE = _class.staticFieldId(
    r'CAMERA_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CAMERA_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CAMERA_SERVICE =>
      _id_CAMERA_SERVICE.get(_class, const jni.JStringType());

  static final _id_CAPTIONING_SERVICE = _class.staticFieldId(
    r'CAPTIONING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CAPTIONING_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CAPTIONING_SERVICE =>
      _id_CAPTIONING_SERVICE.get(_class, const jni.JStringType());

  static final _id_CARRIER_CONFIG_SERVICE = _class.staticFieldId(
    r'CARRIER_CONFIG_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CARRIER_CONFIG_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CARRIER_CONFIG_SERVICE =>
      _id_CARRIER_CONFIG_SERVICE.get(_class, const jni.JStringType());

  static final _id_CLIPBOARD_SERVICE = _class.staticFieldId(
    r'CLIPBOARD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CLIPBOARD_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CLIPBOARD_SERVICE =>
      _id_CLIPBOARD_SERVICE.get(_class, const jni.JStringType());

  static final _id_COMPANION_DEVICE_SERVICE = _class.staticFieldId(
    r'COMPANION_DEVICE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String COMPANION_DEVICE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get COMPANION_DEVICE_SERVICE =>
      _id_COMPANION_DEVICE_SERVICE.get(_class, const jni.JStringType());

  static final _id_CONNECTIVITY_DIAGNOSTICS_SERVICE = _class.staticFieldId(
    r'CONNECTIVITY_DIAGNOSTICS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONNECTIVITY_DIAGNOSTICS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONNECTIVITY_DIAGNOSTICS_SERVICE =>
      _id_CONNECTIVITY_DIAGNOSTICS_SERVICE.get(_class, const jni.JStringType());

  static final _id_CONNECTIVITY_SERVICE = _class.staticFieldId(
    r'CONNECTIVITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONNECTIVITY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONNECTIVITY_SERVICE =>
      _id_CONNECTIVITY_SERVICE.get(_class, const jni.JStringType());

  static final _id_CONSUMER_IR_SERVICE = _class.staticFieldId(
    r'CONSUMER_IR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONSUMER_IR_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONSUMER_IR_SERVICE =>
      _id_CONSUMER_IR_SERVICE.get(_class, const jni.JStringType());

  /// from: static public final int CONTEXT_IGNORE_SECURITY
  static const CONTEXT_IGNORE_SECURITY = 2;

  /// from: static public final int CONTEXT_INCLUDE_CODE
  static const CONTEXT_INCLUDE_CODE = 1;

  /// from: static public final int CONTEXT_RESTRICTED
  static const CONTEXT_RESTRICTED = 4;
  static final _id_CREDENTIAL_SERVICE = _class.staticFieldId(
    r'CREDENTIAL_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CREDENTIAL_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CREDENTIAL_SERVICE =>
      _id_CREDENTIAL_SERVICE.get(_class, const jni.JStringType());

  static final _id_CROSS_PROFILE_APPS_SERVICE = _class.staticFieldId(
    r'CROSS_PROFILE_APPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CROSS_PROFILE_APPS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CROSS_PROFILE_APPS_SERVICE =>
      _id_CROSS_PROFILE_APPS_SERVICE.get(_class, const jni.JStringType());

  /// from: static public final int DEVICE_ID_DEFAULT
  static const DEVICE_ID_DEFAULT = 0;

  /// from: static public final int DEVICE_ID_INVALID
  static const DEVICE_ID_INVALID = -1;
  static final _id_DEVICE_LOCK_SERVICE = _class.staticFieldId(
    r'DEVICE_LOCK_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEVICE_LOCK_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEVICE_LOCK_SERVICE =>
      _id_DEVICE_LOCK_SERVICE.get(_class, const jni.JStringType());

  static final _id_DEVICE_POLICY_SERVICE = _class.staticFieldId(
    r'DEVICE_POLICY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEVICE_POLICY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEVICE_POLICY_SERVICE =>
      _id_DEVICE_POLICY_SERVICE.get(_class, const jni.JStringType());

  static final _id_DISPLAY_HASH_SERVICE = _class.staticFieldId(
    r'DISPLAY_HASH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DISPLAY_HASH_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DISPLAY_HASH_SERVICE =>
      _id_DISPLAY_HASH_SERVICE.get(_class, const jni.JStringType());

  static final _id_DISPLAY_SERVICE = _class.staticFieldId(
    r'DISPLAY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DISPLAY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DISPLAY_SERVICE =>
      _id_DISPLAY_SERVICE.get(_class, const jni.JStringType());

  static final _id_DOMAIN_VERIFICATION_SERVICE = _class.staticFieldId(
    r'DOMAIN_VERIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DOMAIN_VERIFICATION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DOMAIN_VERIFICATION_SERVICE =>
      _id_DOMAIN_VERIFICATION_SERVICE.get(_class, const jni.JStringType());

  static final _id_DOWNLOAD_SERVICE = _class.staticFieldId(
    r'DOWNLOAD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DOWNLOAD_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DOWNLOAD_SERVICE =>
      _id_DOWNLOAD_SERVICE.get(_class, const jni.JStringType());

  static final _id_DROPBOX_SERVICE = _class.staticFieldId(
    r'DROPBOX_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DROPBOX_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DROPBOX_SERVICE =>
      _id_DROPBOX_SERVICE.get(_class, const jni.JStringType());

  static final _id_EUICC_SERVICE = _class.staticFieldId(
    r'EUICC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EUICC_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EUICC_SERVICE =>
      _id_EUICC_SERVICE.get(_class, const jni.JStringType());

  static final _id_FILE_INTEGRITY_SERVICE = _class.staticFieldId(
    r'FILE_INTEGRITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FILE_INTEGRITY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FILE_INTEGRITY_SERVICE =>
      _id_FILE_INTEGRITY_SERVICE.get(_class, const jni.JStringType());

  static final _id_FINGERPRINT_SERVICE = _class.staticFieldId(
    r'FINGERPRINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FINGERPRINT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FINGERPRINT_SERVICE =>
      _id_FINGERPRINT_SERVICE.get(_class, const jni.JStringType());

  static final _id_GAME_SERVICE = _class.staticFieldId(
    r'GAME_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GAME_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GAME_SERVICE =>
      _id_GAME_SERVICE.get(_class, const jni.JStringType());

  static final _id_GRAMMATICAL_INFLECTION_SERVICE = _class.staticFieldId(
    r'GRAMMATICAL_INFLECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GRAMMATICAL_INFLECTION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GRAMMATICAL_INFLECTION_SERVICE =>
      _id_GRAMMATICAL_INFLECTION_SERVICE.get(_class, const jni.JStringType());

  static final _id_HARDWARE_PROPERTIES_SERVICE = _class.staticFieldId(
    r'HARDWARE_PROPERTIES_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String HARDWARE_PROPERTIES_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HARDWARE_PROPERTIES_SERVICE =>
      _id_HARDWARE_PROPERTIES_SERVICE.get(_class, const jni.JStringType());

  static final _id_HEALTHCONNECT_SERVICE = _class.staticFieldId(
    r'HEALTHCONNECT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String HEALTHCONNECT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HEALTHCONNECT_SERVICE =>
      _id_HEALTHCONNECT_SERVICE.get(_class, const jni.JStringType());

  static final _id_INPUT_METHOD_SERVICE = _class.staticFieldId(
    r'INPUT_METHOD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INPUT_METHOD_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INPUT_METHOD_SERVICE =>
      _id_INPUT_METHOD_SERVICE.get(_class, const jni.JStringType());

  static final _id_INPUT_SERVICE = _class.staticFieldId(
    r'INPUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INPUT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INPUT_SERVICE =>
      _id_INPUT_SERVICE.get(_class, const jni.JStringType());

  static final _id_IPSEC_SERVICE = _class.staticFieldId(
    r'IPSEC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IPSEC_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IPSEC_SERVICE =>
      _id_IPSEC_SERVICE.get(_class, const jni.JStringType());

  static final _id_JOB_SCHEDULER_SERVICE = _class.staticFieldId(
    r'JOB_SCHEDULER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String JOB_SCHEDULER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get JOB_SCHEDULER_SERVICE =>
      _id_JOB_SCHEDULER_SERVICE.get(_class, const jni.JStringType());

  static final _id_KEYGUARD_SERVICE = _class.staticFieldId(
    r'KEYGUARD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String KEYGUARD_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get KEYGUARD_SERVICE =>
      _id_KEYGUARD_SERVICE.get(_class, const jni.JStringType());

  static final _id_LAUNCHER_APPS_SERVICE = _class.staticFieldId(
    r'LAUNCHER_APPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LAUNCHER_APPS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LAUNCHER_APPS_SERVICE =>
      _id_LAUNCHER_APPS_SERVICE.get(_class, const jni.JStringType());

  static final _id_LAYOUT_INFLATER_SERVICE = _class.staticFieldId(
    r'LAYOUT_INFLATER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LAYOUT_INFLATER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LAYOUT_INFLATER_SERVICE =>
      _id_LAYOUT_INFLATER_SERVICE.get(_class, const jni.JStringType());

  static final _id_LOCALE_SERVICE = _class.staticFieldId(
    r'LOCALE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LOCALE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LOCALE_SERVICE =>
      _id_LOCALE_SERVICE.get(_class, const jni.JStringType());

  static final _id_LOCATION_SERVICE = _class.staticFieldId(
    r'LOCATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LOCATION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LOCATION_SERVICE =>
      _id_LOCATION_SERVICE.get(_class, const jni.JStringType());

  static final _id_MEDIA_COMMUNICATION_SERVICE = _class.staticFieldId(
    r'MEDIA_COMMUNICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_COMMUNICATION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_COMMUNICATION_SERVICE =>
      _id_MEDIA_COMMUNICATION_SERVICE.get(_class, const jni.JStringType());

  static final _id_MEDIA_METRICS_SERVICE = _class.staticFieldId(
    r'MEDIA_METRICS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_METRICS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_METRICS_SERVICE =>
      _id_MEDIA_METRICS_SERVICE.get(_class, const jni.JStringType());

  static final _id_MEDIA_PROJECTION_SERVICE = _class.staticFieldId(
    r'MEDIA_PROJECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_PROJECTION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_PROJECTION_SERVICE =>
      _id_MEDIA_PROJECTION_SERVICE.get(_class, const jni.JStringType());

  static final _id_MEDIA_ROUTER_SERVICE = _class.staticFieldId(
    r'MEDIA_ROUTER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_ROUTER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_ROUTER_SERVICE =>
      _id_MEDIA_ROUTER_SERVICE.get(_class, const jni.JStringType());

  static final _id_MEDIA_SESSION_SERVICE = _class.staticFieldId(
    r'MEDIA_SESSION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_SESSION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_SESSION_SERVICE =>
      _id_MEDIA_SESSION_SERVICE.get(_class, const jni.JStringType());

  static final _id_MIDI_SERVICE = _class.staticFieldId(
    r'MIDI_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MIDI_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MIDI_SERVICE =>
      _id_MIDI_SERVICE.get(_class, const jni.JStringType());

  /// from: static public final int MODE_APPEND
  static const MODE_APPEND = 32768;

  /// from: static public final int MODE_ENABLE_WRITE_AHEAD_LOGGING
  static const MODE_ENABLE_WRITE_AHEAD_LOGGING = 8;

  /// from: static public final int MODE_MULTI_PROCESS
  static const MODE_MULTI_PROCESS = 4;

  /// from: static public final int MODE_NO_LOCALIZED_COLLATORS
  static const MODE_NO_LOCALIZED_COLLATORS = 16;

  /// from: static public final int MODE_PRIVATE
  static const MODE_PRIVATE = 0;

  /// from: static public final int MODE_WORLD_READABLE
  static const MODE_WORLD_READABLE = 1;

  /// from: static public final int MODE_WORLD_WRITEABLE
  static const MODE_WORLD_WRITEABLE = 2;
  static final _id_NETWORK_STATS_SERVICE = _class.staticFieldId(
    r'NETWORK_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NETWORK_STATS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NETWORK_STATS_SERVICE =>
      _id_NETWORK_STATS_SERVICE.get(_class, const jni.JStringType());

  static final _id_NFC_SERVICE = _class.staticFieldId(
    r'NFC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NFC_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NFC_SERVICE =>
      _id_NFC_SERVICE.get(_class, const jni.JStringType());

  static final _id_NOTIFICATION_SERVICE = _class.staticFieldId(
    r'NOTIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NOTIFICATION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NOTIFICATION_SERVICE =>
      _id_NOTIFICATION_SERVICE.get(_class, const jni.JStringType());

  static final _id_NSD_SERVICE = _class.staticFieldId(
    r'NSD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NSD_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NSD_SERVICE =>
      _id_NSD_SERVICE.get(_class, const jni.JStringType());

  static final _id_OVERLAY_SERVICE = _class.staticFieldId(
    r'OVERLAY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String OVERLAY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get OVERLAY_SERVICE =>
      _id_OVERLAY_SERVICE.get(_class, const jni.JStringType());

  static final _id_PEOPLE_SERVICE = _class.staticFieldId(
    r'PEOPLE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PEOPLE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PEOPLE_SERVICE =>
      _id_PEOPLE_SERVICE.get(_class, const jni.JStringType());

  static final _id_PERFORMANCE_HINT_SERVICE = _class.staticFieldId(
    r'PERFORMANCE_HINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PERFORMANCE_HINT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PERFORMANCE_HINT_SERVICE =>
      _id_PERFORMANCE_HINT_SERVICE.get(_class, const jni.JStringType());

  static final _id_POWER_SERVICE = _class.staticFieldId(
    r'POWER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String POWER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get POWER_SERVICE =>
      _id_POWER_SERVICE.get(_class, const jni.JStringType());

  static final _id_PRINT_SERVICE = _class.staticFieldId(
    r'PRINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PRINT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PRINT_SERVICE =>
      _id_PRINT_SERVICE.get(_class, const jni.JStringType());

  /// from: static public final int RECEIVER_EXPORTED
  static const RECEIVER_EXPORTED = 2;

  /// from: static public final int RECEIVER_NOT_EXPORTED
  static const RECEIVER_NOT_EXPORTED = 4;

  /// from: static public final int RECEIVER_VISIBLE_TO_INSTANT_APPS
  static const RECEIVER_VISIBLE_TO_INSTANT_APPS = 1;
  static final _id_RESTRICTIONS_SERVICE = _class.staticFieldId(
    r'RESTRICTIONS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RESTRICTIONS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RESTRICTIONS_SERVICE =>
      _id_RESTRICTIONS_SERVICE.get(_class, const jni.JStringType());

  static final _id_ROLE_SERVICE = _class.staticFieldId(
    r'ROLE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ROLE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ROLE_SERVICE =>
      _id_ROLE_SERVICE.get(_class, const jni.JStringType());

  static final _id_SEARCH_SERVICE = _class.staticFieldId(
    r'SEARCH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SEARCH_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SEARCH_SERVICE =>
      _id_SEARCH_SERVICE.get(_class, const jni.JStringType());

  static final _id_SENSOR_SERVICE = _class.staticFieldId(
    r'SENSOR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SENSOR_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SENSOR_SERVICE =>
      _id_SENSOR_SERVICE.get(_class, const jni.JStringType());

  static final _id_SHORTCUT_SERVICE = _class.staticFieldId(
    r'SHORTCUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SHORTCUT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SHORTCUT_SERVICE =>
      _id_SHORTCUT_SERVICE.get(_class, const jni.JStringType());

  static final _id_STATUS_BAR_SERVICE = _class.staticFieldId(
    r'STATUS_BAR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String STATUS_BAR_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get STATUS_BAR_SERVICE =>
      _id_STATUS_BAR_SERVICE.get(_class, const jni.JStringType());

  static final _id_STORAGE_SERVICE = _class.staticFieldId(
    r'STORAGE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String STORAGE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get STORAGE_SERVICE =>
      _id_STORAGE_SERVICE.get(_class, const jni.JStringType());

  static final _id_STORAGE_STATS_SERVICE = _class.staticFieldId(
    r'STORAGE_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String STORAGE_STATS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get STORAGE_STATS_SERVICE =>
      _id_STORAGE_STATS_SERVICE.get(_class, const jni.JStringType());

  static final _id_SYSTEM_HEALTH_SERVICE = _class.staticFieldId(
    r'SYSTEM_HEALTH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYSTEM_HEALTH_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYSTEM_HEALTH_SERVICE =>
      _id_SYSTEM_HEALTH_SERVICE.get(_class, const jni.JStringType());

  static final _id_TELECOM_SERVICE = _class.staticFieldId(
    r'TELECOM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TELECOM_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TELECOM_SERVICE =>
      _id_TELECOM_SERVICE.get(_class, const jni.JStringType());

  static final _id_TELEPHONY_IMS_SERVICE = _class.staticFieldId(
    r'TELEPHONY_IMS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TELEPHONY_IMS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TELEPHONY_IMS_SERVICE =>
      _id_TELEPHONY_IMS_SERVICE.get(_class, const jni.JStringType());

  static final _id_TELEPHONY_SERVICE = _class.staticFieldId(
    r'TELEPHONY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TELEPHONY_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TELEPHONY_SERVICE =>
      _id_TELEPHONY_SERVICE.get(_class, const jni.JStringType());

  static final _id_TELEPHONY_SUBSCRIPTION_SERVICE = _class.staticFieldId(
    r'TELEPHONY_SUBSCRIPTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TELEPHONY_SUBSCRIPTION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TELEPHONY_SUBSCRIPTION_SERVICE =>
      _id_TELEPHONY_SUBSCRIPTION_SERVICE.get(_class, const jni.JStringType());

  static final _id_TEXT_CLASSIFICATION_SERVICE = _class.staticFieldId(
    r'TEXT_CLASSIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TEXT_CLASSIFICATION_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_CLASSIFICATION_SERVICE =>
      _id_TEXT_CLASSIFICATION_SERVICE.get(_class, const jni.JStringType());

  static final _id_TEXT_SERVICES_MANAGER_SERVICE = _class.staticFieldId(
    r'TEXT_SERVICES_MANAGER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TEXT_SERVICES_MANAGER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TEXT_SERVICES_MANAGER_SERVICE =>
      _id_TEXT_SERVICES_MANAGER_SERVICE.get(_class, const jni.JStringType());

  static final _id_TV_INPUT_SERVICE = _class.staticFieldId(
    r'TV_INPUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TV_INPUT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TV_INPUT_SERVICE =>
      _id_TV_INPUT_SERVICE.get(_class, const jni.JStringType());

  static final _id_TV_INTERACTIVE_APP_SERVICE = _class.staticFieldId(
    r'TV_INTERACTIVE_APP_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TV_INTERACTIVE_APP_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TV_INTERACTIVE_APP_SERVICE =>
      _id_TV_INTERACTIVE_APP_SERVICE.get(_class, const jni.JStringType());

  static final _id_UI_MODE_SERVICE = _class.staticFieldId(
    r'UI_MODE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String UI_MODE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get UI_MODE_SERVICE =>
      _id_UI_MODE_SERVICE.get(_class, const jni.JStringType());

  static final _id_USAGE_STATS_SERVICE = _class.staticFieldId(
    r'USAGE_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USAGE_STATS_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USAGE_STATS_SERVICE =>
      _id_USAGE_STATS_SERVICE.get(_class, const jni.JStringType());

  static final _id_USB_SERVICE = _class.staticFieldId(
    r'USB_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USB_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USB_SERVICE =>
      _id_USB_SERVICE.get(_class, const jni.JStringType());

  static final _id_USER_SERVICE = _class.staticFieldId(
    r'USER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String USER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USER_SERVICE =>
      _id_USER_SERVICE.get(_class, const jni.JStringType());

  static final _id_VIBRATOR_MANAGER_SERVICE = _class.staticFieldId(
    r'VIBRATOR_MANAGER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VIBRATOR_MANAGER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VIBRATOR_MANAGER_SERVICE =>
      _id_VIBRATOR_MANAGER_SERVICE.get(_class, const jni.JStringType());

  static final _id_VIBRATOR_SERVICE = _class.staticFieldId(
    r'VIBRATOR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VIBRATOR_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VIBRATOR_SERVICE =>
      _id_VIBRATOR_SERVICE.get(_class, const jni.JStringType());

  static final _id_VIRTUAL_DEVICE_SERVICE = _class.staticFieldId(
    r'VIRTUAL_DEVICE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VIRTUAL_DEVICE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VIRTUAL_DEVICE_SERVICE =>
      _id_VIRTUAL_DEVICE_SERVICE.get(_class, const jni.JStringType());

  static final _id_VPN_MANAGEMENT_SERVICE = _class.staticFieldId(
    r'VPN_MANAGEMENT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VPN_MANAGEMENT_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VPN_MANAGEMENT_SERVICE =>
      _id_VPN_MANAGEMENT_SERVICE.get(_class, const jni.JStringType());

  static final _id_WALLPAPER_SERVICE = _class.staticFieldId(
    r'WALLPAPER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WALLPAPER_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WALLPAPER_SERVICE =>
      _id_WALLPAPER_SERVICE.get(_class, const jni.JStringType());

  static final _id_WIFI_AWARE_SERVICE = _class.staticFieldId(
    r'WIFI_AWARE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WIFI_AWARE_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WIFI_AWARE_SERVICE =>
      _id_WIFI_AWARE_SERVICE.get(_class, const jni.JStringType());

  static final _id_WIFI_P2P_SERVICE = _class.staticFieldId(
    r'WIFI_P2P_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WIFI_P2P_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WIFI_P2P_SERVICE =>
      _id_WIFI_P2P_SERVICE.get(_class, const jni.JStringType());

  static final _id_WIFI_RTT_RANGING_SERVICE = _class.staticFieldId(
    r'WIFI_RTT_RANGING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WIFI_RTT_RANGING_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WIFI_RTT_RANGING_SERVICE =>
      _id_WIFI_RTT_RANGING_SERVICE.get(_class, const jni.JStringType());

  static final _id_WIFI_SERVICE = _class.staticFieldId(
    r'WIFI_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WIFI_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WIFI_SERVICE =>
      _id_WIFI_SERVICE.get(_class, const jni.JStringType());

  static final _id_WINDOW_SERVICE = _class.staticFieldId(
    r'WINDOW_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WINDOW_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WINDOW_SERVICE =>
      _id_WINDOW_SERVICE.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Context() {
    return Context.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getAssets = _class.instanceMethodId(
    r'getAssets',
    r'()Landroid/content/res/AssetManager;',
  );

  static final _getAssets = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.content.res.AssetManager getAssets()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAssets() {
    return _getAssets(reference.pointer, _id_getAssets as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getResources = _class.instanceMethodId(
    r'getResources',
    r'()Landroid/content/res/Resources;',
  );

  static final _getResources = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.content.res.Resources getResources()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getResources() {
    return _getResources(
            reference.pointer, _id_getResources as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getPackageManager = _class.instanceMethodId(
    r'getPackageManager',
    r'()Landroid/content/pm/PackageManager;',
  );

  static final _getPackageManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.content.pm.PackageManager getPackageManager()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getPackageManager() {
    return _getPackageManager(
            reference.pointer, _id_getPackageManager as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getContentResolver = _class.instanceMethodId(
    r'getContentResolver',
    r'()Landroid/content/ContentResolver;',
  );

  static final _getContentResolver = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.content.ContentResolver getContentResolver()
  /// The returned object must be released after use, by calling the [release] method.
  ContentResolver getContentResolver() {
    return _getContentResolver(
            reference.pointer, _id_getContentResolver as jni.JMethodIDPtr)
        .object(const $ContentResolverType());
  }

  static final _id_getMainLooper = _class.instanceMethodId(
    r'getMainLooper',
    r'()Landroid/os/Looper;',
  );

  static final _getMainLooper = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.os.Looper getMainLooper()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getMainLooper() {
    return _getMainLooper(
            reference.pointer, _id_getMainLooper as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getMainExecutor = _class.instanceMethodId(
    r'getMainExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getMainExecutor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.concurrent.Executor getMainExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  Executor getMainExecutor() {
    return _getMainExecutor(
            reference.pointer, _id_getMainExecutor as jni.JMethodIDPtr)
        .object(const $ExecutorType());
  }

  static final _id_getApplicationContext = _class.instanceMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.content.Context getApplicationContext()
  /// The returned object must be released after use, by calling the [release] method.
  Context getApplicationContext() {
    return _getApplicationContext(
            reference.pointer, _id_getApplicationContext as jni.JMethodIDPtr)
        .object(const $ContextType());
  }

  static final _id_registerComponentCallbacks = _class.instanceMethodId(
    r'registerComponentCallbacks',
    r'(Landroid/content/ComponentCallbacks;)V',
  );

  static final _registerComponentCallbacks = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void registerComponentCallbacks(android.content.ComponentCallbacks componentCallbacks)
  void registerComponentCallbacks(
    jni.JObject componentCallbacks,
  ) {
    _registerComponentCallbacks(
            reference.pointer,
            _id_registerComponentCallbacks as jni.JMethodIDPtr,
            componentCallbacks.reference.pointer)
        .check();
  }

  static final _id_unregisterComponentCallbacks = _class.instanceMethodId(
    r'unregisterComponentCallbacks',
    r'(Landroid/content/ComponentCallbacks;)V',
  );

  static final _unregisterComponentCallbacks = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterComponentCallbacks(android.content.ComponentCallbacks componentCallbacks)
  void unregisterComponentCallbacks(
    jni.JObject componentCallbacks,
  ) {
    _unregisterComponentCallbacks(
            reference.pointer,
            _id_unregisterComponentCallbacks as jni.JMethodIDPtr,
            componentCallbacks.reference.pointer)
        .check();
  }

  static final _id_getText = _class.instanceMethodId(
    r'getText',
    r'(I)Ljava/lang/CharSequence;',
  );

  static final _getText = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final java.lang.CharSequence getText(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getText(
    int i,
  ) {
    return _getText(reference.pointer, _id_getText as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_getString = _class.instanceMethodId(
    r'getString',
    r'(I)Ljava/lang/String;',
  );

  static final _getString = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final java.lang.String getString(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getString(
    int i,
  ) {
    return _getString(reference.pointer, _id_getString as jni.JMethodIDPtr, i)
        .object(const jni.JStringType());
  }

  static final _id_getString1 = _class.instanceMethodId(
    r'getString',
    r'(I[Ljava/lang/Object;)Ljava/lang/String;',
  );

  static final _getString1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getString(int i, java.lang.Object[] objects)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getString1(
    int i,
    jni.JArray<jni.JObject> objects,
  ) {
    return _getString1(reference.pointer, _id_getString1 as jni.JMethodIDPtr, i,
            objects.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getColor = _class.instanceMethodId(
    r'getColor',
    r'(I)I',
  );

  static final _getColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final int getColor(int i)
  int getColor(
    int i,
  ) {
    return _getColor(reference.pointer, _id_getColor as jni.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getDrawable = _class.instanceMethodId(
    r'getDrawable',
    r'(I)Landroid/graphics/drawable/Drawable;',
  );

  static final _getDrawable = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final android.graphics.drawable.Drawable getDrawable(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDrawable(
    int i,
  ) {
    return _getDrawable(
            reference.pointer, _id_getDrawable as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_getColorStateList = _class.instanceMethodId(
    r'getColorStateList',
    r'(I)Landroid/content/res/ColorStateList;',
  );

  static final _getColorStateList = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final android.content.res.ColorStateList getColorStateList(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getColorStateList(
    int i,
  ) {
    return _getColorStateList(
            reference.pointer, _id_getColorStateList as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_setTheme = _class.instanceMethodId(
    r'setTheme',
    r'(I)V',
  );

  static final _setTheme = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract void setTheme(int i)
  void setTheme(
    int i,
  ) {
    _setTheme(reference.pointer, _id_setTheme as jni.JMethodIDPtr, i).check();
  }

  static final _id_getTheme = _class.instanceMethodId(
    r'getTheme',
    r'()Landroid/content/res/Resources$Theme;',
  );

  static final _getTheme = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.content.res.Resources$Theme getTheme()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTheme() {
    return _getTheme(reference.pointer, _id_getTheme as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_obtainStyledAttributes = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'([I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject obtainStyledAttributes(
    jni.JArray<jni.jint> is0,
  ) {
    return _obtainStyledAttributes(
            reference.pointer,
            _id_obtainStyledAttributes as jni.JMethodIDPtr,
            is0.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_obtainStyledAttributes1 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(I[I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(int i, int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject obtainStyledAttributes1(
    int i,
    jni.JArray<jni.jint> is0,
  ) {
    return _obtainStyledAttributes1(
            reference.pointer,
            _id_obtainStyledAttributes1 as jni.JMethodIDPtr,
            i,
            is0.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_obtainStyledAttributes2 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(Landroid/util/AttributeSet;[I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet attributeSet, int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject obtainStyledAttributes2(
    jni.JObject attributeSet,
    jni.JArray<jni.jint> is0,
  ) {
    return _obtainStyledAttributes2(
            reference.pointer,
            _id_obtainStyledAttributes2 as jni.JMethodIDPtr,
            attributeSet.reference.pointer,
            is0.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_obtainStyledAttributes3 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(Landroid/util/AttributeSet;[III)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet attributeSet, int[] is, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject obtainStyledAttributes3(
    jni.JObject attributeSet,
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
  ) {
    return _obtainStyledAttributes3(
            reference.pointer,
            _id_obtainStyledAttributes3 as jni.JMethodIDPtr,
            attributeSet.reference.pointer,
            is0.reference.pointer,
            i,
            i1)
        .object(const jni.JObjectType());
  }

  static final _id_getClassLoader = _class.instanceMethodId(
    r'getClassLoader',
    r'()Ljava/lang/ClassLoader;',
  );

  static final _getClassLoader = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.ClassLoader getClassLoader()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getClassLoader() {
    return _getClassLoader(
            reference.pointer, _id_getClassLoader as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getPackageName = _class.instanceMethodId(
    r'getPackageName',
    r'()Ljava/lang/String;',
  );

  static final _getPackageName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getPackageName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPackageName() {
    return _getPackageName(
            reference.pointer, _id_getPackageName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getOpPackageName = _class.instanceMethodId(
    r'getOpPackageName',
    r'()Ljava/lang/String;',
  );

  static final _getOpPackageName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getOpPackageName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOpPackageName() {
    return _getOpPackageName(
            reference.pointer, _id_getOpPackageName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAttributionTag = _class.instanceMethodId(
    r'getAttributionTag',
    r'()Ljava/lang/String;',
  );

  static final _getAttributionTag = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAttributionTag()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAttributionTag() {
    return _getAttributionTag(
            reference.pointer, _id_getAttributionTag as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAttributionSource = _class.instanceMethodId(
    r'getAttributionSource',
    r'()Landroid/content/AttributionSource;',
  );

  static final _getAttributionSource = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.content.AttributionSource getAttributionSource()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getAttributionSource() {
    return _getAttributionSource(
            reference.pointer, _id_getAttributionSource as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getParams = _class.instanceMethodId(
    r'getParams',
    r'()Landroid/content/ContextParams;',
  );

  static final _getParams = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.content.ContextParams getParams()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getParams() {
    return _getParams(reference.pointer, _id_getParams as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getApplicationInfo = _class.instanceMethodId(
    r'getApplicationInfo',
    r'()Landroid/content/pm/ApplicationInfo;',
  );

  static final _getApplicationInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.content.pm.ApplicationInfo getApplicationInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getApplicationInfo() {
    return _getApplicationInfo(
            reference.pointer, _id_getApplicationInfo as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getPackageResourcePath = _class.instanceMethodId(
    r'getPackageResourcePath',
    r'()Ljava/lang/String;',
  );

  static final _getPackageResourcePath = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getPackageResourcePath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPackageResourcePath() {
    return _getPackageResourcePath(
            reference.pointer, _id_getPackageResourcePath as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPackageCodePath = _class.instanceMethodId(
    r'getPackageCodePath',
    r'()Ljava/lang/String;',
  );

  static final _getPackageCodePath = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getPackageCodePath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPackageCodePath() {
    return _getPackageCodePath(
            reference.pointer, _id_getPackageCodePath as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSharedPreferences = _class.instanceMethodId(
    r'getSharedPreferences',
    r'(Ljava/lang/String;I)Landroid/content/SharedPreferences;',
  );

  static final _getSharedPreferences = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.SharedPreferences getSharedPreferences(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSharedPreferences(
    jni.JString string,
    int i,
  ) {
    return _getSharedPreferences(
            reference.pointer,
            _id_getSharedPreferences as jni.JMethodIDPtr,
            string.reference.pointer,
            i)
        .object(const jni.JObjectType());
  }

  static final _id_moveSharedPreferencesFrom = _class.instanceMethodId(
    r'moveSharedPreferencesFrom',
    r'(Landroid/content/Context;Ljava/lang/String;)Z',
  );

  static final _moveSharedPreferencesFrom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean moveSharedPreferencesFrom(android.content.Context context, java.lang.String string)
  bool moveSharedPreferencesFrom(
    Context context,
    jni.JString string,
  ) {
    return _moveSharedPreferencesFrom(
            reference.pointer,
            _id_moveSharedPreferencesFrom as jni.JMethodIDPtr,
            context.reference.pointer,
            string.reference.pointer)
        .boolean;
  }

  static final _id_deleteSharedPreferences = _class.instanceMethodId(
    r'deleteSharedPreferences',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteSharedPreferences = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean deleteSharedPreferences(java.lang.String string)
  bool deleteSharedPreferences(
    jni.JString string,
  ) {
    return _deleteSharedPreferences(
            reference.pointer,
            _id_deleteSharedPreferences as jni.JMethodIDPtr,
            string.reference.pointer)
        .boolean;
  }

  static final _id_openFileInput = _class.instanceMethodId(
    r'openFileInput',
    r'(Ljava/lang/String;)Ljava/io/FileInputStream;',
  );

  static final _openFileInput = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.FileInputStream openFileInput(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openFileInput(
    jni.JString string,
  ) {
    return _openFileInput(reference.pointer,
            _id_openFileInput as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openFileOutput = _class.instanceMethodId(
    r'openFileOutput',
    r'(Ljava/lang/String;I)Ljava/io/FileOutputStream;',
  );

  static final _openFileOutput = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.io.FileOutputStream openFileOutput(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openFileOutput(
    jni.JString string,
    int i,
  ) {
    return _openFileOutput(reference.pointer,
            _id_openFileOutput as jni.JMethodIDPtr, string.reference.pointer, i)
        .object(const jni.JObjectType());
  }

  static final _id_deleteFile = _class.instanceMethodId(
    r'deleteFile',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteFile = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean deleteFile(java.lang.String string)
  bool deleteFile(
    jni.JString string,
  ) {
    return _deleteFile(reference.pointer, _id_deleteFile as jni.JMethodIDPtr,
            string.reference.pointer)
        .boolean;
  }

  static final _id_getFileStreamPath = _class.instanceMethodId(
    r'getFileStreamPath',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getFileStreamPath = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getFileStreamPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFileStreamPath(
    jni.JString string,
  ) {
    return _getFileStreamPath(reference.pointer,
            _id_getFileStreamPath as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getDataDir = _class.instanceMethodId(
    r'getDataDir',
    r'()Ljava/io/File;',
  );

  static final _getDataDir = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File getDataDir()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDataDir() {
    return _getDataDir(reference.pointer, _id_getDataDir as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getFilesDir = _class.instanceMethodId(
    r'getFilesDir',
    r'()Ljava/io/File;',
  );

  static final _getFilesDir = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File getFilesDir()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFilesDir() {
    return _getFilesDir(reference.pointer, _id_getFilesDir as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getNoBackupFilesDir = _class.instanceMethodId(
    r'getNoBackupFilesDir',
    r'()Ljava/io/File;',
  );

  static final _getNoBackupFilesDir = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File getNoBackupFilesDir()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getNoBackupFilesDir() {
    return _getNoBackupFilesDir(
            reference.pointer, _id_getNoBackupFilesDir as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getExternalFilesDir = _class.instanceMethodId(
    r'getExternalFilesDir',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getExternalFilesDir = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getExternalFilesDir(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getExternalFilesDir(
    jni.JString string,
  ) {
    return _getExternalFilesDir(
            reference.pointer,
            _id_getExternalFilesDir as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getExternalFilesDirs = _class.instanceMethodId(
    r'getExternalFilesDirs',
    r'(Ljava/lang/String;)[Ljava/io/File;',
  );

  static final _getExternalFilesDirs = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File[] getExternalFilesDirs(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> getExternalFilesDirs(
    jni.JString string,
  ) {
    return _getExternalFilesDirs(
            reference.pointer,
            _id_getExternalFilesDirs as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getObbDir = _class.instanceMethodId(
    r'getObbDir',
    r'()Ljava/io/File;',
  );

  static final _getObbDir = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File getObbDir()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getObbDir() {
    return _getObbDir(reference.pointer, _id_getObbDir as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getObbDirs = _class.instanceMethodId(
    r'getObbDirs',
    r'()[Ljava/io/File;',
  );

  static final _getObbDirs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File[] getObbDirs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> getObbDirs() {
    return _getObbDirs(reference.pointer, _id_getObbDirs as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getCacheDir = _class.instanceMethodId(
    r'getCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getCacheDir = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File getCacheDir()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCacheDir() {
    return _getCacheDir(reference.pointer, _id_getCacheDir as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getCodeCacheDir = _class.instanceMethodId(
    r'getCodeCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getCodeCacheDir = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File getCodeCacheDir()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCodeCacheDir() {
    return _getCodeCacheDir(
            reference.pointer, _id_getCodeCacheDir as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getExternalCacheDir = _class.instanceMethodId(
    r'getExternalCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getExternalCacheDir = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File getExternalCacheDir()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getExternalCacheDir() {
    return _getExternalCacheDir(
            reference.pointer, _id_getExternalCacheDir as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getExternalCacheDirs = _class.instanceMethodId(
    r'getExternalCacheDirs',
    r'()[Ljava/io/File;',
  );

  static final _getExternalCacheDirs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File[] getExternalCacheDirs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> getExternalCacheDirs() {
    return _getExternalCacheDirs(
            reference.pointer, _id_getExternalCacheDirs as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getExternalMediaDirs = _class.instanceMethodId(
    r'getExternalMediaDirs',
    r'()[Ljava/io/File;',
  );

  static final _getExternalMediaDirs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.io.File[] getExternalMediaDirs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> getExternalMediaDirs() {
    return _getExternalMediaDirs(
            reference.pointer, _id_getExternalMediaDirs as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_fileList = _class.instanceMethodId(
    r'fileList',
    r'()[Ljava/lang/String;',
  );

  static final _fileList = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String[] fileList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> fileList() {
    return _fileList(reference.pointer, _id_fileList as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JStringType()));
  }

  static final _id_getDir = _class.instanceMethodId(
    r'getDir',
    r'(Ljava/lang/String;I)Ljava/io/File;',
  );

  static final _getDir = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.io.File getDir(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDir(
    jni.JString string,
    int i,
  ) {
    return _getDir(reference.pointer, _id_getDir as jni.JMethodIDPtr,
            string.reference.pointer, i)
        .object(const jni.JObjectType());
  }

  static final _id_openOrCreateDatabase = _class.instanceMethodId(
    r'openOrCreateDatabase',
    r'(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase;',
  );

  static final _openOrCreateDatabase = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String string, int i, android.database.sqlite.SQLiteDatabase$CursorFactory cursorFactory)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openOrCreateDatabase(
    jni.JString string,
    int i,
    jni.JObject cursorFactory,
  ) {
    return _openOrCreateDatabase(
            reference.pointer,
            _id_openOrCreateDatabase as jni.JMethodIDPtr,
            string.reference.pointer,
            i,
            cursorFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openOrCreateDatabase1 = _class.instanceMethodId(
    r'openOrCreateDatabase',
    r'(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase$CursorFactory;Landroid/database/DatabaseErrorHandler;)Landroid/database/sqlite/SQLiteDatabase;',
  );

  static final _openOrCreateDatabase1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String string, int i, android.database.sqlite.SQLiteDatabase$CursorFactory cursorFactory, android.database.DatabaseErrorHandler databaseErrorHandler)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openOrCreateDatabase1(
    jni.JString string,
    int i,
    jni.JObject cursorFactory,
    jni.JObject databaseErrorHandler,
  ) {
    return _openOrCreateDatabase1(
            reference.pointer,
            _id_openOrCreateDatabase1 as jni.JMethodIDPtr,
            string.reference.pointer,
            i,
            cursorFactory.reference.pointer,
            databaseErrorHandler.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_moveDatabaseFrom = _class.instanceMethodId(
    r'moveDatabaseFrom',
    r'(Landroid/content/Context;Ljava/lang/String;)Z',
  );

  static final _moveDatabaseFrom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean moveDatabaseFrom(android.content.Context context, java.lang.String string)
  bool moveDatabaseFrom(
    Context context,
    jni.JString string,
  ) {
    return _moveDatabaseFrom(
            reference.pointer,
            _id_moveDatabaseFrom as jni.JMethodIDPtr,
            context.reference.pointer,
            string.reference.pointer)
        .boolean;
  }

  static final _id_deleteDatabase = _class.instanceMethodId(
    r'deleteDatabase',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteDatabase = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean deleteDatabase(java.lang.String string)
  bool deleteDatabase(
    jni.JString string,
  ) {
    return _deleteDatabase(reference.pointer,
            _id_deleteDatabase as jni.JMethodIDPtr, string.reference.pointer)
        .boolean;
  }

  static final _id_getDatabasePath = _class.instanceMethodId(
    r'getDatabasePath',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getDatabasePath = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getDatabasePath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDatabasePath(
    jni.JString string,
  ) {
    return _getDatabasePath(reference.pointer,
            _id_getDatabasePath as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_databaseList = _class.instanceMethodId(
    r'databaseList',
    r'()[Ljava/lang/String;',
  );

  static final _databaseList = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String[] databaseList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> databaseList() {
    return _databaseList(
            reference.pointer, _id_databaseList as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JStringType()));
  }

  static final _id_getWallpaper = _class.instanceMethodId(
    r'getWallpaper',
    r'()Landroid/graphics/drawable/Drawable;',
  );

  static final _getWallpaper = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.graphics.drawable.Drawable getWallpaper()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getWallpaper() {
    return _getWallpaper(
            reference.pointer, _id_getWallpaper as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_peekWallpaper = _class.instanceMethodId(
    r'peekWallpaper',
    r'()Landroid/graphics/drawable/Drawable;',
  );

  static final _peekWallpaper = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.graphics.drawable.Drawable peekWallpaper()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject peekWallpaper() {
    return _peekWallpaper(
            reference.pointer, _id_peekWallpaper as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getWallpaperDesiredMinimumWidth = _class.instanceMethodId(
    r'getWallpaperDesiredMinimumWidth',
    r'()I',
  );

  static final _getWallpaperDesiredMinimumWidth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getWallpaperDesiredMinimumWidth()
  int getWallpaperDesiredMinimumWidth() {
    return _getWallpaperDesiredMinimumWidth(reference.pointer,
            _id_getWallpaperDesiredMinimumWidth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getWallpaperDesiredMinimumHeight = _class.instanceMethodId(
    r'getWallpaperDesiredMinimumHeight',
    r'()I',
  );

  static final _getWallpaperDesiredMinimumHeight =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public abstract int getWallpaperDesiredMinimumHeight()
  int getWallpaperDesiredMinimumHeight() {
    return _getWallpaperDesiredMinimumHeight(reference.pointer,
            _id_getWallpaperDesiredMinimumHeight as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setWallpaper = _class.instanceMethodId(
    r'setWallpaper',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _setWallpaper = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setWallpaper(android.graphics.Bitmap bitmap)
  void setWallpaper(
    jni.JObject bitmap,
  ) {
    _setWallpaper(reference.pointer, _id_setWallpaper as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }

  static final _id_setWallpaper1 = _class.instanceMethodId(
    r'setWallpaper',
    r'(Ljava/io/InputStream;)V',
  );

  static final _setWallpaper1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setWallpaper(java.io.InputStream inputStream)
  void setWallpaper1(
    jni.JObject inputStream,
  ) {
    _setWallpaper1(reference.pointer, _id_setWallpaper1 as jni.JMethodIDPtr,
            inputStream.reference.pointer)
        .check();
  }

  static final _id_clearWallpaper = _class.instanceMethodId(
    r'clearWallpaper',
    r'()V',
  );

  static final _clearWallpaper = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void clearWallpaper()
  void clearWallpaper() {
    _clearWallpaper(reference.pointer, _id_clearWallpaper as jni.JMethodIDPtr)
        .check();
  }

  static final _id_startActivity = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Intent;)V',
  );

  static final _startActivity = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startActivity(android.content.Intent intent)
  void startActivity(
    jni.JObject intent,
  ) {
    _startActivity(reference.pointer, _id_startActivity as jni.JMethodIDPtr,
            intent.reference.pointer)
        .check();
  }

  static final _id_startActivity1 = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivity1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startActivity(android.content.Intent intent, android.os.Bundle bundle)
  void startActivity1(
    jni.JObject intent,
    jni.JObject bundle,
  ) {
    _startActivity1(reference.pointer, _id_startActivity1 as jni.JMethodIDPtr,
            intent.reference.pointer, bundle.reference.pointer)
        .check();
  }

  static final _id_startActivities = _class.instanceMethodId(
    r'startActivities',
    r'([Landroid/content/Intent;)V',
  );

  static final _startActivities = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startActivities(android.content.Intent[] intents)
  void startActivities(
    jni.JArray<jni.JObject> intents,
  ) {
    _startActivities(reference.pointer, _id_startActivities as jni.JMethodIDPtr,
            intents.reference.pointer)
        .check();
  }

  static final _id_startActivities1 = _class.instanceMethodId(
    r'startActivities',
    r'([Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivities1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startActivities(android.content.Intent[] intents, android.os.Bundle bundle)
  void startActivities1(
    jni.JArray<jni.JObject> intents,
    jni.JObject bundle,
  ) {
    _startActivities1(
            reference.pointer,
            _id_startActivities1 as jni.JMethodIDPtr,
            intents.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_startIntentSender = _class.instanceMethodId(
    r'startIntentSender',
    r'(Landroid/content/IntentSender;Landroid/content/Intent;III)V',
  );

  static final _startIntentSender = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public abstract void startIntentSender(android.content.IntentSender intentSender, android.content.Intent intent, int i, int i1, int i2)
  void startIntentSender(
    jni.JObject intentSender,
    jni.JObject intent,
    int i,
    int i1,
    int i2,
  ) {
    _startIntentSender(
            reference.pointer,
            _id_startIntentSender as jni.JMethodIDPtr,
            intentSender.reference.pointer,
            intent.reference.pointer,
            i,
            i1,
            i2)
        .check();
  }

  static final _id_startIntentSender1 = _class.instanceMethodId(
    r'startIntentSender',
    r'(Landroid/content/IntentSender;Landroid/content/Intent;IIILandroid/os/Bundle;)V',
  );

  static final _startIntentSender1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startIntentSender(android.content.IntentSender intentSender, android.content.Intent intent, int i, int i1, int i2, android.os.Bundle bundle)
  void startIntentSender1(
    jni.JObject intentSender,
    jni.JObject intent,
    int i,
    int i1,
    int i2,
    jni.JObject bundle,
  ) {
    _startIntentSender1(
            reference.pointer,
            _id_startIntentSender1 as jni.JMethodIDPtr,
            intentSender.reference.pointer,
            intent.reference.pointer,
            i,
            i1,
            i2,
            bundle.reference.pointer)
        .check();
  }

  static final _id_sendBroadcast = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _sendBroadcast = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendBroadcast(android.content.Intent intent)
  void sendBroadcast(
    jni.JObject intent,
  ) {
    _sendBroadcast(reference.pointer, _id_sendBroadcast as jni.JMethodIDPtr,
            intent.reference.pointer)
        .check();
  }

  static final _id_sendBroadcast1 = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;)V',
  );

  static final _sendBroadcast1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendBroadcast(android.content.Intent intent, java.lang.String string)
  void sendBroadcast1(
    jni.JObject intent,
    jni.JString string,
  ) {
    _sendBroadcast1(reference.pointer, _id_sendBroadcast1 as jni.JMethodIDPtr,
            intent.reference.pointer, string.reference.pointer)
        .check();
  }

  static final _id_sendBroadcastWithMultiplePermissions =
      _class.instanceMethodId(
    r'sendBroadcastWithMultiplePermissions',
    r'(Landroid/content/Intent;[Ljava/lang/String;)V',
  );

  static final _sendBroadcastWithMultiplePermissions =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<
                          (
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>();

  /// from: public void sendBroadcastWithMultiplePermissions(android.content.Intent intent, java.lang.String[] strings)
  void sendBroadcastWithMultiplePermissions(
    jni.JObject intent,
    jni.JArray<jni.JString> strings,
  ) {
    _sendBroadcastWithMultiplePermissions(
            reference.pointer,
            _id_sendBroadcastWithMultiplePermissions as jni.JMethodIDPtr,
            intent.reference.pointer,
            strings.reference.pointer)
        .check();
  }

  static final _id_sendBroadcast2 = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendBroadcast2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle)
  void sendBroadcast2(
    jni.JObject intent,
    jni.JString string,
    jni.JObject bundle,
  ) {
    _sendBroadcast2(
            reference.pointer,
            _id_sendBroadcast2 as jni.JMethodIDPtr,
            intent.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;)V',
  );

  static final _sendOrderedBroadcast = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string)
  void sendOrderedBroadcast(
    jni.JObject intent,
    jni.JString string,
  ) {
    _sendOrderedBroadcast(
            reference.pointer,
            _id_sendOrderedBroadcast as jni.JMethodIDPtr,
            intent.reference.pointer,
            string.reference.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast1 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle)
  void sendOrderedBroadcast1(
    jni.JObject intent,
    jni.JString string,
    jni.JObject bundle,
  ) {
    _sendOrderedBroadcast1(
            reference.pointer,
            _id_sendOrderedBroadcast1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast2 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle)
  void sendOrderedBroadcast2(
    jni.JObject intent,
    jni.JString string,
    jni.JObject broadcastReceiver,
    jni.JObject handler,
    int i,
    jni.JString string1,
    jni.JObject bundle,
  ) {
    _sendOrderedBroadcast2(
            reference.pointer,
            _id_sendOrderedBroadcast2 as jni.JMethodIDPtr,
            intent.reference.pointer,
            string.reference.pointer,
            broadcastReceiver.reference.pointer,
            handler.reference.pointer,
            i,
            string1.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast3 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle1)
  void sendOrderedBroadcast3(
    jni.JObject intent,
    jni.JString string,
    jni.JObject bundle,
    jni.JObject broadcastReceiver,
    jni.JObject handler,
    int i,
    jni.JString string1,
    jni.JObject bundle1,
  ) {
    _sendOrderedBroadcast3(
            reference.pointer,
            _id_sendOrderedBroadcast3 as jni.JMethodIDPtr,
            intent.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer,
            broadcastReceiver.reference.pointer,
            handler.reference.pointer,
            i,
            string1.reference.pointer,
            bundle1.reference.pointer)
        .check();
  }

  static final _id_sendBroadcastAsUser = _class.instanceMethodId(
    r'sendBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _sendBroadcastAsUser = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)
  void sendBroadcastAsUser(
    jni.JObject intent,
    jni.JObject userHandle,
  ) {
    _sendBroadcastAsUser(
            reference.pointer,
            _id_sendBroadcastAsUser as jni.JMethodIDPtr,
            intent.reference.pointer,
            userHandle.reference.pointer)
        .check();
  }

  static final _id_sendBroadcastAsUser1 = _class.instanceMethodId(
    r'sendBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;)V',
  );

  static final _sendBroadcastAsUser1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, java.lang.String string)
  void sendBroadcastAsUser1(
    jni.JObject intent,
    jni.JObject userHandle,
    jni.JString string,
  ) {
    _sendBroadcastAsUser1(
            reference.pointer,
            _id_sendBroadcastAsUser1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            userHandle.reference.pointer,
            string.reference.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcastAsUser = _class.instanceMethodId(
    r'sendOrderedBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcastAsUser = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, java.lang.String string, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle)
  void sendOrderedBroadcastAsUser(
    jni.JObject intent,
    jni.JObject userHandle,
    jni.JString string,
    jni.JObject broadcastReceiver,
    jni.JObject handler,
    int i,
    jni.JString string1,
    jni.JObject bundle,
  ) {
    _sendOrderedBroadcastAsUser(
            reference.pointer,
            _id_sendOrderedBroadcastAsUser as jni.JMethodIDPtr,
            intent.reference.pointer,
            userHandle.reference.pointer,
            string.reference.pointer,
            broadcastReceiver.reference.pointer,
            handler.reference.pointer,
            i,
            string1.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast4 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, java.lang.String string1, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string2, android.os.Bundle bundle)
  void sendOrderedBroadcast4(
    jni.JObject intent,
    jni.JString string,
    jni.JString string1,
    jni.JObject broadcastReceiver,
    jni.JObject handler,
    int i,
    jni.JString string2,
    jni.JObject bundle,
  ) {
    _sendOrderedBroadcast4(
            reference.pointer,
            _id_sendOrderedBroadcast4 as jni.JMethodIDPtr,
            intent.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer,
            broadcastReceiver.reference.pointer,
            handler.reference.pointer,
            i,
            string2.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_sendStickyBroadcast = _class.instanceMethodId(
    r'sendStickyBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _sendStickyBroadcast = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendStickyBroadcast(android.content.Intent intent)
  void sendStickyBroadcast(
    jni.JObject intent,
  ) {
    _sendStickyBroadcast(
            reference.pointer,
            _id_sendStickyBroadcast as jni.JMethodIDPtr,
            intent.reference.pointer)
        .check();
  }

  static final _id_sendStickyBroadcast1 = _class.instanceMethodId(
    r'sendStickyBroadcast',
    r'(Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _sendStickyBroadcast1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStickyBroadcast(android.content.Intent intent, android.os.Bundle bundle)
  void sendStickyBroadcast1(
    jni.JObject intent,
    jni.JObject bundle,
  ) {
    _sendStickyBroadcast1(
            reference.pointer,
            _id_sendStickyBroadcast1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_sendStickyOrderedBroadcast = _class.instanceMethodId(
    r'sendStickyOrderedBroadcast',
    r'(Landroid/content/Intent;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendStickyOrderedBroadcast = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendStickyOrderedBroadcast(android.content.Intent intent, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string, android.os.Bundle bundle)
  void sendStickyOrderedBroadcast(
    jni.JObject intent,
    jni.JObject broadcastReceiver,
    jni.JObject handler,
    int i,
    jni.JString string,
    jni.JObject bundle,
  ) {
    _sendStickyOrderedBroadcast(
            reference.pointer,
            _id_sendStickyOrderedBroadcast as jni.JMethodIDPtr,
            intent.reference.pointer,
            broadcastReceiver.reference.pointer,
            handler.reference.pointer,
            i,
            string.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_removeStickyBroadcast = _class.instanceMethodId(
    r'removeStickyBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _removeStickyBroadcast = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeStickyBroadcast(android.content.Intent intent)
  void removeStickyBroadcast(
    jni.JObject intent,
  ) {
    _removeStickyBroadcast(
            reference.pointer,
            _id_removeStickyBroadcast as jni.JMethodIDPtr,
            intent.reference.pointer)
        .check();
  }

  static final _id_sendStickyBroadcastAsUser = _class.instanceMethodId(
    r'sendStickyBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _sendStickyBroadcastAsUser = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)
  void sendStickyBroadcastAsUser(
    jni.JObject intent,
    jni.JObject userHandle,
  ) {
    _sendStickyBroadcastAsUser(
            reference.pointer,
            _id_sendStickyBroadcastAsUser as jni.JMethodIDPtr,
            intent.reference.pointer,
            userHandle.reference.pointer)
        .check();
  }

  static final _id_sendStickyOrderedBroadcastAsUser = _class.instanceMethodId(
    r'sendStickyOrderedBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendStickyOrderedBroadcastAsUser =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<
                          (
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>,
                            $Int32,
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  int,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendStickyOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string, android.os.Bundle bundle)
  void sendStickyOrderedBroadcastAsUser(
    jni.JObject intent,
    jni.JObject userHandle,
    jni.JObject broadcastReceiver,
    jni.JObject handler,
    int i,
    jni.JString string,
    jni.JObject bundle,
  ) {
    _sendStickyOrderedBroadcastAsUser(
            reference.pointer,
            _id_sendStickyOrderedBroadcastAsUser as jni.JMethodIDPtr,
            intent.reference.pointer,
            userHandle.reference.pointer,
            broadcastReceiver.reference.pointer,
            handler.reference.pointer,
            i,
            string.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_removeStickyBroadcastAsUser = _class.instanceMethodId(
    r'removeStickyBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _removeStickyBroadcastAsUser = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)
  void removeStickyBroadcastAsUser(
    jni.JObject intent,
    jni.JObject userHandle,
  ) {
    _removeStickyBroadcastAsUser(
            reference.pointer,
            _id_removeStickyBroadcastAsUser as jni.JMethodIDPtr,
            intent.reference.pointer,
            userHandle.reference.pointer)
        .check();
  }

  static final _id_registerReceiver = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;',
  );

  static final _registerReceiver = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject registerReceiver(
    jni.JObject broadcastReceiver,
    jni.JObject intentFilter,
  ) {
    return _registerReceiver(
            reference.pointer,
            _id_registerReceiver as jni.JMethodIDPtr,
            broadcastReceiver.reference.pointer,
            intentFilter.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_registerReceiver1 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;I)Landroid/content/Intent;',
  );

  static final _registerReceiver1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject registerReceiver1(
    jni.JObject broadcastReceiver,
    jni.JObject intentFilter,
    int i,
  ) {
    return _registerReceiver1(
            reference.pointer,
            _id_registerReceiver1 as jni.JMethodIDPtr,
            broadcastReceiver.reference.pointer,
            intentFilter.reference.pointer,
            i)
        .object(const jni.JObjectType());
  }

  static final _id_registerReceiver2 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;)Landroid/content/Intent;',
  );

  static final _registerReceiver2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, java.lang.String string, android.os.Handler handler)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject registerReceiver2(
    jni.JObject broadcastReceiver,
    jni.JObject intentFilter,
    jni.JString string,
    jni.JObject handler,
  ) {
    return _registerReceiver2(
            reference.pointer,
            _id_registerReceiver2 as jni.JMethodIDPtr,
            broadcastReceiver.reference.pointer,
            intentFilter.reference.pointer,
            string.reference.pointer,
            handler.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_registerReceiver3 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;I)Landroid/content/Intent;',
  );

  static final _registerReceiver3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, java.lang.String string, android.os.Handler handler, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject registerReceiver3(
    jni.JObject broadcastReceiver,
    jni.JObject intentFilter,
    jni.JString string,
    jni.JObject handler,
    int i,
  ) {
    return _registerReceiver3(
            reference.pointer,
            _id_registerReceiver3 as jni.JMethodIDPtr,
            broadcastReceiver.reference.pointer,
            intentFilter.reference.pointer,
            string.reference.pointer,
            handler.reference.pointer,
            i)
        .object(const jni.JObjectType());
  }

  static final _id_unregisterReceiver = _class.instanceMethodId(
    r'unregisterReceiver',
    r'(Landroid/content/BroadcastReceiver;)V',
  );

  static final _unregisterReceiver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unregisterReceiver(android.content.BroadcastReceiver broadcastReceiver)
  void unregisterReceiver(
    jni.JObject broadcastReceiver,
  ) {
    _unregisterReceiver(
            reference.pointer,
            _id_unregisterReceiver as jni.JMethodIDPtr,
            broadcastReceiver.reference.pointer)
        .check();
  }

  static final _id_startService = _class.instanceMethodId(
    r'startService',
    r'(Landroid/content/Intent;)Landroid/content/ComponentName;',
  );

  static final _startService = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.ComponentName startService(android.content.Intent intent)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startService(
    jni.JObject intent,
  ) {
    return _startService(reference.pointer,
            _id_startService as jni.JMethodIDPtr, intent.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_startForegroundService = _class.instanceMethodId(
    r'startForegroundService',
    r'(Landroid/content/Intent;)Landroid/content/ComponentName;',
  );

  static final _startForegroundService = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.ComponentName startForegroundService(android.content.Intent intent)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startForegroundService(
    jni.JObject intent,
  ) {
    return _startForegroundService(
            reference.pointer,
            _id_startForegroundService as jni.JMethodIDPtr,
            intent.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_stopService = _class.instanceMethodId(
    r'stopService',
    r'(Landroid/content/Intent;)Z',
  );

  static final _stopService = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean stopService(android.content.Intent intent)
  bool stopService(
    jni.JObject intent,
  ) {
    return _stopService(reference.pointer, _id_stopService as jni.JMethodIDPtr,
            intent.reference.pointer)
        .boolean;
  }

  static final _id_bindService = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;I)Z',
  );

  static final _bindService = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean bindService(android.content.Intent intent, android.content.ServiceConnection serviceConnection, int i)
  bool bindService(
    jni.JObject intent,
    jni.JObject serviceConnection,
    int i,
  ) {
    return _bindService(reference.pointer, _id_bindService as jni.JMethodIDPtr,
            intent.reference.pointer, serviceConnection.reference.pointer, i)
        .boolean;
  }

  static final _id_bindService1 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;Landroid/content/Context$BindServiceFlags;)Z',
  );

  static final _bindService1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean bindService(android.content.Intent intent, android.content.ServiceConnection serviceConnection, android.content.Context$BindServiceFlags bindServiceFlags)
  bool bindService1(
    jni.JObject intent,
    jni.JObject serviceConnection,
    Context_BindServiceFlags bindServiceFlags,
  ) {
    return _bindService1(
            reference.pointer,
            _id_bindService1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            serviceConnection.reference.pointer,
            bindServiceFlags.reference.pointer)
        .boolean;
  }

  static final _id_bindService2 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;ILjava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindService2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean bindService(android.content.Intent intent, int i, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)
  bool bindService2(
    jni.JObject intent,
    int i,
    Executor executor,
    jni.JObject serviceConnection,
  ) {
    return _bindService2(
            reference.pointer,
            _id_bindService2 as jni.JMethodIDPtr,
            intent.reference.pointer,
            i,
            executor.reference.pointer,
            serviceConnection.reference.pointer)
        .boolean;
  }

  static final _id_bindService3 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/Context$BindServiceFlags;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindService3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean bindService(android.content.Intent intent, android.content.Context$BindServiceFlags bindServiceFlags, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)
  bool bindService3(
    jni.JObject intent,
    Context_BindServiceFlags bindServiceFlags,
    Executor executor,
    jni.JObject serviceConnection,
  ) {
    return _bindService3(
            reference.pointer,
            _id_bindService3 as jni.JMethodIDPtr,
            intent.reference.pointer,
            bindServiceFlags.reference.pointer,
            executor.reference.pointer,
            serviceConnection.reference.pointer)
        .boolean;
  }

  static final _id_bindIsolatedService = _class.instanceMethodId(
    r'bindIsolatedService',
    r'(Landroid/content/Intent;ILjava/lang/String;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindIsolatedService = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean bindIsolatedService(android.content.Intent intent, int i, java.lang.String string, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)
  bool bindIsolatedService(
    jni.JObject intent,
    int i,
    jni.JString string,
    Executor executor,
    jni.JObject serviceConnection,
  ) {
    return _bindIsolatedService(
            reference.pointer,
            _id_bindIsolatedService as jni.JMethodIDPtr,
            intent.reference.pointer,
            i,
            string.reference.pointer,
            executor.reference.pointer,
            serviceConnection.reference.pointer)
        .boolean;
  }

  static final _id_bindIsolatedService1 = _class.instanceMethodId(
    r'bindIsolatedService',
    r'(Landroid/content/Intent;Landroid/content/Context$BindServiceFlags;Ljava/lang/String;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindIsolatedService1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean bindIsolatedService(android.content.Intent intent, android.content.Context$BindServiceFlags bindServiceFlags, java.lang.String string, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)
  bool bindIsolatedService1(
    jni.JObject intent,
    Context_BindServiceFlags bindServiceFlags,
    jni.JString string,
    Executor executor,
    jni.JObject serviceConnection,
  ) {
    return _bindIsolatedService1(
            reference.pointer,
            _id_bindIsolatedService1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            bindServiceFlags.reference.pointer,
            string.reference.pointer,
            executor.reference.pointer,
            serviceConnection.reference.pointer)
        .boolean;
  }

  static final _id_bindServiceAsUser = _class.instanceMethodId(
    r'bindServiceAsUser',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;ILandroid/os/UserHandle;)Z',
  );

  static final _bindServiceAsUser = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean bindServiceAsUser(android.content.Intent intent, android.content.ServiceConnection serviceConnection, int i, android.os.UserHandle userHandle)
  bool bindServiceAsUser(
    jni.JObject intent,
    jni.JObject serviceConnection,
    int i,
    jni.JObject userHandle,
  ) {
    return _bindServiceAsUser(
            reference.pointer,
            _id_bindServiceAsUser as jni.JMethodIDPtr,
            intent.reference.pointer,
            serviceConnection.reference.pointer,
            i,
            userHandle.reference.pointer)
        .boolean;
  }

  static final _id_bindServiceAsUser1 = _class.instanceMethodId(
    r'bindServiceAsUser',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;Landroid/content/Context$BindServiceFlags;Landroid/os/UserHandle;)Z',
  );

  static final _bindServiceAsUser1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean bindServiceAsUser(android.content.Intent intent, android.content.ServiceConnection serviceConnection, android.content.Context$BindServiceFlags bindServiceFlags, android.os.UserHandle userHandle)
  bool bindServiceAsUser1(
    jni.JObject intent,
    jni.JObject serviceConnection,
    Context_BindServiceFlags bindServiceFlags,
    jni.JObject userHandle,
  ) {
    return _bindServiceAsUser1(
            reference.pointer,
            _id_bindServiceAsUser1 as jni.JMethodIDPtr,
            intent.reference.pointer,
            serviceConnection.reference.pointer,
            bindServiceFlags.reference.pointer,
            userHandle.reference.pointer)
        .boolean;
  }

  static final _id_updateServiceGroup = _class.instanceMethodId(
    r'updateServiceGroup',
    r'(Landroid/content/ServiceConnection;II)V',
  );

  static final _updateServiceGroup = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void updateServiceGroup(android.content.ServiceConnection serviceConnection, int i, int i1)
  void updateServiceGroup(
    jni.JObject serviceConnection,
    int i,
    int i1,
  ) {
    _updateServiceGroup(
            reference.pointer,
            _id_updateServiceGroup as jni.JMethodIDPtr,
            serviceConnection.reference.pointer,
            i,
            i1)
        .check();
  }

  static final _id_unbindService = _class.instanceMethodId(
    r'unbindService',
    r'(Landroid/content/ServiceConnection;)V',
  );

  static final _unbindService = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unbindService(android.content.ServiceConnection serviceConnection)
  void unbindService(
    jni.JObject serviceConnection,
  ) {
    _unbindService(reference.pointer, _id_unbindService as jni.JMethodIDPtr,
            serviceConnection.reference.pointer)
        .check();
  }

  static final _id_startInstrumentation = _class.instanceMethodId(
    r'startInstrumentation',
    r'(Landroid/content/ComponentName;Ljava/lang/String;Landroid/os/Bundle;)Z',
  );

  static final _startInstrumentation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean startInstrumentation(android.content.ComponentName componentName, java.lang.String string, android.os.Bundle bundle)
  bool startInstrumentation(
    jni.JObject componentName,
    jni.JString string,
    jni.JObject bundle,
  ) {
    return _startInstrumentation(
            reference.pointer,
            _id_startInstrumentation as jni.JMethodIDPtr,
            componentName.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer)
        .boolean;
  }

  static final _id_getSystemService = _class.instanceMethodId(
    r'getSystemService',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _getSystemService = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.Object getSystemService(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSystemService(
    jni.JString string,
  ) {
    return _getSystemService(reference.pointer,
            _id_getSystemService as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getSystemService1 = _class.instanceMethodId(
    r'getSystemService',
    r'(Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getSystemService1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final T getSystemService(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $T getSystemService1<$T extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$T> T,
  }) {
    return _getSystemService1(reference.pointer,
            _id_getSystemService1 as jni.JMethodIDPtr, class0.reference.pointer)
        .object(T);
  }

  static final _id_getSystemServiceName = _class.instanceMethodId(
    r'getSystemServiceName',
    r'(Ljava/lang/Class;)Ljava/lang/String;',
  );

  static final _getSystemServiceName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getSystemServiceName(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSystemServiceName(
    jni.JObject class0,
  ) {
    return _getSystemServiceName(
            reference.pointer,
            _id_getSystemServiceName as jni.JMethodIDPtr,
            class0.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_checkPermission = _class.instanceMethodId(
    r'checkPermission',
    r'(Ljava/lang/String;II)I',
  );

  static final _checkPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract int checkPermission(java.lang.String string, int i, int i1)
  int checkPermission(
    jni.JString string,
    int i,
    int i1,
  ) {
    return _checkPermission(
            reference.pointer,
            _id_checkPermission as jni.JMethodIDPtr,
            string.reference.pointer,
            i,
            i1)
        .integer;
  }

  static final _id_checkCallingPermission = _class.instanceMethodId(
    r'checkCallingPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkCallingPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int checkCallingPermission(java.lang.String string)
  int checkCallingPermission(
    jni.JString string,
  ) {
    return _checkCallingPermission(
            reference.pointer,
            _id_checkCallingPermission as jni.JMethodIDPtr,
            string.reference.pointer)
        .integer;
  }

  static final _id_checkCallingOrSelfPermission = _class.instanceMethodId(
    r'checkCallingOrSelfPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkCallingOrSelfPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int checkCallingOrSelfPermission(java.lang.String string)
  int checkCallingOrSelfPermission(
    jni.JString string,
  ) {
    return _checkCallingOrSelfPermission(
            reference.pointer,
            _id_checkCallingOrSelfPermission as jni.JMethodIDPtr,
            string.reference.pointer)
        .integer;
  }

  static final _id_checkSelfPermission = _class.instanceMethodId(
    r'checkSelfPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkSelfPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int checkSelfPermission(java.lang.String string)
  int checkSelfPermission(
    jni.JString string,
  ) {
    return _checkSelfPermission(
            reference.pointer,
            _id_checkSelfPermission as jni.JMethodIDPtr,
            string.reference.pointer)
        .integer;
  }

  static final _id_enforcePermission = _class.instanceMethodId(
    r'enforcePermission',
    r'(Ljava/lang/String;IILjava/lang/String;)V',
  );

  static final _enforcePermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforcePermission(java.lang.String string, int i, int i1, java.lang.String string1)
  void enforcePermission(
    jni.JString string,
    int i,
    int i1,
    jni.JString string1,
  ) {
    _enforcePermission(
            reference.pointer,
            _id_enforcePermission as jni.JMethodIDPtr,
            string.reference.pointer,
            i,
            i1,
            string1.reference.pointer)
        .check();
  }

  static final _id_enforceCallingPermission = _class.instanceMethodId(
    r'enforceCallingPermission',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _enforceCallingPermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceCallingPermission(java.lang.String string, java.lang.String string1)
  void enforceCallingPermission(
    jni.JString string,
    jni.JString string1,
  ) {
    _enforceCallingPermission(
            reference.pointer,
            _id_enforceCallingPermission as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .check();
  }

  static final _id_enforceCallingOrSelfPermission = _class.instanceMethodId(
    r'enforceCallingOrSelfPermission',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _enforceCallingOrSelfPermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceCallingOrSelfPermission(java.lang.String string, java.lang.String string1)
  void enforceCallingOrSelfPermission(
    jni.JString string,
    jni.JString string1,
  ) {
    _enforceCallingOrSelfPermission(
            reference.pointer,
            _id_enforceCallingOrSelfPermission as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .check();
  }

  static final _id_grantUriPermission = _class.instanceMethodId(
    r'grantUriPermission',
    r'(Ljava/lang/String;Landroid/net/Uri;I)V',
  );

  static final _grantUriPermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void grantUriPermission(java.lang.String string, android.net.Uri uri, int i)
  void grantUriPermission(
    jni.JString string,
    Uri uri,
    int i,
  ) {
    _grantUriPermission(
            reference.pointer,
            _id_grantUriPermission as jni.JMethodIDPtr,
            string.reference.pointer,
            uri.reference.pointer,
            i)
        .check();
  }

  static final _id_revokeUriPermission = _class.instanceMethodId(
    r'revokeUriPermission',
    r'(Landroid/net/Uri;I)V',
  );

  static final _revokeUriPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void revokeUriPermission(android.net.Uri uri, int i)
  void revokeUriPermission(
    Uri uri,
    int i,
  ) {
    _revokeUriPermission(
            reference.pointer,
            _id_revokeUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i)
        .check();
  }

  static final _id_revokeUriPermission1 = _class.instanceMethodId(
    r'revokeUriPermission',
    r'(Ljava/lang/String;Landroid/net/Uri;I)V',
  );

  static final _revokeUriPermission1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void revokeUriPermission(java.lang.String string, android.net.Uri uri, int i)
  void revokeUriPermission1(
    jni.JString string,
    Uri uri,
    int i,
  ) {
    _revokeUriPermission1(
            reference.pointer,
            _id_revokeUriPermission1 as jni.JMethodIDPtr,
            string.reference.pointer,
            uri.reference.pointer,
            i)
        .check();
  }

  static final _id_checkUriPermission = _class.instanceMethodId(
    r'checkUriPermission',
    r'(Landroid/net/Uri;III)I',
  );

  static final _checkUriPermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public abstract int checkUriPermission(android.net.Uri uri, int i, int i1, int i2)
  int checkUriPermission(
    Uri uri,
    int i,
    int i1,
    int i2,
  ) {
    return _checkUriPermission(
            reference.pointer,
            _id_checkUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i,
            i1,
            i2)
        .integer;
  }

  static final _id_checkUriPermissions = _class.instanceMethodId(
    r'checkUriPermissions',
    r'(Ljava/util/List;III)[I',
  );

  static final _checkUriPermissions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public java.lang.Object[] checkUriPermissions(java.util.List list, int i, int i1, int i2)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> checkUriPermissions(
    jni.JList<Uri> list,
    int i,
    int i1,
    int i2,
  ) {
    return _checkUriPermissions(
            reference.pointer,
            _id_checkUriPermissions as jni.JMethodIDPtr,
            list.reference.pointer,
            i,
            i1,
            i2)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_checkCallingUriPermission = _class.instanceMethodId(
    r'checkCallingUriPermission',
    r'(Landroid/net/Uri;I)I',
  );

  static final _checkCallingUriPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int checkCallingUriPermission(android.net.Uri uri, int i)
  int checkCallingUriPermission(
    Uri uri,
    int i,
  ) {
    return _checkCallingUriPermission(
            reference.pointer,
            _id_checkCallingUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i)
        .integer;
  }

  static final _id_checkCallingUriPermissions = _class.instanceMethodId(
    r'checkCallingUriPermissions',
    r'(Ljava/util/List;I)[I',
  );

  static final _checkCallingUriPermissions = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.Object[] checkCallingUriPermissions(java.util.List list, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> checkCallingUriPermissions(
    jni.JList<Uri> list,
    int i,
  ) {
    return _checkCallingUriPermissions(
            reference.pointer,
            _id_checkCallingUriPermissions as jni.JMethodIDPtr,
            list.reference.pointer,
            i)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_checkCallingOrSelfUriPermission = _class.instanceMethodId(
    r'checkCallingOrSelfUriPermission',
    r'(Landroid/net/Uri;I)I',
  );

  static final _checkCallingOrSelfUriPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int checkCallingOrSelfUriPermission(android.net.Uri uri, int i)
  int checkCallingOrSelfUriPermission(
    Uri uri,
    int i,
  ) {
    return _checkCallingOrSelfUriPermission(
            reference.pointer,
            _id_checkCallingOrSelfUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i)
        .integer;
  }

  static final _id_checkCallingOrSelfUriPermissions = _class.instanceMethodId(
    r'checkCallingOrSelfUriPermissions',
    r'(Ljava/util/List;I)[I',
  );

  static final _checkCallingOrSelfUriPermissions =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.Object[] checkCallingOrSelfUriPermissions(java.util.List list, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> checkCallingOrSelfUriPermissions(
    jni.JList<Uri> list,
    int i,
  ) {
    return _checkCallingOrSelfUriPermissions(
            reference.pointer,
            _id_checkCallingOrSelfUriPermissions as jni.JMethodIDPtr,
            list.reference.pointer,
            i)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_checkUriPermission1 = _class.instanceMethodId(
    r'checkUriPermission',
    r'(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;III)I',
  );

  static final _checkUriPermission1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int)>();

  /// from: public abstract int checkUriPermission(android.net.Uri uri, java.lang.String string, java.lang.String string1, int i, int i1, int i2)
  int checkUriPermission1(
    Uri uri,
    jni.JString string,
    jni.JString string1,
    int i,
    int i1,
    int i2,
  ) {
    return _checkUriPermission1(
            reference.pointer,
            _id_checkUriPermission1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer,
            i,
            i1,
            i2)
        .integer;
  }

  static final _id_enforceUriPermission = _class.instanceMethodId(
    r'enforceUriPermission',
    r'(Landroid/net/Uri;IIILjava/lang/String;)V',
  );

  static final _enforceUriPermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceUriPermission(android.net.Uri uri, int i, int i1, int i2, java.lang.String string)
  void enforceUriPermission(
    Uri uri,
    int i,
    int i1,
    int i2,
    jni.JString string,
  ) {
    _enforceUriPermission(
            reference.pointer,
            _id_enforceUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i,
            i1,
            i2,
            string.reference.pointer)
        .check();
  }

  static final _id_enforceCallingUriPermission = _class.instanceMethodId(
    r'enforceCallingUriPermission',
    r'(Landroid/net/Uri;ILjava/lang/String;)V',
  );

  static final _enforceCallingUriPermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceCallingUriPermission(android.net.Uri uri, int i, java.lang.String string)
  void enforceCallingUriPermission(
    Uri uri,
    int i,
    jni.JString string,
  ) {
    _enforceCallingUriPermission(
            reference.pointer,
            _id_enforceCallingUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i,
            string.reference.pointer)
        .check();
  }

  static final _id_enforceCallingOrSelfUriPermission = _class.instanceMethodId(
    r'enforceCallingOrSelfUriPermission',
    r'(Landroid/net/Uri;ILjava/lang/String;)V',
  );

  static final _enforceCallingOrSelfUriPermission =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<
                          (
                            ffi.Pointer<ffi.Void>,
                            $Int32,
                            ffi.Pointer<ffi.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>,
                  int,
                  ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceCallingOrSelfUriPermission(android.net.Uri uri, int i, java.lang.String string)
  void enforceCallingOrSelfUriPermission(
    Uri uri,
    int i,
    jni.JString string,
  ) {
    _enforceCallingOrSelfUriPermission(
            reference.pointer,
            _id_enforceCallingOrSelfUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i,
            string.reference.pointer)
        .check();
  }

  static final _id_enforceUriPermission1 = _class.instanceMethodId(
    r'enforceUriPermission',
    r'(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;IIILjava/lang/String;)V',
  );

  static final _enforceUriPermission1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceUriPermission(android.net.Uri uri, java.lang.String string, java.lang.String string1, int i, int i1, int i2, java.lang.String string2)
  void enforceUriPermission1(
    Uri uri,
    jni.JString string,
    jni.JString string1,
    int i,
    int i1,
    int i2,
    jni.JString string2,
  ) {
    _enforceUriPermission1(
            reference.pointer,
            _id_enforceUriPermission1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer,
            i,
            i1,
            i2,
            string2.reference.pointer)
        .check();
  }

  static final _id_revokeSelfPermissionOnKill = _class.instanceMethodId(
    r'revokeSelfPermissionOnKill',
    r'(Ljava/lang/String;)V',
  );

  static final _revokeSelfPermissionOnKill = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void revokeSelfPermissionOnKill(java.lang.String string)
  void revokeSelfPermissionOnKill(
    jni.JString string,
  ) {
    _revokeSelfPermissionOnKill(
            reference.pointer,
            _id_revokeSelfPermissionOnKill as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_revokeSelfPermissionsOnKill = _class.instanceMethodId(
    r'revokeSelfPermissionsOnKill',
    r'(Ljava/util/Collection;)V',
  );

  static final _revokeSelfPermissionsOnKill = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void revokeSelfPermissionsOnKill(java.util.Collection collection)
  void revokeSelfPermissionsOnKill(
    jni.JObject collection,
  ) {
    _revokeSelfPermissionsOnKill(
            reference.pointer,
            _id_revokeSelfPermissionsOnKill as jni.JMethodIDPtr,
            collection.reference.pointer)
        .check();
  }

  static final _id_createPackageContext = _class.instanceMethodId(
    r'createPackageContext',
    r'(Ljava/lang/String;I)Landroid/content/Context;',
  );

  static final _createPackageContext = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.Context createPackageContext(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  Context createPackageContext(
    jni.JString string,
    int i,
  ) {
    return _createPackageContext(
            reference.pointer,
            _id_createPackageContext as jni.JMethodIDPtr,
            string.reference.pointer,
            i)
        .object(const $ContextType());
  }

  static final _id_createContextForSplit = _class.instanceMethodId(
    r'createContextForSplit',
    r'(Ljava/lang/String;)Landroid/content/Context;',
  );

  static final _createContextForSplit = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Context createContextForSplit(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Context createContextForSplit(
    jni.JString string,
  ) {
    return _createContextForSplit(
            reference.pointer,
            _id_createContextForSplit as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_createConfigurationContext = _class.instanceMethodId(
    r'createConfigurationContext',
    r'(Landroid/content/res/Configuration;)Landroid/content/Context;',
  );

  static final _createConfigurationContext = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Context createConfigurationContext(android.content.res.Configuration configuration)
  /// The returned object must be released after use, by calling the [release] method.
  Context createConfigurationContext(
    jni.JObject configuration,
  ) {
    return _createConfigurationContext(
            reference.pointer,
            _id_createConfigurationContext as jni.JMethodIDPtr,
            configuration.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_createDisplayContext = _class.instanceMethodId(
    r'createDisplayContext',
    r'(Landroid/view/Display;)Landroid/content/Context;',
  );

  static final _createDisplayContext = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Context createDisplayContext(android.view.Display display)
  /// The returned object must be released after use, by calling the [release] method.
  Context createDisplayContext(
    jni.JObject display,
  ) {
    return _createDisplayContext(
            reference.pointer,
            _id_createDisplayContext as jni.JMethodIDPtr,
            display.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_createDeviceContext = _class.instanceMethodId(
    r'createDeviceContext',
    r'(I)Landroid/content/Context;',
  );

  static final _createDeviceContext = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public android.content.Context createDeviceContext(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Context createDeviceContext(
    int i,
  ) {
    return _createDeviceContext(
            reference.pointer, _id_createDeviceContext as jni.JMethodIDPtr, i)
        .object(const $ContextType());
  }

  static final _id_createWindowContext = _class.instanceMethodId(
    r'createWindowContext',
    r'(ILandroid/os/Bundle;)Landroid/content/Context;',
  );

  static final _createWindowContext = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context createWindowContext(int i, android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  Context createWindowContext(
    int i,
    jni.JObject bundle,
  ) {
    return _createWindowContext(
            reference.pointer,
            _id_createWindowContext as jni.JMethodIDPtr,
            i,
            bundle.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_createWindowContext1 = _class.instanceMethodId(
    r'createWindowContext',
    r'(Landroid/view/Display;ILandroid/os/Bundle;)Landroid/content/Context;',
  );

  static final _createWindowContext1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context createWindowContext(android.view.Display display, int i, android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  Context createWindowContext1(
    jni.JObject display,
    int i,
    jni.JObject bundle,
  ) {
    return _createWindowContext1(
            reference.pointer,
            _id_createWindowContext1 as jni.JMethodIDPtr,
            display.reference.pointer,
            i,
            bundle.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_createContext = _class.instanceMethodId(
    r'createContext',
    r'(Landroid/content/ContextParams;)Landroid/content/Context;',
  );

  static final _createContext = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context createContext(android.content.ContextParams contextParams)
  /// The returned object must be released after use, by calling the [release] method.
  Context createContext(
    jni.JObject contextParams,
  ) {
    return _createContext(
            reference.pointer,
            _id_createContext as jni.JMethodIDPtr,
            contextParams.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_createAttributionContext = _class.instanceMethodId(
    r'createAttributionContext',
    r'(Ljava/lang/String;)Landroid/content/Context;',
  );

  static final _createAttributionContext = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context createAttributionContext(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Context createAttributionContext(
    jni.JString string,
  ) {
    return _createAttributionContext(
            reference.pointer,
            _id_createAttributionContext as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_createDeviceProtectedStorageContext =
      _class.instanceMethodId(
    r'createDeviceProtectedStorageContext',
    r'()Landroid/content/Context;',
  );

  static final _createDeviceProtectedStorageContext =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public abstract android.content.Context createDeviceProtectedStorageContext()
  /// The returned object must be released after use, by calling the [release] method.
  Context createDeviceProtectedStorageContext() {
    return _createDeviceProtectedStorageContext(reference.pointer,
            _id_createDeviceProtectedStorageContext as jni.JMethodIDPtr)
        .object(const $ContextType());
  }

  static final _id_getDisplay = _class.instanceMethodId(
    r'getDisplay',
    r'()Landroid/view/Display;',
  );

  static final _getDisplay = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.view.Display getDisplay()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDisplay() {
    return _getDisplay(reference.pointer, _id_getDisplay as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getDeviceId = _class.instanceMethodId(
    r'getDeviceId',
    r'()I',
  );

  static final _getDeviceId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getDeviceId()
  int getDeviceId() {
    return _getDeviceId(reference.pointer, _id_getDeviceId as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_registerDeviceIdChangeListener = _class.instanceMethodId(
    r'registerDeviceIdChangeListener',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/IntConsumer;)V',
  );

  static final _registerDeviceIdChangeListener = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerDeviceIdChangeListener(java.util.concurrent.Executor executor, java.util.function.IntConsumer intConsumer)
  void registerDeviceIdChangeListener(
    Executor executor,
    jni.JObject intConsumer,
  ) {
    _registerDeviceIdChangeListener(
            reference.pointer,
            _id_registerDeviceIdChangeListener as jni.JMethodIDPtr,
            executor.reference.pointer,
            intConsumer.reference.pointer)
        .check();
  }

  static final _id_unregisterDeviceIdChangeListener = _class.instanceMethodId(
    r'unregisterDeviceIdChangeListener',
    r'(Ljava/util/function/IntConsumer;)V',
  );

  static final _unregisterDeviceIdChangeListener =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterDeviceIdChangeListener(java.util.function.IntConsumer intConsumer)
  void unregisterDeviceIdChangeListener(
    jni.JObject intConsumer,
  ) {
    _unregisterDeviceIdChangeListener(
            reference.pointer,
            _id_unregisterDeviceIdChangeListener as jni.JMethodIDPtr,
            intConsumer.reference.pointer)
        .check();
  }

  static final _id_isRestricted = _class.instanceMethodId(
    r'isRestricted',
    r'()Z',
  );

  static final _isRestricted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isRestricted()
  bool isRestricted() {
    return _isRestricted(
            reference.pointer, _id_isRestricted as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isDeviceProtectedStorage = _class.instanceMethodId(
    r'isDeviceProtectedStorage',
    r'()Z',
  );

  static final _isDeviceProtectedStorage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isDeviceProtectedStorage()
  bool isDeviceProtectedStorage() {
    return _isDeviceProtectedStorage(
            reference.pointer, _id_isDeviceProtectedStorage as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isUiContext = _class.instanceMethodId(
    r'isUiContext',
    r'()Z',
  );

  static final _isUiContext = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isUiContext()
  bool isUiContext() {
    return _isUiContext(reference.pointer, _id_isUiContext as jni.JMethodIDPtr)
        .boolean;
  }
}

final class $ContextType extends jni.JObjType<Context> {
  const $ContextType();

  @override
  String get signature => r'Landroid/content/Context;';

  @override
  Context fromReference(jni.JReference reference) =>
      Context.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ContextType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContextType) && other is $ContextType;
  }
}

/// from: android.content.ContentResolver$MimeTypeInfo
class ContentResolver_MimeTypeInfo extends jni.JObject {
  @override
  late final jni.JObjType<ContentResolver_MimeTypeInfo> $type = type;

  ContentResolver_MimeTypeInfo.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/content/ContentResolver$MimeTypeInfo');

  /// The type which includes information such as the signature of this class.
  static const type = $ContentResolver_MimeTypeInfoType();
  static final _id_getIcon = _class.instanceMethodId(
    r'getIcon',
    r'()Landroid/graphics/drawable/Icon;',
  );

  static final _getIcon = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.drawable.Icon getIcon()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getIcon() {
    return _getIcon(reference.pointer, _id_getIcon as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getLabel = _class.instanceMethodId(
    r'getLabel',
    r'()Ljava/lang/CharSequence;',
  );

  static final _getLabel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.CharSequence getLabel()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLabel() {
    return _getLabel(reference.pointer, _id_getLabel as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getContentDescription = _class.instanceMethodId(
    r'getContentDescription',
    r'()Ljava/lang/CharSequence;',
  );

  static final _getContentDescription = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.CharSequence getContentDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContentDescription() {
    return _getContentDescription(
            reference.pointer, _id_getContentDescription as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $ContentResolver_MimeTypeInfoType
    extends jni.JObjType<ContentResolver_MimeTypeInfo> {
  const $ContentResolver_MimeTypeInfoType();

  @override
  String get signature => r'Landroid/content/ContentResolver$MimeTypeInfo;';

  @override
  ContentResolver_MimeTypeInfo fromReference(jni.JReference reference) =>
      ContentResolver_MimeTypeInfo.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ContentResolver_MimeTypeInfoType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContentResolver_MimeTypeInfoType) &&
        other is $ContentResolver_MimeTypeInfoType;
  }
}

/// from: android.content.ContentResolver
class ContentResolver extends jni.JObject {
  @override
  late final jni.JObjType<ContentResolver> $type = type;

  ContentResolver.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/content/ContentResolver');

  /// The type which includes information such as the signature of this class.
  static const type = $ContentResolverType();
  static final _id_ANY_CURSOR_ITEM_TYPE = _class.staticFieldId(
    r'ANY_CURSOR_ITEM_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ANY_CURSOR_ITEM_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ANY_CURSOR_ITEM_TYPE =>
      _id_ANY_CURSOR_ITEM_TYPE.get(_class, const jni.JStringType());

  static final _id_CURSOR_DIR_BASE_TYPE = _class.staticFieldId(
    r'CURSOR_DIR_BASE_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CURSOR_DIR_BASE_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CURSOR_DIR_BASE_TYPE =>
      _id_CURSOR_DIR_BASE_TYPE.get(_class, const jni.JStringType());

  static final _id_CURSOR_ITEM_BASE_TYPE = _class.staticFieldId(
    r'CURSOR_ITEM_BASE_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CURSOR_ITEM_BASE_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CURSOR_ITEM_BASE_TYPE =>
      _id_CURSOR_ITEM_BASE_TYPE.get(_class, const jni.JStringType());

  static final _id_EXTRA_HONORED_ARGS = _class.staticFieldId(
    r'EXTRA_HONORED_ARGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_HONORED_ARGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_HONORED_ARGS =>
      _id_EXTRA_HONORED_ARGS.get(_class, const jni.JStringType());

  static final _id_EXTRA_REFRESH_SUPPORTED = _class.staticFieldId(
    r'EXTRA_REFRESH_SUPPORTED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_REFRESH_SUPPORTED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_REFRESH_SUPPORTED =>
      _id_EXTRA_REFRESH_SUPPORTED.get(_class, const jni.JStringType());

  static final _id_EXTRA_SIZE = _class.staticFieldId(
    r'EXTRA_SIZE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_SIZE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_SIZE =>
      _id_EXTRA_SIZE.get(_class, const jni.JStringType());

  static final _id_EXTRA_TOTAL_COUNT = _class.staticFieldId(
    r'EXTRA_TOTAL_COUNT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_TOTAL_COUNT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_TOTAL_COUNT =>
      _id_EXTRA_TOTAL_COUNT.get(_class, const jni.JStringType());

  /// from: static public final int NOTIFY_DELETE
  static const NOTIFY_DELETE = 16;

  /// from: static public final int NOTIFY_INSERT
  static const NOTIFY_INSERT = 4;

  /// from: static public final int NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS
  static const NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS = 2;

  /// from: static public final int NOTIFY_SYNC_TO_NETWORK
  static const NOTIFY_SYNC_TO_NETWORK = 1;

  /// from: static public final int NOTIFY_UPDATE
  static const NOTIFY_UPDATE = 8;
  static final _id_QUERY_ARG_GROUP_COLUMNS = _class.staticFieldId(
    r'QUERY_ARG_GROUP_COLUMNS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_GROUP_COLUMNS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_GROUP_COLUMNS =>
      _id_QUERY_ARG_GROUP_COLUMNS.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_LIMIT = _class.staticFieldId(
    r'QUERY_ARG_LIMIT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_LIMIT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_LIMIT =>
      _id_QUERY_ARG_LIMIT.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_OFFSET = _class.staticFieldId(
    r'QUERY_ARG_OFFSET',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_OFFSET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_OFFSET =>
      _id_QUERY_ARG_OFFSET.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SORT_COLLATION = _class.staticFieldId(
    r'QUERY_ARG_SORT_COLLATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SORT_COLLATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SORT_COLLATION =>
      _id_QUERY_ARG_SORT_COLLATION.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SORT_COLUMNS = _class.staticFieldId(
    r'QUERY_ARG_SORT_COLUMNS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SORT_COLUMNS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SORT_COLUMNS =>
      _id_QUERY_ARG_SORT_COLUMNS.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SORT_DIRECTION = _class.staticFieldId(
    r'QUERY_ARG_SORT_DIRECTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SORT_DIRECTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SORT_DIRECTION =>
      _id_QUERY_ARG_SORT_DIRECTION.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SORT_LOCALE = _class.staticFieldId(
    r'QUERY_ARG_SORT_LOCALE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SORT_LOCALE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SORT_LOCALE =>
      _id_QUERY_ARG_SORT_LOCALE.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SQL_GROUP_BY = _class.staticFieldId(
    r'QUERY_ARG_SQL_GROUP_BY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SQL_GROUP_BY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SQL_GROUP_BY =>
      _id_QUERY_ARG_SQL_GROUP_BY.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SQL_HAVING = _class.staticFieldId(
    r'QUERY_ARG_SQL_HAVING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SQL_HAVING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SQL_HAVING =>
      _id_QUERY_ARG_SQL_HAVING.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SQL_LIMIT = _class.staticFieldId(
    r'QUERY_ARG_SQL_LIMIT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SQL_LIMIT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SQL_LIMIT =>
      _id_QUERY_ARG_SQL_LIMIT.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SQL_SELECTION = _class.staticFieldId(
    r'QUERY_ARG_SQL_SELECTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SQL_SELECTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SQL_SELECTION =>
      _id_QUERY_ARG_SQL_SELECTION.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SQL_SELECTION_ARGS = _class.staticFieldId(
    r'QUERY_ARG_SQL_SELECTION_ARGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SQL_SELECTION_ARGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SQL_SELECTION_ARGS =>
      _id_QUERY_ARG_SQL_SELECTION_ARGS.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_SQL_SORT_ORDER = _class.staticFieldId(
    r'QUERY_ARG_SQL_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_SQL_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_SQL_SORT_ORDER =>
      _id_QUERY_ARG_SQL_SORT_ORDER.get(_class, const jni.JStringType());

  /// from: static public final int QUERY_SORT_DIRECTION_ASCENDING
  static const QUERY_SORT_DIRECTION_ASCENDING = 0;

  /// from: static public final int QUERY_SORT_DIRECTION_DESCENDING
  static const QUERY_SORT_DIRECTION_DESCENDING = 1;
  static final _id_SCHEME_ANDROID_RESOURCE = _class.staticFieldId(
    r'SCHEME_ANDROID_RESOURCE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SCHEME_ANDROID_RESOURCE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SCHEME_ANDROID_RESOURCE =>
      _id_SCHEME_ANDROID_RESOURCE.get(_class, const jni.JStringType());

  static final _id_SCHEME_CONTENT = _class.staticFieldId(
    r'SCHEME_CONTENT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SCHEME_CONTENT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SCHEME_CONTENT =>
      _id_SCHEME_CONTENT.get(_class, const jni.JStringType());

  static final _id_SCHEME_FILE = _class.staticFieldId(
    r'SCHEME_FILE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SCHEME_FILE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SCHEME_FILE =>
      _id_SCHEME_FILE.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_ACCOUNT = _class.staticFieldId(
    r'SYNC_EXTRAS_ACCOUNT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_ACCOUNT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_ACCOUNT =>
      _id_SYNC_EXTRAS_ACCOUNT.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS = _class.staticFieldId(
    r'SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS =>
      _id_SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS.get(
          _class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_DO_NOT_RETRY = _class.staticFieldId(
    r'SYNC_EXTRAS_DO_NOT_RETRY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_DO_NOT_RETRY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_DO_NOT_RETRY =>
      _id_SYNC_EXTRAS_DO_NOT_RETRY.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_EXPEDITED = _class.staticFieldId(
    r'SYNC_EXTRAS_EXPEDITED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_EXPEDITED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_EXPEDITED =>
      _id_SYNC_EXTRAS_EXPEDITED.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_FORCE = _class.staticFieldId(
    r'SYNC_EXTRAS_FORCE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_FORCE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_FORCE =>
      _id_SYNC_EXTRAS_FORCE.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_IGNORE_BACKOFF = _class.staticFieldId(
    r'SYNC_EXTRAS_IGNORE_BACKOFF',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_IGNORE_BACKOFF
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_IGNORE_BACKOFF =>
      _id_SYNC_EXTRAS_IGNORE_BACKOFF.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_IGNORE_SETTINGS = _class.staticFieldId(
    r'SYNC_EXTRAS_IGNORE_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_IGNORE_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_IGNORE_SETTINGS =>
      _id_SYNC_EXTRAS_IGNORE_SETTINGS.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_INITIALIZE = _class.staticFieldId(
    r'SYNC_EXTRAS_INITIALIZE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_INITIALIZE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_INITIALIZE =>
      _id_SYNC_EXTRAS_INITIALIZE.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_MANUAL = _class.staticFieldId(
    r'SYNC_EXTRAS_MANUAL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_MANUAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_MANUAL =>
      _id_SYNC_EXTRAS_MANUAL.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS =
      _class.staticFieldId(
    r'SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS =>
      _id_SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS.get(
          _class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_REQUIRE_CHARGING = _class.staticFieldId(
    r'SYNC_EXTRAS_REQUIRE_CHARGING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_REQUIRE_CHARGING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_REQUIRE_CHARGING =>
      _id_SYNC_EXTRAS_REQUIRE_CHARGING.get(_class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB = _class.staticFieldId(
    r'SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB =>
      _id_SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB.get(
          _class, const jni.JStringType());

  static final _id_SYNC_EXTRAS_UPLOAD = _class.staticFieldId(
    r'SYNC_EXTRAS_UPLOAD',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SYNC_EXTRAS_UPLOAD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SYNC_EXTRAS_UPLOAD =>
      _id_SYNC_EXTRAS_UPLOAD.get(_class, const jni.JStringType());

  /// from: static public final int SYNC_OBSERVER_TYPE_ACTIVE
  static const SYNC_OBSERVER_TYPE_ACTIVE = 4;

  /// from: static public final int SYNC_OBSERVER_TYPE_PENDING
  static const SYNC_OBSERVER_TYPE_PENDING = 2;

  /// from: static public final int SYNC_OBSERVER_TYPE_SETTINGS
  static const SYNC_OBSERVER_TYPE_SETTINGS = 1;
  static final _id_new0 = _class.constructorId(
    r'(Landroid/content/Context;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory ContentResolver(
    Context context,
  ) {
    return ContentResolver.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, context.reference.pointer)
        .reference);
  }

  static final _id_wrap = _class.staticMethodId(
    r'wrap',
    r'(Landroid/content/ContentProvider;)Landroid/content/ContentResolver;',
  );

  static final _wrap = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ContentResolver wrap(android.content.ContentProvider contentProvider)
  /// The returned object must be released after use, by calling the [release] method.
  static ContentResolver wrap(
    jni.JObject contentProvider,
  ) {
    return _wrap(_class.reference.pointer, _id_wrap as jni.JMethodIDPtr,
            contentProvider.reference.pointer)
        .object(const $ContentResolverType());
  }

  static final _id_wrap1 = _class.staticMethodId(
    r'wrap',
    r'(Landroid/content/ContentProviderClient;)Landroid/content/ContentResolver;',
  );

  static final _wrap1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ContentResolver wrap(android.content.ContentProviderClient contentProviderClient)
  /// The returned object must be released after use, by calling the [release] method.
  static ContentResolver wrap1(
    jni.JObject contentProviderClient,
  ) {
    return _wrap1(_class.reference.pointer, _id_wrap1 as jni.JMethodIDPtr,
            contentProviderClient.reference.pointer)
        .object(const $ContentResolverType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'(Landroid/net/Uri;)Ljava/lang/String;',
  );

  static final _getType = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getType(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getType(
    Uri uri,
  ) {
    return _getType(reference.pointer, _id_getType as jni.JMethodIDPtr,
            uri.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getStreamTypes = _class.instanceMethodId(
    r'getStreamTypes',
    r'(Landroid/net/Uri;Ljava/lang/String;)[Ljava/lang/String;',
  );

  static final _getStreamTypes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getStreamTypes(android.net.Uri uri, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getStreamTypes(
    Uri uri,
    jni.JString string,
  ) {
    return _getStreamTypes(
            reference.pointer,
            _id_getStreamTypes as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer)
        .object(const jni.JArrayType(jni.JStringType()));
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _query = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] strings, java.lang.String string, java.lang.String[] strings1, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Cursor query(
    Uri uri,
    jni.JArray<jni.JString> strings,
    jni.JString string,
    jni.JArray<jni.JString> strings1,
    jni.JString string1,
  ) {
    return _query(
            reference.pointer,
            _id_query as jni.JMethodIDPtr,
            uri.reference.pointer,
            strings.reference.pointer,
            string.reference.pointer,
            strings1.reference.pointer,
            string1.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_query1 = _class.instanceMethodId(
    r'query',
    r'(Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/database/Cursor;',
  );

  static final _query1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] strings, java.lang.String string, java.lang.String[] strings1, java.lang.String string1, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  Cursor query1(
    Uri uri,
    jni.JArray<jni.JString> strings,
    jni.JString string,
    jni.JArray<jni.JString> strings1,
    jni.JString string1,
    jni.JObject cancellationSignal,
  ) {
    return _query1(
            reference.pointer,
            _id_query1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            strings.reference.pointer,
            string.reference.pointer,
            strings1.reference.pointer,
            string1.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_query2 = _class.instanceMethodId(
    r'query',
    r'(Landroid/net/Uri;[Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/database/Cursor;',
  );

  static final _query2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] strings, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  Cursor query2(
    Uri uri,
    jni.JArray<jni.JString> strings,
    jni.JObject bundle,
    jni.JObject cancellationSignal,
  ) {
    return _query2(
            reference.pointer,
            _id_query2 as jni.JMethodIDPtr,
            uri.reference.pointer,
            strings.reference.pointer,
            bundle.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_canonicalize = _class.instanceMethodId(
    r'canonicalize',
    r'(Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _canonicalize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri canonicalize(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  Uri canonicalize(
    Uri uri,
  ) {
    return _canonicalize(reference.pointer,
            _id_canonicalize as jni.JMethodIDPtr, uri.reference.pointer)
        .object(const $UriType());
  }

  static final _id_uncanonicalize = _class.instanceMethodId(
    r'uncanonicalize',
    r'(Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _uncanonicalize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri uncanonicalize(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  Uri uncanonicalize(
    Uri uri,
  ) {
    return _uncanonicalize(reference.pointer,
            _id_uncanonicalize as jni.JMethodIDPtr, uri.reference.pointer)
        .object(const $UriType());
  }

  static final _id_refresh = _class.instanceMethodId(
    r'refresh',
    r'(Landroid/net/Uri;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Z',
  );

  static final _refresh = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean refresh(android.net.Uri uri, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal)
  bool refresh(
    Uri uri,
    jni.JObject bundle,
    jni.JObject cancellationSignal,
  ) {
    return _refresh(
            reference.pointer,
            _id_refresh as jni.JMethodIDPtr,
            uri.reference.pointer,
            bundle.reference.pointer,
            cancellationSignal.reference.pointer)
        .boolean;
  }

  static final _id_openInputStream = _class.instanceMethodId(
    r'openInputStream',
    r'(Landroid/net/Uri;)Ljava/io/InputStream;',
  );

  static final _openInputStream = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.io.InputStream openInputStream(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openInputStream(
    Uri uri,
  ) {
    return _openInputStream(reference.pointer,
            _id_openInputStream as jni.JMethodIDPtr, uri.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openOutputStream = _class.instanceMethodId(
    r'openOutputStream',
    r'(Landroid/net/Uri;)Ljava/io/OutputStream;',
  );

  static final _openOutputStream = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.io.OutputStream openOutputStream(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openOutputStream(
    Uri uri,
  ) {
    return _openOutputStream(reference.pointer,
            _id_openOutputStream as jni.JMethodIDPtr, uri.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openOutputStream1 = _class.instanceMethodId(
    r'openOutputStream',
    r'(Landroid/net/Uri;Ljava/lang/String;)Ljava/io/OutputStream;',
  );

  static final _openOutputStream1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.io.OutputStream openOutputStream(android.net.Uri uri, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openOutputStream1(
    Uri uri,
    jni.JString string,
  ) {
    return _openOutputStream1(
            reference.pointer,
            _id_openOutputStream1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openFile = _class.instanceMethodId(
    r'openFile',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/os/ParcelFileDescriptor;',
  );

  static final _openFile = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String string, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openFile(
    Uri uri,
    jni.JString string,
    jni.JObject cancellationSignal,
  ) {
    return _openFile(
            reference.pointer,
            _id_openFile as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openFileDescriptor = _class.instanceMethodId(
    r'openFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;)Landroid/os/ParcelFileDescriptor;',
  );

  static final _openFileDescriptor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.ParcelFileDescriptor openFileDescriptor(android.net.Uri uri, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openFileDescriptor(
    Uri uri,
    jni.JString string,
  ) {
    return _openFileDescriptor(
            reference.pointer,
            _id_openFileDescriptor as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openFileDescriptor1 = _class.instanceMethodId(
    r'openFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/os/ParcelFileDescriptor;',
  );

  static final _openFileDescriptor1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.ParcelFileDescriptor openFileDescriptor(android.net.Uri uri, java.lang.String string, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openFileDescriptor1(
    Uri uri,
    jni.JString string,
    jni.JObject cancellationSignal,
  ) {
    return _openFileDescriptor1(
            reference.pointer,
            _id_openFileDescriptor1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openAssetFile = _class.instanceMethodId(
    r'openAssetFile',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openAssetFile = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri uri, java.lang.String string, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openAssetFile(
    Uri uri,
    jni.JString string,
    jni.JObject cancellationSignal,
  ) {
    return _openAssetFile(
            reference.pointer,
            _id_openAssetFile as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openAssetFileDescriptor = _class.instanceMethodId(
    r'openAssetFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openAssetFileDescriptor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openAssetFileDescriptor(android.net.Uri uri, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openAssetFileDescriptor(
    Uri uri,
    jni.JString string,
  ) {
    return _openAssetFileDescriptor(
            reference.pointer,
            _id_openAssetFileDescriptor as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openAssetFileDescriptor1 = _class.instanceMethodId(
    r'openAssetFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openAssetFileDescriptor1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openAssetFileDescriptor(android.net.Uri uri, java.lang.String string, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openAssetFileDescriptor1(
    Uri uri,
    jni.JString string,
    jni.JObject cancellationSignal,
  ) {
    return _openAssetFileDescriptor1(
            reference.pointer,
            _id_openAssetFileDescriptor1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openTypedAssetFile = _class.instanceMethodId(
    r'openTypedAssetFile',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openTypedAssetFile = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFile(android.net.Uri uri, java.lang.String string, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openTypedAssetFile(
    Uri uri,
    jni.JString string,
    jni.JObject bundle,
    jni.JObject cancellationSignal,
  ) {
    return _openTypedAssetFile(
            reference.pointer,
            _id_openTypedAssetFile as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openTypedAssetFileDescriptor = _class.instanceMethodId(
    r'openTypedAssetFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openTypedAssetFileDescriptor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String string, android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openTypedAssetFileDescriptor(
    Uri uri,
    jni.JString string,
    jni.JObject bundle,
  ) {
    return _openTypedAssetFileDescriptor(
            reference.pointer,
            _id_openTypedAssetFileDescriptor as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_openTypedAssetFileDescriptor1 = _class.instanceMethodId(
    r'openTypedAssetFileDescriptor',
    r'(Landroid/net/Uri;Ljava/lang/String;Landroid/os/Bundle;Landroid/os/CancellationSignal;)Landroid/content/res/AssetFileDescriptor;',
  );

  static final _openTypedAssetFileDescriptor1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String string, android.os.Bundle bundle, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openTypedAssetFileDescriptor1(
    Uri uri,
    jni.JString string,
    jni.JObject bundle,
    jni.JObject cancellationSignal,
  ) {
    return _openTypedAssetFileDescriptor1(
            reference.pointer,
            _id_openTypedAssetFileDescriptor1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_insert = _class.instanceMethodId(
    r'insert',
    r'(Landroid/net/Uri;Landroid/content/ContentValues;)Landroid/net/Uri;',
  );

  static final _insert = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri insert(android.net.Uri uri, android.content.ContentValues contentValues)
  /// The returned object must be released after use, by calling the [release] method.
  Uri insert(
    Uri uri,
    ContentValues contentValues,
  ) {
    return _insert(reference.pointer, _id_insert as jni.JMethodIDPtr,
            uri.reference.pointer, contentValues.reference.pointer)
        .object(const $UriType());
  }

  static final _id_insert1 = _class.instanceMethodId(
    r'insert',
    r'(Landroid/net/Uri;Landroid/content/ContentValues;Landroid/os/Bundle;)Landroid/net/Uri;',
  );

  static final _insert1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri insert(android.net.Uri uri, android.content.ContentValues contentValues, android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  Uri insert1(
    Uri uri,
    ContentValues contentValues,
    jni.JObject bundle,
  ) {
    return _insert1(
            reference.pointer,
            _id_insert1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            contentValues.reference.pointer,
            bundle.reference.pointer)
        .object(const $UriType());
  }

  static final _id_applyBatch = _class.instanceMethodId(
    r'applyBatch',
    r'(Ljava/lang/String;Ljava/util/ArrayList;)[Landroid/content/ContentProviderResult;',
  );

  static final _applyBatch = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object[] applyBatch(java.lang.String string, java.util.ArrayList arrayList)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> applyBatch(
    jni.JString string,
    jni.JObject arrayList,
  ) {
    return _applyBatch(reference.pointer, _id_applyBatch as jni.JMethodIDPtr,
            string.reference.pointer, arrayList.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_bulkInsert = _class.instanceMethodId(
    r'bulkInsert',
    r'(Landroid/net/Uri;[Landroid/content/ContentValues;)I',
  );

  static final _bulkInsert = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final int bulkInsert(android.net.Uri uri, android.content.ContentValues[] contentValuess)
  int bulkInsert(
    Uri uri,
    jni.JArray<ContentValues> contentValuess,
  ) {
    return _bulkInsert(reference.pointer, _id_bulkInsert as jni.JMethodIDPtr,
            uri.reference.pointer, contentValuess.reference.pointer)
        .integer;
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'(Landroid/net/Uri;Ljava/lang/String;[Ljava/lang/String;)I',
  );

  static final _delete = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int delete(android.net.Uri uri, java.lang.String string, java.lang.String[] strings)
  int delete(
    Uri uri,
    jni.JString string,
    jni.JArray<jni.JString> strings,
  ) {
    return _delete(
            reference.pointer,
            _id_delete as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            strings.reference.pointer)
        .integer;
  }

  static final _id_delete1 = _class.instanceMethodId(
    r'delete',
    r'(Landroid/net/Uri;Landroid/os/Bundle;)I',
  );

  static final _delete1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final int delete(android.net.Uri uri, android.os.Bundle bundle)
  int delete1(
    Uri uri,
    jni.JObject bundle,
  ) {
    return _delete1(reference.pointer, _id_delete1 as jni.JMethodIDPtr,
            uri.reference.pointer, bundle.reference.pointer)
        .integer;
  }

  static final _id_update = _class.instanceMethodId(
    r'update',
    r'(Landroid/net/Uri;Landroid/content/ContentValues;Ljava/lang/String;[Ljava/lang/String;)I',
  );

  static final _update = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int update(android.net.Uri uri, android.content.ContentValues contentValues, java.lang.String string, java.lang.String[] strings)
  int update(
    Uri uri,
    ContentValues contentValues,
    jni.JString string,
    jni.JArray<jni.JString> strings,
  ) {
    return _update(
            reference.pointer,
            _id_update as jni.JMethodIDPtr,
            uri.reference.pointer,
            contentValues.reference.pointer,
            string.reference.pointer,
            strings.reference.pointer)
        .integer;
  }

  static final _id_update1 = _class.instanceMethodId(
    r'update',
    r'(Landroid/net/Uri;Landroid/content/ContentValues;Landroid/os/Bundle;)I',
  );

  static final _update1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int update(android.net.Uri uri, android.content.ContentValues contentValues, android.os.Bundle bundle)
  int update1(
    Uri uri,
    ContentValues contentValues,
    jni.JObject bundle,
  ) {
    return _update1(
            reference.pointer,
            _id_update1 as jni.JMethodIDPtr,
            uri.reference.pointer,
            contentValues.reference.pointer,
            bundle.reference.pointer)
        .integer;
  }

  static final _id_call = _class.instanceMethodId(
    r'call',
    r'(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Landroid/os/Bundle;',
  );

  static final _call = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Bundle call(android.net.Uri uri, java.lang.String string, java.lang.String string1, android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject call(
    Uri uri,
    jni.JString string,
    jni.JString string1,
    jni.JObject bundle,
  ) {
    return _call(
            reference.pointer,
            _id_call as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer,
            bundle.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_call1 = _class.instanceMethodId(
    r'call',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Landroid/os/Bundle;)Landroid/os/Bundle;',
  );

  static final _call1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Bundle call(java.lang.String string, java.lang.String string1, java.lang.String string2, android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject call1(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JObject bundle,
  ) {
    return _call1(
            reference.pointer,
            _id_call1 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            bundle.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_acquireContentProviderClient = _class.instanceMethodId(
    r'acquireContentProviderClient',
    r'(Landroid/net/Uri;)Landroid/content/ContentProviderClient;',
  );

  static final _acquireContentProviderClient = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentProviderClient acquireContentProviderClient(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject acquireContentProviderClient(
    Uri uri,
  ) {
    return _acquireContentProviderClient(
            reference.pointer,
            _id_acquireContentProviderClient as jni.JMethodIDPtr,
            uri.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_acquireContentProviderClient1 = _class.instanceMethodId(
    r'acquireContentProviderClient',
    r'(Ljava/lang/String;)Landroid/content/ContentProviderClient;',
  );

  static final _acquireContentProviderClient1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentProviderClient acquireContentProviderClient(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject acquireContentProviderClient1(
    jni.JString string,
  ) {
    return _acquireContentProviderClient1(
            reference.pointer,
            _id_acquireContentProviderClient1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_acquireUnstableContentProviderClient =
      _class.instanceMethodId(
    r'acquireUnstableContentProviderClient',
    r'(Landroid/net/Uri;)Landroid/content/ContentProviderClient;',
  );

  static final _acquireUnstableContentProviderClient =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentProviderClient acquireUnstableContentProviderClient(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject acquireUnstableContentProviderClient(
    Uri uri,
  ) {
    return _acquireUnstableContentProviderClient(
            reference.pointer,
            _id_acquireUnstableContentProviderClient as jni.JMethodIDPtr,
            uri.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_acquireUnstableContentProviderClient1 =
      _class.instanceMethodId(
    r'acquireUnstableContentProviderClient',
    r'(Ljava/lang/String;)Landroid/content/ContentProviderClient;',
  );

  static final _acquireUnstableContentProviderClient1 =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentProviderClient acquireUnstableContentProviderClient(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject acquireUnstableContentProviderClient1(
    jni.JString string,
  ) {
    return _acquireUnstableContentProviderClient1(
            reference.pointer,
            _id_acquireUnstableContentProviderClient1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_registerContentObserver = _class.instanceMethodId(
    r'registerContentObserver',
    r'(Landroid/net/Uri;ZLandroid/database/ContentObserver;)V',
  );

  static final _registerContentObserver = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void registerContentObserver(android.net.Uri uri, boolean z, android.database.ContentObserver contentObserver)
  void registerContentObserver(
    Uri uri,
    bool z,
    jni.JObject contentObserver,
  ) {
    _registerContentObserver(
            reference.pointer,
            _id_registerContentObserver as jni.JMethodIDPtr,
            uri.reference.pointer,
            z ? 1 : 0,
            contentObserver.reference.pointer)
        .check();
  }

  static final _id_unregisterContentObserver = _class.instanceMethodId(
    r'unregisterContentObserver',
    r'(Landroid/database/ContentObserver;)V',
  );

  static final _unregisterContentObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void unregisterContentObserver(android.database.ContentObserver contentObserver)
  void unregisterContentObserver(
    jni.JObject contentObserver,
  ) {
    _unregisterContentObserver(
            reference.pointer,
            _id_unregisterContentObserver as jni.JMethodIDPtr,
            contentObserver.reference.pointer)
        .check();
  }

  static final _id_notifyChange = _class.instanceMethodId(
    r'notifyChange',
    r'(Landroid/net/Uri;Landroid/database/ContentObserver;)V',
  );

  static final _notifyChange = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver contentObserver)
  void notifyChange(
    Uri uri,
    jni.JObject contentObserver,
  ) {
    _notifyChange(reference.pointer, _id_notifyChange as jni.JMethodIDPtr,
            uri.reference.pointer, contentObserver.reference.pointer)
        .check();
  }

  static final _id_notifyChange1 = _class.instanceMethodId(
    r'notifyChange',
    r'(Landroid/net/Uri;Landroid/database/ContentObserver;Z)V',
  );

  static final _notifyChange1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver contentObserver, boolean z)
  void notifyChange1(
    Uri uri,
    jni.JObject contentObserver,
    bool z,
  ) {
    _notifyChange1(reference.pointer, _id_notifyChange1 as jni.JMethodIDPtr,
            uri.reference.pointer, contentObserver.reference.pointer, z ? 1 : 0)
        .check();
  }

  static final _id_notifyChange2 = _class.instanceMethodId(
    r'notifyChange',
    r'(Landroid/net/Uri;Landroid/database/ContentObserver;I)V',
  );

  static final _notifyChange2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver contentObserver, int i)
  void notifyChange2(
    Uri uri,
    jni.JObject contentObserver,
    int i,
  ) {
    _notifyChange2(reference.pointer, _id_notifyChange2 as jni.JMethodIDPtr,
            uri.reference.pointer, contentObserver.reference.pointer, i)
        .check();
  }

  static final _id_notifyChange3 = _class.instanceMethodId(
    r'notifyChange',
    r'(Ljava/util/Collection;Landroid/database/ContentObserver;I)V',
  );

  static final _notifyChange3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void notifyChange(java.util.Collection collection, android.database.ContentObserver contentObserver, int i)
  void notifyChange3(
    jni.JObject collection,
    jni.JObject contentObserver,
    int i,
  ) {
    _notifyChange3(reference.pointer, _id_notifyChange3 as jni.JMethodIDPtr,
            collection.reference.pointer, contentObserver.reference.pointer, i)
        .check();
  }

  static final _id_takePersistableUriPermission = _class.instanceMethodId(
    r'takePersistableUriPermission',
    r'(Landroid/net/Uri;I)V',
  );

  static final _takePersistableUriPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void takePersistableUriPermission(android.net.Uri uri, int i)
  void takePersistableUriPermission(
    Uri uri,
    int i,
  ) {
    _takePersistableUriPermission(
            reference.pointer,
            _id_takePersistableUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i)
        .check();
  }

  static final _id_releasePersistableUriPermission = _class.instanceMethodId(
    r'releasePersistableUriPermission',
    r'(Landroid/net/Uri;I)V',
  );

  static final _releasePersistableUriPermission = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void releasePersistableUriPermission(android.net.Uri uri, int i)
  void releasePersistableUriPermission(
    Uri uri,
    int i,
  ) {
    _releasePersistableUriPermission(
            reference.pointer,
            _id_releasePersistableUriPermission as jni.JMethodIDPtr,
            uri.reference.pointer,
            i)
        .check();
  }

  static final _id_getPersistedUriPermissions = _class.instanceMethodId(
    r'getPersistedUriPermissions',
    r'()Ljava/util/List;',
  );

  static final _getPersistedUriPermissions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getPersistedUriPermissions()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getPersistedUriPermissions() {
    return _getPersistedUriPermissions(reference.pointer,
            _id_getPersistedUriPermissions as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_getOutgoingPersistedUriPermissions = _class.instanceMethodId(
    r'getOutgoingPersistedUriPermissions',
    r'()Ljava/util/List;',
  );

  static final _getOutgoingPersistedUriPermissions =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public java.util.List getOutgoingPersistedUriPermissions()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getOutgoingPersistedUriPermissions() {
    return _getOutgoingPersistedUriPermissions(reference.pointer,
            _id_getOutgoingPersistedUriPermissions as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_startSync = _class.instanceMethodId(
    r'startSync',
    r'(Landroid/net/Uri;Landroid/os/Bundle;)V',
  );

  static final _startSync = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startSync(android.net.Uri uri, android.os.Bundle bundle)
  void startSync(
    Uri uri,
    jni.JObject bundle,
  ) {
    _startSync(reference.pointer, _id_startSync as jni.JMethodIDPtr,
            uri.reference.pointer, bundle.reference.pointer)
        .check();
  }

  static final _id_requestSync = _class.staticMethodId(
    r'requestSync',
    r'(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _requestSync = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void requestSync(android.accounts.Account account, java.lang.String string, android.os.Bundle bundle)
  static void requestSync(
    jni.JObject account,
    jni.JString string,
    jni.JObject bundle,
  ) {
    _requestSync(
            _class.reference.pointer,
            _id_requestSync as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_requestSync1 = _class.staticMethodId(
    r'requestSync',
    r'(Landroid/content/SyncRequest;)V',
  );

  static final _requestSync1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void requestSync(android.content.SyncRequest syncRequest)
  static void requestSync1(
    jni.JObject syncRequest,
  ) {
    _requestSync1(_class.reference.pointer,
            _id_requestSync1 as jni.JMethodIDPtr, syncRequest.reference.pointer)
        .check();
  }

  static final _id_validateSyncExtrasBundle = _class.staticMethodId(
    r'validateSyncExtrasBundle',
    r'(Landroid/os/Bundle;)V',
  );

  static final _validateSyncExtrasBundle = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void validateSyncExtrasBundle(android.os.Bundle bundle)
  static void validateSyncExtrasBundle(
    jni.JObject bundle,
  ) {
    _validateSyncExtrasBundle(
            _class.reference.pointer,
            _id_validateSyncExtrasBundle as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .check();
  }

  static final _id_cancelSync = _class.instanceMethodId(
    r'cancelSync',
    r'(Landroid/net/Uri;)V',
  );

  static final _cancelSync = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void cancelSync(android.net.Uri uri)
  void cancelSync(
    Uri uri,
  ) {
    _cancelSync(reference.pointer, _id_cancelSync as jni.JMethodIDPtr,
            uri.reference.pointer)
        .check();
  }

  static final _id_cancelSync1 = _class.staticMethodId(
    r'cancelSync',
    r'(Landroid/accounts/Account;Ljava/lang/String;)V',
  );

  static final _cancelSync1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void cancelSync(android.accounts.Account account, java.lang.String string)
  static void cancelSync1(
    jni.JObject account,
    jni.JString string,
  ) {
    _cancelSync1(_class.reference.pointer, _id_cancelSync1 as jni.JMethodIDPtr,
            account.reference.pointer, string.reference.pointer)
        .check();
  }

  static final _id_getSyncAdapterTypes = _class.staticMethodId(
    r'getSyncAdapterTypes',
    r'()[Landroid/content/SyncAdapterType;',
  );

  static final _getSyncAdapterTypes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public android.content.SyncAdapterType[] getSyncAdapterTypes()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> getSyncAdapterTypes() {
    return _getSyncAdapterTypes(_class.reference.pointer,
            _id_getSyncAdapterTypes as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getSyncAutomatically = _class.staticMethodId(
    r'getSyncAutomatically',
    r'(Landroid/accounts/Account;Ljava/lang/String;)Z',
  );

  static final _getSyncAutomatically = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean getSyncAutomatically(android.accounts.Account account, java.lang.String string)
  static bool getSyncAutomatically(
    jni.JObject account,
    jni.JString string,
  ) {
    return _getSyncAutomatically(
            _class.reference.pointer,
            _id_getSyncAutomatically as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer)
        .boolean;
  }

  static final _id_setSyncAutomatically = _class.staticMethodId(
    r'setSyncAutomatically',
    r'(Landroid/accounts/Account;Ljava/lang/String;Z)V',
  );

  static final _setSyncAutomatically = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void setSyncAutomatically(android.accounts.Account account, java.lang.String string, boolean z)
  static void setSyncAutomatically(
    jni.JObject account,
    jni.JString string,
    bool z,
  ) {
    _setSyncAutomatically(
            _class.reference.pointer,
            _id_setSyncAutomatically as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer,
            z ? 1 : 0)
        .check();
  }

  static final _id_addPeriodicSync = _class.staticMethodId(
    r'addPeriodicSync',
    r'(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;J)V',
  );

  static final _addPeriodicSync = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: static public void addPeriodicSync(android.accounts.Account account, java.lang.String string, android.os.Bundle bundle, long j)
  static void addPeriodicSync(
    jni.JObject account,
    jni.JString string,
    jni.JObject bundle,
    int j,
  ) {
    _addPeriodicSync(
            _class.reference.pointer,
            _id_addPeriodicSync as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer,
            j)
        .check();
  }

  static final _id_removePeriodicSync = _class.staticMethodId(
    r'removePeriodicSync',
    r'(Landroid/accounts/Account;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _removePeriodicSync = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void removePeriodicSync(android.accounts.Account account, java.lang.String string, android.os.Bundle bundle)
  static void removePeriodicSync(
    jni.JObject account,
    jni.JString string,
    jni.JObject bundle,
  ) {
    _removePeriodicSync(
            _class.reference.pointer,
            _id_removePeriodicSync as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_cancelSync2 = _class.staticMethodId(
    r'cancelSync',
    r'(Landroid/content/SyncRequest;)V',
  );

  static final _cancelSync2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void cancelSync(android.content.SyncRequest syncRequest)
  static void cancelSync2(
    jni.JObject syncRequest,
  ) {
    _cancelSync2(_class.reference.pointer, _id_cancelSync2 as jni.JMethodIDPtr,
            syncRequest.reference.pointer)
        .check();
  }

  static final _id_getPeriodicSyncs = _class.staticMethodId(
    r'getPeriodicSyncs',
    r'(Landroid/accounts/Account;Ljava/lang/String;)Ljava/util/List;',
  );

  static final _getPeriodicSyncs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.List getPeriodicSyncs(android.accounts.Account account, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JList<jni.JObject> getPeriodicSyncs(
    jni.JObject account,
    jni.JString string,
  ) {
    return _getPeriodicSyncs(
            _class.reference.pointer,
            _id_getPeriodicSyncs as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_getIsSyncable = _class.staticMethodId(
    r'getIsSyncable',
    r'(Landroid/accounts/Account;Ljava/lang/String;)I',
  );

  static final _getIsSyncable = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public int getIsSyncable(android.accounts.Account account, java.lang.String string)
  static int getIsSyncable(
    jni.JObject account,
    jni.JString string,
  ) {
    return _getIsSyncable(
            _class.reference.pointer,
            _id_getIsSyncable as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer)
        .integer;
  }

  static final _id_setIsSyncable = _class.staticMethodId(
    r'setIsSyncable',
    r'(Landroid/accounts/Account;Ljava/lang/String;I)V',
  );

  static final _setIsSyncable = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void setIsSyncable(android.accounts.Account account, java.lang.String string, int i)
  static void setIsSyncable(
    jni.JObject account,
    jni.JString string,
    int i,
  ) {
    _setIsSyncable(
            _class.reference.pointer,
            _id_setIsSyncable as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer,
            i)
        .check();
  }

  static final _id_getMasterSyncAutomatically = _class.staticMethodId(
    r'getMasterSyncAutomatically',
    r'()Z',
  );

  static final _getMasterSyncAutomatically = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public boolean getMasterSyncAutomatically()
  static bool getMasterSyncAutomatically() {
    return _getMasterSyncAutomatically(_class.reference.pointer,
            _id_getMasterSyncAutomatically as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setMasterSyncAutomatically = _class.staticMethodId(
    r'setMasterSyncAutomatically',
    r'(Z)V',
  );

  static final _setMasterSyncAutomatically = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public void setMasterSyncAutomatically(boolean z)
  static void setMasterSyncAutomatically(
    bool z,
  ) {
    _setMasterSyncAutomatically(_class.reference.pointer,
            _id_setMasterSyncAutomatically as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isSyncActive = _class.staticMethodId(
    r'isSyncActive',
    r'(Landroid/accounts/Account;Ljava/lang/String;)Z',
  );

  static final _isSyncActive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isSyncActive(android.accounts.Account account, java.lang.String string)
  static bool isSyncActive(
    jni.JObject account,
    jni.JString string,
  ) {
    return _isSyncActive(
            _class.reference.pointer,
            _id_isSyncActive as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer)
        .boolean;
  }

  static final _id_getCurrentSync = _class.staticMethodId(
    r'getCurrentSync',
    r'()Landroid/content/SyncInfo;',
  );

  static final _getCurrentSync = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public android.content.SyncInfo getCurrentSync()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getCurrentSync() {
    return _getCurrentSync(
            _class.reference.pointer, _id_getCurrentSync as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getCurrentSyncs = _class.staticMethodId(
    r'getCurrentSyncs',
    r'()Ljava/util/List;',
  );

  static final _getCurrentSyncs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.util.List getCurrentSyncs()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JList<jni.JObject> getCurrentSyncs() {
    return _getCurrentSyncs(
            _class.reference.pointer, _id_getCurrentSyncs as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_isSyncPending = _class.staticMethodId(
    r'isSyncPending',
    r'(Landroid/accounts/Account;Ljava/lang/String;)Z',
  );

  static final _isSyncPending = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isSyncPending(android.accounts.Account account, java.lang.String string)
  static bool isSyncPending(
    jni.JObject account,
    jni.JString string,
  ) {
    return _isSyncPending(
            _class.reference.pointer,
            _id_isSyncPending as jni.JMethodIDPtr,
            account.reference.pointer,
            string.reference.pointer)
        .boolean;
  }

  static final _id_addStatusChangeListener = _class.staticMethodId(
    r'addStatusChangeListener',
    r'(ILandroid/content/SyncStatusObserver;)Ljava/lang/Object;',
  );

  static final _addStatusChangeListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.Object addStatusChangeListener(int i, android.content.SyncStatusObserver syncStatusObserver)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject addStatusChangeListener(
    int i,
    jni.JObject syncStatusObserver,
  ) {
    return _addStatusChangeListener(
            _class.reference.pointer,
            _id_addStatusChangeListener as jni.JMethodIDPtr,
            i,
            syncStatusObserver.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_removeStatusChangeListener = _class.staticMethodId(
    r'removeStatusChangeListener',
    r'(Ljava/lang/Object;)V',
  );

  static final _removeStatusChangeListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void removeStatusChangeListener(java.lang.Object object)
  static void removeStatusChangeListener(
    jni.JObject object,
  ) {
    _removeStatusChangeListener(
            _class.reference.pointer,
            _id_removeStatusChangeListener as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  static final _id_getTypeInfo = _class.instanceMethodId(
    r'getTypeInfo',
    r'(Ljava/lang/String;)Landroid/content/ContentResolver$MimeTypeInfo;',
  );

  static final _getTypeInfo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentResolver$MimeTypeInfo getTypeInfo(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ContentResolver_MimeTypeInfo getTypeInfo(
    jni.JString string,
  ) {
    return _getTypeInfo(reference.pointer, _id_getTypeInfo as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $ContentResolver_MimeTypeInfoType());
  }

  static final _id_loadThumbnail = _class.instanceMethodId(
    r'loadThumbnail',
    r'(Landroid/net/Uri;Landroid/util/Size;Landroid/os/CancellationSignal;)Landroid/graphics/Bitmap;',
  );

  static final _loadThumbnail = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap loadThumbnail(android.net.Uri uri, android.util.Size size, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject loadThumbnail(
    Uri uri,
    Size size,
    jni.JObject cancellationSignal,
  ) {
    return _loadThumbnail(
            reference.pointer,
            _id_loadThumbnail as jni.JMethodIDPtr,
            uri.reference.pointer,
            size.reference.pointer,
            cancellationSignal.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $ContentResolverType extends jni.JObjType<ContentResolver> {
  const $ContentResolverType();

  @override
  String get signature => r'Landroid/content/ContentResolver;';

  @override
  ContentResolver fromReference(jni.JReference reference) =>
      ContentResolver.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ContentResolverType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContentResolverType) &&
        other is $ContentResolverType;
  }
}

/// from: android.content.ContentValues
class ContentValues extends jni.JObject {
  @override
  late final jni.JObjType<ContentValues> $type = type;

  ContentValues.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/content/ContentValues');

  /// The type which includes information such as the signature of this class.
  static const type = $ContentValuesType();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  static final _id_TAG = _class.staticFieldId(
    r'TAG',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TAG
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TAG => _id_TAG.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ContentValues() {
    return ContentValues.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(I)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void <init>(int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory ContentValues.new1(
    int i,
  ) {
    return ContentValues.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr, i)
            .reference);
  }

  static final _id_new2 = _class.constructorId(
    r'(Landroid/content/ContentValues;)V',
  );

  static final _new2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ContentValues contentValues)
  /// The returned object must be released after use, by calling the [release] method.
  factory ContentValues.new2(
    ContentValues contentValues,
  ) {
    return ContentValues.fromReference(_new2(_class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr, contentValues.reference.pointer)
        .reference);
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _put = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, java.lang.String string1)
  void put(
    jni.JString string,
    jni.JString string1,
  ) {
    _put(reference.pointer, _id_put as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .check();
  }

  static final _id_putAll = _class.instanceMethodId(
    r'putAll',
    r'(Landroid/content/ContentValues;)V',
  );

  static final _putAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putAll(android.content.ContentValues contentValues)
  void putAll(
    ContentValues contentValues,
  ) {
    _putAll(reference.pointer, _id_putAll as jni.JMethodIDPtr,
            contentValues.reference.pointer)
        .check();
  }

  static final _id_put1 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Byte;)V',
  );

  static final _put1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, java.lang.Byte byte)
  void put1(
    jni.JString string,
    jni.JByte byte,
  ) {
    _put1(reference.pointer, _id_put1 as jni.JMethodIDPtr,
            string.reference.pointer, byte.reference.pointer)
        .check();
  }

  static final _id_put2 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Short;)V',
  );

  static final _put2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, java.lang.Short short)
  void put2(
    jni.JString string,
    jni.JShort short,
  ) {
    _put2(reference.pointer, _id_put2 as jni.JMethodIDPtr,
            string.reference.pointer, short.reference.pointer)
        .check();
  }

  static final _id_put3 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Integer;)V',
  );

  static final _put3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, java.lang.Integer integer)
  void put3(
    jni.JString string,
    jni.JInteger integer,
  ) {
    _put3(reference.pointer, _id_put3 as jni.JMethodIDPtr,
            string.reference.pointer, integer.reference.pointer)
        .check();
  }

  static final _id_put4 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Long;)V',
  );

  static final _put4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, java.lang.Long long)
  void put4(
    jni.JString string,
    jni.JLong long,
  ) {
    _put4(reference.pointer, _id_put4 as jni.JMethodIDPtr,
            string.reference.pointer, long.reference.pointer)
        .check();
  }

  static final _id_put5 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Float;)V',
  );

  static final _put5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, java.lang.Float float)
  void put5(
    jni.JString string,
    jni.JFloat float,
  ) {
    _put5(reference.pointer, _id_put5 as jni.JMethodIDPtr,
            string.reference.pointer, float.reference.pointer)
        .check();
  }

  static final _id_put6 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Double;)V',
  );

  static final _put6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, java.lang.Double double)
  void put6(
    jni.JString string,
    jni.JDouble double,
  ) {
    _put6(reference.pointer, _id_put6 as jni.JMethodIDPtr,
            string.reference.pointer, double.reference.pointer)
        .check();
  }

  static final _id_put7 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Boolean;)V',
  );

  static final _put7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, java.lang.Boolean boolean)
  void put7(
    jni.JString string,
    jni.JBoolean boolean,
  ) {
    _put7(reference.pointer, _id_put7 as jni.JMethodIDPtr,
            string.reference.pointer, boolean.reference.pointer)
        .check();
  }

  static final _id_put8 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;[B)V',
  );

  static final _put8 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String string, byte[] bs)
  void put8(
    jni.JString string,
    jni.JArray<jni.jbyte> bs,
  ) {
    _put8(reference.pointer, _id_put8 as jni.JMethodIDPtr,
            string.reference.pointer, bs.reference.pointer)
        .check();
  }

  static final _id_putNull = _class.instanceMethodId(
    r'putNull',
    r'(Ljava/lang/String;)V',
  );

  static final _putNull = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putNull(java.lang.String string)
  void putNull(
    jni.JString string,
  ) {
    _putNull(reference.pointer, _id_putNull as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int size()
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).integer;
  }

  static final _id_isEmpty = _class.instanceMethodId(
    r'isEmpty',
    r'()Z',
  );

  static final _isEmpty = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isEmpty()
  bool isEmpty() {
    return _isEmpty(reference.pointer, _id_isEmpty as jni.JMethodIDPtr).boolean;
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/String;)V',
  );

  static final _remove = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void remove(java.lang.String string)
  void remove(
    jni.JString string,
  ) {
    _remove(reference.pointer, _id_remove as jni.JMethodIDPtr,
            string.reference.pointer)
        .check();
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void clear()
  void clear() {
    _clear(reference.pointer, _id_clear as jni.JMethodIDPtr).check();
  }

  static final _id_containsKey = _class.instanceMethodId(
    r'containsKey',
    r'(Ljava/lang/String;)Z',
  );

  static final _containsKey = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean containsKey(java.lang.String string)
  bool containsKey(
    jni.JString string,
  ) {
    return _containsKey(reference.pointer, _id_containsKey as jni.JMethodIDPtr,
            string.reference.pointer)
        .boolean;
  }

  static final _id_get0 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _get0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get0(
    jni.JString string,
  ) {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getAsString = _class.instanceMethodId(
    r'getAsString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getAsString = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAsString(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAsString(
    jni.JString string,
  ) {
    return _getAsString(reference.pointer, _id_getAsString as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getAsLong = _class.instanceMethodId(
    r'getAsLong',
    r'(Ljava/lang/String;)Ljava/lang/Long;',
  );

  static final _getAsLong = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Long getAsLong(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JLong getAsLong(
    jni.JString string,
  ) {
    return _getAsLong(reference.pointer, _id_getAsLong as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JLongType());
  }

  static final _id_getAsInteger = _class.instanceMethodId(
    r'getAsInteger',
    r'(Ljava/lang/String;)Ljava/lang/Integer;',
  );

  static final _getAsInteger = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Integer getAsInteger(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger getAsInteger(
    jni.JString string,
  ) {
    return _getAsInteger(reference.pointer,
            _id_getAsInteger as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JIntegerType());
  }

  static final _id_getAsShort = _class.instanceMethodId(
    r'getAsShort',
    r'(Ljava/lang/String;)Ljava/lang/Short;',
  );

  static final _getAsShort = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Short getAsShort(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JShort getAsShort(
    jni.JString string,
  ) {
    return _getAsShort(reference.pointer, _id_getAsShort as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JShortType());
  }

  static final _id_getAsByte = _class.instanceMethodId(
    r'getAsByte',
    r'(Ljava/lang/String;)Ljava/lang/Byte;',
  );

  static final _getAsByte = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Byte getAsByte(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByte getAsByte(
    jni.JString string,
  ) {
    return _getAsByte(reference.pointer, _id_getAsByte as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JByteType());
  }

  static final _id_getAsDouble = _class.instanceMethodId(
    r'getAsDouble',
    r'(Ljava/lang/String;)Ljava/lang/Double;',
  );

  static final _getAsDouble = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Double getAsDouble(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JDouble getAsDouble(
    jni.JString string,
  ) {
    return _getAsDouble(reference.pointer, _id_getAsDouble as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JDoubleType());
  }

  static final _id_getAsFloat = _class.instanceMethodId(
    r'getAsFloat',
    r'(Ljava/lang/String;)Ljava/lang/Float;',
  );

  static final _getAsFloat = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Float getAsFloat(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JFloat getAsFloat(
    jni.JString string,
  ) {
    return _getAsFloat(reference.pointer, _id_getAsFloat as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JFloatType());
  }

  static final _id_getAsBoolean = _class.instanceMethodId(
    r'getAsBoolean',
    r'(Ljava/lang/String;)Ljava/lang/Boolean;',
  );

  static final _getAsBoolean = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Boolean getAsBoolean(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JBoolean getAsBoolean(
    jni.JString string,
  ) {
    return _getAsBoolean(reference.pointer,
            _id_getAsBoolean as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JBooleanType());
  }

  static final _id_getAsByteArray = _class.instanceMethodId(
    r'getAsByteArray',
    r'(Ljava/lang/String;)[B',
  );

  static final _getAsByteArray = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] getAsByteArray(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getAsByteArray(
    jni.JString string,
  ) {
    return _getAsByteArray(reference.pointer,
            _id_getAsByteArray as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_valueSet = _class.instanceMethodId(
    r'valueSet',
    r'()Ljava/util/Set;',
  );

  static final _valueSet = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.Set valueSet()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JObject> valueSet() {
    return _valueSet(reference.pointer, _id_valueSet as jni.JMethodIDPtr)
        .object(const jni.JSetType(jni.JObjectType()));
  }

  static final _id_keySet = _class.instanceMethodId(
    r'keySet',
    r'()Ljava/util/Set;',
  );

  static final _keySet = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.Set keySet()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> keySet() {
    return _keySet(reference.pointer, _id_keySet as jni.JMethodIDPtr)
        .object(const jni.JSetType(jni.JStringType()));
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, _id_writeToParcel as jni.JMethodIDPtr,
            parcel.reference.pointer, i)
        .check();
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $ContentValuesType extends jni.JObjType<ContentValues> {
  const $ContentValuesType();

  @override
  String get signature => r'Landroid/content/ContentValues;';

  @override
  ContentValues fromReference(jni.JReference reference) =>
      ContentValues.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ContentValuesType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContentValuesType) &&
        other is $ContentValuesType;
  }
}

/// from: android.database.Cursor
class Cursor extends jni.JObject {
  @override
  late final jni.JObjType<Cursor> $type = type;

  Cursor.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/database/Cursor');

  /// The type which includes information such as the signature of this class.
  static const type = $CursorType();

  /// from: static public final int FIELD_TYPE_BLOB
  static const FIELD_TYPE_BLOB = 4;

  /// from: static public final int FIELD_TYPE_FLOAT
  static const FIELD_TYPE_FLOAT = 2;

  /// from: static public final int FIELD_TYPE_INTEGER
  static const FIELD_TYPE_INTEGER = 1;

  /// from: static public final int FIELD_TYPE_NULL
  static const FIELD_TYPE_NULL = 0;

  /// from: static public final int FIELD_TYPE_STRING
  static const FIELD_TYPE_STRING = 3;
  static final _id_getCount = _class.instanceMethodId(
    r'getCount',
    r'()I',
  );

  static final _getCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getCount()
  int getCount() {
    return _getCount(reference.pointer, _id_getCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPosition = _class.instanceMethodId(
    r'getPosition',
    r'()I',
  );

  static final _getPosition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getPosition()
  int getPosition() {
    return _getPosition(reference.pointer, _id_getPosition as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_move = _class.instanceMethodId(
    r'move',
    r'(I)Z',
  );

  static final _move = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract boolean move(int i)
  bool move(
    int i,
  ) {
    return _move(reference.pointer, _id_move as jni.JMethodIDPtr, i).boolean;
  }

  static final _id_moveToPosition = _class.instanceMethodId(
    r'moveToPosition',
    r'(I)Z',
  );

  static final _moveToPosition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract boolean moveToPosition(int i)
  bool moveToPosition(
    int i,
  ) {
    return _moveToPosition(
            reference.pointer, _id_moveToPosition as jni.JMethodIDPtr, i)
        .boolean;
  }

  static final _id_moveToFirst = _class.instanceMethodId(
    r'moveToFirst',
    r'()Z',
  );

  static final _moveToFirst = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean moveToFirst()
  bool moveToFirst() {
    return _moveToFirst(reference.pointer, _id_moveToFirst as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_moveToLast = _class.instanceMethodId(
    r'moveToLast',
    r'()Z',
  );

  static final _moveToLast = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean moveToLast()
  bool moveToLast() {
    return _moveToLast(reference.pointer, _id_moveToLast as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_moveToNext = _class.instanceMethodId(
    r'moveToNext',
    r'()Z',
  );

  static final _moveToNext = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean moveToNext()
  bool moveToNext() {
    return _moveToNext(reference.pointer, _id_moveToNext as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_moveToPrevious = _class.instanceMethodId(
    r'moveToPrevious',
    r'()Z',
  );

  static final _moveToPrevious = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean moveToPrevious()
  bool moveToPrevious() {
    return _moveToPrevious(
            reference.pointer, _id_moveToPrevious as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isFirst = _class.instanceMethodId(
    r'isFirst',
    r'()Z',
  );

  static final _isFirst = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isFirst()
  bool isFirst() {
    return _isFirst(reference.pointer, _id_isFirst as jni.JMethodIDPtr).boolean;
  }

  static final _id_isLast = _class.instanceMethodId(
    r'isLast',
    r'()Z',
  );

  static final _isLast = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isLast()
  bool isLast() {
    return _isLast(reference.pointer, _id_isLast as jni.JMethodIDPtr).boolean;
  }

  static final _id_isBeforeFirst = _class.instanceMethodId(
    r'isBeforeFirst',
    r'()Z',
  );

  static final _isBeforeFirst = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isBeforeFirst()
  bool isBeforeFirst() {
    return _isBeforeFirst(
            reference.pointer, _id_isBeforeFirst as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isAfterLast = _class.instanceMethodId(
    r'isAfterLast',
    r'()Z',
  );

  static final _isAfterLast = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isAfterLast()
  bool isAfterLast() {
    return _isAfterLast(reference.pointer, _id_isAfterLast as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getColumnIndex = _class.instanceMethodId(
    r'getColumnIndex',
    r'(Ljava/lang/String;)I',
  );

  static final _getColumnIndex = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getColumnIndex(java.lang.String string)
  int getColumnIndex(
    jni.JString string,
  ) {
    return _getColumnIndex(reference.pointer,
            _id_getColumnIndex as jni.JMethodIDPtr, string.reference.pointer)
        .integer;
  }

  static final _id_getColumnIndexOrThrow = _class.instanceMethodId(
    r'getColumnIndexOrThrow',
    r'(Ljava/lang/String;)I',
  );

  static final _getColumnIndexOrThrow = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getColumnIndexOrThrow(java.lang.String string)
  int getColumnIndexOrThrow(
    jni.JString string,
  ) {
    return _getColumnIndexOrThrow(
            reference.pointer,
            _id_getColumnIndexOrThrow as jni.JMethodIDPtr,
            string.reference.pointer)
        .integer;
  }

  static final _id_getColumnName = _class.instanceMethodId(
    r'getColumnName',
    r'(I)Ljava/lang/String;',
  );

  static final _getColumnName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract java.lang.String getColumnName(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getColumnName(
    int i,
  ) {
    return _getColumnName(
            reference.pointer, _id_getColumnName as jni.JMethodIDPtr, i)
        .object(const jni.JStringType());
  }

  static final _id_getColumnNames = _class.instanceMethodId(
    r'getColumnNames',
    r'()[Ljava/lang/String;',
  );

  static final _getColumnNames = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String[] getColumnNames()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getColumnNames() {
    return _getColumnNames(
            reference.pointer, _id_getColumnNames as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JStringType()));
  }

  static final _id_getColumnCount = _class.instanceMethodId(
    r'getColumnCount',
    r'()I',
  );

  static final _getColumnCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getColumnCount()
  int getColumnCount() {
    return _getColumnCount(
            reference.pointer, _id_getColumnCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getBlob = _class.instanceMethodId(
    r'getBlob',
    r'(I)[B',
  );

  static final _getBlob = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract byte[] getBlob(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getBlob(
    int i,
  ) {
    return _getBlob(reference.pointer, _id_getBlob as jni.JMethodIDPtr, i)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_getString = _class.instanceMethodId(
    r'getString',
    r'(I)Ljava/lang/String;',
  );

  static final _getString = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract java.lang.String getString(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getString(
    int i,
  ) {
    return _getString(reference.pointer, _id_getString as jni.JMethodIDPtr, i)
        .object(const jni.JStringType());
  }

  static final _id_copyStringToBuffer = _class.instanceMethodId(
    r'copyStringToBuffer',
    r'(ILandroid/database/CharArrayBuffer;)V',
  );

  static final _copyStringToBuffer = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void copyStringToBuffer(int i, android.database.CharArrayBuffer charArrayBuffer)
  void copyStringToBuffer(
    int i,
    jni.JObject charArrayBuffer,
  ) {
    _copyStringToBuffer(
            reference.pointer,
            _id_copyStringToBuffer as jni.JMethodIDPtr,
            i,
            charArrayBuffer.reference.pointer)
        .check();
  }

  static final _id_getShort = _class.instanceMethodId(
    r'getShort',
    r'(I)S',
  );

  static final _getShort = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallShortMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract short getShort(int i)
  int getShort(
    int i,
  ) {
    return _getShort(reference.pointer, _id_getShort as jni.JMethodIDPtr, i)
        .short;
  }

  static final _id_getInt = _class.instanceMethodId(
    r'getInt',
    r'(I)I',
  );

  static final _getInt = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract int getInt(int i)
  int getInt(
    int i,
  ) {
    return _getInt(reference.pointer, _id_getInt as jni.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(I)J',
  );

  static final _getLong = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract long getLong(int i)
  int getLong(
    int i,
  ) {
    return _getLong(reference.pointer, _id_getLong as jni.JMethodIDPtr, i).long;
  }

  static final _id_getFloat = _class.instanceMethodId(
    r'getFloat',
    r'(I)F',
  );

  static final _getFloat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract float getFloat(int i)
  double getFloat(
    int i,
  ) {
    return _getFloat(reference.pointer, _id_getFloat as jni.JMethodIDPtr, i)
        .float;
  }

  static final _id_getDouble = _class.instanceMethodId(
    r'getDouble',
    r'(I)D',
  );

  static final _getDouble = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract double getDouble(int i)
  double getDouble(
    int i,
  ) {
    return _getDouble(reference.pointer, _id_getDouble as jni.JMethodIDPtr, i)
        .doubleFloat;
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'(I)I',
  );

  static final _getType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract int getType(int i)
  int getType(
    int i,
  ) {
    return _getType(reference.pointer, _id_getType as jni.JMethodIDPtr, i)
        .integer;
  }

  static final _id_isNull1 = _class.instanceMethodId(
    r'isNull',
    r'(I)Z',
  );

  static final _isNull1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract boolean isNull(int i)
  bool isNull1(
    int i,
  ) {
    return _isNull1(reference.pointer, _id_isNull1 as jni.JMethodIDPtr, i)
        .boolean;
  }

  static final _id_deactivate = _class.instanceMethodId(
    r'deactivate',
    r'()V',
  );

  static final _deactivate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void deactivate()
  void deactivate() {
    _deactivate(reference.pointer, _id_deactivate as jni.JMethodIDPtr).check();
  }

  static final _id_requery = _class.instanceMethodId(
    r'requery',
    r'()Z',
  );

  static final _requery = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean requery()
  bool requery() {
    return _requery(reference.pointer, _id_requery as jni.JMethodIDPtr).boolean;
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_isClosed = _class.instanceMethodId(
    r'isClosed',
    r'()Z',
  );

  static final _isClosed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isClosed()
  bool isClosed() {
    return _isClosed(reference.pointer, _id_isClosed as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_registerContentObserver = _class.instanceMethodId(
    r'registerContentObserver',
    r'(Landroid/database/ContentObserver;)V',
  );

  static final _registerContentObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void registerContentObserver(android.database.ContentObserver contentObserver)
  void registerContentObserver(
    jni.JObject contentObserver,
  ) {
    _registerContentObserver(
            reference.pointer,
            _id_registerContentObserver as jni.JMethodIDPtr,
            contentObserver.reference.pointer)
        .check();
  }

  static final _id_unregisterContentObserver = _class.instanceMethodId(
    r'unregisterContentObserver',
    r'(Landroid/database/ContentObserver;)V',
  );

  static final _unregisterContentObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unregisterContentObserver(android.database.ContentObserver contentObserver)
  void unregisterContentObserver(
    jni.JObject contentObserver,
  ) {
    _unregisterContentObserver(
            reference.pointer,
            _id_unregisterContentObserver as jni.JMethodIDPtr,
            contentObserver.reference.pointer)
        .check();
  }

  static final _id_registerDataSetObserver = _class.instanceMethodId(
    r'registerDataSetObserver',
    r'(Landroid/database/DataSetObserver;)V',
  );

  static final _registerDataSetObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void registerDataSetObserver(android.database.DataSetObserver dataSetObserver)
  void registerDataSetObserver(
    jni.JObject dataSetObserver,
  ) {
    _registerDataSetObserver(
            reference.pointer,
            _id_registerDataSetObserver as jni.JMethodIDPtr,
            dataSetObserver.reference.pointer)
        .check();
  }

  static final _id_unregisterDataSetObserver = _class.instanceMethodId(
    r'unregisterDataSetObserver',
    r'(Landroid/database/DataSetObserver;)V',
  );

  static final _unregisterDataSetObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unregisterDataSetObserver(android.database.DataSetObserver dataSetObserver)
  void unregisterDataSetObserver(
    jni.JObject dataSetObserver,
  ) {
    _unregisterDataSetObserver(
            reference.pointer,
            _id_unregisterDataSetObserver as jni.JMethodIDPtr,
            dataSetObserver.reference.pointer)
        .check();
  }

  static final _id_setNotificationUri = _class.instanceMethodId(
    r'setNotificationUri',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;)V',
  );

  static final _setNotificationUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setNotificationUri(android.content.ContentResolver contentResolver, android.net.Uri uri)
  void setNotificationUri(
    ContentResolver contentResolver,
    Uri uri,
  ) {
    _setNotificationUri(
            reference.pointer,
            _id_setNotificationUri as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer)
        .check();
  }

  static final _id_setNotificationUris = _class.instanceMethodId(
    r'setNotificationUris',
    r'(Landroid/content/ContentResolver;Ljava/util/List;)V',
  );

  static final _setNotificationUris = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setNotificationUris(android.content.ContentResolver contentResolver, java.util.List list)
  void setNotificationUris(
    ContentResolver contentResolver,
    jni.JList<Uri> list,
  ) {
    _setNotificationUris(
            reference.pointer,
            _id_setNotificationUris as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            list.reference.pointer)
        .check();
  }

  static final _id_getNotificationUri = _class.instanceMethodId(
    r'getNotificationUri',
    r'()Landroid/net/Uri;',
  );

  static final _getNotificationUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.net.Uri getNotificationUri()
  /// The returned object must be released after use, by calling the [release] method.
  Uri getNotificationUri() {
    return _getNotificationUri(
            reference.pointer, _id_getNotificationUri as jni.JMethodIDPtr)
        .object(const $UriType());
  }

  static final _id_getNotificationUris = _class.instanceMethodId(
    r'getNotificationUris',
    r'()Ljava/util/List;',
  );

  static final _getNotificationUris = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getNotificationUris()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Uri> getNotificationUris() {
    return _getNotificationUris(
            reference.pointer, _id_getNotificationUris as jni.JMethodIDPtr)
        .object(const jni.JListType($UriType()));
  }

  static final _id_getWantsAllOnMoveCalls = _class.instanceMethodId(
    r'getWantsAllOnMoveCalls',
    r'()Z',
  );

  static final _getWantsAllOnMoveCalls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean getWantsAllOnMoveCalls()
  bool getWantsAllOnMoveCalls() {
    return _getWantsAllOnMoveCalls(
            reference.pointer, _id_getWantsAllOnMoveCalls as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setExtras = _class.instanceMethodId(
    r'setExtras',
    r'(Landroid/os/Bundle;)V',
  );

  static final _setExtras = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setExtras(android.os.Bundle bundle)
  void setExtras(
    jni.JObject bundle,
  ) {
    _setExtras(reference.pointer, _id_setExtras as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .check();
  }

  static final _id_getExtras = _class.instanceMethodId(
    r'getExtras',
    r'()Landroid/os/Bundle;',
  );

  static final _getExtras = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.os.Bundle getExtras()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getExtras() {
    return _getExtras(reference.pointer, _id_getExtras as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_respond = _class.instanceMethodId(
    r'respond',
    r'(Landroid/os/Bundle;)Landroid/os/Bundle;',
  );

  static final _respond = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.os.Bundle respond(android.os.Bundle bundle)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject respond(
    jni.JObject bundle,
  ) {
    return _respond(reference.pointer, _id_respond as jni.JMethodIDPtr,
            bundle.reference.pointer)
        .object(const jni.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CursorImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getCount()I') {
        final $r = _$impls[$p]!.getCount();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getPosition()I') {
        final $r = _$impls[$p]!.getPosition();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'move(I)Z') {
        final $r = _$impls[$p]!.move(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'moveToPosition(I)Z') {
        final $r = _$impls[$p]!.moveToPosition(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'moveToFirst()Z') {
        final $r = _$impls[$p]!.moveToFirst();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'moveToLast()Z') {
        final $r = _$impls[$p]!.moveToLast();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'moveToNext()Z') {
        final $r = _$impls[$p]!.moveToNext();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'moveToPrevious()Z') {
        final $r = _$impls[$p]!.moveToPrevious();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'isFirst()Z') {
        final $r = _$impls[$p]!.isFirst();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'isLast()Z') {
        final $r = _$impls[$p]!.isLast();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'isBeforeFirst()Z') {
        final $r = _$impls[$p]!.isBeforeFirst();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'isAfterLast()Z') {
        final $r = _$impls[$p]!.isAfterLast();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'getColumnIndex(Ljava/lang/String;)I') {
        final $r = _$impls[$p]!.getColumnIndex(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getColumnIndexOrThrow(Ljava/lang/String;)I') {
        final $r = _$impls[$p]!.getColumnIndexOrThrow(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getColumnName(I)Ljava/lang/String;') {
        final $r = _$impls[$p]!.getColumnName(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'getColumnNames()[Ljava/lang/String;') {
        final $r = _$impls[$p]!.getColumnNames();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'getColumnCount()I') {
        final $r = _$impls[$p]!.getColumnCount();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getBlob(I)[B') {
        final $r = _$impls[$p]!.getBlob(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'getString(I)Ljava/lang/String;') {
        final $r = _$impls[$p]!.getString(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'copyStringToBuffer(ILandroid/database/CharArrayBuffer;)V') {
        _$impls[$p]!.copyStringToBuffer(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'getShort(I)S') {
        final $r = _$impls[$p]!.getShort(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JShort($r).reference.toPointer();
      }
      if ($d == r'getInt(I)I') {
        final $r = _$impls[$p]!.getInt(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getLong(I)J') {
        final $r = _$impls[$p]!.getLong(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JLong($r).reference.toPointer();
      }
      if ($d == r'getFloat(I)F') {
        final $r = _$impls[$p]!.getFloat(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JFloat($r).reference.toPointer();
      }
      if ($d == r'getDouble(I)D') {
        final $r = _$impls[$p]!.getDouble(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JDouble($r).reference.toPointer();
      }
      if ($d == r'getType(I)I') {
        final $r = _$impls[$p]!.getType(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'isNull(I)Z') {
        final $r = _$impls[$p]!.isNull1(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'deactivate()V') {
        _$impls[$p]!.deactivate();
        return jni.nullptr;
      }
      if ($d == r'requery()Z') {
        final $r = _$impls[$p]!.requery();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni.nullptr;
      }
      if ($d == r'isClosed()Z') {
        final $r = _$impls[$p]!.isClosed();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d ==
          r'registerContentObserver(Landroid/database/ContentObserver;)V') {
        _$impls[$p]!.registerContentObserver(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'unregisterContentObserver(Landroid/database/ContentObserver;)V') {
        _$impls[$p]!.unregisterContentObserver(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'registerDataSetObserver(Landroid/database/DataSetObserver;)V') {
        _$impls[$p]!.registerDataSetObserver(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'unregisterDataSetObserver(Landroid/database/DataSetObserver;)V') {
        _$impls[$p]!.unregisterDataSetObserver(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'setNotificationUri(Landroid/content/ContentResolver;Landroid/net/Uri;)V') {
        _$impls[$p]!.setNotificationUri(
          $a[0].castTo(const $ContentResolverType(), releaseOriginal: true),
          $a[1].castTo(const $UriType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'setNotificationUris(Landroid/content/ContentResolver;Ljava/util/List;)V') {
        _$impls[$p]!.setNotificationUris(
          $a[0].castTo(const $ContentResolverType(), releaseOriginal: true),
          $a[1].castTo(const jni.JListType($UriType()), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'getNotificationUri()Landroid/net/Uri;') {
        final $r = _$impls[$p]!.getNotificationUri();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'getNotificationUris()Ljava/util/List;') {
        final $r = _$impls[$p]!.getNotificationUris();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'getWantsAllOnMoveCalls()Z') {
        final $r = _$impls[$p]!.getWantsAllOnMoveCalls();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'setExtras(Landroid/os/Bundle;)V') {
        _$impls[$p]!.setExtras(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'getExtras()Landroid/os/Bundle;') {
        final $r = _$impls[$p]!.getExtras();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'respond(Landroid/os/Bundle;)Landroid/os/Bundle;') {
        final $r = _$impls[$p]!.respond(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Cursor.implement(
    $CursorImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Cursor.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.database.Cursor',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CursorImpl {
  factory $CursorImpl({
    required int Function() getCount,
    required int Function() getPosition,
    required bool Function(int i) move,
    required bool Function(int i) moveToPosition,
    required bool Function() moveToFirst,
    required bool Function() moveToLast,
    required bool Function() moveToNext,
    required bool Function() moveToPrevious,
    required bool Function() isFirst,
    required bool Function() isLast,
    required bool Function() isBeforeFirst,
    required bool Function() isAfterLast,
    required int Function(jni.JString string) getColumnIndex,
    required int Function(jni.JString string) getColumnIndexOrThrow,
    required jni.JString Function(int i) getColumnName,
    required jni.JArray<jni.JString> Function() getColumnNames,
    required int Function() getColumnCount,
    required jni.JArray<jni.jbyte> Function(int i) getBlob,
    required jni.JString Function(int i) getString,
    required void Function(int i, jni.JObject charArrayBuffer)
        copyStringToBuffer,
    required int Function(int i) getShort,
    required int Function(int i) getInt,
    required int Function(int i) getLong,
    required double Function(int i) getFloat,
    required double Function(int i) getDouble,
    required int Function(int i) getType,
    required bool Function(int i) isNull1,
    required void Function() deactivate,
    required bool Function() requery,
    required void Function() close,
    required bool Function() isClosed,
    required void Function(jni.JObject contentObserver) registerContentObserver,
    required void Function(jni.JObject contentObserver)
        unregisterContentObserver,
    required void Function(jni.JObject dataSetObserver) registerDataSetObserver,
    required void Function(jni.JObject dataSetObserver)
        unregisterDataSetObserver,
    required void Function(ContentResolver contentResolver, Uri uri)
        setNotificationUri,
    required void Function(ContentResolver contentResolver, jni.JList<Uri> list)
        setNotificationUris,
    required Uri Function() getNotificationUri,
    required jni.JList<Uri> Function() getNotificationUris,
    required bool Function() getWantsAllOnMoveCalls,
    required void Function(jni.JObject bundle) setExtras,
    required jni.JObject Function() getExtras,
    required jni.JObject Function(jni.JObject bundle) respond,
  }) = _$CursorImpl;

  int getCount();
  int getPosition();
  bool move(int i);
  bool moveToPosition(int i);
  bool moveToFirst();
  bool moveToLast();
  bool moveToNext();
  bool moveToPrevious();
  bool isFirst();
  bool isLast();
  bool isBeforeFirst();
  bool isAfterLast();
  int getColumnIndex(jni.JString string);
  int getColumnIndexOrThrow(jni.JString string);
  jni.JString getColumnName(int i);
  jni.JArray<jni.JString> getColumnNames();
  int getColumnCount();
  jni.JArray<jni.jbyte> getBlob(int i);
  jni.JString getString(int i);
  void copyStringToBuffer(int i, jni.JObject charArrayBuffer);
  int getShort(int i);
  int getInt(int i);
  int getLong(int i);
  double getFloat(int i);
  double getDouble(int i);
  int getType(int i);
  bool isNull1(int i);
  void deactivate();
  bool requery();
  void close();
  bool isClosed();
  void registerContentObserver(jni.JObject contentObserver);
  void unregisterContentObserver(jni.JObject contentObserver);
  void registerDataSetObserver(jni.JObject dataSetObserver);
  void unregisterDataSetObserver(jni.JObject dataSetObserver);
  void setNotificationUri(ContentResolver contentResolver, Uri uri);
  void setNotificationUris(
      ContentResolver contentResolver, jni.JList<Uri> list);
  Uri getNotificationUri();
  jni.JList<Uri> getNotificationUris();
  bool getWantsAllOnMoveCalls();
  void setExtras(jni.JObject bundle);
  jni.JObject getExtras();
  jni.JObject respond(jni.JObject bundle);
}

class _$CursorImpl implements $CursorImpl {
  _$CursorImpl({
    required int Function() getCount,
    required int Function() getPosition,
    required bool Function(int i) move,
    required bool Function(int i) moveToPosition,
    required bool Function() moveToFirst,
    required bool Function() moveToLast,
    required bool Function() moveToNext,
    required bool Function() moveToPrevious,
    required bool Function() isFirst,
    required bool Function() isLast,
    required bool Function() isBeforeFirst,
    required bool Function() isAfterLast,
    required int Function(jni.JString string) getColumnIndex,
    required int Function(jni.JString string) getColumnIndexOrThrow,
    required jni.JString Function(int i) getColumnName,
    required jni.JArray<jni.JString> Function() getColumnNames,
    required int Function() getColumnCount,
    required jni.JArray<jni.jbyte> Function(int i) getBlob,
    required jni.JString Function(int i) getString,
    required void Function(int i, jni.JObject charArrayBuffer)
        copyStringToBuffer,
    required int Function(int i) getShort,
    required int Function(int i) getInt,
    required int Function(int i) getLong,
    required double Function(int i) getFloat,
    required double Function(int i) getDouble,
    required int Function(int i) getType,
    required bool Function(int i) isNull1,
    required void Function() deactivate,
    required bool Function() requery,
    required void Function() close,
    required bool Function() isClosed,
    required void Function(jni.JObject contentObserver) registerContentObserver,
    required void Function(jni.JObject contentObserver)
        unregisterContentObserver,
    required void Function(jni.JObject dataSetObserver) registerDataSetObserver,
    required void Function(jni.JObject dataSetObserver)
        unregisterDataSetObserver,
    required void Function(ContentResolver contentResolver, Uri uri)
        setNotificationUri,
    required void Function(ContentResolver contentResolver, jni.JList<Uri> list)
        setNotificationUris,
    required Uri Function() getNotificationUri,
    required jni.JList<Uri> Function() getNotificationUris,
    required bool Function() getWantsAllOnMoveCalls,
    required void Function(jni.JObject bundle) setExtras,
    required jni.JObject Function() getExtras,
    required jni.JObject Function(jni.JObject bundle) respond,
  })  : _getCount = getCount,
        _getPosition = getPosition,
        _move = move,
        _moveToPosition = moveToPosition,
        _moveToFirst = moveToFirst,
        _moveToLast = moveToLast,
        _moveToNext = moveToNext,
        _moveToPrevious = moveToPrevious,
        _isFirst = isFirst,
        _isLast = isLast,
        _isBeforeFirst = isBeforeFirst,
        _isAfterLast = isAfterLast,
        _getColumnIndex = getColumnIndex,
        _getColumnIndexOrThrow = getColumnIndexOrThrow,
        _getColumnName = getColumnName,
        _getColumnNames = getColumnNames,
        _getColumnCount = getColumnCount,
        _getBlob = getBlob,
        _getString = getString,
        _copyStringToBuffer = copyStringToBuffer,
        _getShort = getShort,
        _getInt = getInt,
        _getLong = getLong,
        _getFloat = getFloat,
        _getDouble = getDouble,
        _getType = getType,
        _isNull1 = isNull1,
        _deactivate = deactivate,
        _requery = requery,
        _close = close,
        _isClosed = isClosed,
        _registerContentObserver = registerContentObserver,
        _unregisterContentObserver = unregisterContentObserver,
        _registerDataSetObserver = registerDataSetObserver,
        _unregisterDataSetObserver = unregisterDataSetObserver,
        _setNotificationUri = setNotificationUri,
        _setNotificationUris = setNotificationUris,
        _getNotificationUri = getNotificationUri,
        _getNotificationUris = getNotificationUris,
        _getWantsAllOnMoveCalls = getWantsAllOnMoveCalls,
        _setExtras = setExtras,
        _getExtras = getExtras,
        _respond = respond;

  final int Function() _getCount;
  final int Function() _getPosition;
  final bool Function(int i) _move;
  final bool Function(int i) _moveToPosition;
  final bool Function() _moveToFirst;
  final bool Function() _moveToLast;
  final bool Function() _moveToNext;
  final bool Function() _moveToPrevious;
  final bool Function() _isFirst;
  final bool Function() _isLast;
  final bool Function() _isBeforeFirst;
  final bool Function() _isAfterLast;
  final int Function(jni.JString string) _getColumnIndex;
  final int Function(jni.JString string) _getColumnIndexOrThrow;
  final jni.JString Function(int i) _getColumnName;
  final jni.JArray<jni.JString> Function() _getColumnNames;
  final int Function() _getColumnCount;
  final jni.JArray<jni.jbyte> Function(int i) _getBlob;
  final jni.JString Function(int i) _getString;
  final void Function(int i, jni.JObject charArrayBuffer) _copyStringToBuffer;
  final int Function(int i) _getShort;
  final int Function(int i) _getInt;
  final int Function(int i) _getLong;
  final double Function(int i) _getFloat;
  final double Function(int i) _getDouble;
  final int Function(int i) _getType;
  final bool Function(int i) _isNull1;
  final void Function() _deactivate;
  final bool Function() _requery;
  final void Function() _close;
  final bool Function() _isClosed;
  final void Function(jni.JObject contentObserver) _registerContentObserver;
  final void Function(jni.JObject contentObserver) _unregisterContentObserver;
  final void Function(jni.JObject dataSetObserver) _registerDataSetObserver;
  final void Function(jni.JObject dataSetObserver) _unregisterDataSetObserver;
  final void Function(ContentResolver contentResolver, Uri uri)
      _setNotificationUri;
  final void Function(ContentResolver contentResolver, jni.JList<Uri> list)
      _setNotificationUris;
  final Uri Function() _getNotificationUri;
  final jni.JList<Uri> Function() _getNotificationUris;
  final bool Function() _getWantsAllOnMoveCalls;
  final void Function(jni.JObject bundle) _setExtras;
  final jni.JObject Function() _getExtras;
  final jni.JObject Function(jni.JObject bundle) _respond;

  int getCount() {
    return _getCount();
  }

  int getPosition() {
    return _getPosition();
  }

  bool move(int i) {
    return _move(i);
  }

  bool moveToPosition(int i) {
    return _moveToPosition(i);
  }

  bool moveToFirst() {
    return _moveToFirst();
  }

  bool moveToLast() {
    return _moveToLast();
  }

  bool moveToNext() {
    return _moveToNext();
  }

  bool moveToPrevious() {
    return _moveToPrevious();
  }

  bool isFirst() {
    return _isFirst();
  }

  bool isLast() {
    return _isLast();
  }

  bool isBeforeFirst() {
    return _isBeforeFirst();
  }

  bool isAfterLast() {
    return _isAfterLast();
  }

  int getColumnIndex(jni.JString string) {
    return _getColumnIndex(string);
  }

  int getColumnIndexOrThrow(jni.JString string) {
    return _getColumnIndexOrThrow(string);
  }

  jni.JString getColumnName(int i) {
    return _getColumnName(i);
  }

  jni.JArray<jni.JString> getColumnNames() {
    return _getColumnNames();
  }

  int getColumnCount() {
    return _getColumnCount();
  }

  jni.JArray<jni.jbyte> getBlob(int i) {
    return _getBlob(i);
  }

  jni.JString getString(int i) {
    return _getString(i);
  }

  void copyStringToBuffer(int i, jni.JObject charArrayBuffer) {
    return _copyStringToBuffer(i, charArrayBuffer);
  }

  int getShort(int i) {
    return _getShort(i);
  }

  int getInt(int i) {
    return _getInt(i);
  }

  int getLong(int i) {
    return _getLong(i);
  }

  double getFloat(int i) {
    return _getFloat(i);
  }

  double getDouble(int i) {
    return _getDouble(i);
  }

  int getType(int i) {
    return _getType(i);
  }

  bool isNull1(int i) {
    return _isNull1(i);
  }

  void deactivate() {
    return _deactivate();
  }

  bool requery() {
    return _requery();
  }

  void close() {
    return _close();
  }

  bool isClosed() {
    return _isClosed();
  }

  void registerContentObserver(jni.JObject contentObserver) {
    return _registerContentObserver(contentObserver);
  }

  void unregisterContentObserver(jni.JObject contentObserver) {
    return _unregisterContentObserver(contentObserver);
  }

  void registerDataSetObserver(jni.JObject dataSetObserver) {
    return _registerDataSetObserver(dataSetObserver);
  }

  void unregisterDataSetObserver(jni.JObject dataSetObserver) {
    return _unregisterDataSetObserver(dataSetObserver);
  }

  void setNotificationUri(ContentResolver contentResolver, Uri uri) {
    return _setNotificationUri(contentResolver, uri);
  }

  void setNotificationUris(
      ContentResolver contentResolver, jni.JList<Uri> list) {
    return _setNotificationUris(contentResolver, list);
  }

  Uri getNotificationUri() {
    return _getNotificationUri();
  }

  jni.JList<Uri> getNotificationUris() {
    return _getNotificationUris();
  }

  bool getWantsAllOnMoveCalls() {
    return _getWantsAllOnMoveCalls();
  }

  void setExtras(jni.JObject bundle) {
    return _setExtras(bundle);
  }

  jni.JObject getExtras() {
    return _getExtras();
  }

  jni.JObject respond(jni.JObject bundle) {
    return _respond(bundle);
  }
}

final class $CursorType extends jni.JObjType<Cursor> {
  const $CursorType();

  @override
  String get signature => r'Landroid/database/Cursor;';

  @override
  Cursor fromReference(jni.JReference reference) =>
      Cursor.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CursorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CursorType) && other is $CursorType;
  }
}

/// from: android.graphics.Point
class Point extends jni.JObject {
  @override
  late final jni.JObjType<Point> $type = type;

  Point.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/graphics/Point');

  /// The type which includes information such as the signature of this class.
  static const type = $PointType();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  static final _id_x = _class.instanceFieldId(
    r'x',
    r'I',
  );

  /// from: public int x
  int get x => _id_x.get(this, const jni.jintType());

  /// from: public int x
  set x(int value) => _id_x.set(this, const jni.jintType(), value);

  static final _id_y = _class.instanceFieldId(
    r'y',
    r'I',
  );

  /// from: public int y
  int get y => _id_y.get(this, const jni.jintType());

  /// from: public int y
  set y(int value) => _id_y.set(this, const jni.jintType(), value);

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Point() {
    return Point.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(II)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void <init>(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Point.new1(
    int i,
    int i1,
  ) {
    return Point.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr, i, i1)
            .reference);
  }

  static final _id_new2 = _class.constructorId(
    r'(Landroid/graphics/Point;)V',
  );

  static final _new2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.Point point)
  /// The returned object must be released after use, by calling the [release] method.
  factory Point.new2(
    Point point,
  ) {
    return Point.fromReference(_new2(_class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr, point.reference.pointer)
        .reference);
  }

  static final _id_set0 = _class.instanceMethodId(
    r'set',
    r'(II)V',
  );

  static final _set0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void set(int i, int i1)
  void set0(
    int i,
    int i1,
  ) {
    _set0(reference.pointer, _id_set0 as jni.JMethodIDPtr, i, i1).check();
  }

  static final _id_negate = _class.instanceMethodId(
    r'negate',
    r'()V',
  );

  static final _negate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void negate()
  void negate() {
    _negate(reference.pointer, _id_negate as jni.JMethodIDPtr).check();
  }

  static final _id_offset = _class.instanceMethodId(
    r'offset',
    r'(II)V',
  );

  static final _offset = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public final void offset(int i, int i1)
  void offset(
    int i,
    int i1,
  ) {
    _offset(reference.pointer, _id_offset as jni.JMethodIDPtr, i, i1).check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(II)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr, ffi.VarArgs<($Int32, $Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public final boolean equals(int i, int i1)
  bool equals(
    int i,
    int i1,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr, i, i1)
        .boolean;
  }

  static final _id_equals1 = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return _equals1(reference.pointer, _id_equals1 as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, _id_writeToParcel as jni.JMethodIDPtr,
            parcel.reference.pointer, i)
        .check();
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel parcel)
  void readFromParcel(
    jni.JObject parcel,
  ) {
    _readFromParcel(reference.pointer, _id_readFromParcel as jni.JMethodIDPtr,
            parcel.reference.pointer)
        .check();
  }
}

final class $PointType extends jni.JObjType<Point> {
  const $PointType();

  @override
  String get signature => r'Landroid/graphics/Point;';

  @override
  Point fromReference(jni.JReference reference) =>
      Point.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PointType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PointType) && other is $PointType;
  }
}

/// from: android.graphics.Rect
class Rect extends jni.JObject {
  @override
  late final jni.JObjType<Rect> $type = type;

  Rect.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/graphics/Rect');

  /// The type which includes information such as the signature of this class.
  static const type = $RectType();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  static final _id_bottom = _class.instanceFieldId(
    r'bottom',
    r'I',
  );

  /// from: public int bottom
  int get bottom => _id_bottom.get(this, const jni.jintType());

  /// from: public int bottom
  set bottom(int value) => _id_bottom.set(this, const jni.jintType(), value);

  static final _id_left = _class.instanceFieldId(
    r'left',
    r'I',
  );

  /// from: public int left
  int get left => _id_left.get(this, const jni.jintType());

  /// from: public int left
  set left(int value) => _id_left.set(this, const jni.jintType(), value);

  static final _id_right = _class.instanceFieldId(
    r'right',
    r'I',
  );

  /// from: public int right
  int get right => _id_right.get(this, const jni.jintType());

  /// from: public int right
  set right(int value) => _id_right.set(this, const jni.jintType(), value);

  static final _id_top = _class.instanceFieldId(
    r'top',
    r'I',
  );

  /// from: public int top
  int get top => _id_top.get(this, const jni.jintType());

  /// from: public int top
  set top(int value) => _id_top.set(this, const jni.jintType(), value);

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect() {
    return Rect.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(IIII)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public void <init>(int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect.new1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return Rect.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, i, i1, i2, i3)
        .reference);
  }

  static final _id_new2 = _class.constructorId(
    r'(Landroid/graphics/Rect;)V',
  );

  static final _new2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.Rect rect)
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect.new2(
    Rect rect,
  ) {
    return Rect.fromReference(_new2(_class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr, rect.reference.pointer)
        .reference);
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_toShortString = _class.instanceMethodId(
    r'toShortString',
    r'()Ljava/lang/String;',
  );

  static final _toShortString = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toShortString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toShortString() {
    return _toShortString(
            reference.pointer, _id_toShortString as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_flattenToString = _class.instanceMethodId(
    r'flattenToString',
    r'()Ljava/lang/String;',
  );

  static final _flattenToString = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String flattenToString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString flattenToString() {
    return _flattenToString(
            reference.pointer, _id_flattenToString as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_unflattenFromString = _class.staticMethodId(
    r'unflattenFromString',
    r'(Ljava/lang/String;)Landroid/graphics/Rect;',
  );

  static final _unflattenFromString = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Rect unflattenFromString(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Rect unflattenFromString(
    jni.JString string,
  ) {
    return _unflattenFromString(
            _class.reference.pointer,
            _id_unflattenFromString as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $RectType());
  }

  static final _id_isEmpty = _class.instanceMethodId(
    r'isEmpty',
    r'()Z',
  );

  static final _isEmpty = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isEmpty()
  bool isEmpty() {
    return _isEmpty(reference.pointer, _id_isEmpty as jni.JMethodIDPtr).boolean;
  }

  static final _id_width = _class.instanceMethodId(
    r'width',
    r'()I',
  );

  static final _width = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int width()
  int width() {
    return _width(reference.pointer, _id_width as jni.JMethodIDPtr).integer;
  }

  static final _id_height = _class.instanceMethodId(
    r'height',
    r'()I',
  );

  static final _height = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int height()
  int height() {
    return _height(reference.pointer, _id_height as jni.JMethodIDPtr).integer;
  }

  static final _id_centerX = _class.instanceMethodId(
    r'centerX',
    r'()I',
  );

  static final _centerX = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int centerX()
  int centerX() {
    return _centerX(reference.pointer, _id_centerX as jni.JMethodIDPtr).integer;
  }

  static final _id_centerY = _class.instanceMethodId(
    r'centerY',
    r'()I',
  );

  static final _centerY = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int centerY()
  int centerY() {
    return _centerY(reference.pointer, _id_centerY as jni.JMethodIDPtr).integer;
  }

  static final _id_exactCenterX = _class.instanceMethodId(
    r'exactCenterX',
    r'()F',
  );

  static final _exactCenterX = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public float exactCenterX()
  double exactCenterX() {
    return _exactCenterX(
            reference.pointer, _id_exactCenterX as jni.JMethodIDPtr)
        .float;
  }

  static final _id_exactCenterY = _class.instanceMethodId(
    r'exactCenterY',
    r'()F',
  );

  static final _exactCenterY = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public float exactCenterY()
  double exactCenterY() {
    return _exactCenterY(
            reference.pointer, _id_exactCenterY as jni.JMethodIDPtr)
        .float;
  }

  static final _id_setEmpty = _class.instanceMethodId(
    r'setEmpty',
    r'()V',
  );

  static final _setEmpty = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void setEmpty()
  void setEmpty() {
    _setEmpty(reference.pointer, _id_setEmpty as jni.JMethodIDPtr).check();
  }

  static final _id_set0 = _class.instanceMethodId(
    r'set',
    r'(IIII)V',
  );

  static final _set0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public void set(int i, int i1, int i2, int i3)
  void set0(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _set0(reference.pointer, _id_set0 as jni.JMethodIDPtr, i, i1, i2, i3)
        .check();
  }

  static final _id_set1 = _class.instanceMethodId(
    r'set',
    r'(Landroid/graphics/Rect;)V',
  );

  static final _set1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void set(android.graphics.Rect rect)
  void set1(
    Rect rect,
  ) {
    _set1(reference.pointer, _id_set1 as jni.JMethodIDPtr,
            rect.reference.pointer)
        .check();
  }

  static final _id_offset = _class.instanceMethodId(
    r'offset',
    r'(II)V',
  );

  static final _offset = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void offset(int i, int i1)
  void offset(
    int i,
    int i1,
  ) {
    _offset(reference.pointer, _id_offset as jni.JMethodIDPtr, i, i1).check();
  }

  static final _id_offsetTo = _class.instanceMethodId(
    r'offsetTo',
    r'(II)V',
  );

  static final _offsetTo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void offsetTo(int i, int i1)
  void offsetTo(
    int i,
    int i1,
  ) {
    _offsetTo(reference.pointer, _id_offsetTo as jni.JMethodIDPtr, i, i1)
        .check();
  }

  static final _id_inset = _class.instanceMethodId(
    r'inset',
    r'(II)V',
  );

  static final _inset = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void inset(int i, int i1)
  void inset(
    int i,
    int i1,
  ) {
    _inset(reference.pointer, _id_inset as jni.JMethodIDPtr, i, i1).check();
  }

  static final _id_inset1 = _class.instanceMethodId(
    r'inset',
    r'(Landroid/graphics/Insets;)V',
  );

  static final _inset1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void inset(android.graphics.Insets insets)
  void inset1(
    jni.JObject insets,
  ) {
    _inset1(reference.pointer, _id_inset1 as jni.JMethodIDPtr,
            insets.reference.pointer)
        .check();
  }

  static final _id_inset2 = _class.instanceMethodId(
    r'inset',
    r'(IIII)V',
  );

  static final _inset2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public void inset(int i, int i1, int i2, int i3)
  void inset2(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _inset2(reference.pointer, _id_inset2 as jni.JMethodIDPtr, i, i1, i2, i3)
        .check();
  }

  static final _id_contains = _class.instanceMethodId(
    r'contains',
    r'(II)Z',
  );

  static final _contains = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr, ffi.VarArgs<($Int32, $Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public boolean contains(int i, int i1)
  bool contains(
    int i,
    int i1,
  ) {
    return _contains(reference.pointer, _id_contains as jni.JMethodIDPtr, i, i1)
        .boolean;
  }

  static final _id_contains1 = _class.instanceMethodId(
    r'contains',
    r'(IIII)Z',
  );

  static final _contains1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public boolean contains(int i, int i1, int i2, int i3)
  bool contains1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _contains1(
            reference.pointer, _id_contains1 as jni.JMethodIDPtr, i, i1, i2, i3)
        .boolean;
  }

  static final _id_contains2 = _class.instanceMethodId(
    r'contains',
    r'(Landroid/graphics/Rect;)Z',
  );

  static final _contains2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean contains(android.graphics.Rect rect)
  bool contains2(
    Rect rect,
  ) {
    return _contains2(reference.pointer, _id_contains2 as jni.JMethodIDPtr,
            rect.reference.pointer)
        .boolean;
  }

  static final _id_intersect = _class.instanceMethodId(
    r'intersect',
    r'(IIII)Z',
  );

  static final _intersect = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public boolean intersect(int i, int i1, int i2, int i3)
  bool intersect(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _intersect(
            reference.pointer, _id_intersect as jni.JMethodIDPtr, i, i1, i2, i3)
        .boolean;
  }

  static final _id_intersect1 = _class.instanceMethodId(
    r'intersect',
    r'(Landroid/graphics/Rect;)Z',
  );

  static final _intersect1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean intersect(android.graphics.Rect rect)
  bool intersect1(
    Rect rect,
  ) {
    return _intersect1(reference.pointer, _id_intersect1 as jni.JMethodIDPtr,
            rect.reference.pointer)
        .boolean;
  }

  static final _id_setIntersect = _class.instanceMethodId(
    r'setIntersect',
    r'(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z',
  );

  static final _setIntersect = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setIntersect(android.graphics.Rect rect, android.graphics.Rect rect1)
  bool setIntersect(
    Rect rect,
    Rect rect1,
  ) {
    return _setIntersect(
            reference.pointer,
            _id_setIntersect as jni.JMethodIDPtr,
            rect.reference.pointer,
            rect1.reference.pointer)
        .boolean;
  }

  static final _id_intersects = _class.instanceMethodId(
    r'intersects',
    r'(IIII)Z',
  );

  static final _intersects = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public boolean intersects(int i, int i1, int i2, int i3)
  bool intersects(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _intersects(reference.pointer, _id_intersects as jni.JMethodIDPtr, i,
            i1, i2, i3)
        .boolean;
  }

  static final _id_intersects1 = _class.staticMethodId(
    r'intersects',
    r'(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z',
  );

  static final _intersects1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean intersects(android.graphics.Rect rect, android.graphics.Rect rect1)
  static bool intersects1(
    Rect rect,
    Rect rect1,
  ) {
    return _intersects1(
            _class.reference.pointer,
            _id_intersects1 as jni.JMethodIDPtr,
            rect.reference.pointer,
            rect1.reference.pointer)
        .boolean;
  }

  static final _id_union = _class.instanceMethodId(
    r'union',
    r'(IIII)V',
  );

  static final _union = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public void union(int i, int i1, int i2, int i3)
  void union(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _union(reference.pointer, _id_union as jni.JMethodIDPtr, i, i1, i2, i3)
        .check();
  }

  static final _id_union1 = _class.instanceMethodId(
    r'union',
    r'(Landroid/graphics/Rect;)V',
  );

  static final _union1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void union(android.graphics.Rect rect)
  void union1(
    Rect rect,
  ) {
    _union1(reference.pointer, _id_union1 as jni.JMethodIDPtr,
            rect.reference.pointer)
        .check();
  }

  static final _id_union2 = _class.instanceMethodId(
    r'union',
    r'(II)V',
  );

  static final _union2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void union(int i, int i1)
  void union2(
    int i,
    int i1,
  ) {
    _union2(reference.pointer, _id_union2 as jni.JMethodIDPtr, i, i1).check();
  }

  static final _id_sort = _class.instanceMethodId(
    r'sort',
    r'()V',
  );

  static final _sort = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void sort()
  void sort() {
    _sort(reference.pointer, _id_sort as jni.JMethodIDPtr).check();
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, _id_writeToParcel as jni.JMethodIDPtr,
            parcel.reference.pointer, i)
        .check();
  }

  static final _id_readFromParcel = _class.instanceMethodId(
    r'readFromParcel',
    r'(Landroid/os/Parcel;)V',
  );

  static final _readFromParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel parcel)
  void readFromParcel(
    jni.JObject parcel,
  ) {
    _readFromParcel(reference.pointer, _id_readFromParcel as jni.JMethodIDPtr,
            parcel.reference.pointer)
        .check();
  }
}

final class $RectType extends jni.JObjType<Rect> {
  const $RectType();

  @override
  String get signature => r'Landroid/graphics/Rect;';

  @override
  Rect fromReference(jni.JReference reference) => Rect.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RectType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RectType) && other is $RectType;
  }
}

/// from: android.media.Image$Plane
class Image_Plane extends jni.JObject {
  @override
  late final jni.JObjType<Image_Plane> $type = type;

  Image_Plane.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/media/Image$Plane');

  /// The type which includes information such as the signature of this class.
  static const type = $Image_PlaneType();
  static final _id_getRowStride = _class.instanceMethodId(
    r'getRowStride',
    r'()I',
  );

  static final _getRowStride = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getRowStride()
  int getRowStride() {
    return _getRowStride(
            reference.pointer, _id_getRowStride as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPixelStride = _class.instanceMethodId(
    r'getPixelStride',
    r'()I',
  );

  static final _getPixelStride = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getPixelStride()
  int getPixelStride() {
    return _getPixelStride(
            reference.pointer, _id_getPixelStride as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getBuffer = _class.instanceMethodId(
    r'getBuffer',
    r'()Ljava/nio/ByteBuffer;',
  );

  static final _getBuffer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.nio.ByteBuffer getBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByteBuffer getBuffer() {
    return _getBuffer(reference.pointer, _id_getBuffer as jni.JMethodIDPtr)
        .object(const jni.JByteBufferType());
  }
}

final class $Image_PlaneType extends jni.JObjType<Image_Plane> {
  const $Image_PlaneType();

  @override
  String get signature => r'Landroid/media/Image$Plane;';

  @override
  Image_Plane fromReference(jni.JReference reference) =>
      Image_Plane.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Image_PlaneType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Image_PlaneType) && other is $Image_PlaneType;
  }
}

/// from: android.media.Image
class Image extends jni.JObject {
  @override
  late final jni.JObjType<Image> $type = type;

  Image.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/media/Image');

  /// The type which includes information such as the signature of this class.
  static const type = $ImageType();
  static final _id_getFormat = _class.instanceMethodId(
    r'getFormat',
    r'()I',
  );

  static final _getFormat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getFormat()
  int getFormat() {
    return _getFormat(reference.pointer, _id_getFormat as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getWidth()
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getHeight()
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()J',
  );

  static final _getTimestamp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract long getTimestamp()
  int getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni.JMethodIDPtr)
        .long;
  }

  static final _id_getFence = _class.instanceMethodId(
    r'getFence',
    r'()Landroid/hardware/SyncFence;',
  );

  static final _getFence = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.hardware.SyncFence getFence()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFence() {
    return _getFence(reference.pointer, _id_getFence as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getHardwareBuffer = _class.instanceMethodId(
    r'getHardwareBuffer',
    r'()Landroid/hardware/HardwareBuffer;',
  );

  static final _getHardwareBuffer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.hardware.HardwareBuffer getHardwareBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHardwareBuffer() {
    return _getHardwareBuffer(
            reference.pointer, _id_getHardwareBuffer as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setTimestamp = _class.instanceMethodId(
    r'setTimestamp',
    r'(J)V',
  );

  static final _setTimestamp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setTimestamp(long j)
  void setTimestamp(
    int j,
  ) {
    _setTimestamp(reference.pointer, _id_setTimestamp as jni.JMethodIDPtr, j)
        .check();
  }

  static final _id_setFence = _class.instanceMethodId(
    r'setFence',
    r'(Landroid/hardware/SyncFence;)V',
  );

  static final _setFence = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setFence(android.hardware.SyncFence syncFence)
  void setFence(
    jni.JObject syncFence,
  ) {
    _setFence(reference.pointer, _id_setFence as jni.JMethodIDPtr,
            syncFence.reference.pointer)
        .check();
  }

  static final _id_getDataSpace = _class.instanceMethodId(
    r'getDataSpace',
    r'()I',
  );

  static final _getDataSpace = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getDataSpace()
  int getDataSpace() {
    return _getDataSpace(
            reference.pointer, _id_getDataSpace as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setDataSpace = _class.instanceMethodId(
    r'setDataSpace',
    r'(I)V',
  );

  static final _setDataSpace = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setDataSpace(int i)
  void setDataSpace(
    int i,
  ) {
    _setDataSpace(reference.pointer, _id_setDataSpace as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getCropRect = _class.instanceMethodId(
    r'getCropRect',
    r'()Landroid/graphics/Rect;',
  );

  static final _getCropRect = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Rect getCropRect()
  /// The returned object must be released after use, by calling the [release] method.
  Rect getCropRect() {
    return _getCropRect(reference.pointer, _id_getCropRect as jni.JMethodIDPtr)
        .object(const $RectType());
  }

  static final _id_setCropRect = _class.instanceMethodId(
    r'setCropRect',
    r'(Landroid/graphics/Rect;)V',
  );

  static final _setCropRect = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setCropRect(android.graphics.Rect rect)
  void setCropRect(
    Rect rect,
  ) {
    _setCropRect(reference.pointer, _id_setCropRect as jni.JMethodIDPtr,
            rect.reference.pointer)
        .check();
  }

  static final _id_getPlanes = _class.instanceMethodId(
    r'getPlanes',
    r'()[Landroid/media/Image$Plane;',
  );

  static final _getPlanes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.media.Image$Plane[] getPlanes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<Image_Plane> getPlanes() {
    return _getPlanes(reference.pointer, _id_getPlanes as jni.JMethodIDPtr)
        .object(const jni.JArrayType($Image_PlaneType()));
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }
}

final class $ImageType extends jni.JObjType<Image> {
  const $ImageType();

  @override
  String get signature => r'Landroid/media/Image;';

  @override
  Image fromReference(jni.JReference reference) =>
      Image.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ImageType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageType) && other is $ImageType;
  }
}

/// from: android.net.Uri$Builder
class Uri_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Uri_Builder> $type = type;

  Uri_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/net/Uri$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $Uri_BuilderType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Uri_Builder() {
    return Uri_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_scheme = _class.instanceMethodId(
    r'scheme',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _scheme = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder scheme(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder scheme(
    jni.JString string,
  ) {
    return _scheme(reference.pointer, _id_scheme as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_opaquePart = _class.instanceMethodId(
    r'opaquePart',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _opaquePart = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder opaquePart(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder opaquePart(
    jni.JString string,
  ) {
    return _opaquePart(reference.pointer, _id_opaquePart as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_encodedOpaquePart = _class.instanceMethodId(
    r'encodedOpaquePart',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _encodedOpaquePart = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedOpaquePart(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedOpaquePart(
    jni.JString string,
  ) {
    return _encodedOpaquePart(reference.pointer,
            _id_encodedOpaquePart as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_authority = _class.instanceMethodId(
    r'authority',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _authority = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder authority(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder authority(
    jni.JString string,
  ) {
    return _authority(reference.pointer, _id_authority as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_encodedAuthority = _class.instanceMethodId(
    r'encodedAuthority',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _encodedAuthority = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedAuthority(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedAuthority(
    jni.JString string,
  ) {
    return _encodedAuthority(reference.pointer,
            _id_encodedAuthority as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_path = _class.instanceMethodId(
    r'path',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _path = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder path(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder path(
    jni.JString string,
  ) {
    return _path(reference.pointer, _id_path as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_encodedPath = _class.instanceMethodId(
    r'encodedPath',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _encodedPath = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedPath(
    jni.JString string,
  ) {
    return _encodedPath(reference.pointer, _id_encodedPath as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_appendPath = _class.instanceMethodId(
    r'appendPath',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _appendPath = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendPath(
    jni.JString string,
  ) {
    return _appendPath(reference.pointer, _id_appendPath as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_appendEncodedPath = _class.instanceMethodId(
    r'appendEncodedPath',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _appendEncodedPath = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendEncodedPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendEncodedPath(
    jni.JString string,
  ) {
    return _appendEncodedPath(reference.pointer,
            _id_appendEncodedPath as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _query = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder query(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder query(
    jni.JString string,
  ) {
    return _query(reference.pointer, _id_query as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_encodedQuery = _class.instanceMethodId(
    r'encodedQuery',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _encodedQuery = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedQuery(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedQuery(
    jni.JString string,
  ) {
    return _encodedQuery(reference.pointer,
            _id_encodedQuery as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_fragment = _class.instanceMethodId(
    r'fragment',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _fragment = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder fragment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder fragment(
    jni.JString string,
  ) {
    return _fragment(reference.pointer, _id_fragment as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_encodedFragment = _class.instanceMethodId(
    r'encodedFragment',
    r'(Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _encodedFragment = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedFragment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedFragment(
    jni.JString string,
  ) {
    return _encodedFragment(reference.pointer,
            _id_encodedFragment as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_appendQueryParameter = _class.instanceMethodId(
    r'appendQueryParameter',
    r'(Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri$Builder;',
  );

  static final _appendQueryParameter = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendQueryParameter(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendQueryParameter(
    jni.JString string,
    jni.JString string1,
  ) {
    return _appendQueryParameter(
            reference.pointer,
            _id_appendQueryParameter as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _id_clearQuery = _class.instanceMethodId(
    r'clearQuery',
    r'()Landroid/net/Uri$Builder;',
  );

  static final _clearQuery = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.net.Uri$Builder clearQuery()
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder clearQuery() {
    return _clearQuery(reference.pointer, _id_clearQuery as jni.JMethodIDPtr)
        .object(const $Uri_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroid/net/Uri;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.net.Uri build()
  /// The returned object must be released after use, by calling the [release] method.
  Uri build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $UriType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $Uri_BuilderType extends jni.JObjType<Uri_Builder> {
  const $Uri_BuilderType();

  @override
  String get signature => r'Landroid/net/Uri$Builder;';

  @override
  Uri_Builder fromReference(jni.JReference reference) =>
      Uri_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Uri_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Uri_BuilderType) && other is $Uri_BuilderType;
  }
}

/// from: android.net.Uri
class Uri extends jni.JObject {
  @override
  late final jni.JObjType<Uri> $type = type;

  Uri.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/net/Uri');

  /// The type which includes information such as the signature of this class.
  static const type = $UriType();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  static final _id_EMPTY = _class.staticFieldId(
    r'EMPTY',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EMPTY
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EMPTY => _id_EMPTY.get(_class, const $UriType());

  static final _id_isHierarchical = _class.instanceMethodId(
    r'isHierarchical',
    r'()Z',
  );

  static final _isHierarchical = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isHierarchical()
  bool isHierarchical() {
    return _isHierarchical(
            reference.pointer, _id_isHierarchical as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isOpaque = _class.instanceMethodId(
    r'isOpaque',
    r'()Z',
  );

  static final _isOpaque = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isOpaque()
  bool isOpaque() {
    return _isOpaque(reference.pointer, _id_isOpaque as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isRelative = _class.instanceMethodId(
    r'isRelative',
    r'()Z',
  );

  static final _isRelative = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isRelative()
  bool isRelative() {
    return _isRelative(reference.pointer, _id_isRelative as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isAbsolute = _class.instanceMethodId(
    r'isAbsolute',
    r'()Z',
  );

  static final _isAbsolute = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isAbsolute()
  bool isAbsolute() {
    return _isAbsolute(reference.pointer, _id_isAbsolute as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getScheme = _class.instanceMethodId(
    r'getScheme',
    r'()Ljava/lang/String;',
  );

  static final _getScheme = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getScheme()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getScheme() {
    return _getScheme(reference.pointer, _id_getScheme as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSchemeSpecificPart = _class.instanceMethodId(
    r'getSchemeSpecificPart',
    r'()Ljava/lang/String;',
  );

  static final _getSchemeSpecificPart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getSchemeSpecificPart()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSchemeSpecificPart() {
    return _getSchemeSpecificPart(
            reference.pointer, _id_getSchemeSpecificPart as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getEncodedSchemeSpecificPart = _class.instanceMethodId(
    r'getEncodedSchemeSpecificPart',
    r'()Ljava/lang/String;',
  );

  static final _getEncodedSchemeSpecificPart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getEncodedSchemeSpecificPart()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedSchemeSpecificPart() {
    return _getEncodedSchemeSpecificPart(reference.pointer,
            _id_getEncodedSchemeSpecificPart as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAuthority = _class.instanceMethodId(
    r'getAuthority',
    r'()Ljava/lang/String;',
  );

  static final _getAuthority = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getAuthority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAuthority() {
    return _getAuthority(
            reference.pointer, _id_getAuthority as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getEncodedAuthority = _class.instanceMethodId(
    r'getEncodedAuthority',
    r'()Ljava/lang/String;',
  );

  static final _getEncodedAuthority = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getEncodedAuthority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedAuthority() {
    return _getEncodedAuthority(
            reference.pointer, _id_getEncodedAuthority as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getUserInfo = _class.instanceMethodId(
    r'getUserInfo',
    r'()Ljava/lang/String;',
  );

  static final _getUserInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getUserInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUserInfo() {
    return _getUserInfo(reference.pointer, _id_getUserInfo as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getEncodedUserInfo = _class.instanceMethodId(
    r'getEncodedUserInfo',
    r'()Ljava/lang/String;',
  );

  static final _getEncodedUserInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getEncodedUserInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedUserInfo() {
    return _getEncodedUserInfo(
            reference.pointer, _id_getEncodedUserInfo as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getHost = _class.instanceMethodId(
    r'getHost',
    r'()Ljava/lang/String;',
  );

  static final _getHost = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getHost()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getHost() {
    return _getHost(reference.pointer, _id_getHost as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPort = _class.instanceMethodId(
    r'getPort',
    r'()I',
  );

  static final _getPort = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getPort()
  int getPort() {
    return _getPort(reference.pointer, _id_getPort as jni.JMethodIDPtr).integer;
  }

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPath() {
    return _getPath(reference.pointer, _id_getPath as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getEncodedPath = _class.instanceMethodId(
    r'getEncodedPath',
    r'()Ljava/lang/String;',
  );

  static final _getEncodedPath = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getEncodedPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedPath() {
    return _getEncodedPath(
            reference.pointer, _id_getEncodedPath as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getQuery = _class.instanceMethodId(
    r'getQuery',
    r'()Ljava/lang/String;',
  );

  static final _getQuery = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getQuery() {
    return _getQuery(reference.pointer, _id_getQuery as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getEncodedQuery = _class.instanceMethodId(
    r'getEncodedQuery',
    r'()Ljava/lang/String;',
  );

  static final _getEncodedQuery = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getEncodedQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedQuery() {
    return _getEncodedQuery(
            reference.pointer, _id_getEncodedQuery as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getFragment = _class.instanceMethodId(
    r'getFragment',
    r'()Ljava/lang/String;',
  );

  static final _getFragment = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getFragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFragment() {
    return _getFragment(reference.pointer, _id_getFragment as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getEncodedFragment = _class.instanceMethodId(
    r'getEncodedFragment',
    r'()Ljava/lang/String;',
  );

  static final _getEncodedFragment = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getEncodedFragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedFragment() {
    return _getEncodedFragment(
            reference.pointer, _id_getEncodedFragment as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPathSegments = _class.instanceMethodId(
    r'getPathSegments',
    r'()Ljava/util/List;',
  );

  static final _getPathSegments = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.util.List getPathSegments()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getPathSegments() {
    return _getPathSegments(
            reference.pointer, _id_getPathSegments as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_getLastPathSegment = _class.instanceMethodId(
    r'getLastPathSegment',
    r'()Ljava/lang/String;',
  );

  static final _getLastPathSegment = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String getLastPathSegment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLastPathSegment() {
    return _getLastPathSegment(
            reference.pointer, _id_getLastPathSegment as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Landroid/net/Uri;)I',
  );

  static final _compareTo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(android.net.Uri uri)
  int compareTo(
    Uri uri,
  ) {
    return _compareTo(reference.pointer, _id_compareTo as jni.JMethodIDPtr,
            uri.reference.pointer)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_buildUpon = _class.instanceMethodId(
    r'buildUpon',
    r'()Landroid/net/Uri$Builder;',
  );

  static final _buildUpon = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.net.Uri$Builder buildUpon()
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder buildUpon() {
    return _buildUpon(reference.pointer, _id_buildUpon as jni.JMethodIDPtr)
        .object(const $Uri_BuilderType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _parse = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri parse(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri parse(
    jni.JString string,
  ) {
    return _parse(_class.reference.pointer, _id_parse as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_fromFile = _class.staticMethodId(
    r'fromFile',
    r'(Ljava/io/File;)Landroid/net/Uri;',
  );

  static final _fromFile = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri fromFile(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri fromFile(
    jni.JObject file,
  ) {
    return _fromFile(_class.reference.pointer, _id_fromFile as jni.JMethodIDPtr,
            file.reference.pointer)
        .object(const $UriType());
  }

  static final _id_fromParts = _class.staticMethodId(
    r'fromParts',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _fromParts = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri fromParts(java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri fromParts(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return _fromParts(
            _class.reference.pointer,
            _id_fromParts as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getQueryParameterNames = _class.instanceMethodId(
    r'getQueryParameterNames',
    r'()Ljava/util/Set;',
  );

  static final _getQueryParameterNames = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.Set getQueryParameterNames()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> getQueryParameterNames() {
    return _getQueryParameterNames(
            reference.pointer, _id_getQueryParameterNames as jni.JMethodIDPtr)
        .object(const jni.JSetType(jni.JStringType()));
  }

  static final _id_getQueryParameters = _class.instanceMethodId(
    r'getQueryParameters',
    r'(Ljava/lang/String;)Ljava/util/List;',
  );

  static final _getQueryParameters = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getQueryParameters(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getQueryParameters(
    jni.JString string,
  ) {
    return _getQueryParameters(
            reference.pointer,
            _id_getQueryParameters as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_getQueryParameter = _class.instanceMethodId(
    r'getQueryParameter',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getQueryParameter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getQueryParameter(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getQueryParameter(
    jni.JString string,
  ) {
    return _getQueryParameter(reference.pointer,
            _id_getQueryParameter as jni.JMethodIDPtr, string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getBooleanQueryParameter = _class.instanceMethodId(
    r'getBooleanQueryParameter',
    r'(Ljava/lang/String;Z)Z',
  );

  static final _getBooleanQueryParameter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean getBooleanQueryParameter(java.lang.String string, boolean z)
  bool getBooleanQueryParameter(
    jni.JString string,
    bool z,
  ) {
    return _getBooleanQueryParameter(
            reference.pointer,
            _id_getBooleanQueryParameter as jni.JMethodIDPtr,
            string.reference.pointer,
            z ? 1 : 0)
        .boolean;
  }

  static final _id_normalizeScheme = _class.instanceMethodId(
    r'normalizeScheme',
    r'()Landroid/net/Uri;',
  );

  static final _normalizeScheme = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.net.Uri normalizeScheme()
  /// The returned object must be released after use, by calling the [release] method.
  Uri normalizeScheme() {
    return _normalizeScheme(
            reference.pointer, _id_normalizeScheme as jni.JMethodIDPtr)
        .object(const $UriType());
  }

  static final _id_writeToParcel = _class.staticMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;Landroid/net/Uri;)V',
  );

  static final _writeToParcel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writeToParcel(android.os.Parcel parcel, android.net.Uri uri)
  static void writeToParcel(
    jni.JObject parcel,
    Uri uri,
  ) {
    _writeToParcel(
            _class.reference.pointer,
            _id_writeToParcel as jni.JMethodIDPtr,
            parcel.reference.pointer,
            uri.reference.pointer)
        .check();
  }

  static final _id_encode = _class.staticMethodId(
    r'encode',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _encode = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String encode(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString encode(
    jni.JString string,
  ) {
    return _encode(_class.reference.pointer, _id_encode as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_encode1 = _class.staticMethodId(
    r'encode',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _encode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String encode(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString encode1(
    jni.JString string,
    jni.JString string1,
  ) {
    return _encode1(_class.reference.pointer, _id_encode1 as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_decode = _class.staticMethodId(
    r'decode',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _decode = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String decode(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString decode(
    jni.JString string,
  ) {
    return _decode(_class.reference.pointer, _id_decode as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_withAppendedPath = _class.staticMethodId(
    r'withAppendedPath',
    r'(Landroid/net/Uri;Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _withAppendedPath = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri withAppendedPath(android.net.Uri uri, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri withAppendedPath(
    Uri uri,
    jni.JString string,
  ) {
    return _withAppendedPath(
            _class.reference.pointer,
            _id_withAppendedPath as jni.JMethodIDPtr,
            uri.reference.pointer,
            string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_compareTo1 = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/lang/Object;)I',
  );

  static final _compareTo1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(java.lang.Object object)
  int compareTo1(
    jni.JObject object,
  ) {
    return _compareTo1(reference.pointer, _id_compareTo1 as jni.JMethodIDPtr,
            object.reference.pointer)
        .integer;
  }
}

final class $UriType extends jni.JObjType<Uri> {
  const $UriType();

  @override
  String get signature => r'Landroid/net/Uri;';

  @override
  Uri fromReference(jni.JReference reference) => Uri.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UriType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($UriType) && other is $UriType;
  }
}

/// from: android.os.Environment
class Environment extends jni.JObject {
  @override
  late final jni.JObjType<Environment> $type = type;

  Environment.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/os/Environment');

  /// The type which includes information such as the signature of this class.
  static const type = $EnvironmentType();
  static final _id_DIRECTORY_ALARMS = _class.staticFieldId(
    r'DIRECTORY_ALARMS',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_ALARMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_ALARMS =>
      _id_DIRECTORY_ALARMS.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_ALARMS
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_ALARMS(jni.JString value) =>
      _id_DIRECTORY_ALARMS.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_AUDIOBOOKS = _class.staticFieldId(
    r'DIRECTORY_AUDIOBOOKS',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_AUDIOBOOKS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_AUDIOBOOKS =>
      _id_DIRECTORY_AUDIOBOOKS.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_AUDIOBOOKS
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_AUDIOBOOKS(jni.JString value) =>
      _id_DIRECTORY_AUDIOBOOKS.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_DCIM = _class.staticFieldId(
    r'DIRECTORY_DCIM',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_DCIM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_DCIM =>
      _id_DIRECTORY_DCIM.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_DCIM
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_DCIM(jni.JString value) =>
      _id_DIRECTORY_DCIM.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_DOCUMENTS = _class.staticFieldId(
    r'DIRECTORY_DOCUMENTS',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_DOCUMENTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_DOCUMENTS =>
      _id_DIRECTORY_DOCUMENTS.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_DOCUMENTS
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_DOCUMENTS(jni.JString value) =>
      _id_DIRECTORY_DOCUMENTS.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_DOWNLOADS = _class.staticFieldId(
    r'DIRECTORY_DOWNLOADS',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_DOWNLOADS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_DOWNLOADS =>
      _id_DIRECTORY_DOWNLOADS.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_DOWNLOADS
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_DOWNLOADS(jni.JString value) =>
      _id_DIRECTORY_DOWNLOADS.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_MOVIES = _class.staticFieldId(
    r'DIRECTORY_MOVIES',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_MOVIES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_MOVIES =>
      _id_DIRECTORY_MOVIES.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_MOVIES
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_MOVIES(jni.JString value) =>
      _id_DIRECTORY_MOVIES.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_MUSIC = _class.staticFieldId(
    r'DIRECTORY_MUSIC',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_MUSIC
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_MUSIC =>
      _id_DIRECTORY_MUSIC.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_MUSIC
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_MUSIC(jni.JString value) =>
      _id_DIRECTORY_MUSIC.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_NOTIFICATIONS = _class.staticFieldId(
    r'DIRECTORY_NOTIFICATIONS',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_NOTIFICATIONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_NOTIFICATIONS =>
      _id_DIRECTORY_NOTIFICATIONS.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_NOTIFICATIONS
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_NOTIFICATIONS(jni.JString value) =>
      _id_DIRECTORY_NOTIFICATIONS.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_PICTURES = _class.staticFieldId(
    r'DIRECTORY_PICTURES',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_PICTURES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_PICTURES =>
      _id_DIRECTORY_PICTURES.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_PICTURES
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_PICTURES(jni.JString value) =>
      _id_DIRECTORY_PICTURES.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_PODCASTS = _class.staticFieldId(
    r'DIRECTORY_PODCASTS',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_PODCASTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_PODCASTS =>
      _id_DIRECTORY_PODCASTS.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_PODCASTS
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_PODCASTS(jni.JString value) =>
      _id_DIRECTORY_PODCASTS.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_RECORDINGS = _class.staticFieldId(
    r'DIRECTORY_RECORDINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_RECORDINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_RECORDINGS =>
      _id_DIRECTORY_RECORDINGS.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_RECORDINGS
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_RECORDINGS(jni.JString value) =>
      _id_DIRECTORY_RECORDINGS.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_RINGTONES = _class.staticFieldId(
    r'DIRECTORY_RINGTONES',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_RINGTONES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_RINGTONES =>
      _id_DIRECTORY_RINGTONES.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_RINGTONES
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_RINGTONES(jni.JString value) =>
      _id_DIRECTORY_RINGTONES.set(_class, const jni.JStringType(), value);

  static final _id_DIRECTORY_SCREENSHOTS = _class.staticFieldId(
    r'DIRECTORY_SCREENSHOTS',
    r'Ljava/lang/String;',
  );

  /// from: static public java.lang.String DIRECTORY_SCREENSHOTS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_SCREENSHOTS =>
      _id_DIRECTORY_SCREENSHOTS.get(_class, const jni.JStringType());

  /// from: static public java.lang.String DIRECTORY_SCREENSHOTS
  /// The returned object must be released after use, by calling the [release] method.
  static set DIRECTORY_SCREENSHOTS(jni.JString value) =>
      _id_DIRECTORY_SCREENSHOTS.set(_class, const jni.JStringType(), value);

  static final _id_MEDIA_BAD_REMOVAL = _class.staticFieldId(
    r'MEDIA_BAD_REMOVAL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_BAD_REMOVAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_BAD_REMOVAL =>
      _id_MEDIA_BAD_REMOVAL.get(_class, const jni.JStringType());

  static final _id_MEDIA_CHECKING = _class.staticFieldId(
    r'MEDIA_CHECKING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_CHECKING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_CHECKING =>
      _id_MEDIA_CHECKING.get(_class, const jni.JStringType());

  static final _id_MEDIA_EJECTING = _class.staticFieldId(
    r'MEDIA_EJECTING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_EJECTING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_EJECTING =>
      _id_MEDIA_EJECTING.get(_class, const jni.JStringType());

  static final _id_MEDIA_MOUNTED = _class.staticFieldId(
    r'MEDIA_MOUNTED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_MOUNTED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_MOUNTED =>
      _id_MEDIA_MOUNTED.get(_class, const jni.JStringType());

  static final _id_MEDIA_MOUNTED_READ_ONLY = _class.staticFieldId(
    r'MEDIA_MOUNTED_READ_ONLY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_MOUNTED_READ_ONLY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_MOUNTED_READ_ONLY =>
      _id_MEDIA_MOUNTED_READ_ONLY.get(_class, const jni.JStringType());

  static final _id_MEDIA_NOFS = _class.staticFieldId(
    r'MEDIA_NOFS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_NOFS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_NOFS =>
      _id_MEDIA_NOFS.get(_class, const jni.JStringType());

  static final _id_MEDIA_REMOVED = _class.staticFieldId(
    r'MEDIA_REMOVED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_REMOVED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_REMOVED =>
      _id_MEDIA_REMOVED.get(_class, const jni.JStringType());

  static final _id_MEDIA_SHARED = _class.staticFieldId(
    r'MEDIA_SHARED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_SHARED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_SHARED =>
      _id_MEDIA_SHARED.get(_class, const jni.JStringType());

  static final _id_MEDIA_UNKNOWN = _class.staticFieldId(
    r'MEDIA_UNKNOWN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_UNKNOWN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_UNKNOWN =>
      _id_MEDIA_UNKNOWN.get(_class, const jni.JStringType());

  static final _id_MEDIA_UNMOUNTABLE = _class.staticFieldId(
    r'MEDIA_UNMOUNTABLE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_UNMOUNTABLE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_UNMOUNTABLE =>
      _id_MEDIA_UNMOUNTABLE.get(_class, const jni.JStringType());

  static final _id_MEDIA_UNMOUNTED = _class.staticFieldId(
    r'MEDIA_UNMOUNTED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_UNMOUNTED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_UNMOUNTED =>
      _id_MEDIA_UNMOUNTED.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Environment() {
    return Environment.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getRootDirectory = _class.staticMethodId(
    r'getRootDirectory',
    r'()Ljava/io/File;',
  );

  static final _getRootDirectory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.io.File getRootDirectory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getRootDirectory() {
    return _getRootDirectory(
            _class.reference.pointer, _id_getRootDirectory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getStorageDirectory = _class.staticMethodId(
    r'getStorageDirectory',
    r'()Ljava/io/File;',
  );

  static final _getStorageDirectory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.io.File getStorageDirectory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getStorageDirectory() {
    return _getStorageDirectory(_class.reference.pointer,
            _id_getStorageDirectory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getDataDirectory = _class.staticMethodId(
    r'getDataDirectory',
    r'()Ljava/io/File;',
  );

  static final _getDataDirectory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.io.File getDataDirectory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getDataDirectory() {
    return _getDataDirectory(
            _class.reference.pointer, _id_getDataDirectory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getExternalStorageDirectory = _class.staticMethodId(
    r'getExternalStorageDirectory',
    r'()Ljava/io/File;',
  );

  static final _getExternalStorageDirectory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.io.File getExternalStorageDirectory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getExternalStorageDirectory() {
    return _getExternalStorageDirectory(_class.reference.pointer,
            _id_getExternalStorageDirectory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getExternalStoragePublicDirectory = _class.staticMethodId(
    r'getExternalStoragePublicDirectory',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getExternalStoragePublicDirectory =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File getExternalStoragePublicDirectory(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getExternalStoragePublicDirectory(
    jni.JString string,
  ) {
    return _getExternalStoragePublicDirectory(
            _class.reference.pointer,
            _id_getExternalStoragePublicDirectory as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getDownloadCacheDirectory = _class.staticMethodId(
    r'getDownloadCacheDirectory',
    r'()Ljava/io/File;',
  );

  static final _getDownloadCacheDirectory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.io.File getDownloadCacheDirectory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getDownloadCacheDirectory() {
    return _getDownloadCacheDirectory(_class.reference.pointer,
            _id_getDownloadCacheDirectory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getExternalStorageState = _class.staticMethodId(
    r'getExternalStorageState',
    r'()Ljava/lang/String;',
  );

  static final _getExternalStorageState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.lang.String getExternalStorageState()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getExternalStorageState() {
    return _getExternalStorageState(_class.reference.pointer,
            _id_getExternalStorageState as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getStorageState = _class.staticMethodId(
    r'getStorageState',
    r'(Ljava/io/File;)Ljava/lang/String;',
  );

  static final _getStorageState = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getStorageState(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getStorageState(
    jni.JObject file,
  ) {
    return _getStorageState(_class.reference.pointer,
            _id_getStorageState as jni.JMethodIDPtr, file.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getExternalStorageState1 = _class.staticMethodId(
    r'getExternalStorageState',
    r'(Ljava/io/File;)Ljava/lang/String;',
  );

  static final _getExternalStorageState1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getExternalStorageState(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getExternalStorageState1(
    jni.JObject file,
  ) {
    return _getExternalStorageState1(
            _class.reference.pointer,
            _id_getExternalStorageState1 as jni.JMethodIDPtr,
            file.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_isExternalStorageRemovable = _class.staticMethodId(
    r'isExternalStorageRemovable',
    r'()Z',
  );

  static final _isExternalStorageRemovable = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public boolean isExternalStorageRemovable()
  static bool isExternalStorageRemovable() {
    return _isExternalStorageRemovable(_class.reference.pointer,
            _id_isExternalStorageRemovable as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isExternalStorageRemovable1 = _class.staticMethodId(
    r'isExternalStorageRemovable',
    r'(Ljava/io/File;)Z',
  );

  static final _isExternalStorageRemovable1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isExternalStorageRemovable(java.io.File file)
  static bool isExternalStorageRemovable1(
    jni.JObject file,
  ) {
    return _isExternalStorageRemovable1(
            _class.reference.pointer,
            _id_isExternalStorageRemovable1 as jni.JMethodIDPtr,
            file.reference.pointer)
        .boolean;
  }

  static final _id_isExternalStorageEmulated = _class.staticMethodId(
    r'isExternalStorageEmulated',
    r'()Z',
  );

  static final _isExternalStorageEmulated = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public boolean isExternalStorageEmulated()
  static bool isExternalStorageEmulated() {
    return _isExternalStorageEmulated(_class.reference.pointer,
            _id_isExternalStorageEmulated as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isExternalStorageEmulated1 = _class.staticMethodId(
    r'isExternalStorageEmulated',
    r'(Ljava/io/File;)Z',
  );

  static final _isExternalStorageEmulated1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isExternalStorageEmulated(java.io.File file)
  static bool isExternalStorageEmulated1(
    jni.JObject file,
  ) {
    return _isExternalStorageEmulated1(
            _class.reference.pointer,
            _id_isExternalStorageEmulated1 as jni.JMethodIDPtr,
            file.reference.pointer)
        .boolean;
  }

  static final _id_isExternalStorageLegacy = _class.staticMethodId(
    r'isExternalStorageLegacy',
    r'()Z',
  );

  static final _isExternalStorageLegacy = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public boolean isExternalStorageLegacy()
  static bool isExternalStorageLegacy() {
    return _isExternalStorageLegacy(_class.reference.pointer,
            _id_isExternalStorageLegacy as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isExternalStorageLegacy1 = _class.staticMethodId(
    r'isExternalStorageLegacy',
    r'(Ljava/io/File;)Z',
  );

  static final _isExternalStorageLegacy1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isExternalStorageLegacy(java.io.File file)
  static bool isExternalStorageLegacy1(
    jni.JObject file,
  ) {
    return _isExternalStorageLegacy1(
            _class.reference.pointer,
            _id_isExternalStorageLegacy1 as jni.JMethodIDPtr,
            file.reference.pointer)
        .boolean;
  }

  static final _id_isExternalStorageManager = _class.staticMethodId(
    r'isExternalStorageManager',
    r'()Z',
  );

  static final _isExternalStorageManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public boolean isExternalStorageManager()
  static bool isExternalStorageManager() {
    return _isExternalStorageManager(_class.reference.pointer,
            _id_isExternalStorageManager as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isExternalStorageManager1 = _class.staticMethodId(
    r'isExternalStorageManager',
    r'(Ljava/io/File;)Z',
  );

  static final _isExternalStorageManager1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isExternalStorageManager(java.io.File file)
  static bool isExternalStorageManager1(
    jni.JObject file,
  ) {
    return _isExternalStorageManager1(
            _class.reference.pointer,
            _id_isExternalStorageManager1 as jni.JMethodIDPtr,
            file.reference.pointer)
        .boolean;
  }
}

final class $EnvironmentType extends jni.JObjType<Environment> {
  const $EnvironmentType();

  @override
  String get signature => r'Landroid/os/Environment;';

  @override
  Environment fromReference(jni.JReference reference) =>
      Environment.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EnvironmentType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EnvironmentType) && other is $EnvironmentType;
  }
}

/// from: android.provider.MediaStore$Audio$AlbumColumns
class MediaStore_Audio_AlbumColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_AlbumColumns> $type = type;

  MediaStore_Audio_AlbumColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$AlbumColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_AlbumColumnsType();
  static final _id_ALBUM = _class.staticFieldId(
    r'ALBUM',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALBUM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALBUM =>
      _id_ALBUM.get(_class, const jni.JStringType());

  static final _id_ALBUM_ART = _class.staticFieldId(
    r'ALBUM_ART',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALBUM_ART
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALBUM_ART =>
      _id_ALBUM_ART.get(_class, const jni.JStringType());

  static final _id_ALBUM_ID = _class.staticFieldId(
    r'ALBUM_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALBUM_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALBUM_ID =>
      _id_ALBUM_ID.get(_class, const jni.JStringType());

  static final _id_ALBUM_KEY = _class.staticFieldId(
    r'ALBUM_KEY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALBUM_KEY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALBUM_KEY =>
      _id_ALBUM_KEY.get(_class, const jni.JStringType());

  static final _id_ARTIST = _class.staticFieldId(
    r'ARTIST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ARTIST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ARTIST =>
      _id_ARTIST.get(_class, const jni.JStringType());

  static final _id_ARTIST_ID = _class.staticFieldId(
    r'ARTIST_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ARTIST_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ARTIST_ID =>
      _id_ARTIST_ID.get(_class, const jni.JStringType());

  static final _id_ARTIST_KEY = _class.staticFieldId(
    r'ARTIST_KEY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ARTIST_KEY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ARTIST_KEY =>
      _id_ARTIST_KEY.get(_class, const jni.JStringType());

  static final _id_FIRST_YEAR = _class.staticFieldId(
    r'FIRST_YEAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String FIRST_YEAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FIRST_YEAR =>
      _id_FIRST_YEAR.get(_class, const jni.JStringType());

  static final _id_LAST_YEAR = _class.staticFieldId(
    r'LAST_YEAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LAST_YEAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LAST_YEAR =>
      _id_LAST_YEAR.get(_class, const jni.JStringType());

  static final _id_NUMBER_OF_SONGS = _class.staticFieldId(
    r'NUMBER_OF_SONGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NUMBER_OF_SONGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NUMBER_OF_SONGS =>
      _id_NUMBER_OF_SONGS.get(_class, const jni.JStringType());

  static final _id_NUMBER_OF_SONGS_FOR_ARTIST = _class.staticFieldId(
    r'NUMBER_OF_SONGS_FOR_ARTIST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NUMBER_OF_SONGS_FOR_ARTIST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NUMBER_OF_SONGS_FOR_ARTIST =>
      _id_NUMBER_OF_SONGS_FOR_ARTIST.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_Audio_AlbumColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_Audio_AlbumColumns.implement(
    $MediaStore_Audio_AlbumColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_Audio_AlbumColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$Audio$AlbumColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_Audio_AlbumColumnsImpl {
  factory $MediaStore_Audio_AlbumColumnsImpl() =
      _$MediaStore_Audio_AlbumColumnsImpl;
}

class _$MediaStore_Audio_AlbumColumnsImpl
    implements $MediaStore_Audio_AlbumColumnsImpl {
  _$MediaStore_Audio_AlbumColumnsImpl();
}

final class $MediaStore_Audio_AlbumColumnsType
    extends jni.JObjType<MediaStore_Audio_AlbumColumns> {
  const $MediaStore_Audio_AlbumColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$AlbumColumns;';

  @override
  MediaStore_Audio_AlbumColumns fromReference(jni.JReference reference) =>
      MediaStore_Audio_AlbumColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_AlbumColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_AlbumColumnsType) &&
        other is $MediaStore_Audio_AlbumColumnsType;
  }
}

/// from: android.provider.MediaStore$Audio$Albums
class MediaStore_Audio_Albums extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Albums> $type = type;

  MediaStore_Audio_Albums.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$Albums');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_AlbumsType();
  static final _id_CONTENT_TYPE = _class.staticFieldId(
    r'CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_TYPE =>
      _id_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_ENTRY_CONTENT_TYPE = _class.staticFieldId(
    r'ENTRY_CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ENTRY_CONTENT_TYPE =>
      _id_ENTRY_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio_Albums() {
    return MediaStore_Audio_Albums.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }
}

final class $MediaStore_Audio_AlbumsType
    extends jni.JObjType<MediaStore_Audio_Albums> {
  const $MediaStore_Audio_AlbumsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$Albums;';

  @override
  MediaStore_Audio_Albums fromReference(jni.JReference reference) =>
      MediaStore_Audio_Albums.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_AlbumsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_AlbumsType) &&
        other is $MediaStore_Audio_AlbumsType;
  }
}

/// from: android.provider.MediaStore$Audio$ArtistColumns
class MediaStore_Audio_ArtistColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_ArtistColumns> $type = type;

  MediaStore_Audio_ArtistColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$ArtistColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_ArtistColumnsType();
  static final _id_ARTIST = _class.staticFieldId(
    r'ARTIST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ARTIST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ARTIST =>
      _id_ARTIST.get(_class, const jni.JStringType());

  static final _id_ARTIST_KEY = _class.staticFieldId(
    r'ARTIST_KEY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ARTIST_KEY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ARTIST_KEY =>
      _id_ARTIST_KEY.get(_class, const jni.JStringType());

  static final _id_NUMBER_OF_ALBUMS = _class.staticFieldId(
    r'NUMBER_OF_ALBUMS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NUMBER_OF_ALBUMS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NUMBER_OF_ALBUMS =>
      _id_NUMBER_OF_ALBUMS.get(_class, const jni.JStringType());

  static final _id_NUMBER_OF_TRACKS = _class.staticFieldId(
    r'NUMBER_OF_TRACKS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NUMBER_OF_TRACKS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NUMBER_OF_TRACKS =>
      _id_NUMBER_OF_TRACKS.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_Audio_ArtistColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_Audio_ArtistColumns.implement(
    $MediaStore_Audio_ArtistColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_Audio_ArtistColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$Audio$ArtistColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_Audio_ArtistColumnsImpl {
  factory $MediaStore_Audio_ArtistColumnsImpl() =
      _$MediaStore_Audio_ArtistColumnsImpl;
}

class _$MediaStore_Audio_ArtistColumnsImpl
    implements $MediaStore_Audio_ArtistColumnsImpl {
  _$MediaStore_Audio_ArtistColumnsImpl();
}

final class $MediaStore_Audio_ArtistColumnsType
    extends jni.JObjType<MediaStore_Audio_ArtistColumns> {
  const $MediaStore_Audio_ArtistColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$ArtistColumns;';

  @override
  MediaStore_Audio_ArtistColumns fromReference(jni.JReference reference) =>
      MediaStore_Audio_ArtistColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_ArtistColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_ArtistColumnsType) &&
        other is $MediaStore_Audio_ArtistColumnsType;
  }
}

/// from: android.provider.MediaStore$Audio$Artists$Albums
class MediaStore_Audio_Artists_Albums extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Artists_Albums> $type = type;

  MediaStore_Audio_Artists_Albums.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$Artists$Albums');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_Artists_AlbumsType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio_Artists_Albums() {
    return MediaStore_Audio_Artists_Albums.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;J)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
    int j,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer, j)
        .object(const $UriType());
  }
}

final class $MediaStore_Audio_Artists_AlbumsType
    extends jni.JObjType<MediaStore_Audio_Artists_Albums> {
  const $MediaStore_Audio_Artists_AlbumsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$Artists$Albums;';

  @override
  MediaStore_Audio_Artists_Albums fromReference(jni.JReference reference) =>
      MediaStore_Audio_Artists_Albums.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_Artists_AlbumsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_Artists_AlbumsType) &&
        other is $MediaStore_Audio_Artists_AlbumsType;
  }
}

/// from: android.provider.MediaStore$Audio$Artists
class MediaStore_Audio_Artists extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Artists> $type = type;

  MediaStore_Audio_Artists.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$Artists');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_ArtistsType();
  static final _id_CONTENT_TYPE = _class.staticFieldId(
    r'CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_TYPE =>
      _id_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_ENTRY_CONTENT_TYPE = _class.staticFieldId(
    r'ENTRY_CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ENTRY_CONTENT_TYPE =>
      _id_ENTRY_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio_Artists() {
    return MediaStore_Audio_Artists.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }
}

final class $MediaStore_Audio_ArtistsType
    extends jni.JObjType<MediaStore_Audio_Artists> {
  const $MediaStore_Audio_ArtistsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$Artists;';

  @override
  MediaStore_Audio_Artists fromReference(jni.JReference reference) =>
      MediaStore_Audio_Artists.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_ArtistsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_ArtistsType) &&
        other is $MediaStore_Audio_ArtistsType;
  }
}

/// from: android.provider.MediaStore$Audio$AudioColumns
class MediaStore_Audio_AudioColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_AudioColumns> $type = type;

  MediaStore_Audio_AudioColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$AudioColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_AudioColumnsType();
  static final _id_ALBUM_ID = _class.staticFieldId(
    r'ALBUM_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALBUM_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALBUM_ID =>
      _id_ALBUM_ID.get(_class, const jni.JStringType());

  static final _id_ALBUM_KEY = _class.staticFieldId(
    r'ALBUM_KEY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALBUM_KEY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALBUM_KEY =>
      _id_ALBUM_KEY.get(_class, const jni.JStringType());

  static final _id_ARTIST_ID = _class.staticFieldId(
    r'ARTIST_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ARTIST_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ARTIST_ID =>
      _id_ARTIST_ID.get(_class, const jni.JStringType());

  static final _id_ARTIST_KEY = _class.staticFieldId(
    r'ARTIST_KEY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ARTIST_KEY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ARTIST_KEY =>
      _id_ARTIST_KEY.get(_class, const jni.JStringType());

  static final _id_BOOKMARK = _class.staticFieldId(
    r'BOOKMARK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BOOKMARK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BOOKMARK =>
      _id_BOOKMARK.get(_class, const jni.JStringType());

  static final _id_GENRE = _class.staticFieldId(
    r'GENRE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GENRE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GENRE =>
      _id_GENRE.get(_class, const jni.JStringType());

  static final _id_GENRE_ID = _class.staticFieldId(
    r'GENRE_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GENRE_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GENRE_ID =>
      _id_GENRE_ID.get(_class, const jni.JStringType());

  static final _id_GENRE_KEY = _class.staticFieldId(
    r'GENRE_KEY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GENRE_KEY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GENRE_KEY =>
      _id_GENRE_KEY.get(_class, const jni.JStringType());

  static final _id_IS_ALARM = _class.staticFieldId(
    r'IS_ALARM',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_ALARM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_ALARM =>
      _id_IS_ALARM.get(_class, const jni.JStringType());

  static final _id_IS_AUDIOBOOK = _class.staticFieldId(
    r'IS_AUDIOBOOK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_AUDIOBOOK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_AUDIOBOOK =>
      _id_IS_AUDIOBOOK.get(_class, const jni.JStringType());

  static final _id_IS_MUSIC = _class.staticFieldId(
    r'IS_MUSIC',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_MUSIC
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_MUSIC =>
      _id_IS_MUSIC.get(_class, const jni.JStringType());

  static final _id_IS_NOTIFICATION = _class.staticFieldId(
    r'IS_NOTIFICATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_NOTIFICATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_NOTIFICATION =>
      _id_IS_NOTIFICATION.get(_class, const jni.JStringType());

  static final _id_IS_PODCAST = _class.staticFieldId(
    r'IS_PODCAST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_PODCAST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_PODCAST =>
      _id_IS_PODCAST.get(_class, const jni.JStringType());

  static final _id_IS_RECORDING = _class.staticFieldId(
    r'IS_RECORDING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_RECORDING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_RECORDING =>
      _id_IS_RECORDING.get(_class, const jni.JStringType());

  static final _id_IS_RINGTONE = _class.staticFieldId(
    r'IS_RINGTONE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_RINGTONE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_RINGTONE =>
      _id_IS_RINGTONE.get(_class, const jni.JStringType());

  static final _id_TITLE_KEY = _class.staticFieldId(
    r'TITLE_KEY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TITLE_KEY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TITLE_KEY =>
      _id_TITLE_KEY.get(_class, const jni.JStringType());

  static final _id_TITLE_RESOURCE_URI = _class.staticFieldId(
    r'TITLE_RESOURCE_URI',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TITLE_RESOURCE_URI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TITLE_RESOURCE_URI =>
      _id_TITLE_RESOURCE_URI.get(_class, const jni.JStringType());

  static final _id_TRACK = _class.staticFieldId(
    r'TRACK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TRACK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TRACK =>
      _id_TRACK.get(_class, const jni.JStringType());

  static final _id_YEAR = _class.staticFieldId(
    r'YEAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String YEAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get YEAR => _id_YEAR.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_Audio_AudioColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_Audio_AudioColumns.implement(
    $MediaStore_Audio_AudioColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_Audio_AudioColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$Audio$AudioColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_Audio_AudioColumnsImpl {
  factory $MediaStore_Audio_AudioColumnsImpl() =
      _$MediaStore_Audio_AudioColumnsImpl;
}

class _$MediaStore_Audio_AudioColumnsImpl
    implements $MediaStore_Audio_AudioColumnsImpl {
  _$MediaStore_Audio_AudioColumnsImpl();
}

final class $MediaStore_Audio_AudioColumnsType
    extends jni.JObjType<MediaStore_Audio_AudioColumns> {
  const $MediaStore_Audio_AudioColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$AudioColumns;';

  @override
  MediaStore_Audio_AudioColumns fromReference(jni.JReference reference) =>
      MediaStore_Audio_AudioColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_AudioColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_AudioColumnsType) &&
        other is $MediaStore_Audio_AudioColumnsType;
  }
}

/// from: android.provider.MediaStore$Audio$Genres$Members
class MediaStore_Audio_Genres_Members extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Genres_Members> $type = type;

  MediaStore_Audio_Genres_Members.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$Genres$Members');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_Genres_MembersType();
  static final _id_AUDIO_ID = _class.staticFieldId(
    r'AUDIO_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String AUDIO_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUDIO_ID =>
      _id_AUDIO_ID.get(_class, const jni.JStringType());

  static final _id_CONTENT_DIRECTORY = _class.staticFieldId(
    r'CONTENT_DIRECTORY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_DIRECTORY =>
      _id_CONTENT_DIRECTORY.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_GENRE_ID = _class.staticFieldId(
    r'GENRE_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GENRE_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GENRE_ID =>
      _id_GENRE_ID.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio_Genres_Members() {
    return MediaStore_Audio_Genres_Members.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;J)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
    int j,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer, j)
        .object(const $UriType());
  }
}

final class $MediaStore_Audio_Genres_MembersType
    extends jni.JObjType<MediaStore_Audio_Genres_Members> {
  const $MediaStore_Audio_Genres_MembersType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$Genres$Members;';

  @override
  MediaStore_Audio_Genres_Members fromReference(jni.JReference reference) =>
      MediaStore_Audio_Genres_Members.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_Genres_MembersType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_Genres_MembersType) &&
        other is $MediaStore_Audio_Genres_MembersType;
  }
}

/// from: android.provider.MediaStore$Audio$Genres
class MediaStore_Audio_Genres extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Genres> $type = type;

  MediaStore_Audio_Genres.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$Genres');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_GenresType();
  static final _id_CONTENT_TYPE = _class.staticFieldId(
    r'CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_TYPE =>
      _id_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_ENTRY_CONTENT_TYPE = _class.staticFieldId(
    r'ENTRY_CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ENTRY_CONTENT_TYPE =>
      _id_ENTRY_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio_Genres() {
    return MediaStore_Audio_Genres.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getContentUriForAudioId = _class.staticMethodId(
    r'getContentUriForAudioId',
    r'(Ljava/lang/String;I)Landroid/net/Uri;',
  );

  static final _getContentUriForAudioId = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUriForAudioId(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUriForAudioId(
    jni.JString string,
    int i,
  ) {
    return _getContentUriForAudioId(
            _class.reference.pointer,
            _id_getContentUriForAudioId as jni.JMethodIDPtr,
            string.reference.pointer,
            i)
        .object(const $UriType());
  }
}

final class $MediaStore_Audio_GenresType
    extends jni.JObjType<MediaStore_Audio_Genres> {
  const $MediaStore_Audio_GenresType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$Genres;';

  @override
  MediaStore_Audio_Genres fromReference(jni.JReference reference) =>
      MediaStore_Audio_Genres.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_GenresType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_GenresType) &&
        other is $MediaStore_Audio_GenresType;
  }
}

/// from: android.provider.MediaStore$Audio$GenresColumns
class MediaStore_Audio_GenresColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_GenresColumns> $type = type;

  MediaStore_Audio_GenresColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$GenresColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_GenresColumnsType();
  static final _id_NAME = _class.staticFieldId(
    r'NAME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NAME => _id_NAME.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_Audio_GenresColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_Audio_GenresColumns.implement(
    $MediaStore_Audio_GenresColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_Audio_GenresColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$Audio$GenresColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_Audio_GenresColumnsImpl {
  factory $MediaStore_Audio_GenresColumnsImpl() =
      _$MediaStore_Audio_GenresColumnsImpl;
}

class _$MediaStore_Audio_GenresColumnsImpl
    implements $MediaStore_Audio_GenresColumnsImpl {
  _$MediaStore_Audio_GenresColumnsImpl();
}

final class $MediaStore_Audio_GenresColumnsType
    extends jni.JObjType<MediaStore_Audio_GenresColumns> {
  const $MediaStore_Audio_GenresColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$GenresColumns;';

  @override
  MediaStore_Audio_GenresColumns fromReference(jni.JReference reference) =>
      MediaStore_Audio_GenresColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_GenresColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_GenresColumnsType) &&
        other is $MediaStore_Audio_GenresColumnsType;
  }
}

/// from: android.provider.MediaStore$Audio$Media
class MediaStore_Audio_Media extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Media> $type = type;

  MediaStore_Audio_Media.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$Media');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_MediaType();
  static final _id_CONTENT_TYPE = _class.staticFieldId(
    r'CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_TYPE =>
      _id_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_ENTRY_CONTENT_TYPE = _class.staticFieldId(
    r'ENTRY_CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ENTRY_CONTENT_TYPE =>
      _id_ENTRY_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_EXTRA_MAX_BYTES = _class.staticFieldId(
    r'EXTRA_MAX_BYTES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MAX_BYTES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MAX_BYTES =>
      _id_EXTRA_MAX_BYTES.get(_class, const jni.JStringType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_RECORD_SOUND_ACTION = _class.staticFieldId(
    r'RECORD_SOUND_ACTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RECORD_SOUND_ACTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RECORD_SOUND_ACTION =>
      _id_RECORD_SOUND_ACTION.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio_Media() {
    return MediaStore_Audio_Media.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getContentUri1 = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;J)Landroid/net/Uri;',
  );

  static final _getContentUri1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri1(
    jni.JString string,
    int j,
  ) {
    return _getContentUri1(_class.reference.pointer,
            _id_getContentUri1 as jni.JMethodIDPtr, string.reference.pointer, j)
        .object(const $UriType());
  }

  static final _id_getContentUriForPath = _class.staticMethodId(
    r'getContentUriForPath',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUriForPath = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUriForPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUriForPath(
    jni.JString string,
  ) {
    return _getContentUriForPath(
            _class.reference.pointer,
            _id_getContentUriForPath as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $UriType());
  }
}

final class $MediaStore_Audio_MediaType
    extends jni.JObjType<MediaStore_Audio_Media> {
  const $MediaStore_Audio_MediaType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$Media;';

  @override
  MediaStore_Audio_Media fromReference(jni.JReference reference) =>
      MediaStore_Audio_Media.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_MediaType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_MediaType) &&
        other is $MediaStore_Audio_MediaType;
  }
}

/// from: android.provider.MediaStore$Audio$Playlists$Members
class MediaStore_Audio_Playlists_Members extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Playlists_Members> $type = type;

  MediaStore_Audio_Playlists_Members.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'android/provider/MediaStore$Audio$Playlists$Members');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_Playlists_MembersType();
  static final _id_AUDIO_ID = _class.staticFieldId(
    r'AUDIO_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String AUDIO_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUDIO_ID =>
      _id_AUDIO_ID.get(_class, const jni.JStringType());

  static final _id_CONTENT_DIRECTORY = _class.staticFieldId(
    r'CONTENT_DIRECTORY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_DIRECTORY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_DIRECTORY =>
      _id_CONTENT_DIRECTORY.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_PLAYLIST_ID = _class.staticFieldId(
    r'PLAYLIST_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PLAYLIST_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PLAYLIST_ID =>
      _id_PLAYLIST_ID.get(_class, const jni.JStringType());

  static final _id_PLAY_ORDER = _class.staticFieldId(
    r'PLAY_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PLAY_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PLAY_ORDER =>
      _id_PLAY_ORDER.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio_Playlists_Members() {
    return MediaStore_Audio_Playlists_Members.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;J)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
    int j,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer, j)
        .object(const $UriType());
  }

  static final _id_moveItem = _class.staticMethodId(
    r'moveItem',
    r'(Landroid/content/ContentResolver;JII)Z',
  );

  static final _moveItem = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: static public boolean moveItem(android.content.ContentResolver contentResolver, long j, int i, int i1)
  static bool moveItem(
    ContentResolver contentResolver,
    int j,
    int i,
    int i1,
  ) {
    return _moveItem(_class.reference.pointer, _id_moveItem as jni.JMethodIDPtr,
            contentResolver.reference.pointer, j, i, i1)
        .boolean;
  }
}

final class $MediaStore_Audio_Playlists_MembersType
    extends jni.JObjType<MediaStore_Audio_Playlists_Members> {
  const $MediaStore_Audio_Playlists_MembersType();

  @override
  String get signature =>
      r'Landroid/provider/MediaStore$Audio$Playlists$Members;';

  @override
  MediaStore_Audio_Playlists_Members fromReference(jni.JReference reference) =>
      MediaStore_Audio_Playlists_Members.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_Playlists_MembersType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_Playlists_MembersType) &&
        other is $MediaStore_Audio_Playlists_MembersType;
  }
}

/// from: android.provider.MediaStore$Audio$Playlists
class MediaStore_Audio_Playlists extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Playlists> $type = type;

  MediaStore_Audio_Playlists.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$Playlists');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_PlaylistsType();
  static final _id_CONTENT_TYPE = _class.staticFieldId(
    r'CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_TYPE =>
      _id_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_ENTRY_CONTENT_TYPE = _class.staticFieldId(
    r'ENTRY_CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ENTRY_CONTENT_TYPE =>
      _id_ENTRY_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio_Playlists() {
    return MediaStore_Audio_Playlists.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }
}

final class $MediaStore_Audio_PlaylistsType
    extends jni.JObjType<MediaStore_Audio_Playlists> {
  const $MediaStore_Audio_PlaylistsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$Playlists;';

  @override
  MediaStore_Audio_Playlists fromReference(jni.JReference reference) =>
      MediaStore_Audio_Playlists.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_PlaylistsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_PlaylistsType) &&
        other is $MediaStore_Audio_PlaylistsType;
  }
}

/// from: android.provider.MediaStore$Audio$PlaylistsColumns
class MediaStore_Audio_PlaylistsColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_PlaylistsColumns> $type = type;

  MediaStore_Audio_PlaylistsColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$PlaylistsColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_PlaylistsColumnsType();
  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATA => _id_DATA.get(_class, const jni.JStringType());

  static final _id_DATE_ADDED = _class.staticFieldId(
    r'DATE_ADDED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATE_ADDED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATE_ADDED =>
      _id_DATE_ADDED.get(_class, const jni.JStringType());

  static final _id_DATE_MODIFIED = _class.staticFieldId(
    r'DATE_MODIFIED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATE_MODIFIED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATE_MODIFIED =>
      _id_DATE_MODIFIED.get(_class, const jni.JStringType());

  static final _id_NAME = _class.staticFieldId(
    r'NAME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NAME => _id_NAME.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_Audio_PlaylistsColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_Audio_PlaylistsColumns.implement(
    $MediaStore_Audio_PlaylistsColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_Audio_PlaylistsColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$Audio$PlaylistsColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_Audio_PlaylistsColumnsImpl {
  factory $MediaStore_Audio_PlaylistsColumnsImpl() =
      _$MediaStore_Audio_PlaylistsColumnsImpl;
}

class _$MediaStore_Audio_PlaylistsColumnsImpl
    implements $MediaStore_Audio_PlaylistsColumnsImpl {
  _$MediaStore_Audio_PlaylistsColumnsImpl();
}

final class $MediaStore_Audio_PlaylistsColumnsType
    extends jni.JObjType<MediaStore_Audio_PlaylistsColumns> {
  const $MediaStore_Audio_PlaylistsColumnsType();

  @override
  String get signature =>
      r'Landroid/provider/MediaStore$Audio$PlaylistsColumns;';

  @override
  MediaStore_Audio_PlaylistsColumns fromReference(jni.JReference reference) =>
      MediaStore_Audio_PlaylistsColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_PlaylistsColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_PlaylistsColumnsType) &&
        other is $MediaStore_Audio_PlaylistsColumnsType;
  }
}

/// from: android.provider.MediaStore$Audio$Radio
class MediaStore_Audio_Radio extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio_Radio> $type = type;

  MediaStore_Audio_Radio.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio$Radio');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Audio_RadioType();
  static final _id_ENTRY_CONTENT_TYPE = _class.staticFieldId(
    r'ENTRY_CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ENTRY_CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ENTRY_CONTENT_TYPE =>
      _id_ENTRY_CONTENT_TYPE.get(_class, const jni.JStringType());
}

final class $MediaStore_Audio_RadioType
    extends jni.JObjType<MediaStore_Audio_Radio> {
  const $MediaStore_Audio_RadioType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio$Radio;';

  @override
  MediaStore_Audio_Radio fromReference(jni.JReference reference) =>
      MediaStore_Audio_Radio.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Audio_RadioType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Audio_RadioType) &&
        other is $MediaStore_Audio_RadioType;
  }
}

/// from: android.provider.MediaStore$Audio
class MediaStore_Audio extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Audio> $type = type;

  MediaStore_Audio.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Audio');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_AudioType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Audio() {
    return MediaStore_Audio.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_keyFor = _class.staticMethodId(
    r'keyFor',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _keyFor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String keyFor(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString keyFor(
    jni.JString string,
  ) {
    return _keyFor(_class.reference.pointer, _id_keyFor as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }
}

final class $MediaStore_AudioType extends jni.JObjType<MediaStore_Audio> {
  const $MediaStore_AudioType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Audio;';

  @override
  MediaStore_Audio fromReference(jni.JReference reference) =>
      MediaStore_Audio.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_AudioType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_AudioType) &&
        other is $MediaStore_AudioType;
  }
}

/// from: android.provider.MediaStore$DownloadColumns
class MediaStore_DownloadColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_DownloadColumns> $type = type;

  MediaStore_DownloadColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$DownloadColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_DownloadColumnsType();
  static final _id_DOWNLOAD_URI = _class.staticFieldId(
    r'DOWNLOAD_URI',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DOWNLOAD_URI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DOWNLOAD_URI =>
      _id_DOWNLOAD_URI.get(_class, const jni.JStringType());

  static final _id_REFERER_URI = _class.staticFieldId(
    r'REFERER_URI',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String REFERER_URI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get REFERER_URI =>
      _id_REFERER_URI.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_DownloadColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_DownloadColumns.implement(
    $MediaStore_DownloadColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_DownloadColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$DownloadColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_DownloadColumnsImpl {
  factory $MediaStore_DownloadColumnsImpl() = _$MediaStore_DownloadColumnsImpl;
}

class _$MediaStore_DownloadColumnsImpl
    implements $MediaStore_DownloadColumnsImpl {
  _$MediaStore_DownloadColumnsImpl();
}

final class $MediaStore_DownloadColumnsType
    extends jni.JObjType<MediaStore_DownloadColumns> {
  const $MediaStore_DownloadColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$DownloadColumns;';

  @override
  MediaStore_DownloadColumns fromReference(jni.JReference reference) =>
      MediaStore_DownloadColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_DownloadColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_DownloadColumnsType) &&
        other is $MediaStore_DownloadColumnsType;
  }
}

/// from: android.provider.MediaStore$Downloads
class MediaStore_Downloads extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Downloads> $type = type;

  MediaStore_Downloads.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Downloads');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_DownloadsType();
  static final _id_CONTENT_TYPE = _class.staticFieldId(
    r'CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_TYPE =>
      _id_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getContentUri1 = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;J)Landroid/net/Uri;',
  );

  static final _getContentUri1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri1(
    jni.JString string,
    int j,
  ) {
    return _getContentUri1(_class.reference.pointer,
            _id_getContentUri1 as jni.JMethodIDPtr, string.reference.pointer, j)
        .object(const $UriType());
  }
}

final class $MediaStore_DownloadsType
    extends jni.JObjType<MediaStore_Downloads> {
  const $MediaStore_DownloadsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Downloads;';

  @override
  MediaStore_Downloads fromReference(jni.JReference reference) =>
      MediaStore_Downloads.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_DownloadsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_DownloadsType) &&
        other is $MediaStore_DownloadsType;
  }
}

/// from: android.provider.MediaStore$Files$FileColumns
class MediaStore_Files_FileColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Files_FileColumns> $type = type;

  MediaStore_Files_FileColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Files$FileColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Files_FileColumnsType();
  static final _id_MEDIA_TYPE = _class.staticFieldId(
    r'MEDIA_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_TYPE =>
      _id_MEDIA_TYPE.get(_class, const jni.JStringType());

  /// from: static public final int MEDIA_TYPE_AUDIO
  static const MEDIA_TYPE_AUDIO = 2;

  /// from: static public final int MEDIA_TYPE_DOCUMENT
  static const MEDIA_TYPE_DOCUMENT = 6;

  /// from: static public final int MEDIA_TYPE_IMAGE
  static const MEDIA_TYPE_IMAGE = 1;

  /// from: static public final int MEDIA_TYPE_NONE
  static const MEDIA_TYPE_NONE = 0;

  /// from: static public final int MEDIA_TYPE_PLAYLIST
  static const MEDIA_TYPE_PLAYLIST = 4;

  /// from: static public final int MEDIA_TYPE_SUBTITLE
  static const MEDIA_TYPE_SUBTITLE = 5;

  /// from: static public final int MEDIA_TYPE_VIDEO
  static const MEDIA_TYPE_VIDEO = 3;
  static final _id_MIME_TYPE = _class.staticFieldId(
    r'MIME_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MIME_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MIME_TYPE =>
      _id_MIME_TYPE.get(_class, const jni.JStringType());

  static final _id_PARENT = _class.staticFieldId(
    r'PARENT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PARENT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PARENT =>
      _id_PARENT.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_Files_FileColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_Files_FileColumns.implement(
    $MediaStore_Files_FileColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_Files_FileColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$Files$FileColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_Files_FileColumnsImpl {
  factory $MediaStore_Files_FileColumnsImpl() =
      _$MediaStore_Files_FileColumnsImpl;
}

class _$MediaStore_Files_FileColumnsImpl
    implements $MediaStore_Files_FileColumnsImpl {
  _$MediaStore_Files_FileColumnsImpl();
}

final class $MediaStore_Files_FileColumnsType
    extends jni.JObjType<MediaStore_Files_FileColumns> {
  const $MediaStore_Files_FileColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Files$FileColumns;';

  @override
  MediaStore_Files_FileColumns fromReference(jni.JReference reference) =>
      MediaStore_Files_FileColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Files_FileColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Files_FileColumnsType) &&
        other is $MediaStore_Files_FileColumnsType;
  }
}

/// from: android.provider.MediaStore$Files
class MediaStore_Files extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Files> $type = type;

  MediaStore_Files.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Files');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_FilesType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Files() {
    return MediaStore_Files.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getContentUri1 = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;J)Landroid/net/Uri;',
  );

  static final _getContentUri1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri1(
    jni.JString string,
    int j,
  ) {
    return _getContentUri1(_class.reference.pointer,
            _id_getContentUri1 as jni.JMethodIDPtr, string.reference.pointer, j)
        .object(const $UriType());
  }
}

final class $MediaStore_FilesType extends jni.JObjType<MediaStore_Files> {
  const $MediaStore_FilesType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Files;';

  @override
  MediaStore_Files fromReference(jni.JReference reference) =>
      MediaStore_Files.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_FilesType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_FilesType) &&
        other is $MediaStore_FilesType;
  }
}

/// from: android.provider.MediaStore$Images$ImageColumns
class MediaStore_Images_ImageColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Images_ImageColumns> $type = type;

  MediaStore_Images_ImageColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Images$ImageColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Images_ImageColumnsType();
  static final _id_DESCRIPTION = _class.staticFieldId(
    r'DESCRIPTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DESCRIPTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DESCRIPTION =>
      _id_DESCRIPTION.get(_class, const jni.JStringType());

  static final _id_EXPOSURE_TIME = _class.staticFieldId(
    r'EXPOSURE_TIME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXPOSURE_TIME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXPOSURE_TIME =>
      _id_EXPOSURE_TIME.get(_class, const jni.JStringType());

  static final _id_F_NUMBER = _class.staticFieldId(
    r'F_NUMBER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String F_NUMBER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get F_NUMBER =>
      _id_F_NUMBER.get(_class, const jni.JStringType());

  static final _id_ISO = _class.staticFieldId(
    r'ISO',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ISO
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ISO => _id_ISO.get(_class, const jni.JStringType());

  static final _id_IS_PRIVATE = _class.staticFieldId(
    r'IS_PRIVATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_PRIVATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_PRIVATE =>
      _id_IS_PRIVATE.get(_class, const jni.JStringType());

  static final _id_LATITUDE = _class.staticFieldId(
    r'LATITUDE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LATITUDE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LATITUDE =>
      _id_LATITUDE.get(_class, const jni.JStringType());

  static final _id_LONGITUDE = _class.staticFieldId(
    r'LONGITUDE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LONGITUDE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LONGITUDE =>
      _id_LONGITUDE.get(_class, const jni.JStringType());

  static final _id_MINI_THUMB_MAGIC = _class.staticFieldId(
    r'MINI_THUMB_MAGIC',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MINI_THUMB_MAGIC
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MINI_THUMB_MAGIC =>
      _id_MINI_THUMB_MAGIC.get(_class, const jni.JStringType());

  static final _id_PICASA_ID = _class.staticFieldId(
    r'PICASA_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String PICASA_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PICASA_ID =>
      _id_PICASA_ID.get(_class, const jni.JStringType());

  static final _id_SCENE_CAPTURE_TYPE = _class.staticFieldId(
    r'SCENE_CAPTURE_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SCENE_CAPTURE_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SCENE_CAPTURE_TYPE =>
      _id_SCENE_CAPTURE_TYPE.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_Images_ImageColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_Images_ImageColumns.implement(
    $MediaStore_Images_ImageColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_Images_ImageColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$Images$ImageColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_Images_ImageColumnsImpl {
  factory $MediaStore_Images_ImageColumnsImpl() =
      _$MediaStore_Images_ImageColumnsImpl;
}

class _$MediaStore_Images_ImageColumnsImpl
    implements $MediaStore_Images_ImageColumnsImpl {
  _$MediaStore_Images_ImageColumnsImpl();
}

final class $MediaStore_Images_ImageColumnsType
    extends jni.JObjType<MediaStore_Images_ImageColumns> {
  const $MediaStore_Images_ImageColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Images$ImageColumns;';

  @override
  MediaStore_Images_ImageColumns fromReference(jni.JReference reference) =>
      MediaStore_Images_ImageColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Images_ImageColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Images_ImageColumnsType) &&
        other is $MediaStore_Images_ImageColumnsType;
  }
}

/// from: android.provider.MediaStore$Images$Media
class MediaStore_Images_Media extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Images_Media> $type = type;

  MediaStore_Images_Media.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Images$Media');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Images_MediaType();
  static final _id_CONTENT_TYPE = _class.staticFieldId(
    r'CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_TYPE =>
      _id_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Images_Media() {
    return MediaStore_Images_Media.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_query = _class.staticMethodId(
    r'query',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _query = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.database.Cursor query(android.content.ContentResolver contentResolver, android.net.Uri uri, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  static Cursor query(
    ContentResolver contentResolver,
    Uri uri,
    jni.JArray<jni.JString> strings,
  ) {
    return _query(
            _class.reference.pointer,
            _id_query as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer,
            strings.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_query1 = _class.staticMethodId(
    r'query',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _query1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.database.Cursor query(android.content.ContentResolver contentResolver, android.net.Uri uri, java.lang.String[] strings, java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  static Cursor query1(
    ContentResolver contentResolver,
    Uri uri,
    jni.JArray<jni.JString> strings,
    jni.JString string,
    jni.JString string1,
  ) {
    return _query1(
            _class.reference.pointer,
            _id_query1 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer,
            strings.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_query2 = _class.staticMethodId(
    r'query',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _query2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.database.Cursor query(android.content.ContentResolver contentResolver, android.net.Uri uri, java.lang.String[] strings, java.lang.String string, java.lang.String[] strings1, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  static Cursor query2(
    ContentResolver contentResolver,
    Uri uri,
    jni.JArray<jni.JString> strings,
    jni.JString string,
    jni.JArray<jni.JString> strings1,
    jni.JString string1,
  ) {
    return _query2(
            _class.reference.pointer,
            _id_query2 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer,
            strings.reference.pointer,
            string.reference.pointer,
            strings1.reference.pointer,
            string1.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_getBitmap = _class.staticMethodId(
    r'getBitmap',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/graphics/Bitmap;',
  );

  static final _getBitmap = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap getBitmap(android.content.ContentResolver contentResolver, android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getBitmap(
    ContentResolver contentResolver,
    Uri uri,
  ) {
    return _getBitmap(
            _class.reference.pointer,
            _id_getBitmap as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_insertImage = _class.staticMethodId(
    r'insertImage',
    r'(Landroid/content/ContentResolver;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _insertImage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String insertImage(android.content.ContentResolver contentResolver, java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString insertImage(
    ContentResolver contentResolver,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return _insertImage(
            _class.reference.pointer,
            _id_insertImage as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_insertImage1 = _class.staticMethodId(
    r'insertImage',
    r'(Landroid/content/ContentResolver;Landroid/graphics/Bitmap;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _insertImage1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String insertImage(android.content.ContentResolver contentResolver, android.graphics.Bitmap bitmap, java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString insertImage1(
    ContentResolver contentResolver,
    jni.JObject bitmap,
    jni.JString string,
    jni.JString string1,
  ) {
    return _insertImage1(
            _class.reference.pointer,
            _id_insertImage1 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            bitmap.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getContentUri1 = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;J)Landroid/net/Uri;',
  );

  static final _getContentUri1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri1(
    jni.JString string,
    int j,
  ) {
    return _getContentUri1(_class.reference.pointer,
            _id_getContentUri1 as jni.JMethodIDPtr, string.reference.pointer, j)
        .object(const $UriType());
  }
}

final class $MediaStore_Images_MediaType
    extends jni.JObjType<MediaStore_Images_Media> {
  const $MediaStore_Images_MediaType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Images$Media;';

  @override
  MediaStore_Images_Media fromReference(jni.JReference reference) =>
      MediaStore_Images_Media.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Images_MediaType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Images_MediaType) &&
        other is $MediaStore_Images_MediaType;
  }
}

/// from: android.provider.MediaStore$Images$Thumbnails
class MediaStore_Images_Thumbnails extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Images_Thumbnails> $type = type;

  MediaStore_Images_Thumbnails.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Images$Thumbnails');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Images_ThumbnailsType();
  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATA => _id_DATA.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  /// from: static public final int FULL_SCREEN_KIND
  static const FULL_SCREEN_KIND = 2;
  static final _id_HEIGHT = _class.staticFieldId(
    r'HEIGHT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String HEIGHT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HEIGHT =>
      _id_HEIGHT.get(_class, const jni.JStringType());

  static final _id_IMAGE_ID = _class.staticFieldId(
    r'IMAGE_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IMAGE_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IMAGE_ID =>
      _id_IMAGE_ID.get(_class, const jni.JStringType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_KIND = _class.staticFieldId(
    r'KIND',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String KIND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get KIND => _id_KIND.get(_class, const jni.JStringType());

  /// from: static public final int MICRO_KIND
  static const MICRO_KIND = 3;

  /// from: static public final int MINI_KIND
  static const MINI_KIND = 1;
  static final _id_THUMB_DATA = _class.staticFieldId(
    r'THUMB_DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String THUMB_DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get THUMB_DATA =>
      _id_THUMB_DATA.get(_class, const jni.JStringType());

  static final _id_WIDTH = _class.staticFieldId(
    r'WIDTH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WIDTH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WIDTH =>
      _id_WIDTH.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Images_Thumbnails() {
    return MediaStore_Images_Thumbnails.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_query = _class.staticMethodId(
    r'query',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _query = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final android.database.Cursor query(android.content.ContentResolver contentResolver, android.net.Uri uri, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  static Cursor query(
    ContentResolver contentResolver,
    Uri uri,
    jni.JArray<jni.JString> strings,
  ) {
    return _query(
            _class.reference.pointer,
            _id_query as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer,
            strings.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_queryMiniThumbnails = _class.staticMethodId(
    r'queryMiniThumbnails',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;I[Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _queryMiniThumbnails = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final android.database.Cursor queryMiniThumbnails(android.content.ContentResolver contentResolver, android.net.Uri uri, int i, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  static Cursor queryMiniThumbnails(
    ContentResolver contentResolver,
    Uri uri,
    int i,
    jni.JArray<jni.JString> strings,
  ) {
    return _queryMiniThumbnails(
            _class.reference.pointer,
            _id_queryMiniThumbnails as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer,
            i,
            strings.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_queryMiniThumbnail = _class.staticMethodId(
    r'queryMiniThumbnail',
    r'(Landroid/content/ContentResolver;JI[Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _queryMiniThumbnail = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public final android.database.Cursor queryMiniThumbnail(android.content.ContentResolver contentResolver, long j, int i, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  static Cursor queryMiniThumbnail(
    ContentResolver contentResolver,
    int j,
    int i,
    jni.JArray<jni.JString> strings,
  ) {
    return _queryMiniThumbnail(
            _class.reference.pointer,
            _id_queryMiniThumbnail as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j,
            i,
            strings.reference.pointer)
        .object(const $CursorType());
  }

  static final _id_cancelThumbnailRequest = _class.staticMethodId(
    r'cancelThumbnailRequest',
    r'(Landroid/content/ContentResolver;J)V',
  );

  static final _cancelThumbnailRequest = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void cancelThumbnailRequest(android.content.ContentResolver contentResolver, long j)
  static void cancelThumbnailRequest(
    ContentResolver contentResolver,
    int j,
  ) {
    _cancelThumbnailRequest(
            _class.reference.pointer,
            _id_cancelThumbnailRequest as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j)
        .check();
  }

  static final _id_getThumbnail = _class.staticMethodId(
    r'getThumbnail',
    r'(Landroid/content/ContentResolver;JILandroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _getThumbnail = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap getThumbnail(android.content.ContentResolver contentResolver, long j, int i, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getThumbnail(
    ContentResolver contentResolver,
    int j,
    int i,
    jni.JObject options,
  ) {
    return _getThumbnail(
            _class.reference.pointer,
            _id_getThumbnail as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j,
            i,
            options.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_cancelThumbnailRequest1 = _class.staticMethodId(
    r'cancelThumbnailRequest',
    r'(Landroid/content/ContentResolver;JJ)V',
  );

  static final _cancelThumbnailRequest1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public void cancelThumbnailRequest(android.content.ContentResolver contentResolver, long j, long j1)
  static void cancelThumbnailRequest1(
    ContentResolver contentResolver,
    int j,
    int j1,
  ) {
    _cancelThumbnailRequest1(
            _class.reference.pointer,
            _id_cancelThumbnailRequest1 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j,
            j1)
        .check();
  }

  static final _id_getThumbnail1 = _class.staticMethodId(
    r'getThumbnail',
    r'(Landroid/content/ContentResolver;JJILandroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _getThumbnail1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap getThumbnail(android.content.ContentResolver contentResolver, long j, long j1, int i, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getThumbnail1(
    ContentResolver contentResolver,
    int j,
    int j1,
    int i,
    jni.JObject options,
  ) {
    return _getThumbnail1(
            _class.reference.pointer,
            _id_getThumbnail1 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j,
            j1,
            i,
            options.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getKindSize = _class.staticMethodId(
    r'getKindSize',
    r'(I)Landroid/util/Size;',
  );

  static final _getKindSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public android.util.Size getKindSize(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static Size getKindSize(
    int i,
  ) {
    return _getKindSize(
            _class.reference.pointer, _id_getKindSize as jni.JMethodIDPtr, i)
        .object(const $SizeType());
  }
}

final class $MediaStore_Images_ThumbnailsType
    extends jni.JObjType<MediaStore_Images_Thumbnails> {
  const $MediaStore_Images_ThumbnailsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Images$Thumbnails;';

  @override
  MediaStore_Images_Thumbnails fromReference(jni.JReference reference) =>
      MediaStore_Images_Thumbnails.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Images_ThumbnailsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Images_ThumbnailsType) &&
        other is $MediaStore_Images_ThumbnailsType;
  }
}

/// from: android.provider.MediaStore$Images
class MediaStore_Images extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Images> $type = type;

  MediaStore_Images.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Images');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_ImagesType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Images() {
    return MediaStore_Images.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MediaStore_ImagesType extends jni.JObjType<MediaStore_Images> {
  const $MediaStore_ImagesType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Images;';

  @override
  MediaStore_Images fromReference(jni.JReference reference) =>
      MediaStore_Images.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_ImagesType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_ImagesType) &&
        other is $MediaStore_ImagesType;
  }
}

/// from: android.provider.MediaStore$MediaColumns
class MediaStore_MediaColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_MediaColumns> $type = type;

  MediaStore_MediaColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$MediaColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_MediaColumnsType();
  static final _id_ALBUM = _class.staticFieldId(
    r'ALBUM',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALBUM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALBUM =>
      _id_ALBUM.get(_class, const jni.JStringType());

  static final _id_ALBUM_ARTIST = _class.staticFieldId(
    r'ALBUM_ARTIST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ALBUM_ARTIST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ALBUM_ARTIST =>
      _id_ALBUM_ARTIST.get(_class, const jni.JStringType());

  static final _id_ARTIST = _class.staticFieldId(
    r'ARTIST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ARTIST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ARTIST =>
      _id_ARTIST.get(_class, const jni.JStringType());

  static final _id_AUTHOR = _class.staticFieldId(
    r'AUTHOR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String AUTHOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTHOR =>
      _id_AUTHOR.get(_class, const jni.JStringType());

  static final _id_BITRATE = _class.staticFieldId(
    r'BITRATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BITRATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BITRATE =>
      _id_BITRATE.get(_class, const jni.JStringType());

  static final _id_BUCKET_DISPLAY_NAME = _class.staticFieldId(
    r'BUCKET_DISPLAY_NAME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BUCKET_DISPLAY_NAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BUCKET_DISPLAY_NAME =>
      _id_BUCKET_DISPLAY_NAME.get(_class, const jni.JStringType());

  static final _id_BUCKET_ID = _class.staticFieldId(
    r'BUCKET_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BUCKET_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BUCKET_ID =>
      _id_BUCKET_ID.get(_class, const jni.JStringType());

  static final _id_CAPTURE_FRAMERATE = _class.staticFieldId(
    r'CAPTURE_FRAMERATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CAPTURE_FRAMERATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CAPTURE_FRAMERATE =>
      _id_CAPTURE_FRAMERATE.get(_class, const jni.JStringType());

  static final _id_CD_TRACK_NUMBER = _class.staticFieldId(
    r'CD_TRACK_NUMBER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CD_TRACK_NUMBER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CD_TRACK_NUMBER =>
      _id_CD_TRACK_NUMBER.get(_class, const jni.JStringType());

  static final _id_COMPILATION = _class.staticFieldId(
    r'COMPILATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String COMPILATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get COMPILATION =>
      _id_COMPILATION.get(_class, const jni.JStringType());

  static final _id_COMPOSER = _class.staticFieldId(
    r'COMPOSER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String COMPOSER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get COMPOSER =>
      _id_COMPOSER.get(_class, const jni.JStringType());

  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATA => _id_DATA.get(_class, const jni.JStringType());

  static final _id_DATE_ADDED = _class.staticFieldId(
    r'DATE_ADDED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATE_ADDED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATE_ADDED =>
      _id_DATE_ADDED.get(_class, const jni.JStringType());

  static final _id_DATE_EXPIRES = _class.staticFieldId(
    r'DATE_EXPIRES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATE_EXPIRES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATE_EXPIRES =>
      _id_DATE_EXPIRES.get(_class, const jni.JStringType());

  static final _id_DATE_MODIFIED = _class.staticFieldId(
    r'DATE_MODIFIED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATE_MODIFIED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATE_MODIFIED =>
      _id_DATE_MODIFIED.get(_class, const jni.JStringType());

  static final _id_DATE_TAKEN = _class.staticFieldId(
    r'DATE_TAKEN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATE_TAKEN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATE_TAKEN =>
      _id_DATE_TAKEN.get(_class, const jni.JStringType());

  static final _id_DISC_NUMBER = _class.staticFieldId(
    r'DISC_NUMBER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DISC_NUMBER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DISC_NUMBER =>
      _id_DISC_NUMBER.get(_class, const jni.JStringType());

  static final _id_DISPLAY_NAME = _class.staticFieldId(
    r'DISPLAY_NAME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DISPLAY_NAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DISPLAY_NAME =>
      _id_DISPLAY_NAME.get(_class, const jni.JStringType());

  static final _id_DOCUMENT_ID = _class.staticFieldId(
    r'DOCUMENT_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DOCUMENT_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DOCUMENT_ID =>
      _id_DOCUMENT_ID.get(_class, const jni.JStringType());

  static final _id_DURATION = _class.staticFieldId(
    r'DURATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DURATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DURATION =>
      _id_DURATION.get(_class, const jni.JStringType());

  static final _id_GENERATION_ADDED = _class.staticFieldId(
    r'GENERATION_ADDED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GENERATION_ADDED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GENERATION_ADDED =>
      _id_GENERATION_ADDED.get(_class, const jni.JStringType());

  static final _id_GENERATION_MODIFIED = _class.staticFieldId(
    r'GENERATION_MODIFIED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GENERATION_MODIFIED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GENERATION_MODIFIED =>
      _id_GENERATION_MODIFIED.get(_class, const jni.JStringType());

  static final _id_GENRE = _class.staticFieldId(
    r'GENRE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String GENRE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get GENRE =>
      _id_GENRE.get(_class, const jni.JStringType());

  static final _id_HEIGHT = _class.staticFieldId(
    r'HEIGHT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String HEIGHT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HEIGHT =>
      _id_HEIGHT.get(_class, const jni.JStringType());

  static final _id_INSTANCE_ID = _class.staticFieldId(
    r'INSTANCE_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INSTANCE_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INSTANCE_ID =>
      _id_INSTANCE_ID.get(_class, const jni.JStringType());

  static final _id_IS_DOWNLOAD = _class.staticFieldId(
    r'IS_DOWNLOAD',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_DOWNLOAD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_DOWNLOAD =>
      _id_IS_DOWNLOAD.get(_class, const jni.JStringType());

  static final _id_IS_DRM = _class.staticFieldId(
    r'IS_DRM',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_DRM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_DRM =>
      _id_IS_DRM.get(_class, const jni.JStringType());

  static final _id_IS_FAVORITE = _class.staticFieldId(
    r'IS_FAVORITE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_FAVORITE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_FAVORITE =>
      _id_IS_FAVORITE.get(_class, const jni.JStringType());

  static final _id_IS_PENDING = _class.staticFieldId(
    r'IS_PENDING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_PENDING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_PENDING =>
      _id_IS_PENDING.get(_class, const jni.JStringType());

  static final _id_IS_TRASHED = _class.staticFieldId(
    r'IS_TRASHED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_TRASHED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_TRASHED =>
      _id_IS_TRASHED.get(_class, const jni.JStringType());

  static final _id_MIME_TYPE = _class.staticFieldId(
    r'MIME_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MIME_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MIME_TYPE =>
      _id_MIME_TYPE.get(_class, const jni.JStringType());

  static final _id_NUM_TRACKS = _class.staticFieldId(
    r'NUM_TRACKS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String NUM_TRACKS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get NUM_TRACKS =>
      _id_NUM_TRACKS.get(_class, const jni.JStringType());

  static final _id_ORIENTATION = _class.staticFieldId(
    r'ORIENTATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ORIENTATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ORIENTATION =>
      _id_ORIENTATION.get(_class, const jni.JStringType());

  static final _id_ORIGINAL_DOCUMENT_ID = _class.staticFieldId(
    r'ORIGINAL_DOCUMENT_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ORIGINAL_DOCUMENT_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ORIGINAL_DOCUMENT_ID =>
      _id_ORIGINAL_DOCUMENT_ID.get(_class, const jni.JStringType());

  static final _id_OWNER_PACKAGE_NAME = _class.staticFieldId(
    r'OWNER_PACKAGE_NAME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String OWNER_PACKAGE_NAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get OWNER_PACKAGE_NAME =>
      _id_OWNER_PACKAGE_NAME.get(_class, const jni.JStringType());

  static final _id_RELATIVE_PATH = _class.staticFieldId(
    r'RELATIVE_PATH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RELATIVE_PATH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RELATIVE_PATH =>
      _id_RELATIVE_PATH.get(_class, const jni.JStringType());

  static final _id_RESOLUTION = _class.staticFieldId(
    r'RESOLUTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String RESOLUTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RESOLUTION =>
      _id_RESOLUTION.get(_class, const jni.JStringType());

  static final _id_SIZE = _class.staticFieldId(
    r'SIZE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SIZE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SIZE => _id_SIZE.get(_class, const jni.JStringType());

  static final _id_TITLE = _class.staticFieldId(
    r'TITLE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TITLE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TITLE =>
      _id_TITLE.get(_class, const jni.JStringType());

  static final _id_VOLUME_NAME = _class.staticFieldId(
    r'VOLUME_NAME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VOLUME_NAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VOLUME_NAME =>
      _id_VOLUME_NAME.get(_class, const jni.JStringType());

  static final _id_WIDTH = _class.staticFieldId(
    r'WIDTH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WIDTH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WIDTH =>
      _id_WIDTH.get(_class, const jni.JStringType());

  static final _id_WRITER = _class.staticFieldId(
    r'WRITER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WRITER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WRITER =>
      _id_WRITER.get(_class, const jni.JStringType());

  static final _id_XMP = _class.staticFieldId(
    r'XMP',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String XMP
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get XMP => _id_XMP.get(_class, const jni.JStringType());

  static final _id_YEAR = _class.staticFieldId(
    r'YEAR',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String YEAR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get YEAR => _id_YEAR.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_MediaColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_MediaColumns.implement(
    $MediaStore_MediaColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_MediaColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$MediaColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_MediaColumnsImpl {
  factory $MediaStore_MediaColumnsImpl() = _$MediaStore_MediaColumnsImpl;
}

class _$MediaStore_MediaColumnsImpl implements $MediaStore_MediaColumnsImpl {
  _$MediaStore_MediaColumnsImpl();
}

final class $MediaStore_MediaColumnsType
    extends jni.JObjType<MediaStore_MediaColumns> {
  const $MediaStore_MediaColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$MediaColumns;';

  @override
  MediaStore_MediaColumns fromReference(jni.JReference reference) =>
      MediaStore_MediaColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_MediaColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_MediaColumnsType) &&
        other is $MediaStore_MediaColumnsType;
  }
}

/// from: android.provider.MediaStore$PickerMediaColumns
class MediaStore_PickerMediaColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_PickerMediaColumns> $type = type;

  MediaStore_PickerMediaColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$PickerMediaColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_PickerMediaColumnsType();
  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATA => _id_DATA.get(_class, const jni.JStringType());

  static final _id_DATE_TAKEN = _class.staticFieldId(
    r'DATE_TAKEN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATE_TAKEN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATE_TAKEN =>
      _id_DATE_TAKEN.get(_class, const jni.JStringType());

  static final _id_DISPLAY_NAME = _class.staticFieldId(
    r'DISPLAY_NAME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DISPLAY_NAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DISPLAY_NAME =>
      _id_DISPLAY_NAME.get(_class, const jni.JStringType());

  static final _id_DURATION_MILLIS = _class.staticFieldId(
    r'DURATION_MILLIS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DURATION_MILLIS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DURATION_MILLIS =>
      _id_DURATION_MILLIS.get(_class, const jni.JStringType());

  static final _id_HEIGHT = _class.staticFieldId(
    r'HEIGHT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String HEIGHT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HEIGHT =>
      _id_HEIGHT.get(_class, const jni.JStringType());

  static final _id_MIME_TYPE = _class.staticFieldId(
    r'MIME_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MIME_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MIME_TYPE =>
      _id_MIME_TYPE.get(_class, const jni.JStringType());

  static final _id_ORIENTATION = _class.staticFieldId(
    r'ORIENTATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ORIENTATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ORIENTATION =>
      _id_ORIENTATION.get(_class, const jni.JStringType());

  static final _id_SIZE = _class.staticFieldId(
    r'SIZE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String SIZE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SIZE => _id_SIZE.get(_class, const jni.JStringType());

  static final _id_WIDTH = _class.staticFieldId(
    r'WIDTH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WIDTH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WIDTH =>
      _id_WIDTH.get(_class, const jni.JStringType());
}

final class $MediaStore_PickerMediaColumnsType
    extends jni.JObjType<MediaStore_PickerMediaColumns> {
  const $MediaStore_PickerMediaColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$PickerMediaColumns;';

  @override
  MediaStore_PickerMediaColumns fromReference(jni.JReference reference) =>
      MediaStore_PickerMediaColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_PickerMediaColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_PickerMediaColumnsType) &&
        other is $MediaStore_PickerMediaColumnsType;
  }
}

/// from: android.provider.MediaStore$Video$Media
class MediaStore_Video_Media extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Video_Media> $type = type;

  MediaStore_Video_Media.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Video$Media');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Video_MediaType();
  static final _id_CONTENT_TYPE = _class.staticFieldId(
    r'CONTENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CONTENT_TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CONTENT_TYPE =>
      _id_CONTENT_TYPE.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Video_Media() {
    return MediaStore_Video_Media.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getContentUri1 = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;J)Landroid/net/Uri;',
  );

  static final _getContentUri1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri1(
    jni.JString string,
    int j,
  ) {
    return _getContentUri1(_class.reference.pointer,
            _id_getContentUri1 as jni.JMethodIDPtr, string.reference.pointer, j)
        .object(const $UriType());
  }
}

final class $MediaStore_Video_MediaType
    extends jni.JObjType<MediaStore_Video_Media> {
  const $MediaStore_Video_MediaType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Video$Media;';

  @override
  MediaStore_Video_Media fromReference(jni.JReference reference) =>
      MediaStore_Video_Media.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Video_MediaType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Video_MediaType) &&
        other is $MediaStore_Video_MediaType;
  }
}

/// from: android.provider.MediaStore$Video$Thumbnails
class MediaStore_Video_Thumbnails extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Video_Thumbnails> $type = type;

  MediaStore_Video_Thumbnails.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Video$Thumbnails');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Video_ThumbnailsType();
  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DATA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DATA => _id_DATA.get(_class, const jni.JStringType());

  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_EXTERNAL_CONTENT_URI = _class.staticFieldId(
    r'EXTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri EXTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EXTERNAL_CONTENT_URI =>
      _id_EXTERNAL_CONTENT_URI.get(_class, const $UriType());

  /// from: static public final int FULL_SCREEN_KIND
  static const FULL_SCREEN_KIND = 2;
  static final _id_HEIGHT = _class.staticFieldId(
    r'HEIGHT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String HEIGHT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HEIGHT =>
      _id_HEIGHT.get(_class, const jni.JStringType());

  static final _id_INTERNAL_CONTENT_URI = _class.staticFieldId(
    r'INTERNAL_CONTENT_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri INTERNAL_CONTENT_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get INTERNAL_CONTENT_URI =>
      _id_INTERNAL_CONTENT_URI.get(_class, const $UriType());

  static final _id_KIND = _class.staticFieldId(
    r'KIND',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String KIND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get KIND => _id_KIND.get(_class, const jni.JStringType());

  /// from: static public final int MICRO_KIND
  static const MICRO_KIND = 3;

  /// from: static public final int MINI_KIND
  static const MINI_KIND = 1;
  static final _id_VIDEO_ID = _class.staticFieldId(
    r'VIDEO_ID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VIDEO_ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VIDEO_ID =>
      _id_VIDEO_ID.get(_class, const jni.JStringType());

  static final _id_WIDTH = _class.staticFieldId(
    r'WIDTH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String WIDTH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get WIDTH =>
      _id_WIDTH.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Video_Thumbnails() {
    return MediaStore_Video_Thumbnails.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_cancelThumbnailRequest = _class.staticMethodId(
    r'cancelThumbnailRequest',
    r'(Landroid/content/ContentResolver;J)V',
  );

  static final _cancelThumbnailRequest = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void cancelThumbnailRequest(android.content.ContentResolver contentResolver, long j)
  static void cancelThumbnailRequest(
    ContentResolver contentResolver,
    int j,
  ) {
    _cancelThumbnailRequest(
            _class.reference.pointer,
            _id_cancelThumbnailRequest as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j)
        .check();
  }

  static final _id_getThumbnail = _class.staticMethodId(
    r'getThumbnail',
    r'(Landroid/content/ContentResolver;JILandroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _getThumbnail = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap getThumbnail(android.content.ContentResolver contentResolver, long j, int i, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getThumbnail(
    ContentResolver contentResolver,
    int j,
    int i,
    jni.JObject options,
  ) {
    return _getThumbnail(
            _class.reference.pointer,
            _id_getThumbnail as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j,
            i,
            options.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_cancelThumbnailRequest1 = _class.staticMethodId(
    r'cancelThumbnailRequest',
    r'(Landroid/content/ContentResolver;JJ)V',
  );

  static final _cancelThumbnailRequest1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public void cancelThumbnailRequest(android.content.ContentResolver contentResolver, long j, long j1)
  static void cancelThumbnailRequest1(
    ContentResolver contentResolver,
    int j,
    int j1,
  ) {
    _cancelThumbnailRequest1(
            _class.reference.pointer,
            _id_cancelThumbnailRequest1 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j,
            j1)
        .check();
  }

  static final _id_getThumbnail1 = _class.staticMethodId(
    r'getThumbnail',
    r'(Landroid/content/ContentResolver;JJILandroid/graphics/BitmapFactory$Options;)Landroid/graphics/Bitmap;',
  );

  static final _getThumbnail1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap getThumbnail(android.content.ContentResolver contentResolver, long j, long j1, int i, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getThumbnail1(
    ContentResolver contentResolver,
    int j,
    int j1,
    int i,
    jni.JObject options,
  ) {
    return _getThumbnail1(
            _class.reference.pointer,
            _id_getThumbnail1 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            j,
            j1,
            i,
            options.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getContentUri = _class.staticMethodId(
    r'getContentUri',
    r'(Ljava/lang/String;)Landroid/net/Uri;',
  );

  static final _getContentUri = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getContentUri(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getContentUri(
    jni.JString string,
  ) {
    return _getContentUri(_class.reference.pointer,
            _id_getContentUri as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getKindSize = _class.staticMethodId(
    r'getKindSize',
    r'(I)Landroid/util/Size;',
  );

  static final _getKindSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public android.util.Size getKindSize(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static Size getKindSize(
    int i,
  ) {
    return _getKindSize(
            _class.reference.pointer, _id_getKindSize as jni.JMethodIDPtr, i)
        .object(const $SizeType());
  }
}

final class $MediaStore_Video_ThumbnailsType
    extends jni.JObjType<MediaStore_Video_Thumbnails> {
  const $MediaStore_Video_ThumbnailsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Video$Thumbnails;';

  @override
  MediaStore_Video_Thumbnails fromReference(jni.JReference reference) =>
      MediaStore_Video_Thumbnails.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Video_ThumbnailsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Video_ThumbnailsType) &&
        other is $MediaStore_Video_ThumbnailsType;
  }
}

/// from: android.provider.MediaStore$Video$VideoColumns
class MediaStore_Video_VideoColumns extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Video_VideoColumns> $type = type;

  MediaStore_Video_VideoColumns.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Video$VideoColumns');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_Video_VideoColumnsType();
  static final _id_BOOKMARK = _class.staticFieldId(
    r'BOOKMARK',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String BOOKMARK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BOOKMARK =>
      _id_BOOKMARK.get(_class, const jni.JStringType());

  static final _id_CATEGORY = _class.staticFieldId(
    r'CATEGORY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String CATEGORY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CATEGORY =>
      _id_CATEGORY.get(_class, const jni.JStringType());

  static final _id_COLOR_RANGE = _class.staticFieldId(
    r'COLOR_RANGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String COLOR_RANGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get COLOR_RANGE =>
      _id_COLOR_RANGE.get(_class, const jni.JStringType());

  static final _id_COLOR_STANDARD = _class.staticFieldId(
    r'COLOR_STANDARD',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String COLOR_STANDARD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get COLOR_STANDARD =>
      _id_COLOR_STANDARD.get(_class, const jni.JStringType());

  static final _id_COLOR_TRANSFER = _class.staticFieldId(
    r'COLOR_TRANSFER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String COLOR_TRANSFER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get COLOR_TRANSFER =>
      _id_COLOR_TRANSFER.get(_class, const jni.JStringType());

  static final _id_DESCRIPTION = _class.staticFieldId(
    r'DESCRIPTION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DESCRIPTION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DESCRIPTION =>
      _id_DESCRIPTION.get(_class, const jni.JStringType());

  static final _id_IS_PRIVATE = _class.staticFieldId(
    r'IS_PRIVATE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String IS_PRIVATE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get IS_PRIVATE =>
      _id_IS_PRIVATE.get(_class, const jni.JStringType());

  static final _id_LANGUAGE = _class.staticFieldId(
    r'LANGUAGE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LANGUAGE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LANGUAGE =>
      _id_LANGUAGE.get(_class, const jni.JStringType());

  static final _id_LATITUDE = _class.staticFieldId(
    r'LATITUDE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LATITUDE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LATITUDE =>
      _id_LATITUDE.get(_class, const jni.JStringType());

  static final _id_LONGITUDE = _class.staticFieldId(
    r'LONGITUDE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String LONGITUDE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get LONGITUDE =>
      _id_LONGITUDE.get(_class, const jni.JStringType());

  static final _id_MINI_THUMB_MAGIC = _class.staticFieldId(
    r'MINI_THUMB_MAGIC',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MINI_THUMB_MAGIC
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MINI_THUMB_MAGIC =>
      _id_MINI_THUMB_MAGIC.get(_class, const jni.JStringType());

  static final _id_TAGS = _class.staticFieldId(
    r'TAGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String TAGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TAGS => _id_TAGS.get(_class, const jni.JStringType());

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MediaStore_Video_VideoColumnsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MediaStore_Video_VideoColumns.implement(
    $MediaStore_Video_VideoColumnsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MediaStore_Video_VideoColumns.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'android.provider.MediaStore$Video$VideoColumns',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MediaStore_Video_VideoColumnsImpl {
  factory $MediaStore_Video_VideoColumnsImpl() =
      _$MediaStore_Video_VideoColumnsImpl;
}

class _$MediaStore_Video_VideoColumnsImpl
    implements $MediaStore_Video_VideoColumnsImpl {
  _$MediaStore_Video_VideoColumnsImpl();
}

final class $MediaStore_Video_VideoColumnsType
    extends jni.JObjType<MediaStore_Video_VideoColumns> {
  const $MediaStore_Video_VideoColumnsType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Video$VideoColumns;';

  @override
  MediaStore_Video_VideoColumns fromReference(jni.JReference reference) =>
      MediaStore_Video_VideoColumns.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_Video_VideoColumnsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_Video_VideoColumnsType) &&
        other is $MediaStore_Video_VideoColumnsType;
  }
}

/// from: android.provider.MediaStore$Video
class MediaStore_Video extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore_Video> $type = type;

  MediaStore_Video.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/provider/MediaStore$Video');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStore_VideoType();
  static final _id_DEFAULT_SORT_ORDER = _class.staticFieldId(
    r'DEFAULT_SORT_ORDER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String DEFAULT_SORT_ORDER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEFAULT_SORT_ORDER =>
      _id_DEFAULT_SORT_ORDER.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore_Video() {
    return MediaStore_Video.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_query = _class.staticMethodId(
    r'query',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;[Ljava/lang/String;)Landroid/database/Cursor;',
  );

  static final _query = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.database.Cursor query(android.content.ContentResolver contentResolver, android.net.Uri uri, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  static Cursor query(
    ContentResolver contentResolver,
    Uri uri,
    jni.JArray<jni.JString> strings,
  ) {
    return _query(
            _class.reference.pointer,
            _id_query as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer,
            strings.reference.pointer)
        .object(const $CursorType());
  }
}

final class $MediaStore_VideoType extends jni.JObjType<MediaStore_Video> {
  const $MediaStore_VideoType();

  @override
  String get signature => r'Landroid/provider/MediaStore$Video;';

  @override
  MediaStore_Video fromReference(jni.JReference reference) =>
      MediaStore_Video.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStore_VideoType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStore_VideoType) &&
        other is $MediaStore_VideoType;
  }
}

/// from: android.provider.MediaStore
class MediaStore extends jni.JObject {
  @override
  late final jni.JObjType<MediaStore> $type = type;

  MediaStore.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/provider/MediaStore');

  /// The type which includes information such as the signature of this class.
  static const type = $MediaStoreType();
  static final _id_ACTION_IMAGE_CAPTURE = _class.staticFieldId(
    r'ACTION_IMAGE_CAPTURE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTION_IMAGE_CAPTURE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTION_IMAGE_CAPTURE =>
      _id_ACTION_IMAGE_CAPTURE.get(_class, const jni.JStringType());

  static final _id_ACTION_IMAGE_CAPTURE_SECURE = _class.staticFieldId(
    r'ACTION_IMAGE_CAPTURE_SECURE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTION_IMAGE_CAPTURE_SECURE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTION_IMAGE_CAPTURE_SECURE =>
      _id_ACTION_IMAGE_CAPTURE_SECURE.get(_class, const jni.JStringType());

  static final _id_ACTION_PICK_IMAGES = _class.staticFieldId(
    r'ACTION_PICK_IMAGES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTION_PICK_IMAGES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTION_PICK_IMAGES =>
      _id_ACTION_PICK_IMAGES.get(_class, const jni.JStringType());

  static final _id_ACTION_PICK_IMAGES_SETTINGS = _class.staticFieldId(
    r'ACTION_PICK_IMAGES_SETTINGS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTION_PICK_IMAGES_SETTINGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTION_PICK_IMAGES_SETTINGS =>
      _id_ACTION_PICK_IMAGES_SETTINGS.get(_class, const jni.JStringType());

  static final _id_ACTION_REVIEW = _class.staticFieldId(
    r'ACTION_REVIEW',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTION_REVIEW
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTION_REVIEW =>
      _id_ACTION_REVIEW.get(_class, const jni.JStringType());

  static final _id_ACTION_REVIEW_SECURE = _class.staticFieldId(
    r'ACTION_REVIEW_SECURE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTION_REVIEW_SECURE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTION_REVIEW_SECURE =>
      _id_ACTION_REVIEW_SECURE.get(_class, const jni.JStringType());

  static final _id_ACTION_VIDEO_CAPTURE = _class.staticFieldId(
    r'ACTION_VIDEO_CAPTURE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String ACTION_VIDEO_CAPTURE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ACTION_VIDEO_CAPTURE =>
      _id_ACTION_VIDEO_CAPTURE.get(_class, const jni.JStringType());

  static final _id_AUTHORITY = _class.staticFieldId(
    r'AUTHORITY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String AUTHORITY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get AUTHORITY =>
      _id_AUTHORITY.get(_class, const jni.JStringType());

  static final _id_AUTHORITY_URI = _class.staticFieldId(
    r'AUTHORITY_URI',
    r'Landroid/net/Uri;',
  );

  /// from: static public final android.net.Uri AUTHORITY_URI
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get AUTHORITY_URI =>
      _id_AUTHORITY_URI.get(_class, const $UriType());

  static final _id_EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT = _class.staticFieldId(
    r'EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT =>
      _id_EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT.get(
          _class, const jni.JStringType());

  static final _id_EXTRA_BRIGHTNESS = _class.staticFieldId(
    r'EXTRA_BRIGHTNESS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_BRIGHTNESS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_BRIGHTNESS =>
      _id_EXTRA_BRIGHTNESS.get(_class, const jni.JStringType());

  static final _id_EXTRA_DURATION_LIMIT = _class.staticFieldId(
    r'EXTRA_DURATION_LIMIT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_DURATION_LIMIT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_DURATION_LIMIT =>
      _id_EXTRA_DURATION_LIMIT.get(_class, const jni.JStringType());

  static final _id_EXTRA_FINISH_ON_COMPLETION = _class.staticFieldId(
    r'EXTRA_FINISH_ON_COMPLETION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_FINISH_ON_COMPLETION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_FINISH_ON_COMPLETION =>
      _id_EXTRA_FINISH_ON_COMPLETION.get(_class, const jni.JStringType());

  static final _id_EXTRA_FULL_SCREEN = _class.staticFieldId(
    r'EXTRA_FULL_SCREEN',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_FULL_SCREEN
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_FULL_SCREEN =>
      _id_EXTRA_FULL_SCREEN.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_ALBUM = _class.staticFieldId(
    r'EXTRA_MEDIA_ALBUM',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_ALBUM
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_ALBUM =>
      _id_EXTRA_MEDIA_ALBUM.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_ARTIST = _class.staticFieldId(
    r'EXTRA_MEDIA_ARTIST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_ARTIST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_ARTIST =>
      _id_EXTRA_MEDIA_ARTIST.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_CAPABILITIES = _class.staticFieldId(
    r'EXTRA_MEDIA_CAPABILITIES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_CAPABILITIES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_CAPABILITIES =>
      _id_EXTRA_MEDIA_CAPABILITIES.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_CAPABILITIES_UID = _class.staticFieldId(
    r'EXTRA_MEDIA_CAPABILITIES_UID',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_CAPABILITIES_UID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_CAPABILITIES_UID =>
      _id_EXTRA_MEDIA_CAPABILITIES_UID.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_FOCUS = _class.staticFieldId(
    r'EXTRA_MEDIA_FOCUS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_FOCUS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_FOCUS =>
      _id_EXTRA_MEDIA_FOCUS.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_GENRE = _class.staticFieldId(
    r'EXTRA_MEDIA_GENRE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_GENRE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_GENRE =>
      _id_EXTRA_MEDIA_GENRE.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_PLAYLIST = _class.staticFieldId(
    r'EXTRA_MEDIA_PLAYLIST',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_PLAYLIST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_PLAYLIST =>
      _id_EXTRA_MEDIA_PLAYLIST.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_RADIO_CHANNEL = _class.staticFieldId(
    r'EXTRA_MEDIA_RADIO_CHANNEL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_RADIO_CHANNEL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_RADIO_CHANNEL =>
      _id_EXTRA_MEDIA_RADIO_CHANNEL.get(_class, const jni.JStringType());

  static final _id_EXTRA_MEDIA_TITLE = _class.staticFieldId(
    r'EXTRA_MEDIA_TITLE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_MEDIA_TITLE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_MEDIA_TITLE =>
      _id_EXTRA_MEDIA_TITLE.get(_class, const jni.JStringType());

  static final _id_EXTRA_OUTPUT = _class.staticFieldId(
    r'EXTRA_OUTPUT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_OUTPUT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_OUTPUT =>
      _id_EXTRA_OUTPUT.get(_class, const jni.JStringType());

  static final _id_EXTRA_PICK_IMAGES_MAX = _class.staticFieldId(
    r'EXTRA_PICK_IMAGES_MAX',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_PICK_IMAGES_MAX
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_PICK_IMAGES_MAX =>
      _id_EXTRA_PICK_IMAGES_MAX.get(_class, const jni.JStringType());

  static final _id_EXTRA_SCREEN_ORIENTATION = _class.staticFieldId(
    r'EXTRA_SCREEN_ORIENTATION',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_SCREEN_ORIENTATION
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_SCREEN_ORIENTATION =>
      _id_EXTRA_SCREEN_ORIENTATION.get(_class, const jni.JStringType());

  static final _id_EXTRA_SHOW_ACTION_ICONS = _class.staticFieldId(
    r'EXTRA_SHOW_ACTION_ICONS',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_SHOW_ACTION_ICONS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_SHOW_ACTION_ICONS =>
      _id_EXTRA_SHOW_ACTION_ICONS.get(_class, const jni.JStringType());

  static final _id_EXTRA_SIZE_LIMIT = _class.staticFieldId(
    r'EXTRA_SIZE_LIMIT',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_SIZE_LIMIT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_SIZE_LIMIT =>
      _id_EXTRA_SIZE_LIMIT.get(_class, const jni.JStringType());

  static final _id_EXTRA_VIDEO_QUALITY = _class.staticFieldId(
    r'EXTRA_VIDEO_QUALITY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String EXTRA_VIDEO_QUALITY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EXTRA_VIDEO_QUALITY =>
      _id_EXTRA_VIDEO_QUALITY.get(_class, const jni.JStringType());

  static final _id_INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH = _class.staticFieldId(
    r'INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH =>
      _id_INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH.get(
          _class, const jni.JStringType());

  static final _id_INTENT_ACTION_MEDIA_SEARCH = _class.staticFieldId(
    r'INTENT_ACTION_MEDIA_SEARCH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTENT_ACTION_MEDIA_SEARCH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTENT_ACTION_MEDIA_SEARCH =>
      _id_INTENT_ACTION_MEDIA_SEARCH.get(_class, const jni.JStringType());

  static final _id_INTENT_ACTION_MUSIC_PLAYER = _class.staticFieldId(
    r'INTENT_ACTION_MUSIC_PLAYER',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTENT_ACTION_MUSIC_PLAYER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTENT_ACTION_MUSIC_PLAYER =>
      _id_INTENT_ACTION_MUSIC_PLAYER.get(_class, const jni.JStringType());

  static final _id_INTENT_ACTION_STILL_IMAGE_CAMERA = _class.staticFieldId(
    r'INTENT_ACTION_STILL_IMAGE_CAMERA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTENT_ACTION_STILL_IMAGE_CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTENT_ACTION_STILL_IMAGE_CAMERA =>
      _id_INTENT_ACTION_STILL_IMAGE_CAMERA.get(_class, const jni.JStringType());

  static final _id_INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE =
      _class.staticFieldId(
    r'INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE =>
      _id_INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.get(
          _class, const jni.JStringType());

  static final _id_INTENT_ACTION_TEXT_OPEN_FROM_SEARCH = _class.staticFieldId(
    r'INTENT_ACTION_TEXT_OPEN_FROM_SEARCH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTENT_ACTION_TEXT_OPEN_FROM_SEARCH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTENT_ACTION_TEXT_OPEN_FROM_SEARCH =>
      _id_INTENT_ACTION_TEXT_OPEN_FROM_SEARCH.get(
          _class, const jni.JStringType());

  static final _id_INTENT_ACTION_VIDEO_CAMERA = _class.staticFieldId(
    r'INTENT_ACTION_VIDEO_CAMERA',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTENT_ACTION_VIDEO_CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTENT_ACTION_VIDEO_CAMERA =>
      _id_INTENT_ACTION_VIDEO_CAMERA.get(_class, const jni.JStringType());

  static final _id_INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH = _class.staticFieldId(
    r'INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH =>
      _id_INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH.get(
          _class, const jni.JStringType());

  /// from: static public final int MATCH_DEFAULT
  static const MATCH_DEFAULT = 0;

  /// from: static public final int MATCH_EXCLUDE
  static const MATCH_EXCLUDE = 2;

  /// from: static public final int MATCH_INCLUDE
  static const MATCH_INCLUDE = 1;

  /// from: static public final int MATCH_ONLY
  static const MATCH_ONLY = 3;
  static final _id_MEDIA_IGNORE_FILENAME = _class.staticFieldId(
    r'MEDIA_IGNORE_FILENAME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_IGNORE_FILENAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_IGNORE_FILENAME =>
      _id_MEDIA_IGNORE_FILENAME.get(_class, const jni.JStringType());

  static final _id_MEDIA_SCANNER_VOLUME = _class.staticFieldId(
    r'MEDIA_SCANNER_VOLUME',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String MEDIA_SCANNER_VOLUME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MEDIA_SCANNER_VOLUME =>
      _id_MEDIA_SCANNER_VOLUME.get(_class, const jni.JStringType());

  static final _id_META_DATA_REVIEW_GALLERY_PREWARM_SERVICE =
      _class.staticFieldId(
    r'META_DATA_REVIEW_GALLERY_PREWARM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String META_DATA_REVIEW_GALLERY_PREWARM_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get META_DATA_REVIEW_GALLERY_PREWARM_SERVICE =>
      _id_META_DATA_REVIEW_GALLERY_PREWARM_SERVICE.get(
          _class, const jni.JStringType());

  static final _id_META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE =
      _class.staticFieldId(
    r'META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE =>
      _id_META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE.get(
          _class, const jni.JStringType());

  static final _id_QUERY_ARG_INCLUDE_RECENTLY_UNMOUNTED_VOLUMES =
      _class.staticFieldId(
    r'QUERY_ARG_INCLUDE_RECENTLY_UNMOUNTED_VOLUMES',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_INCLUDE_RECENTLY_UNMOUNTED_VOLUMES
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_INCLUDE_RECENTLY_UNMOUNTED_VOLUMES =>
      _id_QUERY_ARG_INCLUDE_RECENTLY_UNMOUNTED_VOLUMES.get(
          _class, const jni.JStringType());

  static final _id_QUERY_ARG_MATCH_FAVORITE = _class.staticFieldId(
    r'QUERY_ARG_MATCH_FAVORITE',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_MATCH_FAVORITE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_MATCH_FAVORITE =>
      _id_QUERY_ARG_MATCH_FAVORITE.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_MATCH_PENDING = _class.staticFieldId(
    r'QUERY_ARG_MATCH_PENDING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_MATCH_PENDING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_MATCH_PENDING =>
      _id_QUERY_ARG_MATCH_PENDING.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_MATCH_TRASHED = _class.staticFieldId(
    r'QUERY_ARG_MATCH_TRASHED',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_MATCH_TRASHED
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_MATCH_TRASHED =>
      _id_QUERY_ARG_MATCH_TRASHED.get(_class, const jni.JStringType());

  static final _id_QUERY_ARG_RELATED_URI = _class.staticFieldId(
    r'QUERY_ARG_RELATED_URI',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String QUERY_ARG_RELATED_URI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ARG_RELATED_URI =>
      _id_QUERY_ARG_RELATED_URI.get(_class, const jni.JStringType());

  static final _id_UNKNOWN_STRING = _class.staticFieldId(
    r'UNKNOWN_STRING',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String UNKNOWN_STRING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get UNKNOWN_STRING =>
      _id_UNKNOWN_STRING.get(_class, const jni.JStringType());

  static final _id_VOLUME_EXTERNAL = _class.staticFieldId(
    r'VOLUME_EXTERNAL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VOLUME_EXTERNAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VOLUME_EXTERNAL =>
      _id_VOLUME_EXTERNAL.get(_class, const jni.JStringType());

  static final _id_VOLUME_EXTERNAL_PRIMARY = _class.staticFieldId(
    r'VOLUME_EXTERNAL_PRIMARY',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VOLUME_EXTERNAL_PRIMARY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VOLUME_EXTERNAL_PRIMARY =>
      _id_VOLUME_EXTERNAL_PRIMARY.get(_class, const jni.JStringType());

  static final _id_VOLUME_INTERNAL = _class.staticFieldId(
    r'VOLUME_INTERNAL',
    r'Ljava/lang/String;',
  );

  /// from: static public final java.lang.String VOLUME_INTERNAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get VOLUME_INTERNAL =>
      _id_VOLUME_INTERNAL.get(_class, const jni.JStringType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MediaStore() {
    return MediaStore.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getPickImagesMaxLimit = _class.staticMethodId(
    r'getPickImagesMaxLimit',
    r'()I',
  );

  static final _getPickImagesMaxLimit = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public int getPickImagesMaxLimit()
  static int getPickImagesMaxLimit() {
    return _getPickImagesMaxLimit(_class.reference.pointer,
            _id_getPickImagesMaxLimit as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setIncludePending = _class.staticMethodId(
    r'setIncludePending',
    r'(Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _setIncludePending = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri setIncludePending(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri setIncludePending(
    Uri uri,
  ) {
    return _setIncludePending(_class.reference.pointer,
            _id_setIncludePending as jni.JMethodIDPtr, uri.reference.pointer)
        .object(const $UriType());
  }

  static final _id_setRequireOriginal = _class.staticMethodId(
    r'setRequireOriginal',
    r'(Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _setRequireOriginal = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri setRequireOriginal(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri setRequireOriginal(
    Uri uri,
  ) {
    return _setRequireOriginal(_class.reference.pointer,
            _id_setRequireOriginal as jni.JMethodIDPtr, uri.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getRequireOriginal = _class.staticMethodId(
    r'getRequireOriginal',
    r'(Landroid/net/Uri;)Z',
  );

  static final _getRequireOriginal = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean getRequireOriginal(android.net.Uri uri)
  static bool getRequireOriginal(
    Uri uri,
  ) {
    return _getRequireOriginal(_class.reference.pointer,
            _id_getRequireOriginal as jni.JMethodIDPtr, uri.reference.pointer)
        .boolean;
  }

  static final _id_getOriginalMediaFormatFileDescriptor = _class.staticMethodId(
    r'getOriginalMediaFormatFileDescriptor',
    r'(Landroid/content/Context;Landroid/os/ParcelFileDescriptor;)Landroid/os/ParcelFileDescriptor;',
  );

  static final _getOriginalMediaFormatFileDescriptor =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<
                          (
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>
                          )>)>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.ParcelFileDescriptor getOriginalMediaFormatFileDescriptor(android.content.Context context, android.os.ParcelFileDescriptor parcelFileDescriptor)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getOriginalMediaFormatFileDescriptor(
    Context context,
    jni.JObject parcelFileDescriptor,
  ) {
    return _getOriginalMediaFormatFileDescriptor(
            _class.reference.pointer,
            _id_getOriginalMediaFormatFileDescriptor as jni.JMethodIDPtr,
            context.reference.pointer,
            parcelFileDescriptor.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_createWriteRequest = _class.staticMethodId(
    r'createWriteRequest',
    r'(Landroid/content/ContentResolver;Ljava/util/Collection;)Landroid/app/PendingIntent;',
  );

  static final _createWriteRequest = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.PendingIntent createWriteRequest(android.content.ContentResolver contentResolver, java.util.Collection collection)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject createWriteRequest(
    ContentResolver contentResolver,
    jni.JObject collection,
  ) {
    return _createWriteRequest(
            _class.reference.pointer,
            _id_createWriteRequest as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            collection.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_createTrashRequest = _class.staticMethodId(
    r'createTrashRequest',
    r'(Landroid/content/ContentResolver;Ljava/util/Collection;Z)Landroid/app/PendingIntent;',
  );

  static final _createTrashRequest = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent createTrashRequest(android.content.ContentResolver contentResolver, java.util.Collection collection, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject createTrashRequest(
    ContentResolver contentResolver,
    jni.JObject collection,
    bool z,
  ) {
    return _createTrashRequest(
            _class.reference.pointer,
            _id_createTrashRequest as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            collection.reference.pointer,
            z ? 1 : 0)
        .object(const jni.JObjectType());
  }

  static final _id_createFavoriteRequest = _class.staticMethodId(
    r'createFavoriteRequest',
    r'(Landroid/content/ContentResolver;Ljava/util/Collection;Z)Landroid/app/PendingIntent;',
  );

  static final _createFavoriteRequest = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent createFavoriteRequest(android.content.ContentResolver contentResolver, java.util.Collection collection, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject createFavoriteRequest(
    ContentResolver contentResolver,
    jni.JObject collection,
    bool z,
  ) {
    return _createFavoriteRequest(
            _class.reference.pointer,
            _id_createFavoriteRequest as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            collection.reference.pointer,
            z ? 1 : 0)
        .object(const jni.JObjectType());
  }

  static final _id_createDeleteRequest = _class.staticMethodId(
    r'createDeleteRequest',
    r'(Landroid/content/ContentResolver;Ljava/util/Collection;)Landroid/app/PendingIntent;',
  );

  static final _createDeleteRequest = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.PendingIntent createDeleteRequest(android.content.ContentResolver contentResolver, java.util.Collection collection)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject createDeleteRequest(
    ContentResolver contentResolver,
    jni.JObject collection,
  ) {
    return _createDeleteRequest(
            _class.reference.pointer,
            _id_createDeleteRequest as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            collection.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getExternalVolumeNames = _class.staticMethodId(
    r'getExternalVolumeNames',
    r'(Landroid/content/Context;)Ljava/util/Set;',
  );

  static final _getExternalVolumeNames = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.Set getExternalVolumeNames(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JSet<jni.JString> getExternalVolumeNames(
    Context context,
  ) {
    return _getExternalVolumeNames(
            _class.reference.pointer,
            _id_getExternalVolumeNames as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JSetType(jni.JStringType()));
  }

  static final _id_getRecentExternalVolumeNames = _class.staticMethodId(
    r'getRecentExternalVolumeNames',
    r'(Landroid/content/Context;)Ljava/util/Set;',
  );

  static final _getRecentExternalVolumeNames = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.Set getRecentExternalVolumeNames(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JSet<jni.JString> getRecentExternalVolumeNames(
    Context context,
  ) {
    return _getRecentExternalVolumeNames(
            _class.reference.pointer,
            _id_getRecentExternalVolumeNames as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JSetType(jni.JStringType()));
  }

  static final _id_getVolumeName = _class.staticMethodId(
    r'getVolumeName',
    r'(Landroid/net/Uri;)Ljava/lang/String;',
  );

  static final _getVolumeName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getVolumeName(android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getVolumeName(
    Uri uri,
  ) {
    return _getVolumeName(_class.reference.pointer,
            _id_getVolumeName as jni.JMethodIDPtr, uri.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getMediaScannerUri = _class.staticMethodId(
    r'getMediaScannerUri',
    r'()Landroid/net/Uri;',
  );

  static final _getMediaScannerUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public android.net.Uri getMediaScannerUri()
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getMediaScannerUri() {
    return _getMediaScannerUri(_class.reference.pointer,
            _id_getMediaScannerUri as jni.JMethodIDPtr)
        .object(const $UriType());
  }

  static final _id_getVersion = _class.staticMethodId(
    r'getVersion',
    r'(Landroid/content/Context;)Ljava/lang/String;',
  );

  static final _getVersion = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getVersion(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getVersion(
    Context context,
  ) {
    return _getVersion(_class.reference.pointer,
            _id_getVersion as jni.JMethodIDPtr, context.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getVersion1 = _class.staticMethodId(
    r'getVersion',
    r'(Landroid/content/Context;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getVersion1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getVersion(android.content.Context context, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getVersion1(
    Context context,
    jni.JString string,
  ) {
    return _getVersion1(
            _class.reference.pointer,
            _id_getVersion1 as jni.JMethodIDPtr,
            context.reference.pointer,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getGeneration = _class.staticMethodId(
    r'getGeneration',
    r'(Landroid/content/Context;Ljava/lang/String;)J',
  );

  static final _getGeneration = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticLongMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public long getGeneration(android.content.Context context, java.lang.String string)
  static int getGeneration(
    Context context,
    jni.JString string,
  ) {
    return _getGeneration(
            _class.reference.pointer,
            _id_getGeneration as jni.JMethodIDPtr,
            context.reference.pointer,
            string.reference.pointer)
        .long;
  }

  static final _id_getDocumentUri = _class.staticMethodId(
    r'getDocumentUri',
    r'(Landroid/content/Context;Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _getDocumentUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getDocumentUri(android.content.Context context, android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getDocumentUri(
    Context context,
    Uri uri,
  ) {
    return _getDocumentUri(
            _class.reference.pointer,
            _id_getDocumentUri as jni.JMethodIDPtr,
            context.reference.pointer,
            uri.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getMediaUri = _class.staticMethodId(
    r'getMediaUri',
    r'(Landroid/content/Context;Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _getMediaUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getMediaUri(android.content.Context context, android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getMediaUri(
    Context context,
    Uri uri,
  ) {
    return _getMediaUri(
            _class.reference.pointer,
            _id_getMediaUri as jni.JMethodIDPtr,
            context.reference.pointer,
            uri.reference.pointer)
        .object(const $UriType());
  }

  static final _id_isCurrentSystemGallery = _class.staticMethodId(
    r'isCurrentSystemGallery',
    r'(Landroid/content/ContentResolver;ILjava/lang/String;)Z',
  );

  static final _isCurrentSystemGallery = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isCurrentSystemGallery(android.content.ContentResolver contentResolver, int i, java.lang.String string)
  static bool isCurrentSystemGallery(
    ContentResolver contentResolver,
    int i,
    jni.JString string,
  ) {
    return _isCurrentSystemGallery(
            _class.reference.pointer,
            _id_isCurrentSystemGallery as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            i,
            string.reference.pointer)
        .boolean;
  }

  static final _id_getRedactedUri = _class.staticMethodId(
    r'getRedactedUri',
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/net/Uri;',
  );

  static final _getRedactedUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri getRedactedUri(android.content.ContentResolver contentResolver, android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri getRedactedUri(
    ContentResolver contentResolver,
    Uri uri,
  ) {
    return _getRedactedUri(
            _class.reference.pointer,
            _id_getRedactedUri as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer)
        .object(const $UriType());
  }

  static final _id_getRedactedUri1 = _class.staticMethodId(
    r'getRedactedUri',
    r'(Landroid/content/ContentResolver;Ljava/util/List;)Ljava/util/List;',
  );

  static final _getRedactedUri1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.List getRedactedUri(android.content.ContentResolver contentResolver, java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JList<Uri> getRedactedUri1(
    ContentResolver contentResolver,
    jni.JList<Uri> list,
  ) {
    return _getRedactedUri1(
            _class.reference.pointer,
            _id_getRedactedUri1 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            list.reference.pointer)
        .object(const jni.JListType($UriType()));
  }

  static final _id_canManageMedia = _class.staticMethodId(
    r'canManageMedia',
    r'(Landroid/content/Context;)Z',
  );

  static final _canManageMedia = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean canManageMedia(android.content.Context context)
  static bool canManageMedia(
    Context context,
  ) {
    return _canManageMedia(_class.reference.pointer,
            _id_canManageMedia as jni.JMethodIDPtr, context.reference.pointer)
        .boolean;
  }

  static final _id_isCurrentCloudMediaProviderAuthority = _class.staticMethodId(
    r'isCurrentCloudMediaProviderAuthority',
    r'(Landroid/content/ContentResolver;Ljava/lang/String;)Z',
  );

  static final _isCurrentCloudMediaProviderAuthority =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<
                          (
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>
                          )>)>>('globalEnv_CallStaticBooleanMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isCurrentCloudMediaProviderAuthority(android.content.ContentResolver contentResolver, java.lang.String string)
  static bool isCurrentCloudMediaProviderAuthority(
    ContentResolver contentResolver,
    jni.JString string,
  ) {
    return _isCurrentCloudMediaProviderAuthority(
            _class.reference.pointer,
            _id_isCurrentCloudMediaProviderAuthority as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            string.reference.pointer)
        .boolean;
  }

  static final _id_isSupportedCloudMediaProviderAuthority =
      _class.staticMethodId(
    r'isSupportedCloudMediaProviderAuthority',
    r'(Landroid/content/ContentResolver;Ljava/lang/String;)Z',
  );

  static final _isSupportedCloudMediaProviderAuthority =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<
                          (
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>
                          )>)>>('globalEnv_CallStaticBooleanMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isSupportedCloudMediaProviderAuthority(android.content.ContentResolver contentResolver, java.lang.String string)
  static bool isSupportedCloudMediaProviderAuthority(
    ContentResolver contentResolver,
    jni.JString string,
  ) {
    return _isSupportedCloudMediaProviderAuthority(
            _class.reference.pointer,
            _id_isSupportedCloudMediaProviderAuthority as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            string.reference.pointer)
        .boolean;
  }

  static final _id_notifyCloudMediaChangedEvent = _class.staticMethodId(
    r'notifyCloudMediaChangedEvent',
    r'(Landroid/content/ContentResolver;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _notifyCloudMediaChangedEvent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void notifyCloudMediaChangedEvent(android.content.ContentResolver contentResolver, java.lang.String string, java.lang.String string1)
  static void notifyCloudMediaChangedEvent(
    ContentResolver contentResolver,
    jni.JString string,
    jni.JString string1,
  ) {
    _notifyCloudMediaChangedEvent(
            _class.reference.pointer,
            _id_notifyCloudMediaChangedEvent as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer)
        .check();
  }
}

final class $MediaStoreType extends jni.JObjType<MediaStore> {
  const $MediaStoreType();

  @override
  String get signature => r'Landroid/provider/MediaStore;';

  @override
  MediaStore fromReference(jni.JReference reference) =>
      MediaStore.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaStoreType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaStoreType) && other is $MediaStoreType;
  }
}

/// from: android.util.Size
class Size extends jni.JObject {
  @override
  late final jni.JObjType<Size> $type = type;

  Size.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/util/Size');

  /// The type which includes information such as the signature of this class.
  static const type = $SizeType();
  static final _id_new0 = _class.constructorId(
    r'(II)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void <init>(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Size(
    int i,
    int i1,
  ) {
    return Size.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr, i, i1)
            .reference);
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getWidth()
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getHeight()
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_parseSize = _class.staticMethodId(
    r'parseSize',
    r'(Ljava/lang/String;)Landroid/util/Size;',
  );

  static final _parseSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.util.Size parseSize(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Size parseSize(
    jni.JString string,
  ) {
    return _parseSize(_class.reference.pointer,
            _id_parseSize as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $SizeType());
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }
}

final class $SizeType extends jni.JObjType<Size> {
  const $SizeType();

  @override
  String get signature => r'Landroid/util/Size;';

  @override
  Size fromReference(jni.JReference reference) => Size.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($SizeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($SizeType) && other is $SizeType;
  }
}

/// from: androidx.camera.core.CameraSelector$Builder
class CameraSelector_Builder extends jni.JObject {
  @override
  late final jni.JObjType<CameraSelector_Builder> $type = type;

  CameraSelector_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/core/CameraSelector$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraSelector_BuilderType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraSelector_Builder() {
    return CameraSelector_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_requireLensFacing = _class.instanceMethodId(
    r'requireLensFacing',
    r'(I)Landroidx/camera/core/CameraSelector$Builder;',
  );

  static final _requireLensFacing = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public androidx.camera.core.CameraSelector$Builder requireLensFacing(int i)
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector_Builder requireLensFacing(
    int i,
  ) {
    return _requireLensFacing(
            reference.pointer, _id_requireLensFacing as jni.JMethodIDPtr, i)
        .object(const $CameraSelector_BuilderType());
  }

  static final _id_addCameraFilter = _class.instanceMethodId(
    r'addCameraFilter',
    r'(Landroidx/camera/core/CameraFilter;)Landroidx/camera/core/CameraSelector$Builder;',
  );

  static final _addCameraFilter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.core.CameraSelector$Builder addCameraFilter(androidx.camera.core.CameraFilter cameraFilter)
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector_Builder addCameraFilter(
    jni.JObject cameraFilter,
  ) {
    return _addCameraFilter(
            reference.pointer,
            _id_addCameraFilter as jni.JMethodIDPtr,
            cameraFilter.reference.pointer)
        .object(const $CameraSelector_BuilderType());
  }

  static final _id_fromSelector = _class.staticMethodId(
    r'fromSelector',
    r'(Landroidx/camera/core/CameraSelector;)Landroidx/camera/core/CameraSelector$Builder;',
  );

  static final _fromSelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public androidx.camera.core.CameraSelector$Builder fromSelector(androidx.camera.core.CameraSelector cameraSelector)
  /// The returned object must be released after use, by calling the [release] method.
  static CameraSelector_Builder fromSelector(
    CameraSelector cameraSelector,
  ) {
    return _fromSelector(
            _class.reference.pointer,
            _id_fromSelector as jni.JMethodIDPtr,
            cameraSelector.reference.pointer)
        .object(const $CameraSelector_BuilderType());
  }

  static final _id_setPhysicalCameraId = _class.instanceMethodId(
    r'setPhysicalCameraId',
    r'(Ljava/lang/String;)Landroidx/camera/core/CameraSelector$Builder;',
  );

  static final _setPhysicalCameraId = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.core.CameraSelector$Builder setPhysicalCameraId(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector_Builder setPhysicalCameraId(
    jni.JString string,
  ) {
    return _setPhysicalCameraId(
            reference.pointer,
            _id_setPhysicalCameraId as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $CameraSelector_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroidx/camera/core/CameraSelector;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraSelector build()
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $CameraSelectorType());
  }
}

final class $CameraSelector_BuilderType
    extends jni.JObjType<CameraSelector_Builder> {
  const $CameraSelector_BuilderType();

  @override
  String get signature => r'Landroidx/camera/core/CameraSelector$Builder;';

  @override
  CameraSelector_Builder fromReference(jni.JReference reference) =>
      CameraSelector_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraSelector_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraSelector_BuilderType) &&
        other is $CameraSelector_BuilderType;
  }
}

/// from: androidx.camera.core.CameraSelector$LensFacing
class CameraSelector_LensFacing extends jni.JObject {
  @override
  late final jni.JObjType<CameraSelector_LensFacing> $type = type;

  CameraSelector_LensFacing.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/core/CameraSelector$LensFacing');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraSelector_LensFacingType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CameraSelector_LensFacingImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory CameraSelector_LensFacing.implement(
    $CameraSelector_LensFacingImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = CameraSelector_LensFacing.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.CameraSelector$LensFacing',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CameraSelector_LensFacingImpl {
  factory $CameraSelector_LensFacingImpl() = _$CameraSelector_LensFacingImpl;
}

class _$CameraSelector_LensFacingImpl
    implements $CameraSelector_LensFacingImpl {
  _$CameraSelector_LensFacingImpl();
}

final class $CameraSelector_LensFacingType
    extends jni.JObjType<CameraSelector_LensFacing> {
  const $CameraSelector_LensFacingType();

  @override
  String get signature => r'Landroidx/camera/core/CameraSelector$LensFacing;';

  @override
  CameraSelector_LensFacing fromReference(jni.JReference reference) =>
      CameraSelector_LensFacing.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraSelector_LensFacingType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraSelector_LensFacingType) &&
        other is $CameraSelector_LensFacingType;
  }
}

/// from: androidx.camera.core.CameraSelector
class CameraSelector extends jni.JObject {
  @override
  late final jni.JObjType<CameraSelector> $type = type;

  CameraSelector.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/core/CameraSelector');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraSelectorType();

  /// from: static public final int LENS_FACING_UNKNOWN
  static const LENS_FACING_UNKNOWN = -1;

  /// from: static public final int LENS_FACING_FRONT
  static const LENS_FACING_FRONT = 0;

  /// from: static public final int LENS_FACING_BACK
  static const LENS_FACING_BACK = 1;

  /// from: static public final int LENS_FACING_EXTERNAL
  static const LENS_FACING_EXTERNAL = 2;
  static final _id_DEFAULT_FRONT_CAMERA = _class.staticFieldId(
    r'DEFAULT_FRONT_CAMERA',
    r'Landroidx/camera/core/CameraSelector;',
  );

  /// from: static public final androidx.camera.core.CameraSelector DEFAULT_FRONT_CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static CameraSelector get DEFAULT_FRONT_CAMERA =>
      _id_DEFAULT_FRONT_CAMERA.get(_class, const $CameraSelectorType());

  static final _id_DEFAULT_BACK_CAMERA = _class.staticFieldId(
    r'DEFAULT_BACK_CAMERA',
    r'Landroidx/camera/core/CameraSelector;',
  );

  /// from: static public final androidx.camera.core.CameraSelector DEFAULT_BACK_CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static CameraSelector get DEFAULT_BACK_CAMERA =>
      _id_DEFAULT_BACK_CAMERA.get(_class, const $CameraSelectorType());

  static final _id_select = _class.instanceMethodId(
    r'select',
    r'(Ljava/util/LinkedHashSet;)Landroidx/camera/core/impl/CameraInternal;',
  );

  static final _select = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.core.impl.CameraInternal select(java.util.LinkedHashSet linkedHashSet)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject select(
    jni.JObject linkedHashSet,
  ) {
    return _select(reference.pointer, _id_select as jni.JMethodIDPtr,
            linkedHashSet.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_filter = _class.instanceMethodId(
    r'filter',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _filter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List filter(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> filter(
    jni.JList<jni.JObject> list,
  ) {
    return _filter(reference.pointer, _id_filter as jni.JMethodIDPtr,
            list.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_filter1 = _class.instanceMethodId(
    r'filter',
    r'(Ljava/util/LinkedHashSet;)Ljava/util/LinkedHashSet;',
  );

  static final _filter1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.LinkedHashSet filter(java.util.LinkedHashSet linkedHashSet)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject filter1(
    jni.JObject linkedHashSet,
  ) {
    return _filter1(reference.pointer, _id_filter1 as jni.JMethodIDPtr,
            linkedHashSet.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getCameraFilterSet = _class.instanceMethodId(
    r'getCameraFilterSet',
    r'()Ljava/util/LinkedHashSet;',
  );

  static final _getCameraFilterSet = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.LinkedHashSet getCameraFilterSet()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCameraFilterSet() {
    return _getCameraFilterSet(
            reference.pointer, _id_getCameraFilterSet as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getLensFacing = _class.instanceMethodId(
    r'getLensFacing',
    r'()Ljava/lang/Integer;',
  );

  static final _getLensFacing = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Integer getLensFacing()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger getLensFacing() {
    return _getLensFacing(
            reference.pointer, _id_getLensFacing as jni.JMethodIDPtr)
        .object(const jni.JIntegerType());
  }

  static final _id_getPhysicalCameraId = _class.instanceMethodId(
    r'getPhysicalCameraId',
    r'()Ljava/lang/String;',
  );

  static final _getPhysicalCameraId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPhysicalCameraId()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPhysicalCameraId() {
    return _getPhysicalCameraId(
            reference.pointer, _id_getPhysicalCameraId as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $CameraSelectorType extends jni.JObjType<CameraSelector> {
  const $CameraSelectorType();

  @override
  String get signature => r'Landroidx/camera/core/CameraSelector;';

  @override
  CameraSelector fromReference(jni.JReference reference) =>
      CameraSelector.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraSelectorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraSelectorType) &&
        other is $CameraSelectorType;
  }
}

/// from: androidx.camera.core.ImageInfo
class ImageInfo extends jni.JObject {
  @override
  late final jni.JObjType<ImageInfo> $type = type;

  ImageInfo.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/camera/core/ImageInfo');

  /// The type which includes information such as the signature of this class.
  static const type = $ImageInfoType();
  static final _id_getTagBundle = _class.instanceMethodId(
    r'getTagBundle',
    r'()Landroidx/camera/core/impl/TagBundle;',
  );

  static final _getTagBundle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract androidx.camera.core.impl.TagBundle getTagBundle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getTagBundle() {
    return _getTagBundle(
            reference.pointer, _id_getTagBundle as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()J',
  );

  static final _getTimestamp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract long getTimestamp()
  int getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni.JMethodIDPtr)
        .long;
  }

  static final _id_getRotationDegrees = _class.instanceMethodId(
    r'getRotationDegrees',
    r'()I',
  );

  static final _getRotationDegrees = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getRotationDegrees()
  int getRotationDegrees() {
    return _getRotationDegrees(
            reference.pointer, _id_getRotationDegrees as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getSensorToBufferTransformMatrix = _class.instanceMethodId(
    r'getSensorToBufferTransformMatrix',
    r'()Landroid/graphics/Matrix;',
  );

  static final _getSensorToBufferTransformMatrix =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public android.graphics.Matrix getSensorToBufferTransformMatrix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSensorToBufferTransformMatrix() {
    return _getSensorToBufferTransformMatrix(reference.pointer,
            _id_getSensorToBufferTransformMatrix as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_populateExifData = _class.instanceMethodId(
    r'populateExifData',
    r'(Landroidx/camera/core/impl/utils/ExifData$Builder;)V',
  );

  static final _populateExifData = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void populateExifData(androidx.camera.core.impl.utils.ExifData$Builder builder)
  void populateExifData(
    jni.JObject builder,
  ) {
    _populateExifData(reference.pointer,
            _id_populateExifData as jni.JMethodIDPtr, builder.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ImageInfoImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getTagBundle()Landroidx/camera/core/impl/TagBundle;') {
        final $r = _$impls[$p]!.getTagBundle();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'getTimestamp()J') {
        final $r = _$impls[$p]!.getTimestamp();
        return jni.JLong($r).reference.toPointer();
      }
      if ($d == r'getRotationDegrees()I') {
        final $r = _$impls[$p]!.getRotationDegrees();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d ==
          r'getSensorToBufferTransformMatrix()Landroid/graphics/Matrix;') {
        final $r = _$impls[$p]!.getSensorToBufferTransformMatrix();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r'populateExifData(Landroidx/camera/core/impl/utils/ExifData$Builder;)V') {
        _$impls[$p]!.populateExifData(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ImageInfo.implement(
    $ImageInfoImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ImageInfo.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.ImageInfo',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ImageInfoImpl {
  factory $ImageInfoImpl({
    required jni.JObject Function() getTagBundle,
    required int Function() getTimestamp,
    required int Function() getRotationDegrees,
    required jni.JObject Function() getSensorToBufferTransformMatrix,
    required void Function(jni.JObject builder) populateExifData,
  }) = _$ImageInfoImpl;

  jni.JObject getTagBundle();
  int getTimestamp();
  int getRotationDegrees();
  jni.JObject getSensorToBufferTransformMatrix();
  void populateExifData(jni.JObject builder);
}

class _$ImageInfoImpl implements $ImageInfoImpl {
  _$ImageInfoImpl({
    required jni.JObject Function() getTagBundle,
    required int Function() getTimestamp,
    required int Function() getRotationDegrees,
    required jni.JObject Function() getSensorToBufferTransformMatrix,
    required void Function(jni.JObject builder) populateExifData,
  })  : _getTagBundle = getTagBundle,
        _getTimestamp = getTimestamp,
        _getRotationDegrees = getRotationDegrees,
        _getSensorToBufferTransformMatrix = getSensorToBufferTransformMatrix,
        _populateExifData = populateExifData;

  final jni.JObject Function() _getTagBundle;
  final int Function() _getTimestamp;
  final int Function() _getRotationDegrees;
  final jni.JObject Function() _getSensorToBufferTransformMatrix;
  final void Function(jni.JObject builder) _populateExifData;

  jni.JObject getTagBundle() {
    return _getTagBundle();
  }

  int getTimestamp() {
    return _getTimestamp();
  }

  int getRotationDegrees() {
    return _getRotationDegrees();
  }

  jni.JObject getSensorToBufferTransformMatrix() {
    return _getSensorToBufferTransformMatrix();
  }

  void populateExifData(jni.JObject builder) {
    return _populateExifData(builder);
  }
}

final class $ImageInfoType extends jni.JObjType<ImageInfo> {
  const $ImageInfoType();

  @override
  String get signature => r'Landroidx/camera/core/ImageInfo;';

  @override
  ImageInfo fromReference(jni.JReference reference) =>
      ImageInfo.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ImageInfoType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageInfoType) && other is $ImageInfoType;
  }
}

/// from: androidx.camera.core.ImageProxy$PlaneProxy
class ImageProxy_PlaneProxy extends jni.JObject {
  @override
  late final jni.JObjType<ImageProxy_PlaneProxy> $type = type;

  ImageProxy_PlaneProxy.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/core/ImageProxy$PlaneProxy');

  /// The type which includes information such as the signature of this class.
  static const type = $ImageProxy_PlaneProxyType();
  static final _id_getRowStride = _class.instanceMethodId(
    r'getRowStride',
    r'()I',
  );

  static final _getRowStride = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getRowStride()
  int getRowStride() {
    return _getRowStride(
            reference.pointer, _id_getRowStride as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPixelStride = _class.instanceMethodId(
    r'getPixelStride',
    r'()I',
  );

  static final _getPixelStride = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getPixelStride()
  int getPixelStride() {
    return _getPixelStride(
            reference.pointer, _id_getPixelStride as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getBuffer = _class.instanceMethodId(
    r'getBuffer',
    r'()Ljava/nio/ByteBuffer;',
  );

  static final _getBuffer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.nio.ByteBuffer getBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByteBuffer getBuffer() {
    return _getBuffer(reference.pointer, _id_getBuffer as jni.JMethodIDPtr)
        .object(const jni.JByteBufferType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ImageProxy_PlaneProxyImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getRowStride()I') {
        final $r = _$impls[$p]!.getRowStride();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getPixelStride()I') {
        final $r = _$impls[$p]!.getPixelStride();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getBuffer()Ljava/nio/ByteBuffer;') {
        final $r = _$impls[$p]!.getBuffer();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ImageProxy_PlaneProxy.implement(
    $ImageProxy_PlaneProxyImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ImageProxy_PlaneProxy.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.ImageProxy$PlaneProxy',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ImageProxy_PlaneProxyImpl {
  factory $ImageProxy_PlaneProxyImpl({
    required int Function() getRowStride,
    required int Function() getPixelStride,
    required jni.JByteBuffer Function() getBuffer,
  }) = _$ImageProxy_PlaneProxyImpl;

  int getRowStride();
  int getPixelStride();
  jni.JByteBuffer getBuffer();
}

class _$ImageProxy_PlaneProxyImpl implements $ImageProxy_PlaneProxyImpl {
  _$ImageProxy_PlaneProxyImpl({
    required int Function() getRowStride,
    required int Function() getPixelStride,
    required jni.JByteBuffer Function() getBuffer,
  })  : _getRowStride = getRowStride,
        _getPixelStride = getPixelStride,
        _getBuffer = getBuffer;

  final int Function() _getRowStride;
  final int Function() _getPixelStride;
  final jni.JByteBuffer Function() _getBuffer;

  int getRowStride() {
    return _getRowStride();
  }

  int getPixelStride() {
    return _getPixelStride();
  }

  jni.JByteBuffer getBuffer() {
    return _getBuffer();
  }
}

final class $ImageProxy_PlaneProxyType
    extends jni.JObjType<ImageProxy_PlaneProxy> {
  const $ImageProxy_PlaneProxyType();

  @override
  String get signature => r'Landroidx/camera/core/ImageProxy$PlaneProxy;';

  @override
  ImageProxy_PlaneProxy fromReference(jni.JReference reference) =>
      ImageProxy_PlaneProxy.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ImageProxy_PlaneProxyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageProxy_PlaneProxyType) &&
        other is $ImageProxy_PlaneProxyType;
  }
}

/// from: androidx.camera.core.ImageProxy
class ImageProxy extends jni.JObject {
  @override
  late final jni.JObjType<ImageProxy> $type = type;

  ImageProxy.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/camera/core/ImageProxy');

  /// The type which includes information such as the signature of this class.
  static const type = $ImageProxyType();
  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_getCropRect = _class.instanceMethodId(
    r'getCropRect',
    r'()Landroid/graphics/Rect;',
  );

  static final _getCropRect = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.graphics.Rect getCropRect()
  /// The returned object must be released after use, by calling the [release] method.
  Rect getCropRect() {
    return _getCropRect(reference.pointer, _id_getCropRect as jni.JMethodIDPtr)
        .object(const $RectType());
  }

  static final _id_setCropRect = _class.instanceMethodId(
    r'setCropRect',
    r'(Landroid/graphics/Rect;)V',
  );

  static final _setCropRect = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setCropRect(android.graphics.Rect rect)
  void setCropRect(
    Rect rect,
  ) {
    _setCropRect(reference.pointer, _id_setCropRect as jni.JMethodIDPtr,
            rect.reference.pointer)
        .check();
  }

  static final _id_getFormat = _class.instanceMethodId(
    r'getFormat',
    r'()I',
  );

  static final _getFormat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getFormat()
  int getFormat() {
    return _getFormat(reference.pointer, _id_getFormat as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getHeight()
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getWidth()
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPlanes = _class.instanceMethodId(
    r'getPlanes',
    r'()[Landroidx/camera/core/ImageProxy$PlaneProxy;',
  );

  static final _getPlanes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract androidx.camera.core.ImageProxy$PlaneProxy[] getPlanes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<ImageProxy_PlaneProxy> getPlanes() {
    return _getPlanes(reference.pointer, _id_getPlanes as jni.JMethodIDPtr)
        .object(const jni.JArrayType($ImageProxy_PlaneProxyType()));
  }

  static final _id_getImageInfo = _class.instanceMethodId(
    r'getImageInfo',
    r'()Landroidx/camera/core/ImageInfo;',
  );

  static final _getImageInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract androidx.camera.core.ImageInfo getImageInfo()
  /// The returned object must be released after use, by calling the [release] method.
  ImageInfo getImageInfo() {
    return _getImageInfo(
            reference.pointer, _id_getImageInfo as jni.JMethodIDPtr)
        .object(const $ImageInfoType());
  }

  static final _id_getImage = _class.instanceMethodId(
    r'getImage',
    r'()Landroid/media/Image;',
  );

  static final _getImage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.media.Image getImage()
  /// The returned object must be released after use, by calling the [release] method.
  Image getImage() {
    return _getImage(reference.pointer, _id_getImage as jni.JMethodIDPtr)
        .object(const $ImageType());
  }

  static final _id_toBitmap = _class.instanceMethodId(
    r'toBitmap',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _toBitmap = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Bitmap toBitmap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toBitmap() {
    return _toBitmap(reference.pointer, _id_toBitmap as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ImageProxyImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni.nullptr;
      }
      if ($d == r'getCropRect()Landroid/graphics/Rect;') {
        final $r = _$impls[$p]!.getCropRect();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'setCropRect(Landroid/graphics/Rect;)V') {
        _$impls[$p]!.setCropRect(
          $a[0].castTo(const $RectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'getFormat()I') {
        final $r = _$impls[$p]!.getFormat();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getHeight()I') {
        final $r = _$impls[$p]!.getHeight();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getWidth()I') {
        final $r = _$impls[$p]!.getWidth();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d == r'getPlanes()[Landroidx/camera/core/ImageProxy$PlaneProxy;') {
        final $r = _$impls[$p]!.getPlanes();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'getImageInfo()Landroidx/camera/core/ImageInfo;') {
        final $r = _$impls[$p]!.getImageInfo();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'getImage()Landroid/media/Image;') {
        final $r = _$impls[$p]!.getImage();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'toBitmap()Landroid/graphics/Bitmap;') {
        final $r = _$impls[$p]!.toBitmap();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ImageProxy.implement(
    $ImageProxyImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ImageProxy.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.ImageProxy',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ImageProxyImpl {
  factory $ImageProxyImpl({
    required void Function() close,
    required Rect Function() getCropRect,
    required void Function(Rect rect) setCropRect,
    required int Function() getFormat,
    required int Function() getHeight,
    required int Function() getWidth,
    required jni.JArray<ImageProxy_PlaneProxy> Function() getPlanes,
    required ImageInfo Function() getImageInfo,
    required Image Function() getImage,
    required jni.JObject Function() toBitmap,
  }) = _$ImageProxyImpl;

  void close();
  Rect getCropRect();
  void setCropRect(Rect rect);
  int getFormat();
  int getHeight();
  int getWidth();
  jni.JArray<ImageProxy_PlaneProxy> getPlanes();
  ImageInfo getImageInfo();
  Image getImage();
  jni.JObject toBitmap();
}

class _$ImageProxyImpl implements $ImageProxyImpl {
  _$ImageProxyImpl({
    required void Function() close,
    required Rect Function() getCropRect,
    required void Function(Rect rect) setCropRect,
    required int Function() getFormat,
    required int Function() getHeight,
    required int Function() getWidth,
    required jni.JArray<ImageProxy_PlaneProxy> Function() getPlanes,
    required ImageInfo Function() getImageInfo,
    required Image Function() getImage,
    required jni.JObject Function() toBitmap,
  })  : _close = close,
        _getCropRect = getCropRect,
        _setCropRect = setCropRect,
        _getFormat = getFormat,
        _getHeight = getHeight,
        _getWidth = getWidth,
        _getPlanes = getPlanes,
        _getImageInfo = getImageInfo,
        _getImage = getImage,
        _toBitmap = toBitmap;

  final void Function() _close;
  final Rect Function() _getCropRect;
  final void Function(Rect rect) _setCropRect;
  final int Function() _getFormat;
  final int Function() _getHeight;
  final int Function() _getWidth;
  final jni.JArray<ImageProxy_PlaneProxy> Function() _getPlanes;
  final ImageInfo Function() _getImageInfo;
  final Image Function() _getImage;
  final jni.JObject Function() _toBitmap;

  void close() {
    return _close();
  }

  Rect getCropRect() {
    return _getCropRect();
  }

  void setCropRect(Rect rect) {
    return _setCropRect(rect);
  }

  int getFormat() {
    return _getFormat();
  }

  int getHeight() {
    return _getHeight();
  }

  int getWidth() {
    return _getWidth();
  }

  jni.JArray<ImageProxy_PlaneProxy> getPlanes() {
    return _getPlanes();
  }

  ImageInfo getImageInfo() {
    return _getImageInfo();
  }

  Image getImage() {
    return _getImage();
  }

  jni.JObject toBitmap() {
    return _toBitmap();
  }
}

final class $ImageProxyType extends jni.JObjType<ImageProxy> {
  const $ImageProxyType();

  @override
  String get signature => r'Landroidx/camera/core/ImageProxy;';

  @override
  ImageProxy fromReference(jni.JReference reference) =>
      ImageProxy.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ImageProxyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageProxyType) && other is $ImageProxyType;
  }
}

/// from: androidx.camera.core.TorchState$State
class TorchState_State extends jni.JObject {
  @override
  late final jni.JObjType<TorchState_State> $type = type;

  TorchState_State.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/core/TorchState$State');

  /// The type which includes information such as the signature of this class.
  static const type = $TorchState_StateType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $TorchState_StateImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory TorchState_State.implement(
    $TorchState_StateImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = TorchState_State.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.TorchState$State',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $TorchState_StateImpl {
  factory $TorchState_StateImpl() = _$TorchState_StateImpl;
}

class _$TorchState_StateImpl implements $TorchState_StateImpl {
  _$TorchState_StateImpl();
}

final class $TorchState_StateType extends jni.JObjType<TorchState_State> {
  const $TorchState_StateType();

  @override
  String get signature => r'Landroidx/camera/core/TorchState$State;';

  @override
  TorchState_State fromReference(jni.JReference reference) =>
      TorchState_State.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($TorchState_StateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TorchState_StateType) &&
        other is $TorchState_StateType;
  }
}

/// from: androidx.camera.core.TorchState
class TorchState extends jni.JObject {
  @override
  late final jni.JObjType<TorchState> $type = type;

  TorchState.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/camera/core/TorchState');

  /// The type which includes information such as the signature of this class.
  static const type = $TorchStateType();

  /// from: static public final int OFF
  static const OFF = 0;

  /// from: static public final int ON
  static const ON = 1;
}

final class $TorchStateType extends jni.JObjType<TorchState> {
  const $TorchStateType();

  @override
  String get signature => r'Landroidx/camera/core/TorchState;';

  @override
  TorchState fromReference(jni.JReference reference) =>
      TorchState.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($TorchStateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TorchStateType) && other is $TorchStateType;
  }
}

/// from: androidx.camera.core.ZoomState
class ZoomState extends jni.JObject {
  @override
  late final jni.JObjType<ZoomState> $type = type;

  ZoomState.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/camera/core/ZoomState');

  /// The type which includes information such as the signature of this class.
  static const type = $ZoomStateType();
  static final _id_getZoomRatio = _class.instanceMethodId(
    r'getZoomRatio',
    r'()F',
  );

  static final _getZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract float getZoomRatio()
  double getZoomRatio() {
    return _getZoomRatio(
            reference.pointer, _id_getZoomRatio as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getMaxZoomRatio = _class.instanceMethodId(
    r'getMaxZoomRatio',
    r'()F',
  );

  static final _getMaxZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract float getMaxZoomRatio()
  double getMaxZoomRatio() {
    return _getMaxZoomRatio(
            reference.pointer, _id_getMaxZoomRatio as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getMinZoomRatio = _class.instanceMethodId(
    r'getMinZoomRatio',
    r'()F',
  );

  static final _getMinZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract float getMinZoomRatio()
  double getMinZoomRatio() {
    return _getMinZoomRatio(
            reference.pointer, _id_getMinZoomRatio as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getLinearZoom = _class.instanceMethodId(
    r'getLinearZoom',
    r'()F',
  );

  static final _getLinearZoom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract float getLinearZoom()
  double getLinearZoom() {
    return _getLinearZoom(
            reference.pointer, _id_getLinearZoom as jni.JMethodIDPtr)
        .float;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ZoomStateImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getZoomRatio()F') {
        final $r = _$impls[$p]!.getZoomRatio();
        return jni.JFloat($r).reference.toPointer();
      }
      if ($d == r'getMaxZoomRatio()F') {
        final $r = _$impls[$p]!.getMaxZoomRatio();
        return jni.JFloat($r).reference.toPointer();
      }
      if ($d == r'getMinZoomRatio()F') {
        final $r = _$impls[$p]!.getMinZoomRatio();
        return jni.JFloat($r).reference.toPointer();
      }
      if ($d == r'getLinearZoom()F') {
        final $r = _$impls[$p]!.getLinearZoom();
        return jni.JFloat($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ZoomState.implement(
    $ZoomStateImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ZoomState.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.ZoomState',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ZoomStateImpl {
  factory $ZoomStateImpl({
    required double Function() getZoomRatio,
    required double Function() getMaxZoomRatio,
    required double Function() getMinZoomRatio,
    required double Function() getLinearZoom,
  }) = _$ZoomStateImpl;

  double getZoomRatio();
  double getMaxZoomRatio();
  double getMinZoomRatio();
  double getLinearZoom();
}

class _$ZoomStateImpl implements $ZoomStateImpl {
  _$ZoomStateImpl({
    required double Function() getZoomRatio,
    required double Function() getMaxZoomRatio,
    required double Function() getMinZoomRatio,
    required double Function() getLinearZoom,
  })  : _getZoomRatio = getZoomRatio,
        _getMaxZoomRatio = getMaxZoomRatio,
        _getMinZoomRatio = getMinZoomRatio,
        _getLinearZoom = getLinearZoom;

  final double Function() _getZoomRatio;
  final double Function() _getMaxZoomRatio;
  final double Function() _getMinZoomRatio;
  final double Function() _getLinearZoom;

  double getZoomRatio() {
    return _getZoomRatio();
  }

  double getMaxZoomRatio() {
    return _getMaxZoomRatio();
  }

  double getMinZoomRatio() {
    return _getMinZoomRatio();
  }

  double getLinearZoom() {
    return _getLinearZoom();
  }
}

final class $ZoomStateType extends jni.JObjType<ZoomState> {
  const $ZoomStateType();

  @override
  String get signature => r'Landroidx/camera/core/ZoomState;';

  @override
  ZoomState fromReference(jni.JReference reference) =>
      ZoomState.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZoomStateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoomStateType) && other is $ZoomStateType;
  }
}

/// from: androidx.camera.core.resolutionselector.AspectRatioStrategy$AspectRatioFallbackRule
class AspectRatioStrategy_AspectRatioFallbackRule extends jni.JObject {
  @override
  late final jni.JObjType<AspectRatioStrategy_AspectRatioFallbackRule> $type =
      type;

  AspectRatioStrategy_AspectRatioFallbackRule.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/core/resolutionselector/AspectRatioStrategy$AspectRatioFallbackRule');

  /// The type which includes information such as the signature of this class.
  static const type = $AspectRatioStrategy_AspectRatioFallbackRuleType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $AspectRatioStrategy_AspectRatioFallbackRuleImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory AspectRatioStrategy_AspectRatioFallbackRule.implement(
    $AspectRatioStrategy_AspectRatioFallbackRuleImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = AspectRatioStrategy_AspectRatioFallbackRule.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.resolutionselector.AspectRatioStrategy$AspectRatioFallbackRule',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $AspectRatioStrategy_AspectRatioFallbackRuleImpl {
  factory $AspectRatioStrategy_AspectRatioFallbackRuleImpl() =
      _$AspectRatioStrategy_AspectRatioFallbackRuleImpl;
}

class _$AspectRatioStrategy_AspectRatioFallbackRuleImpl
    implements $AspectRatioStrategy_AspectRatioFallbackRuleImpl {
  _$AspectRatioStrategy_AspectRatioFallbackRuleImpl();
}

final class $AspectRatioStrategy_AspectRatioFallbackRuleType
    extends jni.JObjType<AspectRatioStrategy_AspectRatioFallbackRule> {
  const $AspectRatioStrategy_AspectRatioFallbackRuleType();

  @override
  String get signature =>
      r'Landroidx/camera/core/resolutionselector/AspectRatioStrategy$AspectRatioFallbackRule;';

  @override
  AspectRatioStrategy_AspectRatioFallbackRule fromReference(
          jni.JReference reference) =>
      AspectRatioStrategy_AspectRatioFallbackRule.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($AspectRatioStrategy_AspectRatioFallbackRuleType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AspectRatioStrategy_AspectRatioFallbackRuleType) &&
        other is $AspectRatioStrategy_AspectRatioFallbackRuleType;
  }
}

/// from: androidx.camera.core.resolutionselector.AspectRatioStrategy
class AspectRatioStrategy extends jni.JObject {
  @override
  late final jni.JObjType<AspectRatioStrategy> $type = type;

  AspectRatioStrategy.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/core/resolutionselector/AspectRatioStrategy');

  /// The type which includes information such as the signature of this class.
  static const type = $AspectRatioStrategyType();

  /// from: static public final int FALLBACK_RULE_NONE
  static const FALLBACK_RULE_NONE = 0;

  /// from: static public final int FALLBACK_RULE_AUTO
  static const FALLBACK_RULE_AUTO = 1;
  static final _id_RATIO_4_3_FALLBACK_AUTO_STRATEGY = _class.staticFieldId(
    r'RATIO_4_3_FALLBACK_AUTO_STRATEGY',
    r'Landroidx/camera/core/resolutionselector/AspectRatioStrategy;',
  );

  /// from: static public final androidx.camera.core.resolutionselector.AspectRatioStrategy RATIO_4_3_FALLBACK_AUTO_STRATEGY
  /// The returned object must be released after use, by calling the [release] method.
  static AspectRatioStrategy get RATIO_4_3_FALLBACK_AUTO_STRATEGY =>
      _id_RATIO_4_3_FALLBACK_AUTO_STRATEGY.get(
          _class, const $AspectRatioStrategyType());

  static final _id_RATIO_16_9_FALLBACK_AUTO_STRATEGY = _class.staticFieldId(
    r'RATIO_16_9_FALLBACK_AUTO_STRATEGY',
    r'Landroidx/camera/core/resolutionselector/AspectRatioStrategy;',
  );

  /// from: static public final androidx.camera.core.resolutionselector.AspectRatioStrategy RATIO_16_9_FALLBACK_AUTO_STRATEGY
  /// The returned object must be released after use, by calling the [release] method.
  static AspectRatioStrategy get RATIO_16_9_FALLBACK_AUTO_STRATEGY =>
      _id_RATIO_16_9_FALLBACK_AUTO_STRATEGY.get(
          _class, const $AspectRatioStrategyType());

  static final _id_new0 = _class.constructorId(
    r'(II)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void <init>(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory AspectRatioStrategy(
    int i,
    int i1,
  ) {
    return AspectRatioStrategy.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr, i, i1)
            .reference);
  }

  static final _id_getPreferredAspectRatio = _class.instanceMethodId(
    r'getPreferredAspectRatio',
    r'()I',
  );

  static final _getPreferredAspectRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getPreferredAspectRatio()
  int getPreferredAspectRatio() {
    return _getPreferredAspectRatio(
            reference.pointer, _id_getPreferredAspectRatio as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getFallbackRule = _class.instanceMethodId(
    r'getFallbackRule',
    r'()I',
  );

  static final _getFallbackRule = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getFallbackRule()
  int getFallbackRule() {
    return _getFallbackRule(
            reference.pointer, _id_getFallbackRule as jni.JMethodIDPtr)
        .integer;
  }
}

final class $AspectRatioStrategyType extends jni.JObjType<AspectRatioStrategy> {
  const $AspectRatioStrategyType();

  @override
  String get signature =>
      r'Landroidx/camera/core/resolutionselector/AspectRatioStrategy;';

  @override
  AspectRatioStrategy fromReference(jni.JReference reference) =>
      AspectRatioStrategy.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($AspectRatioStrategyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($AspectRatioStrategyType) &&
        other is $AspectRatioStrategyType;
  }
}

/// from: androidx.camera.core.resolutionselector.ResolutionFilter
class ResolutionFilter extends jni.JObject {
  @override
  late final jni.JObjType<ResolutionFilter> $type = type;

  ResolutionFilter.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/core/resolutionselector/ResolutionFilter');

  /// The type which includes information such as the signature of this class.
  static const type = $ResolutionFilterType();
  static final _id_filter = _class.instanceMethodId(
    r'filter',
    r'(Ljava/util/List;I)Ljava/util/List;',
  );

  static final _filter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List filter(java.util.List list, int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Size> filter(
    jni.JList<Size> list,
    int i,
  ) {
    return _filter(reference.pointer, _id_filter as jni.JMethodIDPtr,
            list.reference.pointer, i)
        .object(const jni.JListType($SizeType()));
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ResolutionFilterImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'filter(Ljava/util/List;I)Ljava/util/List;') {
        final $r = _$impls[$p]!.filter(
          $a[0].castTo(const jni.JListType($SizeType()), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ResolutionFilter.implement(
    $ResolutionFilterImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ResolutionFilter.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.resolutionselector.ResolutionFilter',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ResolutionFilterImpl {
  factory $ResolutionFilterImpl({
    required jni.JList<Size> Function(jni.JList<Size> list, int i) filter,
  }) = _$ResolutionFilterImpl;

  jni.JList<Size> filter(jni.JList<Size> list, int i);
}

class _$ResolutionFilterImpl implements $ResolutionFilterImpl {
  _$ResolutionFilterImpl({
    required jni.JList<Size> Function(jni.JList<Size> list, int i) filter,
  }) : _filter = filter;

  final jni.JList<Size> Function(jni.JList<Size> list, int i) _filter;

  jni.JList<Size> filter(jni.JList<Size> list, int i) {
    return _filter(list, i);
  }
}

final class $ResolutionFilterType extends jni.JObjType<ResolutionFilter> {
  const $ResolutionFilterType();

  @override
  String get signature =>
      r'Landroidx/camera/core/resolutionselector/ResolutionFilter;';

  @override
  ResolutionFilter fromReference(jni.JReference reference) =>
      ResolutionFilter.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResolutionFilterType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionFilterType) &&
        other is $ResolutionFilterType;
  }
}

/// from: androidx.camera.core.resolutionselector.ResolutionSelector$AllowedResolutionMode
class ResolutionSelector_AllowedResolutionMode extends jni.JObject {
  @override
  late final jni.JObjType<ResolutionSelector_AllowedResolutionMode> $type =
      type;

  ResolutionSelector_AllowedResolutionMode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/core/resolutionselector/ResolutionSelector$AllowedResolutionMode');

  /// The type which includes information such as the signature of this class.
  static const type = $ResolutionSelector_AllowedResolutionModeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ResolutionSelector_AllowedResolutionModeImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ResolutionSelector_AllowedResolutionMode.implement(
    $ResolutionSelector_AllowedResolutionModeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ResolutionSelector_AllowedResolutionMode.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.resolutionselector.ResolutionSelector$AllowedResolutionMode',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ResolutionSelector_AllowedResolutionModeImpl {
  factory $ResolutionSelector_AllowedResolutionModeImpl() =
      _$ResolutionSelector_AllowedResolutionModeImpl;
}

class _$ResolutionSelector_AllowedResolutionModeImpl
    implements $ResolutionSelector_AllowedResolutionModeImpl {
  _$ResolutionSelector_AllowedResolutionModeImpl();
}

final class $ResolutionSelector_AllowedResolutionModeType
    extends jni.JObjType<ResolutionSelector_AllowedResolutionMode> {
  const $ResolutionSelector_AllowedResolutionModeType();

  @override
  String get signature =>
      r'Landroidx/camera/core/resolutionselector/ResolutionSelector$AllowedResolutionMode;';

  @override
  ResolutionSelector_AllowedResolutionMode fromReference(
          jni.JReference reference) =>
      ResolutionSelector_AllowedResolutionMode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResolutionSelector_AllowedResolutionModeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ResolutionSelector_AllowedResolutionModeType) &&
        other is $ResolutionSelector_AllowedResolutionModeType;
  }
}

/// from: androidx.camera.core.resolutionselector.ResolutionSelector$Builder
class ResolutionSelector_Builder extends jni.JObject {
  @override
  late final jni.JObjType<ResolutionSelector_Builder> $type = type;

  ResolutionSelector_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/core/resolutionselector/ResolutionSelector$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $ResolutionSelector_BuilderType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ResolutionSelector_Builder() {
    return ResolutionSelector_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_fromResolutionSelector = _class.staticMethodId(
    r'fromResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)Landroidx/camera/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _fromResolutionSelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public androidx.camera.core.resolutionselector.ResolutionSelector$Builder fromResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)
  /// The returned object must be released after use, by calling the [release] method.
  static ResolutionSelector_Builder fromResolutionSelector(
    ResolutionSelector resolutionSelector,
  ) {
    return _fromResolutionSelector(
            _class.reference.pointer,
            _id_fromResolutionSelector as jni.JMethodIDPtr,
            resolutionSelector.reference.pointer)
        .object(const $ResolutionSelector_BuilderType());
  }

  static final _id_setAspectRatioStrategy = _class.instanceMethodId(
    r'setAspectRatioStrategy',
    r'(Landroidx/camera/core/resolutionselector/AspectRatioStrategy;)Landroidx/camera/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _setAspectRatioStrategy = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector$Builder setAspectRatioStrategy(androidx.camera.core.resolutionselector.AspectRatioStrategy aspectRatioStrategy)
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector_Builder setAspectRatioStrategy(
    AspectRatioStrategy aspectRatioStrategy,
  ) {
    return _setAspectRatioStrategy(
            reference.pointer,
            _id_setAspectRatioStrategy as jni.JMethodIDPtr,
            aspectRatioStrategy.reference.pointer)
        .object(const $ResolutionSelector_BuilderType());
  }

  static final _id_setResolutionStrategy = _class.instanceMethodId(
    r'setResolutionStrategy',
    r'(Landroidx/camera/core/resolutionselector/ResolutionStrategy;)Landroidx/camera/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _setResolutionStrategy = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector$Builder setResolutionStrategy(androidx.camera.core.resolutionselector.ResolutionStrategy resolutionStrategy)
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector_Builder setResolutionStrategy(
    ResolutionStrategy resolutionStrategy,
  ) {
    return _setResolutionStrategy(
            reference.pointer,
            _id_setResolutionStrategy as jni.JMethodIDPtr,
            resolutionStrategy.reference.pointer)
        .object(const $ResolutionSelector_BuilderType());
  }

  static final _id_setResolutionFilter = _class.instanceMethodId(
    r'setResolutionFilter',
    r'(Landroidx/camera/core/resolutionselector/ResolutionFilter;)Landroidx/camera/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _setResolutionFilter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector$Builder setResolutionFilter(androidx.camera.core.resolutionselector.ResolutionFilter resolutionFilter)
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector_Builder setResolutionFilter(
    ResolutionFilter resolutionFilter,
  ) {
    return _setResolutionFilter(
            reference.pointer,
            _id_setResolutionFilter as jni.JMethodIDPtr,
            resolutionFilter.reference.pointer)
        .object(const $ResolutionSelector_BuilderType());
  }

  static final _id_setAllowedResolutionMode = _class.instanceMethodId(
    r'setAllowedResolutionMode',
    r'(I)Landroidx/camera/core/resolutionselector/ResolutionSelector$Builder;',
  );

  static final _setAllowedResolutionMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector$Builder setAllowedResolutionMode(int i)
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector_Builder setAllowedResolutionMode(
    int i,
  ) {
    return _setAllowedResolutionMode(reference.pointer,
            _id_setAllowedResolutionMode as jni.JMethodIDPtr, i)
        .object(const $ResolutionSelector_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector build()
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $ResolutionSelectorType());
  }
}

final class $ResolutionSelector_BuilderType
    extends jni.JObjType<ResolutionSelector_Builder> {
  const $ResolutionSelector_BuilderType();

  @override
  String get signature =>
      r'Landroidx/camera/core/resolutionselector/ResolutionSelector$Builder;';

  @override
  ResolutionSelector_Builder fromReference(jni.JReference reference) =>
      ResolutionSelector_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResolutionSelector_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionSelector_BuilderType) &&
        other is $ResolutionSelector_BuilderType;
  }
}

/// from: androidx.camera.core.resolutionselector.ResolutionSelector
class ResolutionSelector extends jni.JObject {
  @override
  late final jni.JObjType<ResolutionSelector> $type = type;

  ResolutionSelector.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/core/resolutionselector/ResolutionSelector');

  /// The type which includes information such as the signature of this class.
  static const type = $ResolutionSelectorType();

  /// from: static public final int PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION
  static const PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION = 0;

  /// from: static public final int PREFER_HIGHER_RESOLUTION_OVER_CAPTURE_RATE
  static const PREFER_HIGHER_RESOLUTION_OVER_CAPTURE_RATE = 1;
  static final _id_getAspectRatioStrategy = _class.instanceMethodId(
    r'getAspectRatioStrategy',
    r'()Landroidx/camera/core/resolutionselector/AspectRatioStrategy;',
  );

  static final _getAspectRatioStrategy = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.resolutionselector.AspectRatioStrategy getAspectRatioStrategy()
  /// The returned object must be released after use, by calling the [release] method.
  AspectRatioStrategy getAspectRatioStrategy() {
    return _getAspectRatioStrategy(
            reference.pointer, _id_getAspectRatioStrategy as jni.JMethodIDPtr)
        .object(const $AspectRatioStrategyType());
  }

  static final _id_getResolutionStrategy = _class.instanceMethodId(
    r'getResolutionStrategy',
    r'()Landroidx/camera/core/resolutionselector/ResolutionStrategy;',
  );

  static final _getResolutionStrategy = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionStrategy getResolutionStrategy()
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionStrategy getResolutionStrategy() {
    return _getResolutionStrategy(
            reference.pointer, _id_getResolutionStrategy as jni.JMethodIDPtr)
        .object(const $ResolutionStrategyType());
  }

  static final _id_getResolutionFilter = _class.instanceMethodId(
    r'getResolutionFilter',
    r'()Landroidx/camera/core/resolutionselector/ResolutionFilter;',
  );

  static final _getResolutionFilter = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionFilter getResolutionFilter()
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionFilter getResolutionFilter() {
    return _getResolutionFilter(
            reference.pointer, _id_getResolutionFilter as jni.JMethodIDPtr)
        .object(const $ResolutionFilterType());
  }

  static final _id_getAllowedResolutionMode = _class.instanceMethodId(
    r'getAllowedResolutionMode',
    r'()I',
  );

  static final _getAllowedResolutionMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getAllowedResolutionMode()
  int getAllowedResolutionMode() {
    return _getAllowedResolutionMode(
            reference.pointer, _id_getAllowedResolutionMode as jni.JMethodIDPtr)
        .integer;
  }
}

final class $ResolutionSelectorType extends jni.JObjType<ResolutionSelector> {
  const $ResolutionSelectorType();

  @override
  String get signature =>
      r'Landroidx/camera/core/resolutionselector/ResolutionSelector;';

  @override
  ResolutionSelector fromReference(jni.JReference reference) =>
      ResolutionSelector.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResolutionSelectorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionSelectorType) &&
        other is $ResolutionSelectorType;
  }
}

/// from: androidx.camera.core.resolutionselector.ResolutionStrategy$ResolutionFallbackRule
class ResolutionStrategy_ResolutionFallbackRule extends jni.JObject {
  @override
  late final jni.JObjType<ResolutionStrategy_ResolutionFallbackRule> $type =
      type;

  ResolutionStrategy_ResolutionFallbackRule.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/core/resolutionselector/ResolutionStrategy$ResolutionFallbackRule');

  /// The type which includes information such as the signature of this class.
  static const type = $ResolutionStrategy_ResolutionFallbackRuleType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ResolutionStrategy_ResolutionFallbackRuleImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ResolutionStrategy_ResolutionFallbackRule.implement(
    $ResolutionStrategy_ResolutionFallbackRuleImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ResolutionStrategy_ResolutionFallbackRule.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.core.resolutionselector.ResolutionStrategy$ResolutionFallbackRule',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ResolutionStrategy_ResolutionFallbackRuleImpl {
  factory $ResolutionStrategy_ResolutionFallbackRuleImpl() =
      _$ResolutionStrategy_ResolutionFallbackRuleImpl;
}

class _$ResolutionStrategy_ResolutionFallbackRuleImpl
    implements $ResolutionStrategy_ResolutionFallbackRuleImpl {
  _$ResolutionStrategy_ResolutionFallbackRuleImpl();
}

final class $ResolutionStrategy_ResolutionFallbackRuleType
    extends jni.JObjType<ResolutionStrategy_ResolutionFallbackRule> {
  const $ResolutionStrategy_ResolutionFallbackRuleType();

  @override
  String get signature =>
      r'Landroidx/camera/core/resolutionselector/ResolutionStrategy$ResolutionFallbackRule;';

  @override
  ResolutionStrategy_ResolutionFallbackRule fromReference(
          jni.JReference reference) =>
      ResolutionStrategy_ResolutionFallbackRule.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResolutionStrategy_ResolutionFallbackRuleType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ResolutionStrategy_ResolutionFallbackRuleType) &&
        other is $ResolutionStrategy_ResolutionFallbackRuleType;
  }
}

/// from: androidx.camera.core.resolutionselector.ResolutionStrategy
class ResolutionStrategy extends jni.JObject {
  @override
  late final jni.JObjType<ResolutionStrategy> $type = type;

  ResolutionStrategy.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/core/resolutionselector/ResolutionStrategy');

  /// The type which includes information such as the signature of this class.
  static const type = $ResolutionStrategyType();
  static final _id_HIGHEST_AVAILABLE_STRATEGY = _class.staticFieldId(
    r'HIGHEST_AVAILABLE_STRATEGY',
    r'Landroidx/camera/core/resolutionselector/ResolutionStrategy;',
  );

  /// from: static public final androidx.camera.core.resolutionselector.ResolutionStrategy HIGHEST_AVAILABLE_STRATEGY
  /// The returned object must be released after use, by calling the [release] method.
  static ResolutionStrategy get HIGHEST_AVAILABLE_STRATEGY =>
      _id_HIGHEST_AVAILABLE_STRATEGY.get(
          _class, const $ResolutionStrategyType());

  /// from: static public final int FALLBACK_RULE_NONE
  static const FALLBACK_RULE_NONE = 0;

  /// from: static public final int FALLBACK_RULE_CLOSEST_HIGHER_THEN_LOWER
  static const FALLBACK_RULE_CLOSEST_HIGHER_THEN_LOWER = 1;

  /// from: static public final int FALLBACK_RULE_CLOSEST_HIGHER
  static const FALLBACK_RULE_CLOSEST_HIGHER = 2;

  /// from: static public final int FALLBACK_RULE_CLOSEST_LOWER_THEN_HIGHER
  static const FALLBACK_RULE_CLOSEST_LOWER_THEN_HIGHER = 3;

  /// from: static public final int FALLBACK_RULE_CLOSEST_LOWER
  static const FALLBACK_RULE_CLOSEST_LOWER = 4;
  static final _id_new0 = _class.constructorId(
    r'(Landroid/util/Size;I)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.util.Size size, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResolutionStrategy(
    Size size,
    int i,
  ) {
    return ResolutionStrategy.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, size.reference.pointer, i)
        .reference);
  }

  static final _id_getBoundSize = _class.instanceMethodId(
    r'getBoundSize',
    r'()Landroid/util/Size;',
  );

  static final _getBoundSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.util.Size getBoundSize()
  /// The returned object must be released after use, by calling the [release] method.
  Size getBoundSize() {
    return _getBoundSize(
            reference.pointer, _id_getBoundSize as jni.JMethodIDPtr)
        .object(const $SizeType());
  }

  static final _id_getFallbackRule = _class.instanceMethodId(
    r'getFallbackRule',
    r'()I',
  );

  static final _getFallbackRule = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getFallbackRule()
  int getFallbackRule() {
    return _getFallbackRule(
            reference.pointer, _id_getFallbackRule as jni.JMethodIDPtr)
        .integer;
  }
}

final class $ResolutionStrategyType extends jni.JObjType<ResolutionStrategy> {
  const $ResolutionStrategyType();

  @override
  String get signature =>
      r'Landroidx/camera/core/resolutionselector/ResolutionStrategy;';

  @override
  ResolutionStrategy fromReference(jni.JReference reference) =>
      ResolutionStrategy.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResolutionStrategyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResolutionStrategyType) &&
        other is $ResolutionStrategyType;
  }
}

/// from: androidx.camera.mlkit.vision.MlKitAnalyzer$Result
class MlKitAnalyzer_Result extends jni.JObject {
  @override
  late final jni.JObjType<MlKitAnalyzer_Result> $type = type;

  MlKitAnalyzer_Result.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/mlkit/vision/MlKitAnalyzer$Result');

  /// The type which includes information such as the signature of this class.
  static const type = $MlKitAnalyzer_ResultType();
  static final _id_new0 = _class.constructorId(
    r'(Ljava/util/Map;JLjava/util/Map;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.util.Map map, long j, java.util.Map map1)
  /// The returned object must be released after use, by calling the [release] method.
  factory MlKitAnalyzer_Result(
    jni.JMap<Detector<jni.JObject>, jni.JObject> map,
    int j,
    jni.JMap<Detector<jni.JObject>, jni.JObject> map1,
  ) {
    return MlKitAnalyzer_Result.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            map.reference.pointer,
            j,
            map1.reference.pointer)
        .reference);
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'(Lcom/google/mlkit/vision/interfaces/Detector;)Ljava/lang/Object;',
  );

  static final _getValue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public T getValue(com.google.mlkit.vision.interfaces.Detector detector)
  /// The returned object must be released after use, by calling the [release] method.
  $T getValue<$T extends jni.JObject>(
    Detector<$T> detector, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      (detector.$type as $DetectorType).DetectionResultT,
    ]) as jni.JObjType<$T>;
    return _getValue(reference.pointer, _id_getValue as jni.JMethodIDPtr,
            detector.reference.pointer)
        .object(T);
  }

  static final _id_getThrowable = _class.instanceMethodId(
    r'getThrowable',
    r'(Lcom/google/mlkit/vision/interfaces/Detector;)Ljava/lang/Throwable;',
  );

  static final _getThrowable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Throwable getThrowable(com.google.mlkit.vision.interfaces.Detector detector)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getThrowable(
    Detector<jni.JObject> detector,
  ) {
    return _getThrowable(reference.pointer,
            _id_getThrowable as jni.JMethodIDPtr, detector.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()J',
  );

  static final _getTimestamp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public long getTimestamp()
  int getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni.JMethodIDPtr)
        .long;
  }
}

final class $MlKitAnalyzer_ResultType
    extends jni.JObjType<MlKitAnalyzer_Result> {
  const $MlKitAnalyzer_ResultType();

  @override
  String get signature =>
      r'Landroidx/camera/mlkit/vision/MlKitAnalyzer$Result;';

  @override
  MlKitAnalyzer_Result fromReference(jni.JReference reference) =>
      MlKitAnalyzer_Result.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MlKitAnalyzer_ResultType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MlKitAnalyzer_ResultType) &&
        other is $MlKitAnalyzer_ResultType;
  }
}

/// from: androidx.camera.mlkit.vision.MlKitAnalyzer
class MlKitAnalyzer extends jni.JObject {
  @override
  late final jni.JObjType<MlKitAnalyzer> $type = type;

  MlKitAnalyzer.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/mlkit/vision/MlKitAnalyzer');

  /// The type which includes information such as the signature of this class.
  static const type = $MlKitAnalyzerType();
  static final _id_new0 = _class.constructorId(
    r'(Ljava/util/List;ILjava/util/concurrent/Executor;Landroidx/core/util/Consumer;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.util.List list, int i, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  factory MlKitAnalyzer(
    jni.JList<Detector<jni.JObject>> list,
    int i,
    Executor executor,
    Consumer<MlKitAnalyzer_Result> consumer,
  ) {
    return MlKitAnalyzer.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            list.reference.pointer,
            i,
            executor.reference.pointer,
            consumer.reference.pointer)
        .reference);
  }

  static final _id_analyze = _class.instanceMethodId(
    r'analyze',
    r'(Landroidx/camera/core/ImageProxy;)V',
  );

  static final _analyze = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void analyze(androidx.camera.core.ImageProxy imageProxy)
  void analyze(
    ImageProxy imageProxy,
  ) {
    _analyze(reference.pointer, _id_analyze as jni.JMethodIDPtr,
            imageProxy.reference.pointer)
        .check();
  }

  static final _id_getDefaultTargetResolution = _class.instanceMethodId(
    r'getDefaultTargetResolution',
    r'()Landroid/util/Size;',
  );

  static final _getDefaultTargetResolution = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.util.Size getDefaultTargetResolution()
  /// The returned object must be released after use, by calling the [release] method.
  Size getDefaultTargetResolution() {
    return _getDefaultTargetResolution(reference.pointer,
            _id_getDefaultTargetResolution as jni.JMethodIDPtr)
        .object(const $SizeType());
  }

  static final _id_getTargetCoordinateSystem = _class.instanceMethodId(
    r'getTargetCoordinateSystem',
    r'()I',
  );

  static final _getTargetCoordinateSystem = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int getTargetCoordinateSystem()
  int getTargetCoordinateSystem() {
    return _getTargetCoordinateSystem(reference.pointer,
            _id_getTargetCoordinateSystem as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_updateTransform = _class.instanceMethodId(
    r'updateTransform',
    r'(Landroid/graphics/Matrix;)V',
  );

  static final _updateTransform = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void updateTransform(android.graphics.Matrix matrix)
  void updateTransform(
    jni.JObject matrix,
  ) {
    _updateTransform(reference.pointer, _id_updateTransform as jni.JMethodIDPtr,
            matrix.reference.pointer)
        .check();
  }
}

final class $MlKitAnalyzerType extends jni.JObjType<MlKitAnalyzer> {
  const $MlKitAnalyzerType();

  @override
  String get signature => r'Landroidx/camera/mlkit/vision/MlKitAnalyzer;';

  @override
  MlKitAnalyzer fromReference(jni.JReference reference) =>
      MlKitAnalyzer.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MlKitAnalyzerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MlKitAnalyzerType) &&
        other is $MlKitAnalyzerType;
  }
}

/// from: androidx.camera.video.OutputResults
class OutputResults extends jni.JObject {
  @override
  late final jni.JObjType<OutputResults> $type = type;

  OutputResults.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/video/OutputResults');

  /// The type which includes information such as the signature of this class.
  static const type = $OutputResultsType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputResults() {
    return OutputResults.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getOutputUri = _class.instanceMethodId(
    r'getOutputUri',
    r'()Landroid/net/Uri;',
  );

  static final _getOutputUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract android.net.Uri getOutputUri()
  /// The returned object must be released after use, by calling the [release] method.
  Uri getOutputUri() {
    return _getOutputUri(
            reference.pointer, _id_getOutputUri as jni.JMethodIDPtr)
        .object(const $UriType());
  }
}

final class $OutputResultsType extends jni.JObjType<OutputResults> {
  const $OutputResultsType();

  @override
  String get signature => r'Landroidx/camera/video/OutputResults;';

  @override
  OutputResults fromReference(jni.JReference reference) =>
      OutputResults.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OutputResultsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OutputResultsType) &&
        other is $OutputResultsType;
  }
}

/// from: androidx.camera.video.Recording
class Recording extends jni.JObject {
  @override
  late final jni.JObjType<Recording> $type = type;

  Recording.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/camera/video/Recording');

  /// The type which includes information such as the signature of this class.
  static const type = $RecordingType();
  static final _id_isPersistent = _class.instanceMethodId(
    r'isPersistent',
    r'()Z',
  );

  static final _isPersistent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isPersistent()
  bool isPersistent() {
    return _isPersistent(
            reference.pointer, _id_isPersistent as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_pause = _class.instanceMethodId(
    r'pause',
    r'()V',
  );

  static final _pause = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void pause()
  void pause() {
    _pause(reference.pointer, _id_pause as jni.JMethodIDPtr).check();
  }

  static final _id_resume = _class.instanceMethodId(
    r'resume',
    r'()V',
  );

  static final _resume = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void resume()
  void resume() {
    _resume(reference.pointer, _id_resume as jni.JMethodIDPtr).check();
  }

  static final _id_stop = _class.instanceMethodId(
    r'stop',
    r'()V',
  );

  static final _stop = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void stop()
  void stop() {
    _stop(reference.pointer, _id_stop as jni.JMethodIDPtr).check();
  }

  static final _id_mute = _class.instanceMethodId(
    r'mute',
    r'(Z)V',
  );

  static final _mute = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void mute(boolean z)
  void mute(
    bool z,
  ) {
    _mute(reference.pointer, _id_mute as jni.JMethodIDPtr, z ? 1 : 0).check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_finalize = _class.instanceMethodId(
    r'finalize',
    r'()V',
  );

  static final _finalize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void finalize()
  void finalize() {
    _finalize(reference.pointer, _id_finalize as jni.JMethodIDPtr).check();
  }

  static final _id_isClosed = _class.instanceMethodId(
    r'isClosed',
    r'()Z',
  );

  static final _isClosed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isClosed()
  bool isClosed() {
    return _isClosed(reference.pointer, _id_isClosed as jni.JMethodIDPtr)
        .boolean;
  }
}

final class $RecordingType extends jni.JObjType<Recording> {
  const $RecordingType();

  @override
  String get signature => r'Landroidx/camera/video/Recording;';

  @override
  Recording fromReference(jni.JReference reference) =>
      Recording.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RecordingType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RecordingType) && other is $RecordingType;
  }
}

/// from: androidx.camera.video.VideoRecordEvent$Finalize$VideoRecordError
class VideoRecordEvent_Finalize_VideoRecordError extends jni.JObject {
  @override
  late final jni.JObjType<VideoRecordEvent_Finalize_VideoRecordError> $type =
      type;

  VideoRecordEvent_Finalize_VideoRecordError.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/video/VideoRecordEvent$Finalize$VideoRecordError');

  /// The type which includes information such as the signature of this class.
  static const type = $VideoRecordEvent_Finalize_VideoRecordErrorType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $VideoRecordEvent_Finalize_VideoRecordErrorImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory VideoRecordEvent_Finalize_VideoRecordError.implement(
    $VideoRecordEvent_Finalize_VideoRecordErrorImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = VideoRecordEvent_Finalize_VideoRecordError.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.video.VideoRecordEvent$Finalize$VideoRecordError',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $VideoRecordEvent_Finalize_VideoRecordErrorImpl {
  factory $VideoRecordEvent_Finalize_VideoRecordErrorImpl() =
      _$VideoRecordEvent_Finalize_VideoRecordErrorImpl;
}

class _$VideoRecordEvent_Finalize_VideoRecordErrorImpl
    implements $VideoRecordEvent_Finalize_VideoRecordErrorImpl {
  _$VideoRecordEvent_Finalize_VideoRecordErrorImpl();
}

final class $VideoRecordEvent_Finalize_VideoRecordErrorType
    extends jni.JObjType<VideoRecordEvent_Finalize_VideoRecordError> {
  const $VideoRecordEvent_Finalize_VideoRecordErrorType();

  @override
  String get signature =>
      r'Landroidx/camera/video/VideoRecordEvent$Finalize$VideoRecordError;';

  @override
  VideoRecordEvent_Finalize_VideoRecordError fromReference(
          jni.JReference reference) =>
      VideoRecordEvent_Finalize_VideoRecordError.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($VideoRecordEvent_Finalize_VideoRecordErrorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($VideoRecordEvent_Finalize_VideoRecordErrorType) &&
        other is $VideoRecordEvent_Finalize_VideoRecordErrorType;
  }
}

/// from: androidx.camera.video.VideoRecordEvent$Finalize
class VideoRecordEvent_Finalize extends VideoRecordEvent {
  @override
  late final jni.JObjType<VideoRecordEvent_Finalize> $type = type;

  VideoRecordEvent_Finalize.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/video/VideoRecordEvent$Finalize');

  /// The type which includes information such as the signature of this class.
  static const type = $VideoRecordEvent_FinalizeType();

  /// from: static public final int ERROR_NONE
  static const ERROR_NONE = 0;

  /// from: static public final int ERROR_UNKNOWN
  static const ERROR_UNKNOWN = 1;

  /// from: static public final int ERROR_FILE_SIZE_LIMIT_REACHED
  static const ERROR_FILE_SIZE_LIMIT_REACHED = 2;

  /// from: static public final int ERROR_INSUFFICIENT_STORAGE
  static const ERROR_INSUFFICIENT_STORAGE = 3;

  /// from: static public final int ERROR_SOURCE_INACTIVE
  static const ERROR_SOURCE_INACTIVE = 4;

  /// from: static public final int ERROR_INVALID_OUTPUT_OPTIONS
  static const ERROR_INVALID_OUTPUT_OPTIONS = 5;

  /// from: static public final int ERROR_ENCODING_FAILED
  static const ERROR_ENCODING_FAILED = 6;

  /// from: static public final int ERROR_RECORDER_ERROR
  static const ERROR_RECORDER_ERROR = 7;

  /// from: static public final int ERROR_NO_VALID_DATA
  static const ERROR_NO_VALID_DATA = 8;

  /// from: static public final int ERROR_DURATION_LIMIT_REACHED
  static const ERROR_DURATION_LIMIT_REACHED = 9;

  /// from: static public final int ERROR_RECORDING_GARBAGE_COLLECTED
  static const ERROR_RECORDING_GARBAGE_COLLECTED = 10;
  static final _id_getOutputResults = _class.instanceMethodId(
    r'getOutputResults',
    r'()Landroidx/camera/video/OutputResults;',
  );

  static final _getOutputResults = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.video.OutputResults getOutputResults()
  /// The returned object must be released after use, by calling the [release] method.
  OutputResults getOutputResults() {
    return _getOutputResults(
            reference.pointer, _id_getOutputResults as jni.JMethodIDPtr)
        .object(const $OutputResultsType());
  }

  static final _id_hasError = _class.instanceMethodId(
    r'hasError',
    r'()Z',
  );

  static final _hasError = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean hasError()
  bool hasError() {
    return _hasError(reference.pointer, _id_hasError as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getError = _class.instanceMethodId(
    r'getError',
    r'()I',
  );

  static final _getError = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getError()
  int getError() {
    return _getError(reference.pointer, _id_getError as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getCause = _class.instanceMethodId(
    r'getCause',
    r'()Ljava/lang/Throwable;',
  );

  static final _getCause = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Throwable getCause()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCause() {
    return _getCause(reference.pointer, _id_getCause as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $VideoRecordEvent_FinalizeType
    extends jni.JObjType<VideoRecordEvent_Finalize> {
  const $VideoRecordEvent_FinalizeType();

  @override
  String get signature => r'Landroidx/camera/video/VideoRecordEvent$Finalize;';

  @override
  VideoRecordEvent_Finalize fromReference(jni.JReference reference) =>
      VideoRecordEvent_Finalize.fromReference(reference);

  @override
  jni.JObjType get superType => const $VideoRecordEventType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($VideoRecordEvent_FinalizeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($VideoRecordEvent_FinalizeType) &&
        other is $VideoRecordEvent_FinalizeType;
  }
}

/// from: androidx.camera.video.VideoRecordEvent$Pause
class VideoRecordEvent_Pause extends VideoRecordEvent {
  @override
  late final jni.JObjType<VideoRecordEvent_Pause> $type = type;

  VideoRecordEvent_Pause.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/video/VideoRecordEvent$Pause');

  /// The type which includes information such as the signature of this class.
  static const type = $VideoRecordEvent_PauseType();
}

final class $VideoRecordEvent_PauseType
    extends jni.JObjType<VideoRecordEvent_Pause> {
  const $VideoRecordEvent_PauseType();

  @override
  String get signature => r'Landroidx/camera/video/VideoRecordEvent$Pause;';

  @override
  VideoRecordEvent_Pause fromReference(jni.JReference reference) =>
      VideoRecordEvent_Pause.fromReference(reference);

  @override
  jni.JObjType get superType => const $VideoRecordEventType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($VideoRecordEvent_PauseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($VideoRecordEvent_PauseType) &&
        other is $VideoRecordEvent_PauseType;
  }
}

/// from: androidx.camera.video.VideoRecordEvent$Resume
class VideoRecordEvent_Resume extends VideoRecordEvent {
  @override
  late final jni.JObjType<VideoRecordEvent_Resume> $type = type;

  VideoRecordEvent_Resume.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/video/VideoRecordEvent$Resume');

  /// The type which includes information such as the signature of this class.
  static const type = $VideoRecordEvent_ResumeType();
}

final class $VideoRecordEvent_ResumeType
    extends jni.JObjType<VideoRecordEvent_Resume> {
  const $VideoRecordEvent_ResumeType();

  @override
  String get signature => r'Landroidx/camera/video/VideoRecordEvent$Resume;';

  @override
  VideoRecordEvent_Resume fromReference(jni.JReference reference) =>
      VideoRecordEvent_Resume.fromReference(reference);

  @override
  jni.JObjType get superType => const $VideoRecordEventType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($VideoRecordEvent_ResumeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($VideoRecordEvent_ResumeType) &&
        other is $VideoRecordEvent_ResumeType;
  }
}

/// from: androidx.camera.video.VideoRecordEvent$Start
class VideoRecordEvent_Start extends VideoRecordEvent {
  @override
  late final jni.JObjType<VideoRecordEvent_Start> $type = type;

  VideoRecordEvent_Start.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/video/VideoRecordEvent$Start');

  /// The type which includes information such as the signature of this class.
  static const type = $VideoRecordEvent_StartType();
}

final class $VideoRecordEvent_StartType
    extends jni.JObjType<VideoRecordEvent_Start> {
  const $VideoRecordEvent_StartType();

  @override
  String get signature => r'Landroidx/camera/video/VideoRecordEvent$Start;';

  @override
  VideoRecordEvent_Start fromReference(jni.JReference reference) =>
      VideoRecordEvent_Start.fromReference(reference);

  @override
  jni.JObjType get superType => const $VideoRecordEventType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($VideoRecordEvent_StartType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($VideoRecordEvent_StartType) &&
        other is $VideoRecordEvent_StartType;
  }
}

/// from: androidx.camera.video.VideoRecordEvent$Status
class VideoRecordEvent_Status extends VideoRecordEvent {
  @override
  late final jni.JObjType<VideoRecordEvent_Status> $type = type;

  VideoRecordEvent_Status.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/video/VideoRecordEvent$Status');

  /// The type which includes information such as the signature of this class.
  static const type = $VideoRecordEvent_StatusType();
}

final class $VideoRecordEvent_StatusType
    extends jni.JObjType<VideoRecordEvent_Status> {
  const $VideoRecordEvent_StatusType();

  @override
  String get signature => r'Landroidx/camera/video/VideoRecordEvent$Status;';

  @override
  VideoRecordEvent_Status fromReference(jni.JReference reference) =>
      VideoRecordEvent_Status.fromReference(reference);

  @override
  jni.JObjType get superType => const $VideoRecordEventType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($VideoRecordEvent_StatusType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($VideoRecordEvent_StatusType) &&
        other is $VideoRecordEvent_StatusType;
  }
}

/// from: androidx.camera.video.VideoRecordEvent
class VideoRecordEvent extends jni.JObject {
  @override
  late final jni.JObjType<VideoRecordEvent> $type = type;

  VideoRecordEvent.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/video/VideoRecordEvent');

  /// The type which includes information such as the signature of this class.
  static const type = $VideoRecordEventType();
  static final _id_getRecordingStats = _class.instanceMethodId(
    r'getRecordingStats',
    r'()Landroidx/camera/video/RecordingStats;',
  );

  static final _getRecordingStats = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.video.RecordingStats getRecordingStats()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRecordingStats() {
    return _getRecordingStats(
            reference.pointer, _id_getRecordingStats as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getOutputOptions = _class.instanceMethodId(
    r'getOutputOptions',
    r'()Landroidx/camera/video/OutputOptions;',
  );

  static final _getOutputOptions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.video.OutputOptions getOutputOptions()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOutputOptions() {
    return _getOutputOptions(
            reference.pointer, _id_getOutputOptions as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $VideoRecordEventType extends jni.JObjType<VideoRecordEvent> {
  const $VideoRecordEventType();

  @override
  String get signature => r'Landroidx/camera/video/VideoRecordEvent;';

  @override
  VideoRecordEvent fromReference(jni.JReference reference) =>
      VideoRecordEvent.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($VideoRecordEventType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($VideoRecordEventType) &&
        other is $VideoRecordEventType;
  }
}

/// from: androidx.camera.view.CameraController$OutputSize$OutputAspectRatio
class CameraController_OutputSize_OutputAspectRatio extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_OutputSize_OutputAspectRatio> $type =
      type;

  CameraController_OutputSize_OutputAspectRatio.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/camera/view/CameraController$OutputSize$OutputAspectRatio');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_OutputSize_OutputAspectRatioType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CameraController_OutputSize_OutputAspectRatioImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory CameraController_OutputSize_OutputAspectRatio.implement(
    $CameraController_OutputSize_OutputAspectRatioImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = CameraController_OutputSize_OutputAspectRatio.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.view.CameraController$OutputSize$OutputAspectRatio',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CameraController_OutputSize_OutputAspectRatioImpl {
  factory $CameraController_OutputSize_OutputAspectRatioImpl() =
      _$CameraController_OutputSize_OutputAspectRatioImpl;
}

class _$CameraController_OutputSize_OutputAspectRatioImpl
    implements $CameraController_OutputSize_OutputAspectRatioImpl {
  _$CameraController_OutputSize_OutputAspectRatioImpl();
}

final class $CameraController_OutputSize_OutputAspectRatioType
    extends jni.JObjType<CameraController_OutputSize_OutputAspectRatio> {
  const $CameraController_OutputSize_OutputAspectRatioType();

  @override
  String get signature =>
      r'Landroidx/camera/view/CameraController$OutputSize$OutputAspectRatio;';

  @override
  CameraController_OutputSize_OutputAspectRatio fromReference(
          jni.JReference reference) =>
      CameraController_OutputSize_OutputAspectRatio.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($CameraController_OutputSize_OutputAspectRatioType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($CameraController_OutputSize_OutputAspectRatioType) &&
        other is $CameraController_OutputSize_OutputAspectRatioType;
  }
}

/// from: androidx.camera.view.CameraController$OutputSize
class CameraController_OutputSize extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_OutputSize> $type = type;

  CameraController_OutputSize.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/view/CameraController$OutputSize');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_OutputSizeType();

  /// from: static public final int UNASSIGNED_ASPECT_RATIO
  static const UNASSIGNED_ASPECT_RATIO = -1;
  static final _id_new0 = _class.constructorId(
    r'(I)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void <init>(int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraController_OutputSize(
    int i,
  ) {
    return CameraController_OutputSize.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr, i)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Landroid/util/Size;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.util.Size size)
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraController_OutputSize.new1(
    Size size,
  ) {
    return CameraController_OutputSize.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            size.reference.pointer)
        .reference);
  }

  static final _id_getAspectRatio = _class.instanceMethodId(
    r'getAspectRatio',
    r'()I',
  );

  static final _getAspectRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getAspectRatio()
  int getAspectRatio() {
    return _getAspectRatio(
            reference.pointer, _id_getAspectRatio as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getResolution = _class.instanceMethodId(
    r'getResolution',
    r'()Landroid/util/Size;',
  );

  static final _getResolution = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.util.Size getResolution()
  /// The returned object must be released after use, by calling the [release] method.
  Size getResolution() {
    return _getResolution(
            reference.pointer, _id_getResolution as jni.JMethodIDPtr)
        .object(const $SizeType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $CameraController_OutputSizeType
    extends jni.JObjType<CameraController_OutputSize> {
  const $CameraController_OutputSizeType();

  @override
  String get signature => r'Landroidx/camera/view/CameraController$OutputSize;';

  @override
  CameraController_OutputSize fromReference(jni.JReference reference) =>
      CameraController_OutputSize.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraController_OutputSizeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController_OutputSizeType) &&
        other is $CameraController_OutputSizeType;
  }
}

/// from: androidx.camera.view.CameraController$UseCases
class CameraController_UseCases extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_UseCases> $type = type;

  CameraController_UseCases.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/view/CameraController$UseCases');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_UseCasesType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CameraController_UseCasesImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory CameraController_UseCases.implement(
    $CameraController_UseCasesImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = CameraController_UseCases.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.camera.view.CameraController$UseCases',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CameraController_UseCasesImpl {
  factory $CameraController_UseCasesImpl() = _$CameraController_UseCasesImpl;
}

class _$CameraController_UseCasesImpl
    implements $CameraController_UseCasesImpl {
  _$CameraController_UseCasesImpl();
}

final class $CameraController_UseCasesType
    extends jni.JObjType<CameraController_UseCases> {
  const $CameraController_UseCasesType();

  @override
  String get signature => r'Landroidx/camera/view/CameraController$UseCases;';

  @override
  CameraController_UseCases fromReference(jni.JReference reference) =>
      CameraController_UseCases.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraController_UseCasesType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController_UseCasesType) &&
        other is $CameraController_UseCasesType;
  }
}

/// from: androidx.camera.view.CameraController
class CameraController extends jni.JObject {
  @override
  late final jni.JObjType<CameraController> $type = type;

  CameraController.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/view/CameraController');

  /// The type which includes information such as the signature of this class.
  static const type = $CameraControllerType();

  /// from: static public final int COORDINATE_SYSTEM_VIEW_REFERENCED
  static const COORDINATE_SYSTEM_VIEW_REFERENCED = 1;

  /// from: static public final int TAP_TO_FOCUS_NOT_STARTED
  static const TAP_TO_FOCUS_NOT_STARTED = 0;

  /// from: static public final int TAP_TO_FOCUS_STARTED
  static const TAP_TO_FOCUS_STARTED = 1;

  /// from: static public final int TAP_TO_FOCUS_FOCUSED
  static const TAP_TO_FOCUS_FOCUSED = 2;

  /// from: static public final int TAP_TO_FOCUS_NOT_FOCUSED
  static const TAP_TO_FOCUS_NOT_FOCUSED = 3;

  /// from: static public final int TAP_TO_FOCUS_FAILED
  static const TAP_TO_FOCUS_FAILED = 4;

  /// from: static public final int IMAGE_CAPTURE
  static const IMAGE_CAPTURE = 1;

  /// from: static public final int IMAGE_ANALYSIS
  static const IMAGE_ANALYSIS = 2;

  /// from: static public final int VIDEO_CAPTURE
  static const VIDEO_CAPTURE = 4;
  static final _id_getInitializationFuture = _class.instanceMethodId(
    r'getInitializationFuture',
    r'()Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _getInitializationFuture = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.common.util.concurrent.ListenableFuture getInitializationFuture()
  /// The returned object must be released after use, by calling the [release] method.
  ListenableFuture<jni.JObject> getInitializationFuture() {
    return _getInitializationFuture(
            reference.pointer, _id_getInitializationFuture as jni.JMethodIDPtr)
        .object(const $ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setEnabledUseCases = _class.instanceMethodId(
    r'setEnabledUseCases',
    r'(I)V',
  );

  static final _setEnabledUseCases = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setEnabledUseCases(int i)
  void setEnabledUseCases(
    int i,
  ) {
    _setEnabledUseCases(
            reference.pointer, _id_setEnabledUseCases as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setPreviewTargetSize = _class.instanceMethodId(
    r'setPreviewTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setPreviewTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setPreviewTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setPreviewTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setPreviewTargetSize(
            reference.pointer,
            _id_setPreviewTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getPreviewTargetSize = _class.instanceMethodId(
    r'getPreviewTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getPreviewTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getPreviewTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getPreviewTargetSize() {
    return _getPreviewTargetSize(
            reference.pointer, _id_getPreviewTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_setPreviewResolutionSelector = _class.instanceMethodId(
    r'setPreviewResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setPreviewResolutionSelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setPreviewResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)
  void setPreviewResolutionSelector(
    ResolutionSelector resolutionSelector,
  ) {
    _setPreviewResolutionSelector(
            reference.pointer,
            _id_setPreviewResolutionSelector as jni.JMethodIDPtr,
            resolutionSelector.reference.pointer)
        .check();
  }

  static final _id_getPreviewResolutionSelector = _class.instanceMethodId(
    r'getPreviewResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getPreviewResolutionSelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector getPreviewResolutionSelector()
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector getPreviewResolutionSelector() {
    return _getPreviewResolutionSelector(reference.pointer,
            _id_getPreviewResolutionSelector as jni.JMethodIDPtr)
        .object(const $ResolutionSelectorType());
  }

  static final _id_isImageCaptureEnabled = _class.instanceMethodId(
    r'isImageCaptureEnabled',
    r'()Z',
  );

  static final _isImageCaptureEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isImageCaptureEnabled()
  bool isImageCaptureEnabled() {
    return _isImageCaptureEnabled(
            reference.pointer, _id_isImageCaptureEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getImageCaptureFlashMode = _class.instanceMethodId(
    r'getImageCaptureFlashMode',
    r'()I',
  );

  static final _getImageCaptureFlashMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageCaptureFlashMode()
  int getImageCaptureFlashMode() {
    return _getImageCaptureFlashMode(
            reference.pointer, _id_getImageCaptureFlashMode as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageCaptureFlashMode = _class.instanceMethodId(
    r'setImageCaptureFlashMode',
    r'(I)V',
  );

  static final _setImageCaptureFlashMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageCaptureFlashMode(int i)
  void setImageCaptureFlashMode(
    int i,
  ) {
    _setImageCaptureFlashMode(reference.pointer,
            _id_setImageCaptureFlashMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setScreenFlashUiInfo = _class.instanceMethodId(
    r'setScreenFlashUiInfo',
    r'(Landroidx/camera/view/internal/ScreenFlashUiInfo;)V',
  );

  static final _setScreenFlashUiInfo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setScreenFlashUiInfo(androidx.camera.view.internal.ScreenFlashUiInfo screenFlashUiInfo)
  void setScreenFlashUiInfo(
    jni.JObject screenFlashUiInfo,
  ) {
    _setScreenFlashUiInfo(
            reference.pointer,
            _id_setScreenFlashUiInfo as jni.JMethodIDPtr,
            screenFlashUiInfo.reference.pointer)
        .check();
  }

  static final _id_updateScreenFlashToImageCapture = _class.instanceMethodId(
    r'updateScreenFlashToImageCapture',
    r'()V',
  );

  static final _updateScreenFlashToImageCapture = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void updateScreenFlashToImageCapture()
  void updateScreenFlashToImageCapture() {
    _updateScreenFlashToImageCapture(reference.pointer,
            _id_updateScreenFlashToImageCapture as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getScreenFlashUiInfoByPriority = _class.instanceMethodId(
    r'getScreenFlashUiInfoByPriority',
    r'()Landroidx/camera/view/internal/ScreenFlashUiInfo;',
  );

  static final _getScreenFlashUiInfoByPriority = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.internal.ScreenFlashUiInfo getScreenFlashUiInfoByPriority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getScreenFlashUiInfoByPriority() {
    return _getScreenFlashUiInfoByPriority(reference.pointer,
            _id_getScreenFlashUiInfoByPriority as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_takePicture = _class.instanceMethodId(
    r'takePicture',
    r'(Landroidx/camera/core/ImageCapture$OutputFileOptions;Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageSavedCallback;)V',
  );

  static final _takePicture = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void takePicture(androidx.camera.core.ImageCapture$OutputFileOptions outputFileOptions, java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageSavedCallback onImageSavedCallback)
  void takePicture(
    jni.JObject outputFileOptions,
    Executor executor,
    jni.JObject onImageSavedCallback,
  ) {
    _takePicture(
            reference.pointer,
            _id_takePicture as jni.JMethodIDPtr,
            outputFileOptions.reference.pointer,
            executor.reference.pointer,
            onImageSavedCallback.reference.pointer)
        .check();
  }

  static final _id_takePicture1 = _class.instanceMethodId(
    r'takePicture',
    r'(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageCapturedCallback;)V',
  );

  static final _takePicture1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void takePicture(java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageCapturedCallback onImageCapturedCallback)
  void takePicture1(
    Executor executor,
    jni.JObject onImageCapturedCallback,
  ) {
    _takePicture1(
            reference.pointer,
            _id_takePicture1 as jni.JMethodIDPtr,
            executor.reference.pointer,
            onImageCapturedCallback.reference.pointer)
        .check();
  }

  static final _id_setImageCaptureMode = _class.instanceMethodId(
    r'setImageCaptureMode',
    r'(I)V',
  );

  static final _setImageCaptureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageCaptureMode(int i)
  void setImageCaptureMode(
    int i,
  ) {
    _setImageCaptureMode(
            reference.pointer, _id_setImageCaptureMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getImageCaptureMode = _class.instanceMethodId(
    r'getImageCaptureMode',
    r'()I',
  );

  static final _getImageCaptureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageCaptureMode()
  int getImageCaptureMode() {
    return _getImageCaptureMode(
            reference.pointer, _id_getImageCaptureMode as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageCaptureTargetSize = _class.instanceMethodId(
    r'setImageCaptureTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setImageCaptureTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageCaptureTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setImageCaptureTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setImageCaptureTargetSize(
            reference.pointer,
            _id_setImageCaptureTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getImageCaptureTargetSize = _class.instanceMethodId(
    r'getImageCaptureTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getImageCaptureTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getImageCaptureTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getImageCaptureTargetSize() {
    return _getImageCaptureTargetSize(reference.pointer,
            _id_getImageCaptureTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_setImageCaptureResolutionSelector = _class.instanceMethodId(
    r'setImageCaptureResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setImageCaptureResolutionSelector =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageCaptureResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)
  void setImageCaptureResolutionSelector(
    ResolutionSelector resolutionSelector,
  ) {
    _setImageCaptureResolutionSelector(
            reference.pointer,
            _id_setImageCaptureResolutionSelector as jni.JMethodIDPtr,
            resolutionSelector.reference.pointer)
        .check();
  }

  static final _id_getImageCaptureResolutionSelector = _class.instanceMethodId(
    r'getImageCaptureResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getImageCaptureResolutionSelector =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector getImageCaptureResolutionSelector()
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector getImageCaptureResolutionSelector() {
    return _getImageCaptureResolutionSelector(reference.pointer,
            _id_getImageCaptureResolutionSelector as jni.JMethodIDPtr)
        .object(const $ResolutionSelectorType());
  }

  static final _id_setImageCaptureIoExecutor = _class.instanceMethodId(
    r'setImageCaptureIoExecutor',
    r'(Ljava/util/concurrent/Executor;)V',
  );

  static final _setImageCaptureIoExecutor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageCaptureIoExecutor(java.util.concurrent.Executor executor)
  void setImageCaptureIoExecutor(
    Executor executor,
  ) {
    _setImageCaptureIoExecutor(
            reference.pointer,
            _id_setImageCaptureIoExecutor as jni.JMethodIDPtr,
            executor.reference.pointer)
        .check();
  }

  static final _id_getImageCaptureIoExecutor = _class.instanceMethodId(
    r'getImageCaptureIoExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getImageCaptureIoExecutor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.concurrent.Executor getImageCaptureIoExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  Executor getImageCaptureIoExecutor() {
    return _getImageCaptureIoExecutor(reference.pointer,
            _id_getImageCaptureIoExecutor as jni.JMethodIDPtr)
        .object(const $ExecutorType());
  }

  static final _id_isImageAnalysisEnabled = _class.instanceMethodId(
    r'isImageAnalysisEnabled',
    r'()Z',
  );

  static final _isImageAnalysisEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isImageAnalysisEnabled()
  bool isImageAnalysisEnabled() {
    return _isImageAnalysisEnabled(
            reference.pointer, _id_isImageAnalysisEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setImageAnalysisAnalyzer = _class.instanceMethodId(
    r'setImageAnalysisAnalyzer',
    r'(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageAnalysis$Analyzer;)V',
  );

  static final _setImageAnalysisAnalyzer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisAnalyzer(java.util.concurrent.Executor executor, androidx.camera.core.ImageAnalysis$Analyzer analyzer)
  void setImageAnalysisAnalyzer(
    Executor executor,
    jni.JObject analyzer,
  ) {
    _setImageAnalysisAnalyzer(
            reference.pointer,
            _id_setImageAnalysisAnalyzer as jni.JMethodIDPtr,
            executor.reference.pointer,
            analyzer.reference.pointer)
        .check();
  }

  static final _id_clearImageAnalysisAnalyzer = _class.instanceMethodId(
    r'clearImageAnalysisAnalyzer',
    r'()V',
  );

  static final _clearImageAnalysisAnalyzer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void clearImageAnalysisAnalyzer()
  void clearImageAnalysisAnalyzer() {
    _clearImageAnalysisAnalyzer(reference.pointer,
            _id_clearImageAnalysisAnalyzer as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getImageAnalysisBackpressureStrategy =
      _class.instanceMethodId(
    r'getImageAnalysisBackpressureStrategy',
    r'()I',
  );

  static final _getImageAnalysisBackpressureStrategy =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public int getImageAnalysisBackpressureStrategy()
  int getImageAnalysisBackpressureStrategy() {
    return _getImageAnalysisBackpressureStrategy(reference.pointer,
            _id_getImageAnalysisBackpressureStrategy as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageAnalysisBackpressureStrategy =
      _class.instanceMethodId(
    r'setImageAnalysisBackpressureStrategy',
    r'(I)V',
  );

  static final _setImageAnalysisBackpressureStrategy =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageAnalysisBackpressureStrategy(int i)
  void setImageAnalysisBackpressureStrategy(
    int i,
  ) {
    _setImageAnalysisBackpressureStrategy(reference.pointer,
            _id_setImageAnalysisBackpressureStrategy as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setImageAnalysisImageQueueDepth = _class.instanceMethodId(
    r'setImageAnalysisImageQueueDepth',
    r'(I)V',
  );

  static final _setImageAnalysisImageQueueDepth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageAnalysisImageQueueDepth(int i)
  void setImageAnalysisImageQueueDepth(
    int i,
  ) {
    _setImageAnalysisImageQueueDepth(reference.pointer,
            _id_setImageAnalysisImageQueueDepth as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getImageAnalysisImageQueueDepth = _class.instanceMethodId(
    r'getImageAnalysisImageQueueDepth',
    r'()I',
  );

  static final _getImageAnalysisImageQueueDepth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageAnalysisImageQueueDepth()
  int getImageAnalysisImageQueueDepth() {
    return _getImageAnalysisImageQueueDepth(reference.pointer,
            _id_getImageAnalysisImageQueueDepth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageAnalysisTargetSize = _class.instanceMethodId(
    r'setImageAnalysisTargetSize',
    r'(Landroidx/camera/view/CameraController$OutputSize;)V',
  );

  static final _setImageAnalysisTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setImageAnalysisTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setImageAnalysisTargetSize(
            reference.pointer,
            _id_setImageAnalysisTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getImageAnalysisTargetSize = _class.instanceMethodId(
    r'getImageAnalysisTargetSize',
    r'()Landroidx/camera/view/CameraController$OutputSize;',
  );

  static final _getImageAnalysisTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getImageAnalysisTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getImageAnalysisTargetSize() {
    return _getImageAnalysisTargetSize(reference.pointer,
            _id_getImageAnalysisTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_setImageAnalysisResolutionSelector = _class.instanceMethodId(
    r'setImageAnalysisResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)V',
  );

  static final _setImageAnalysisResolutionSelector =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)
  void setImageAnalysisResolutionSelector(
    ResolutionSelector resolutionSelector,
  ) {
    _setImageAnalysisResolutionSelector(
            reference.pointer,
            _id_setImageAnalysisResolutionSelector as jni.JMethodIDPtr,
            resolutionSelector.reference.pointer)
        .check();
  }

  static final _id_getImageAnalysisResolutionSelector = _class.instanceMethodId(
    r'getImageAnalysisResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getImageAnalysisResolutionSelector =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public androidx.camera.core.resolutionselector.ResolutionSelector getImageAnalysisResolutionSelector()
  /// The returned object must be released after use, by calling the [release] method.
  ResolutionSelector getImageAnalysisResolutionSelector() {
    return _getImageAnalysisResolutionSelector(reference.pointer,
            _id_getImageAnalysisResolutionSelector as jni.JMethodIDPtr)
        .object(const $ResolutionSelectorType());
  }

  static final _id_setImageAnalysisBackgroundExecutor = _class.instanceMethodId(
    r'setImageAnalysisBackgroundExecutor',
    r'(Ljava/util/concurrent/Executor;)V',
  );

  static final _setImageAnalysisBackgroundExecutor =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisBackgroundExecutor(java.util.concurrent.Executor executor)
  void setImageAnalysisBackgroundExecutor(
    Executor executor,
  ) {
    _setImageAnalysisBackgroundExecutor(
            reference.pointer,
            _id_setImageAnalysisBackgroundExecutor as jni.JMethodIDPtr,
            executor.reference.pointer)
        .check();
  }

  static final _id_getImageAnalysisBackgroundExecutor = _class.instanceMethodId(
    r'getImageAnalysisBackgroundExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getImageAnalysisBackgroundExecutor =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public java.util.concurrent.Executor getImageAnalysisBackgroundExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  Executor getImageAnalysisBackgroundExecutor() {
    return _getImageAnalysisBackgroundExecutor(reference.pointer,
            _id_getImageAnalysisBackgroundExecutor as jni.JMethodIDPtr)
        .object(const $ExecutorType());
  }

  static final _id_setImageAnalysisOutputImageFormat = _class.instanceMethodId(
    r'setImageAnalysisOutputImageFormat',
    r'(I)V',
  );

  static final _setImageAnalysisOutputImageFormat =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageAnalysisOutputImageFormat(int i)
  void setImageAnalysisOutputImageFormat(
    int i,
  ) {
    _setImageAnalysisOutputImageFormat(reference.pointer,
            _id_setImageAnalysisOutputImageFormat as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getImageAnalysisOutputImageFormat = _class.instanceMethodId(
    r'getImageAnalysisOutputImageFormat',
    r'()I',
  );

  static final _getImageAnalysisOutputImageFormat =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public int getImageAnalysisOutputImageFormat()
  int getImageAnalysisOutputImageFormat() {
    return _getImageAnalysisOutputImageFormat(reference.pointer,
            _id_getImageAnalysisOutputImageFormat as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_isVideoCaptureEnabled = _class.instanceMethodId(
    r'isVideoCaptureEnabled',
    r'()Z',
  );

  static final _isVideoCaptureEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isVideoCaptureEnabled()
  bool isVideoCaptureEnabled() {
    return _isVideoCaptureEnabled(
            reference.pointer, _id_isVideoCaptureEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_startRecording = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/FileOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.FileOutputOptions fileOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  Recording startRecording(
    jni.JObject fileOutputOptions,
    AudioConfig audioConfig,
    Executor executor,
    Consumer<VideoRecordEvent> consumer,
  ) {
    return _startRecording(
            reference.pointer,
            _id_startRecording as jni.JMethodIDPtr,
            fileOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const $RecordingType());
  }

  static final _id_startRecording1 = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/FileDescriptorOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.FileDescriptorOutputOptions fileDescriptorOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  Recording startRecording1(
    jni.JObject fileDescriptorOutputOptions,
    AudioConfig audioConfig,
    Executor executor,
    Consumer<VideoRecordEvent> consumer,
  ) {
    return _startRecording1(
            reference.pointer,
            _id_startRecording1 as jni.JMethodIDPtr,
            fileDescriptorOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const $RecordingType());
  }

  static final _id_startRecording2 = _class.instanceMethodId(
    r'startRecording',
    r'(Landroidx/camera/video/MediaStoreOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;',
  );

  static final _startRecording2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.MediaStoreOutputOptions mediaStoreOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  Recording startRecording2(
    jni.JObject mediaStoreOutputOptions,
    AudioConfig audioConfig,
    Executor executor,
    Consumer<VideoRecordEvent> consumer,
  ) {
    return _startRecording2(
            reference.pointer,
            _id_startRecording2 as jni.JMethodIDPtr,
            mediaStoreOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const $RecordingType());
  }

  static final _id_isRecording = _class.instanceMethodId(
    r'isRecording',
    r'()Z',
  );

  static final _isRecording = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isRecording()
  bool isRecording() {
    return _isRecording(reference.pointer, _id_isRecording as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setVideoCaptureQualitySelector = _class.instanceMethodId(
    r'setVideoCaptureQualitySelector',
    r'(Landroidx/camera/video/QualitySelector;)V',
  );

  static final _setVideoCaptureQualitySelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setVideoCaptureQualitySelector(androidx.camera.video.QualitySelector qualitySelector)
  void setVideoCaptureQualitySelector(
    jni.JObject qualitySelector,
  ) {
    _setVideoCaptureQualitySelector(
            reference.pointer,
            _id_setVideoCaptureQualitySelector as jni.JMethodIDPtr,
            qualitySelector.reference.pointer)
        .check();
  }

  static final _id_getVideoCaptureQualitySelector = _class.instanceMethodId(
    r'getVideoCaptureQualitySelector',
    r'()Landroidx/camera/video/QualitySelector;',
  );

  static final _getVideoCaptureQualitySelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.video.QualitySelector getVideoCaptureQualitySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVideoCaptureQualitySelector() {
    return _getVideoCaptureQualitySelector(reference.pointer,
            _id_getVideoCaptureQualitySelector as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setVideoCaptureMirrorMode = _class.instanceMethodId(
    r'setVideoCaptureMirrorMode',
    r'(I)V',
  );

  static final _setVideoCaptureMirrorMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setVideoCaptureMirrorMode(int i)
  void setVideoCaptureMirrorMode(
    int i,
  ) {
    _setVideoCaptureMirrorMode(reference.pointer,
            _id_setVideoCaptureMirrorMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getVideoCaptureMirrorMode = _class.instanceMethodId(
    r'getVideoCaptureMirrorMode',
    r'()I',
  );

  static final _getVideoCaptureMirrorMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getVideoCaptureMirrorMode()
  int getVideoCaptureMirrorMode() {
    return _getVideoCaptureMirrorMode(reference.pointer,
            _id_getVideoCaptureMirrorMode as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setVideoCaptureDynamicRange = _class.instanceMethodId(
    r'setVideoCaptureDynamicRange',
    r'(Landroidx/camera/core/DynamicRange;)V',
  );

  static final _setVideoCaptureDynamicRange = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setVideoCaptureDynamicRange(androidx.camera.core.DynamicRange dynamicRange)
  void setVideoCaptureDynamicRange(
    jni.JObject dynamicRange,
  ) {
    _setVideoCaptureDynamicRange(
            reference.pointer,
            _id_setVideoCaptureDynamicRange as jni.JMethodIDPtr,
            dynamicRange.reference.pointer)
        .check();
  }

  static final _id_getVideoCaptureDynamicRange = _class.instanceMethodId(
    r'getVideoCaptureDynamicRange',
    r'()Landroidx/camera/core/DynamicRange;',
  );

  static final _getVideoCaptureDynamicRange = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.DynamicRange getVideoCaptureDynamicRange()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVideoCaptureDynamicRange() {
    return _getVideoCaptureDynamicRange(reference.pointer,
            _id_getVideoCaptureDynamicRange as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setVideoCaptureTargetFrameRate = _class.instanceMethodId(
    r'setVideoCaptureTargetFrameRate',
    r'(Landroid/util/Range;)V',
  );

  static final _setVideoCaptureTargetFrameRate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setVideoCaptureTargetFrameRate(android.util.Range range)
  void setVideoCaptureTargetFrameRate(
    jni.JObject range,
  ) {
    _setVideoCaptureTargetFrameRate(
            reference.pointer,
            _id_setVideoCaptureTargetFrameRate as jni.JMethodIDPtr,
            range.reference.pointer)
        .check();
  }

  static final _id_getVideoCaptureTargetFrameRate = _class.instanceMethodId(
    r'getVideoCaptureTargetFrameRate',
    r'()Landroid/util/Range;',
  );

  static final _getVideoCaptureTargetFrameRate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.util.Range getVideoCaptureTargetFrameRate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVideoCaptureTargetFrameRate() {
    return _getVideoCaptureTargetFrameRate(reference.pointer,
            _id_getVideoCaptureTargetFrameRate as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setCameraSelector = _class.instanceMethodId(
    r'setCameraSelector',
    r'(Landroidx/camera/core/CameraSelector;)V',
  );

  static final _setCameraSelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setCameraSelector(androidx.camera.core.CameraSelector cameraSelector)
  void setCameraSelector(
    CameraSelector cameraSelector,
  ) {
    _setCameraSelector(
            reference.pointer,
            _id_setCameraSelector as jni.JMethodIDPtr,
            cameraSelector.reference.pointer)
        .check();
  }

  static final _id_hasCamera = _class.instanceMethodId(
    r'hasCamera',
    r'(Landroidx/camera/core/CameraSelector;)Z',
  );

  static final _hasCamera = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasCamera(androidx.camera.core.CameraSelector cameraSelector)
  bool hasCamera(
    CameraSelector cameraSelector,
  ) {
    return _hasCamera(reference.pointer, _id_hasCamera as jni.JMethodIDPtr,
            cameraSelector.reference.pointer)
        .boolean;
  }

  static final _id_getCameraSelector = _class.instanceMethodId(
    r'getCameraSelector',
    r'()Landroidx/camera/core/CameraSelector;',
  );

  static final _getCameraSelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraSelector getCameraSelector()
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector getCameraSelector() {
    return _getCameraSelector(
            reference.pointer, _id_getCameraSelector as jni.JMethodIDPtr)
        .object(const $CameraSelectorType());
  }

  static final _id_isPinchToZoomEnabled = _class.instanceMethodId(
    r'isPinchToZoomEnabled',
    r'()Z',
  );

  static final _isPinchToZoomEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isPinchToZoomEnabled()
  bool isPinchToZoomEnabled() {
    return _isPinchToZoomEnabled(
            reference.pointer, _id_isPinchToZoomEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPinchToZoomEnabled = _class.instanceMethodId(
    r'setPinchToZoomEnabled',
    r'(Z)V',
  );

  static final _setPinchToZoomEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setPinchToZoomEnabled(boolean z)
  void setPinchToZoomEnabled(
    bool z,
  ) {
    _setPinchToZoomEnabled(reference.pointer,
            _id_setPinchToZoomEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isTapToFocusEnabled = _class.instanceMethodId(
    r'isTapToFocusEnabled',
    r'()Z',
  );

  static final _isTapToFocusEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isTapToFocusEnabled()
  bool isTapToFocusEnabled() {
    return _isTapToFocusEnabled(
            reference.pointer, _id_isTapToFocusEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setTapToFocusEnabled = _class.instanceMethodId(
    r'setTapToFocusEnabled',
    r'(Z)V',
  );

  static final _setTapToFocusEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setTapToFocusEnabled(boolean z)
  void setTapToFocusEnabled(
    bool z,
  ) {
    _setTapToFocusEnabled(reference.pointer,
            _id_setTapToFocusEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getTapToFocusState = _class.instanceMethodId(
    r'getTapToFocusState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getTapToFocusState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getTapToFocusState()
  /// The returned object must be released after use, by calling the [release] method.
  LiveData<jni.JInteger> getTapToFocusState() {
    return _getTapToFocusState(
            reference.pointer, _id_getTapToFocusState as jni.JMethodIDPtr)
        .object(const $LiveDataType(jni.JIntegerType()));
  }

  static final _id_getZoomState = _class.instanceMethodId(
    r'getZoomState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getZoomState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getZoomState()
  /// The returned object must be released after use, by calling the [release] method.
  LiveData<ZoomState> getZoomState() {
    return _getZoomState(
            reference.pointer, _id_getZoomState as jni.JMethodIDPtr)
        .object(const $LiveDataType($ZoomStateType()));
  }

  static final _id_getCameraInfo = _class.instanceMethodId(
    r'getCameraInfo',
    r'()Landroidx/camera/core/CameraInfo;',
  );

  static final _getCameraInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraInfo getCameraInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCameraInfo() {
    return _getCameraInfo(
            reference.pointer, _id_getCameraInfo as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getCameraControl = _class.instanceMethodId(
    r'getCameraControl',
    r'()Landroidx/camera/core/CameraControl;',
  );

  static final _getCameraControl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraControl getCameraControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCameraControl() {
    return _getCameraControl(
            reference.pointer, _id_getCameraControl as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setZoomRatio = _class.instanceMethodId(
    r'setZoomRatio',
    r'(F)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _setZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture setZoomRatio(float f)
  /// The returned object must be released after use, by calling the [release] method.
  ListenableFuture<jni.JObject> setZoomRatio(
    double f,
  ) {
    return _setZoomRatio(
            reference.pointer, _id_setZoomRatio as jni.JMethodIDPtr, f)
        .object(const $ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setLinearZoom = _class.instanceMethodId(
    r'setLinearZoom',
    r'(F)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _setLinearZoom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture setLinearZoom(float f)
  /// The returned object must be released after use, by calling the [release] method.
  ListenableFuture<jni.JObject> setLinearZoom(
    double f,
  ) {
    return _setLinearZoom(
            reference.pointer, _id_setLinearZoom as jni.JMethodIDPtr, f)
        .object(const $ListenableFutureType(jni.JObjectType()));
  }

  static final _id_getTorchState = _class.instanceMethodId(
    r'getTorchState',
    r'()Landroidx/lifecycle/LiveData;',
  );

  static final _getTorchState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getTorchState()
  /// The returned object must be released after use, by calling the [release] method.
  LiveData<jni.JInteger> getTorchState() {
    return _getTorchState(
            reference.pointer, _id_getTorchState as jni.JMethodIDPtr)
        .object(const $LiveDataType(jni.JIntegerType()));
  }

  static final _id_enableTorch = _class.instanceMethodId(
    r'enableTorch',
    r'(Z)Lcom/google/common/util/concurrent/ListenableFuture;',
  );

  static final _enableTorch = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture enableTorch(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  ListenableFuture<jni.JObject> enableTorch(
    bool z,
  ) {
    return _enableTorch(
            reference.pointer, _id_enableTorch as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setEffects = _class.instanceMethodId(
    r'setEffects',
    r'(Ljava/util/Set;)V',
  );

  static final _setEffects = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setEffects(java.util.Set set)
  void setEffects(
    jni.JSet<jni.JObject> set0,
  ) {
    _setEffects(reference.pointer, _id_setEffects as jni.JMethodIDPtr,
            set0.reference.pointer)
        .check();
  }

  static final _id_clearEffects = _class.instanceMethodId(
    r'clearEffects',
    r'()V',
  );

  static final _clearEffects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void clearEffects()
  void clearEffects() {
    _clearEffects(reference.pointer, _id_clearEffects as jni.JMethodIDPtr)
        .check();
  }

  static final _id_createUseCaseGroup = _class.instanceMethodId(
    r'createUseCaseGroup',
    r'()Landroidx/camera/core/UseCaseGroup;',
  );

  static final _createUseCaseGroup = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected androidx.camera.core.UseCaseGroup createUseCaseGroup()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createUseCaseGroup() {
    return _createUseCaseGroup(
            reference.pointer, _id_createUseCaseGroup as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $CameraControllerType extends jni.JObjType<CameraController> {
  const $CameraControllerType();

  @override
  String get signature => r'Landroidx/camera/view/CameraController;';

  @override
  CameraController fromReference(jni.JReference reference) =>
      CameraController.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraControllerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraControllerType) &&
        other is $CameraControllerType;
  }
}

/// from: androidx.camera.view.LifecycleCameraController
class LifecycleCameraController extends CameraController {
  @override
  late final jni.JObjType<LifecycleCameraController> $type = type;

  LifecycleCameraController.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/view/LifecycleCameraController');

  /// The type which includes information such as the signature of this class.
  static const type = $LifecycleCameraControllerType();
  static final _id_new0 = _class.constructorId(
    r'(Landroid/content/Context;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory LifecycleCameraController(
    Context context,
  ) {
    return LifecycleCameraController.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            context.reference.pointer)
        .reference);
  }

  static final _id_bindToLifecycle = _class.instanceMethodId(
    r'bindToLifecycle',
    r'(Landroidx/lifecycle/LifecycleOwner;)V',
  );

  static final _bindToLifecycle = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void bindToLifecycle(androidx.lifecycle.LifecycleOwner lifecycleOwner)
  void bindToLifecycle(
    LifecycleOwner lifecycleOwner,
  ) {
    _bindToLifecycle(reference.pointer, _id_bindToLifecycle as jni.JMethodIDPtr,
            lifecycleOwner.reference.pointer)
        .check();
  }

  static final _id_unbind = _class.instanceMethodId(
    r'unbind',
    r'()V',
  );

  static final _unbind = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void unbind()
  void unbind() {
    _unbind(reference.pointer, _id_unbind as jni.JMethodIDPtr).check();
  }
}

final class $LifecycleCameraControllerType
    extends jni.JObjType<LifecycleCameraController> {
  const $LifecycleCameraControllerType();

  @override
  String get signature => r'Landroidx/camera/view/LifecycleCameraController;';

  @override
  LifecycleCameraController fromReference(jni.JReference reference) =>
      LifecycleCameraController.fromReference(reference);

  @override
  jni.JObjType get superType => const $CameraControllerType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($LifecycleCameraControllerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($LifecycleCameraControllerType) &&
        other is $LifecycleCameraControllerType;
  }
}

/// from: androidx.camera.view.video.AudioConfig
class AudioConfig extends jni.JObject {
  @override
  late final jni.JObjType<AudioConfig> $type = type;

  AudioConfig.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/camera/view/video/AudioConfig');

  /// The type which includes information such as the signature of this class.
  static const type = $AudioConfigType();
  static final _id_AUDIO_DISABLED = _class.staticFieldId(
    r'AUDIO_DISABLED',
    r'Landroidx/camera/view/video/AudioConfig;',
  );

  /// from: static public final androidx.camera.view.video.AudioConfig AUDIO_DISABLED
  /// The returned object must be released after use, by calling the [release] method.
  static AudioConfig get AUDIO_DISABLED =>
      _id_AUDIO_DISABLED.get(_class, const $AudioConfigType());

  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Z)Landroidx/camera/view/video/AudioConfig;',
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public androidx.camera.view.video.AudioConfig create(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static AudioConfig create(
    bool z,
  ) {
    return _create(
            _class.reference.pointer, _id_create as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $AudioConfigType());
  }

  static final _id_getAudioEnabled = _class.instanceMethodId(
    r'getAudioEnabled',
    r'()Z',
  );

  static final _getAudioEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean getAudioEnabled()
  bool getAudioEnabled() {
    return _getAudioEnabled(
            reference.pointer, _id_getAudioEnabled as jni.JMethodIDPtr)
        .boolean;
  }
}

final class $AudioConfigType extends jni.JObjType<AudioConfig> {
  const $AudioConfigType();

  @override
  String get signature => r'Landroidx/camera/view/video/AudioConfig;';

  @override
  AudioConfig fromReference(jni.JReference reference) =>
      AudioConfig.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($AudioConfigType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($AudioConfigType) && other is $AudioConfigType;
  }
}

/// from: androidx.core.content.ContextCompat$RegisterReceiverFlags
class ContextCompat_RegisterReceiverFlags extends jni.JObject {
  @override
  late final jni.JObjType<ContextCompat_RegisterReceiverFlags> $type = type;

  ContextCompat_RegisterReceiverFlags.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/core/content/ContextCompat$RegisterReceiverFlags');

  /// The type which includes information such as the signature of this class.
  static const type = $ContextCompat_RegisterReceiverFlagsType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ContextCompat_RegisterReceiverFlagsImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ContextCompat_RegisterReceiverFlags.implement(
    $ContextCompat_RegisterReceiverFlagsImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ContextCompat_RegisterReceiverFlags.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.core.content.ContextCompat$RegisterReceiverFlags',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ContextCompat_RegisterReceiverFlagsImpl {
  factory $ContextCompat_RegisterReceiverFlagsImpl() =
      _$ContextCompat_RegisterReceiverFlagsImpl;
}

class _$ContextCompat_RegisterReceiverFlagsImpl
    implements $ContextCompat_RegisterReceiverFlagsImpl {
  _$ContextCompat_RegisterReceiverFlagsImpl();
}

final class $ContextCompat_RegisterReceiverFlagsType
    extends jni.JObjType<ContextCompat_RegisterReceiverFlags> {
  const $ContextCompat_RegisterReceiverFlagsType();

  @override
  String get signature =>
      r'Landroidx/core/content/ContextCompat$RegisterReceiverFlags;';

  @override
  ContextCompat_RegisterReceiverFlags fromReference(jni.JReference reference) =>
      ContextCompat_RegisterReceiverFlags.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ContextCompat_RegisterReceiverFlagsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContextCompat_RegisterReceiverFlagsType) &&
        other is $ContextCompat_RegisterReceiverFlagsType;
  }
}

/// from: androidx.core.content.ContextCompat
class ContextCompat extends jni.JObject {
  @override
  late final jni.JObjType<ContextCompat> $type = type;

  ContextCompat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/core/content/ContextCompat');

  /// The type which includes information such as the signature of this class.
  static const type = $ContextCompatType();

  /// from: static public final int RECEIVER_VISIBLE_TO_INSTANT_APPS
  static const RECEIVER_VISIBLE_TO_INSTANT_APPS = 1;

  /// from: static public final int RECEIVER_EXPORTED
  static const RECEIVER_EXPORTED = 2;

  /// from: static public final int RECEIVER_NOT_EXPORTED
  static const RECEIVER_NOT_EXPORTED = 4;
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ContextCompat() {
    return ContextCompat.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_startActivities = _class.staticMethodId(
    r'startActivities',
    r'(Landroid/content/Context;[Landroid/content/Intent;)Z',
  );

  static final _startActivities = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean startActivities(android.content.Context context, android.content.Intent[] intents)
  static bool startActivities(
    Context context,
    jni.JArray<jni.JObject> intents,
  ) {
    return _startActivities(
            _class.reference.pointer,
            _id_startActivities as jni.JMethodIDPtr,
            context.reference.pointer,
            intents.reference.pointer)
        .boolean;
  }

  static final _id_startActivities1 = _class.staticMethodId(
    r'startActivities',
    r'(Landroid/content/Context;[Landroid/content/Intent;Landroid/os/Bundle;)Z',
  );

  static final _startActivities1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean startActivities(android.content.Context context, android.content.Intent[] intents, android.os.Bundle bundle)
  static bool startActivities1(
    Context context,
    jni.JArray<jni.JObject> intents,
    jni.JObject bundle,
  ) {
    return _startActivities1(
            _class.reference.pointer,
            _id_startActivities1 as jni.JMethodIDPtr,
            context.reference.pointer,
            intents.reference.pointer,
            bundle.reference.pointer)
        .boolean;
  }

  static final _id_startActivity = _class.staticMethodId(
    r'startActivity',
    r'(Landroid/content/Context;Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void startActivity(android.content.Context context, android.content.Intent intent, android.os.Bundle bundle)
  static void startActivity(
    Context context,
    jni.JObject intent,
    jni.JObject bundle,
  ) {
    _startActivity(
            _class.reference.pointer,
            _id_startActivity as jni.JMethodIDPtr,
            context.reference.pointer,
            intent.reference.pointer,
            bundle.reference.pointer)
        .check();
  }

  static final _id_getDataDir = _class.staticMethodId(
    r'getDataDir',
    r'(Landroid/content/Context;)Ljava/io/File;',
  );

  static final _getDataDir = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File getDataDir(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getDataDir(
    Context context,
  ) {
    return _getDataDir(_class.reference.pointer,
            _id_getDataDir as jni.JMethodIDPtr, context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getObbDirs = _class.staticMethodId(
    r'getObbDirs',
    r'(Landroid/content/Context;)[Ljava/io/File;',
  );

  static final _getObbDirs = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File[] getObbDirs(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> getObbDirs(
    Context context,
  ) {
    return _getObbDirs(_class.reference.pointer,
            _id_getObbDirs as jni.JMethodIDPtr, context.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getExternalFilesDirs = _class.staticMethodId(
    r'getExternalFilesDirs',
    r'(Landroid/content/Context;Ljava/lang/String;)[Ljava/io/File;',
  );

  static final _getExternalFilesDirs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File[] getExternalFilesDirs(android.content.Context context, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> getExternalFilesDirs(
    Context context,
    jni.JString string,
  ) {
    return _getExternalFilesDirs(
            _class.reference.pointer,
            _id_getExternalFilesDirs as jni.JMethodIDPtr,
            context.reference.pointer,
            string.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getExternalCacheDirs = _class.staticMethodId(
    r'getExternalCacheDirs',
    r'(Landroid/content/Context;)[Ljava/io/File;',
  );

  static final _getExternalCacheDirs = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File[] getExternalCacheDirs(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> getExternalCacheDirs(
    Context context,
  ) {
    return _getExternalCacheDirs(
            _class.reference.pointer,
            _id_getExternalCacheDirs as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getDrawable = _class.staticMethodId(
    r'getDrawable',
    r'(Landroid/content/Context;I)Landroid/graphics/drawable/Drawable;',
  );

  static final _getDrawable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.drawable.Drawable getDrawable(android.content.Context context, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getDrawable(
    Context context,
    int i,
  ) {
    return _getDrawable(_class.reference.pointer,
            _id_getDrawable as jni.JMethodIDPtr, context.reference.pointer, i)
        .object(const jni.JObjectType());
  }

  static final _id_getColorStateList = _class.staticMethodId(
    r'getColorStateList',
    r'(Landroid/content/Context;I)Landroid/content/res/ColorStateList;',
  );

  static final _getColorStateList = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.content.res.ColorStateList getColorStateList(android.content.Context context, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getColorStateList(
    Context context,
    int i,
  ) {
    return _getColorStateList(
            _class.reference.pointer,
            _id_getColorStateList as jni.JMethodIDPtr,
            context.reference.pointer,
            i)
        .object(const jni.JObjectType());
  }

  static final _id_getColor = _class.staticMethodId(
    r'getColor',
    r'(Landroid/content/Context;I)I',
  );

  static final _getColor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public int getColor(android.content.Context context, int i)
  static int getColor(
    Context context,
    int i,
  ) {
    return _getColor(_class.reference.pointer, _id_getColor as jni.JMethodIDPtr,
            context.reference.pointer, i)
        .integer;
  }

  static final _id_checkSelfPermission = _class.staticMethodId(
    r'checkSelfPermission',
    r'(Landroid/content/Context;Ljava/lang/String;)I',
  );

  static final _checkSelfPermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public int checkSelfPermission(android.content.Context context, java.lang.String string)
  static int checkSelfPermission(
    Context context,
    jni.JString string,
  ) {
    return _checkSelfPermission(
            _class.reference.pointer,
            _id_checkSelfPermission as jni.JMethodIDPtr,
            context.reference.pointer,
            string.reference.pointer)
        .integer;
  }

  static final _id_getNoBackupFilesDir = _class.staticMethodId(
    r'getNoBackupFilesDir',
    r'(Landroid/content/Context;)Ljava/io/File;',
  );

  static final _getNoBackupFilesDir = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File getNoBackupFilesDir(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getNoBackupFilesDir(
    Context context,
  ) {
    return _getNoBackupFilesDir(
            _class.reference.pointer,
            _id_getNoBackupFilesDir as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getCodeCacheDir = _class.staticMethodId(
    r'getCodeCacheDir',
    r'(Landroid/content/Context;)Ljava/io/File;',
  );

  static final _getCodeCacheDir = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File getCodeCacheDir(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getCodeCacheDir(
    Context context,
  ) {
    return _getCodeCacheDir(_class.reference.pointer,
            _id_getCodeCacheDir as jni.JMethodIDPtr, context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_createDeviceProtectedStorageContext = _class.staticMethodId(
    r'createDeviceProtectedStorageContext',
    r'(Landroid/content/Context;)Landroid/content/Context;',
  );

  static final _createDeviceProtectedStorageContext =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Context createDeviceProtectedStorageContext(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static Context createDeviceProtectedStorageContext(
    Context context,
  ) {
    return _createDeviceProtectedStorageContext(
            _class.reference.pointer,
            _id_createDeviceProtectedStorageContext as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_isDeviceProtectedStorage = _class.staticMethodId(
    r'isDeviceProtectedStorage',
    r'(Landroid/content/Context;)Z',
  );

  static final _isDeviceProtectedStorage = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isDeviceProtectedStorage(android.content.Context context)
  static bool isDeviceProtectedStorage(
    Context context,
  ) {
    return _isDeviceProtectedStorage(
            _class.reference.pointer,
            _id_isDeviceProtectedStorage as jni.JMethodIDPtr,
            context.reference.pointer)
        .boolean;
  }

  static final _id_getMainExecutor = _class.staticMethodId(
    r'getMainExecutor',
    r'(Landroid/content/Context;)Ljava/util/concurrent/Executor;',
  );

  static final _getMainExecutor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Executor getMainExecutor(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static Executor getMainExecutor(
    Context context,
  ) {
    return _getMainExecutor(_class.reference.pointer,
            _id_getMainExecutor as jni.JMethodIDPtr, context.reference.pointer)
        .object(const $ExecutorType());
  }

  static final _id_startForegroundService = _class.staticMethodId(
    r'startForegroundService',
    r'(Landroid/content/Context;Landroid/content/Intent;)V',
  );

  static final _startForegroundService = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void startForegroundService(android.content.Context context, android.content.Intent intent)
  static void startForegroundService(
    Context context,
    jni.JObject intent,
  ) {
    _startForegroundService(
            _class.reference.pointer,
            _id_startForegroundService as jni.JMethodIDPtr,
            context.reference.pointer,
            intent.reference.pointer)
        .check();
  }

  static final _id_getDisplayOrDefault = _class.staticMethodId(
    r'getDisplayOrDefault',
    r'(Landroid/content/Context;)Landroid/view/Display;',
  );

  static final _getDisplayOrDefault = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.view.Display getDisplayOrDefault(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getDisplayOrDefault(
    Context context,
  ) {
    return _getDisplayOrDefault(
            _class.reference.pointer,
            _id_getDisplayOrDefault as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getSystemService = _class.staticMethodId(
    r'getSystemService',
    r'(Landroid/content/Context;Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getSystemService = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public T getSystemService(android.content.Context context, java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  static $T getSystemService<$T extends jni.JObject>(
    Context context,
    jni.JObject class0, {
    required jni.JObjType<$T> T,
  }) {
    return _getSystemService(
            _class.reference.pointer,
            _id_getSystemService as jni.JMethodIDPtr,
            context.reference.pointer,
            class0.reference.pointer)
        .object(T);
  }

  static final _id_registerReceiver = _class.staticMethodId(
    r'registerReceiver',
    r'(Landroid/content/Context;Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;I)Landroid/content/Intent;',
  );

  static final _registerReceiver = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: static public android.content.Intent registerReceiver(android.content.Context context, android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject registerReceiver(
    Context context,
    jni.JObject broadcastReceiver,
    jni.JObject intentFilter,
    int i,
  ) {
    return _registerReceiver(
            _class.reference.pointer,
            _id_registerReceiver as jni.JMethodIDPtr,
            context.reference.pointer,
            broadcastReceiver.reference.pointer,
            intentFilter.reference.pointer,
            i)
        .object(const jni.JObjectType());
  }

  static final _id_registerReceiver1 = _class.staticMethodId(
    r'registerReceiver',
    r'(Landroid/content/Context;Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;I)Landroid/content/Intent;',
  );

  static final _registerReceiver1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: static public android.content.Intent registerReceiver(android.content.Context context, android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, java.lang.String string, android.os.Handler handler, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject registerReceiver1(
    Context context,
    jni.JObject broadcastReceiver,
    jni.JObject intentFilter,
    jni.JString string,
    jni.JObject handler,
    int i,
  ) {
    return _registerReceiver1(
            _class.reference.pointer,
            _id_registerReceiver1 as jni.JMethodIDPtr,
            context.reference.pointer,
            broadcastReceiver.reference.pointer,
            intentFilter.reference.pointer,
            string.reference.pointer,
            handler.reference.pointer,
            i)
        .object(const jni.JObjectType());
  }

  static final _id_getSystemServiceName = _class.staticMethodId(
    r'getSystemServiceName',
    r'(Landroid/content/Context;Ljava/lang/Class;)Ljava/lang/String;',
  );

  static final _getSystemServiceName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getSystemServiceName(android.content.Context context, java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getSystemServiceName(
    Context context,
    jni.JObject class0,
  ) {
    return _getSystemServiceName(
            _class.reference.pointer,
            _id_getSystemServiceName as jni.JMethodIDPtr,
            context.reference.pointer,
            class0.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getString = _class.staticMethodId(
    r'getString',
    r'(Landroid/content/Context;I)Ljava/lang/String;',
  );

  static final _getString = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public java.lang.String getString(android.content.Context context, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getString(
    Context context,
    int i,
  ) {
    return _getString(_class.reference.pointer,
            _id_getString as jni.JMethodIDPtr, context.reference.pointer, i)
        .object(const jni.JStringType());
  }

  static final _id_getContextForLanguage = _class.staticMethodId(
    r'getContextForLanguage',
    r'(Landroid/content/Context;)Landroid/content/Context;',
  );

  static final _getContextForLanguage = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Context getContextForLanguage(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static Context getContextForLanguage(
    Context context,
  ) {
    return _getContextForLanguage(
            _class.reference.pointer,
            _id_getContextForLanguage as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const $ContextType());
  }

  static final _id_getAttributionTag = _class.staticMethodId(
    r'getAttributionTag',
    r'(Landroid/content/Context;)Ljava/lang/String;',
  );

  static final _getAttributionTag = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getAttributionTag(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getAttributionTag(
    Context context,
  ) {
    return _getAttributionTag(
            _class.reference.pointer,
            _id_getAttributionTag as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_createAttributionContext = _class.staticMethodId(
    r'createAttributionContext',
    r'(Landroid/content/Context;Ljava/lang/String;)Landroid/content/Context;',
  );

  static final _createAttributionContext = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Context createAttributionContext(android.content.Context context, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Context createAttributionContext(
    Context context,
    jni.JString string,
  ) {
    return _createAttributionContext(
            _class.reference.pointer,
            _id_createAttributionContext as jni.JMethodIDPtr,
            context.reference.pointer,
            string.reference.pointer)
        .object(const $ContextType());
  }
}

final class $ContextCompatType extends jni.JObjType<ContextCompat> {
  const $ContextCompatType();

  @override
  String get signature => r'Landroidx/core/content/ContextCompat;';

  @override
  ContextCompat fromReference(jni.JReference reference) =>
      ContextCompat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ContextCompatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContextCompatType) &&
        other is $ContextCompatType;
  }
}

/// from: androidx.core.util.Consumer
class Consumer<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Consumer<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  Consumer.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/core/util/Consumer');

  /// The type which includes information such as the signature of this class.
  static $ConsumerType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $ConsumerType(
      T,
    );
  }

  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Ljava/lang/Object;)V',
  );

  static final _accept = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void accept(T object)
  void accept(
    $T object,
  ) {
    _accept(reference.pointer, _id_accept as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ConsumerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Ljava/lang/Object;)V') {
        _$impls[$p]!.accept(
          $a[0].castTo(_$impls[$p]!.T, releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Consumer.implement(
    $ConsumerImpl<$T> $impl,
  ) {
    final $p = ReceivePort();
    final $x = Consumer.fromReference(
      $impl.T,
      ProtectedJniExtensions.newPortProxy(
        r'androidx.core.util.Consumer',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ConsumerImpl<$T extends jni.JObject> {
  factory $ConsumerImpl({
    required jni.JObjType<$T> T,
    required void Function($T object) accept,
  }) = _$ConsumerImpl;

  jni.JObjType<$T> get T;

  void accept($T object);
}

class _$ConsumerImpl<$T extends jni.JObject> implements $ConsumerImpl<$T> {
  _$ConsumerImpl({
    required this.T,
    required void Function($T object) accept,
  }) : _accept = accept;

  @override
  final jni.JObjType<$T> T;

  final void Function($T object) _accept;

  void accept($T object) {
    return _accept(object);
  }
}

final class $ConsumerType<$T extends jni.JObject>
    extends jni.JObjType<Consumer<$T>> {
  final jni.JObjType<$T> T;

  const $ConsumerType(
    this.T,
  );

  @override
  String get signature => r'Landroidx/core/util/Consumer;';

  @override
  Consumer<$T> fromReference(jni.JReference reference) =>
      Consumer.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($ConsumerType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ConsumerType<$T>) &&
        other is $ConsumerType<$T> &&
        T == other.T;
  }
}

/// from: androidx.lifecycle.LifecycleOwner
class LifecycleOwner extends jni.JObject {
  @override
  late final jni.JObjType<LifecycleOwner> $type = type;

  LifecycleOwner.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/lifecycle/LifecycleOwner');

  /// The type which includes information such as the signature of this class.
  static const type = $LifecycleOwnerType();
  static final _id_getLifecycle = _class.instanceMethodId(
    r'getLifecycle',
    r'()Landroidx/lifecycle/Lifecycle;',
  );

  static final _getLifecycle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract androidx.lifecycle.Lifecycle getLifecycle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLifecycle() {
    return _getLifecycle(
            reference.pointer, _id_getLifecycle as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $LifecycleOwnerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getLifecycle()Landroidx/lifecycle/Lifecycle;') {
        final $r = _$impls[$p]!.getLifecycle();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory LifecycleOwner.implement(
    $LifecycleOwnerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = LifecycleOwner.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'androidx.lifecycle.LifecycleOwner',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $LifecycleOwnerImpl {
  factory $LifecycleOwnerImpl({
    required jni.JObject Function() getLifecycle,
  }) = _$LifecycleOwnerImpl;

  jni.JObject getLifecycle();
}

class _$LifecycleOwnerImpl implements $LifecycleOwnerImpl {
  _$LifecycleOwnerImpl({
    required jni.JObject Function() getLifecycle,
  }) : _getLifecycle = getLifecycle;

  final jni.JObject Function() _getLifecycle;

  jni.JObject getLifecycle() {
    return _getLifecycle();
  }
}

final class $LifecycleOwnerType extends jni.JObjType<LifecycleOwner> {
  const $LifecycleOwnerType();

  @override
  String get signature => r'Landroidx/lifecycle/LifecycleOwner;';

  @override
  LifecycleOwner fromReference(jni.JReference reference) =>
      LifecycleOwner.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($LifecycleOwnerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($LifecycleOwnerType) &&
        other is $LifecycleOwnerType;
  }
}

/// from: androidx.lifecycle.LiveData
class LiveData<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<LiveData<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  LiveData.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/lifecycle/LiveData');

  /// The type which includes information such as the signature of this class.
  static $LiveDataType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $LiveDataType(
      T,
    );
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T object)
  /// The returned object must be released after use, by calling the [release] method.
  factory LiveData(
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return LiveData.fromReference(
        T,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                object.reference.pointer)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'()V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory LiveData.new1({
    required jni.JObjType<$T> T,
  }) {
    return LiveData.fromReference(
        T,
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_observe = _class.instanceMethodId(
    r'observe',
    r'(Landroidx/lifecycle/LifecycleOwner;Landroidx/lifecycle/Observer;)V',
  );

  static final _observe = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void observe(androidx.lifecycle.LifecycleOwner lifecycleOwner, androidx.lifecycle.Observer observer)
  void observe(
    LifecycleOwner lifecycleOwner,
    Observer<$T> observer,
  ) {
    _observe(reference.pointer, _id_observe as jni.JMethodIDPtr,
            lifecycleOwner.reference.pointer, observer.reference.pointer)
        .check();
  }

  static final _id_observeForever = _class.instanceMethodId(
    r'observeForever',
    r'(Landroidx/lifecycle/Observer;)V',
  );

  static final _observeForever = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void observeForever(androidx.lifecycle.Observer observer)
  void observeForever(
    Observer<$T> observer,
  ) {
    _observeForever(reference.pointer, _id_observeForever as jni.JMethodIDPtr,
            observer.reference.pointer)
        .check();
  }

  static final _id_removeObserver = _class.instanceMethodId(
    r'removeObserver',
    r'(Landroidx/lifecycle/Observer;)V',
  );

  static final _removeObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void removeObserver(androidx.lifecycle.Observer observer)
  void removeObserver(
    Observer<$T> observer,
  ) {
    _removeObserver(reference.pointer, _id_removeObserver as jni.JMethodIDPtr,
            observer.reference.pointer)
        .check();
  }

  static final _id_removeObservers = _class.instanceMethodId(
    r'removeObservers',
    r'(Landroidx/lifecycle/LifecycleOwner;)V',
  );

  static final _removeObservers = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void removeObservers(androidx.lifecycle.LifecycleOwner lifecycleOwner)
  void removeObservers(
    LifecycleOwner lifecycleOwner,
  ) {
    _removeObservers(reference.pointer, _id_removeObservers as jni.JMethodIDPtr,
            lifecycleOwner.reference.pointer)
        .check();
  }

  static final _id_postValue = _class.instanceMethodId(
    r'postValue',
    r'(Ljava/lang/Object;)V',
  );

  static final _postValue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void postValue(T object)
  void postValue(
    $T object,
  ) {
    _postValue(reference.pointer, _id_postValue as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  static final _id_setValue = _class.instanceMethodId(
    r'setValue',
    r'(Ljava/lang/Object;)V',
  );

  static final _setValue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void setValue(T object)
  void setValue(
    $T object,
  ) {
    _setValue(reference.pointer, _id_setValue as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Ljava/lang/Object;',
  );

  static final _getValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public T getValue()
  /// The returned object must be released after use, by calling the [release] method.
  $T getValue() {
    return _getValue(reference.pointer, _id_getValue as jni.JMethodIDPtr)
        .object(T);
  }

  static final _id_isInitialized = _class.instanceMethodId(
    r'isInitialized',
    r'()Z',
  );

  static final _isInitialized = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isInitialized()
  bool isInitialized() {
    return _isInitialized(
            reference.pointer, _id_isInitialized as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_onActive = _class.instanceMethodId(
    r'onActive',
    r'()V',
  );

  static final _onActive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onActive()
  void onActive() {
    _onActive(reference.pointer, _id_onActive as jni.JMethodIDPtr).check();
  }

  static final _id_onInactive = _class.instanceMethodId(
    r'onInactive',
    r'()V',
  );

  static final _onInactive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onInactive()
  void onInactive() {
    _onInactive(reference.pointer, _id_onInactive as jni.JMethodIDPtr).check();
  }

  static final _id_hasObservers = _class.instanceMethodId(
    r'hasObservers',
    r'()Z',
  );

  static final _hasObservers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean hasObservers()
  bool hasObservers() {
    return _hasObservers(
            reference.pointer, _id_hasObservers as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_hasActiveObservers = _class.instanceMethodId(
    r'hasActiveObservers',
    r'()Z',
  );

  static final _hasActiveObservers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean hasActiveObservers()
  bool hasActiveObservers() {
    return _hasActiveObservers(
            reference.pointer, _id_hasActiveObservers as jni.JMethodIDPtr)
        .boolean;
  }
}

final class $LiveDataType<$T extends jni.JObject>
    extends jni.JObjType<LiveData<$T>> {
  final jni.JObjType<$T> T;

  const $LiveDataType(
    this.T,
  );

  @override
  String get signature => r'Landroidx/lifecycle/LiveData;';

  @override
  LiveData<$T> fromReference(jni.JReference reference) =>
      LiveData.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($LiveDataType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($LiveDataType<$T>) &&
        other is $LiveDataType<$T> &&
        T == other.T;
  }
}

/// from: androidx.lifecycle.Observer
class Observer<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Observer<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  Observer.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/lifecycle/Observer');

  /// The type which includes information such as the signature of this class.
  static $ObserverType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $ObserverType(
      T,
    );
  }

  static final _id_onChanged = _class.instanceMethodId(
    r'onChanged',
    r'(Ljava/lang/Object;)V',
  );

  static final _onChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onChanged(T object)
  void onChanged(
    $T object,
  ) {
    _onChanged(reference.pointer, _id_onChanged as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ObserverImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onChanged(Ljava/lang/Object;)V') {
        _$impls[$p]!.onChanged(
          $a[0].castTo(_$impls[$p]!.T, releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Observer.implement(
    $ObserverImpl<$T> $impl,
  ) {
    final $p = ReceivePort();
    final $x = Observer.fromReference(
      $impl.T,
      ProtectedJniExtensions.newPortProxy(
        r'androidx.lifecycle.Observer',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ObserverImpl<$T extends jni.JObject> {
  factory $ObserverImpl({
    required jni.JObjType<$T> T,
    required void Function($T object) onChanged,
  }) = _$ObserverImpl;

  jni.JObjType<$T> get T;

  void onChanged($T object);
}

class _$ObserverImpl<$T extends jni.JObject> implements $ObserverImpl<$T> {
  _$ObserverImpl({
    required this.T,
    required void Function($T object) onChanged,
  }) : _onChanged = onChanged;

  @override
  final jni.JObjType<$T> T;

  final void Function($T object) _onChanged;

  void onChanged($T object) {
    return _onChanged(object);
  }
}

final class $ObserverType<$T extends jni.JObject>
    extends jni.JObjType<Observer<$T>> {
  final jni.JObjType<$T> T;

  const $ObserverType(
    this.T,
  );

  @override
  String get signature => r'Landroidx/lifecycle/Observer;';

  @override
  Observer<$T> fromReference(jni.JReference reference) =>
      Observer.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($ObserverType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObserverType<$T>) &&
        other is $ObserverType<$T> &&
        T == other.T;
  }
}

/// from: com.google.android.gms.tasks.OnCompleteListener
class OnCompleteListener<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<OnCompleteListener<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  OnCompleteListener.fromReference(
    this.TResult,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/android/gms/tasks/OnCompleteListener');

  /// The type which includes information such as the signature of this class.
  static $OnCompleteListenerType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $OnCompleteListenerType(
      TResult,
    );
  }

  static final _id_onComplete = _class.instanceMethodId(
    r'onComplete',
    r'(Lcom/google/android/gms/tasks/Task;)V',
  );

  static final _onComplete = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onComplete(com.google.android.gms.tasks.Task task)
  void onComplete(
    Task<$TResult> task,
  ) {
    _onComplete(reference.pointer, _id_onComplete as jni.JMethodIDPtr,
            task.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnCompleteListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onComplete(Lcom/google/android/gms/tasks/Task;)V') {
        _$impls[$p]!.onComplete(
          $a[0].castTo($TaskType(_$impls[$p]!.TResult), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OnCompleteListener.implement(
    $OnCompleteListenerImpl<$TResult> $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnCompleteListener.fromReference(
      $impl.TResult,
      ProtectedJniExtensions.newPortProxy(
        r'com.google.android.gms.tasks.OnCompleteListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OnCompleteListenerImpl<$TResult extends jni.JObject> {
  factory $OnCompleteListenerImpl({
    required jni.JObjType<$TResult> TResult,
    required void Function(Task<$TResult> task) onComplete,
  }) = _$OnCompleteListenerImpl;

  jni.JObjType<$TResult> get TResult;

  void onComplete(Task<$TResult> task);
}

class _$OnCompleteListenerImpl<$TResult extends jni.JObject>
    implements $OnCompleteListenerImpl<$TResult> {
  _$OnCompleteListenerImpl({
    required this.TResult,
    required void Function(Task<$TResult> task) onComplete,
  }) : _onComplete = onComplete;

  @override
  final jni.JObjType<$TResult> TResult;

  final void Function(Task<$TResult> task) _onComplete;

  void onComplete(Task<$TResult> task) {
    return _onComplete(task);
  }
}

final class $OnCompleteListenerType<$TResult extends jni.JObject>
    extends jni.JObjType<OnCompleteListener<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $OnCompleteListenerType(
    this.TResult,
  );

  @override
  String get signature => r'Lcom/google/android/gms/tasks/OnCompleteListener;';

  @override
  OnCompleteListener<$TResult> fromReference(jni.JReference reference) =>
      OnCompleteListener.fromReference(TResult, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($OnCompleteListenerType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCompleteListenerType<$TResult>) &&
        other is $OnCompleteListenerType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.android.gms.tasks.OnSuccessListener
class OnSuccessListener<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<OnSuccessListener<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  OnSuccessListener.fromReference(
    this.TResult,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/android/gms/tasks/OnSuccessListener');

  /// The type which includes information such as the signature of this class.
  static $OnSuccessListenerType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $OnSuccessListenerType(
      TResult,
    );
  }

  static final _id_onSuccess = _class.instanceMethodId(
    r'onSuccess',
    r'(Ljava/lang/Object;)V',
  );

  static final _onSuccess = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSuccess(TResult object)
  void onSuccess(
    $TResult object,
  ) {
    _onSuccess(reference.pointer, _id_onSuccess as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnSuccessListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSuccess(Ljava/lang/Object;)V') {
        _$impls[$p]!.onSuccess(
          $a[0].castTo(_$impls[$p]!.TResult, releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OnSuccessListener.implement(
    $OnSuccessListenerImpl<$TResult> $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnSuccessListener.fromReference(
      $impl.TResult,
      ProtectedJniExtensions.newPortProxy(
        r'com.google.android.gms.tasks.OnSuccessListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OnSuccessListenerImpl<$TResult extends jni.JObject> {
  factory $OnSuccessListenerImpl({
    required jni.JObjType<$TResult> TResult,
    required void Function($TResult object) onSuccess,
  }) = _$OnSuccessListenerImpl;

  jni.JObjType<$TResult> get TResult;

  void onSuccess($TResult object);
}

class _$OnSuccessListenerImpl<$TResult extends jni.JObject>
    implements $OnSuccessListenerImpl<$TResult> {
  _$OnSuccessListenerImpl({
    required this.TResult,
    required void Function($TResult object) onSuccess,
  }) : _onSuccess = onSuccess;

  @override
  final jni.JObjType<$TResult> TResult;

  final void Function($TResult object) _onSuccess;

  void onSuccess($TResult object) {
    return _onSuccess(object);
  }
}

final class $OnSuccessListenerType<$TResult extends jni.JObject>
    extends jni.JObjType<OnSuccessListener<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $OnSuccessListenerType(
    this.TResult,
  );

  @override
  String get signature => r'Lcom/google/android/gms/tasks/OnSuccessListener;';

  @override
  OnSuccessListener<$TResult> fromReference(jni.JReference reference) =>
      OnSuccessListener.fromReference(TResult, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($OnSuccessListenerType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnSuccessListenerType<$TResult>) &&
        other is $OnSuccessListenerType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.android.gms.tasks.OnFailureListener
class OnFailureListener extends jni.JObject {
  @override
  late final jni.JObjType<OnFailureListener> $type = type;

  OnFailureListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/android/gms/tasks/OnFailureListener');

  /// The type which includes information such as the signature of this class.
  static const type = $OnFailureListenerType();
  static final _id_onFailure = _class.instanceMethodId(
    r'onFailure',
    r'(Ljava/lang/Exception;)V',
  );

  static final _onFailure = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFailure(java.lang.Exception exception)
  void onFailure(
    jni.JObject exception,
  ) {
    _onFailure(reference.pointer, _id_onFailure as jni.JMethodIDPtr,
            exception.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnFailureListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFailure(Ljava/lang/Exception;)V') {
        _$impls[$p]!.onFailure(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OnFailureListener.implement(
    $OnFailureListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnFailureListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.android.gms.tasks.OnFailureListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OnFailureListenerImpl {
  factory $OnFailureListenerImpl({
    required void Function(jni.JObject exception) onFailure,
  }) = _$OnFailureListenerImpl;

  void onFailure(jni.JObject exception);
}

class _$OnFailureListenerImpl implements $OnFailureListenerImpl {
  _$OnFailureListenerImpl({
    required void Function(jni.JObject exception) onFailure,
  }) : _onFailure = onFailure;

  final void Function(jni.JObject exception) _onFailure;

  void onFailure(jni.JObject exception) {
    return _onFailure(exception);
  }
}

final class $OnFailureListenerType extends jni.JObjType<OnFailureListener> {
  const $OnFailureListenerType();

  @override
  String get signature => r'Lcom/google/android/gms/tasks/OnFailureListener;';

  @override
  OnFailureListener fromReference(jni.JReference reference) =>
      OnFailureListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OnFailureListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnFailureListenerType) &&
        other is $OnFailureListenerType;
  }
}

/// from: com.google.android.gms.tasks.OnCanceledListener
class OnCanceledListener extends jni.JObject {
  @override
  late final jni.JObjType<OnCanceledListener> $type = type;

  OnCanceledListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/android/gms/tasks/OnCanceledListener');

  /// The type which includes information such as the signature of this class.
  static const type = $OnCanceledListenerType();
  static final _id_onCanceled = _class.instanceMethodId(
    r'onCanceled',
    r'()V',
  );

  static final _onCanceled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void onCanceled()
  void onCanceled() {
    _onCanceled(reference.pointer, _id_onCanceled as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnCanceledListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCanceled()V') {
        _$impls[$p]!.onCanceled();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory OnCanceledListener.implement(
    $OnCanceledListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnCanceledListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.android.gms.tasks.OnCanceledListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OnCanceledListenerImpl {
  factory $OnCanceledListenerImpl({
    required void Function() onCanceled,
  }) = _$OnCanceledListenerImpl;

  void onCanceled();
}

class _$OnCanceledListenerImpl implements $OnCanceledListenerImpl {
  _$OnCanceledListenerImpl({
    required void Function() onCanceled,
  }) : _onCanceled = onCanceled;

  final void Function() _onCanceled;

  void onCanceled() {
    return _onCanceled();
  }
}

final class $OnCanceledListenerType extends jni.JObjType<OnCanceledListener> {
  const $OnCanceledListenerType();

  @override
  String get signature => r'Lcom/google/android/gms/tasks/OnCanceledListener;';

  @override
  OnCanceledListener fromReference(jni.JReference reference) =>
      OnCanceledListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OnCanceledListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCanceledListenerType) &&
        other is $OnCanceledListenerType;
  }
}

/// from: com.google.android.gms.tasks.Task
class Task<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Task<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  Task.fromReference(
    this.TResult,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/android/gms/tasks/Task');

  /// The type which includes information such as the signature of this class.
  static $TaskType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $TaskType(
      TResult,
    );
  }

  static final _id_addOnCanceledListener = _class.instanceMethodId(
    r'addOnCanceledListener',
    r'(Lcom/google/android/gms/tasks/OnCanceledListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCanceledListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener(
    OnCanceledListener onCanceledListener,
  ) {
    return _addOnCanceledListener(
            reference.pointer,
            _id_addOnCanceledListener as jni.JMethodIDPtr,
            onCanceledListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnCanceledListener1 = _class.instanceMethodId(
    r'addOnCanceledListener',
    r'(Landroid/app/Activity;Lcom/google/android/gms/tasks/OnCanceledListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCanceledListener1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(android.app.Activity activity, com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener1(
    Activity activity,
    OnCanceledListener onCanceledListener,
  ) {
    return _addOnCanceledListener1(
            reference.pointer,
            _id_addOnCanceledListener1 as jni.JMethodIDPtr,
            activity.reference.pointer,
            onCanceledListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnCanceledListener2 = _class.instanceMethodId(
    r'addOnCanceledListener',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/OnCanceledListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCanceledListener2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener2(
    Executor executor,
    OnCanceledListener onCanceledListener,
  ) {
    return _addOnCanceledListener2(
            reference.pointer,
            _id_addOnCanceledListener2 as jni.JMethodIDPtr,
            executor.reference.pointer,
            onCanceledListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnCompleteListener = _class.instanceMethodId(
    r'addOnCompleteListener',
    r'(Lcom/google/android/gms/tasks/OnCompleteListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCompleteListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener(
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return _addOnCompleteListener(
            reference.pointer,
            _id_addOnCompleteListener as jni.JMethodIDPtr,
            onCompleteListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnCompleteListener1 = _class.instanceMethodId(
    r'addOnCompleteListener',
    r'(Landroid/app/Activity;Lcom/google/android/gms/tasks/OnCompleteListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCompleteListener1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(android.app.Activity activity, com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener1(
    Activity activity,
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return _addOnCompleteListener1(
            reference.pointer,
            _id_addOnCompleteListener1 as jni.JMethodIDPtr,
            activity.reference.pointer,
            onCompleteListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnCompleteListener2 = _class.instanceMethodId(
    r'addOnCompleteListener',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/OnCompleteListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCompleteListener2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener2(
    Executor executor,
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return _addOnCompleteListener2(
            reference.pointer,
            _id_addOnCompleteListener2 as jni.JMethodIDPtr,
            executor.reference.pointer,
            onCompleteListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnFailureListener = _class.instanceMethodId(
    r'addOnFailureListener',
    r'(Lcom/google/android/gms/tasks/OnFailureListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnFailureListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener(
    OnFailureListener onFailureListener,
  ) {
    return _addOnFailureListener(
            reference.pointer,
            _id_addOnFailureListener as jni.JMethodIDPtr,
            onFailureListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnFailureListener1 = _class.instanceMethodId(
    r'addOnFailureListener',
    r'(Landroid/app/Activity;Lcom/google/android/gms/tasks/OnFailureListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnFailureListener1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(android.app.Activity activity, com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener1(
    Activity activity,
    OnFailureListener onFailureListener,
  ) {
    return _addOnFailureListener1(
            reference.pointer,
            _id_addOnFailureListener1 as jni.JMethodIDPtr,
            activity.reference.pointer,
            onFailureListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnFailureListener2 = _class.instanceMethodId(
    r'addOnFailureListener',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/OnFailureListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnFailureListener2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener2(
    Executor executor,
    OnFailureListener onFailureListener,
  ) {
    return _addOnFailureListener2(
            reference.pointer,
            _id_addOnFailureListener2 as jni.JMethodIDPtr,
            executor.reference.pointer,
            onFailureListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnSuccessListener = _class.instanceMethodId(
    r'addOnSuccessListener',
    r'(Lcom/google/android/gms/tasks/OnSuccessListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnSuccessListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener(
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return _addOnSuccessListener(
            reference.pointer,
            _id_addOnSuccessListener as jni.JMethodIDPtr,
            onSuccessListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnSuccessListener1 = _class.instanceMethodId(
    r'addOnSuccessListener',
    r'(Landroid/app/Activity;Lcom/google/android/gms/tasks/OnSuccessListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnSuccessListener1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(android.app.Activity activity, com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener1(
    Activity activity,
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return _addOnSuccessListener1(
            reference.pointer,
            _id_addOnSuccessListener1 as jni.JMethodIDPtr,
            activity.reference.pointer,
            onSuccessListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_addOnSuccessListener2 = _class.instanceMethodId(
    r'addOnSuccessListener',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/OnSuccessListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnSuccessListener2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener2(
    Executor executor,
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return _addOnSuccessListener2(
            reference.pointer,
            _id_addOnSuccessListener2 as jni.JMethodIDPtr,
            executor.reference.pointer,
            onSuccessListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _id_continueWith = _class.instanceMethodId(
    r'continueWith',
    r'(Lcom/google/android/gms/tasks/Continuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _continueWith = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWith(com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWith<$TContinuationResult extends jni.JObject>(
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _continueWith(
            reference.pointer,
            _id_continueWith as jni.JMethodIDPtr,
            continuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _id_continueWith1 = _class.instanceMethodId(
    r'continueWith',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/Continuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _continueWith1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWith(java.util.concurrent.Executor executor, com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWith1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _continueWith1(
            reference.pointer,
            _id_continueWith1 as jni.JMethodIDPtr,
            executor.reference.pointer,
            continuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _id_continueWithTask = _class.instanceMethodId(
    r'continueWithTask',
    r'(Lcom/google/android/gms/tasks/Continuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _continueWithTask = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWithTask(com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWithTask<$TContinuationResult extends jni.JObject>(
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _continueWithTask(
            reference.pointer,
            _id_continueWithTask as jni.JMethodIDPtr,
            continuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _id_continueWithTask1 = _class.instanceMethodId(
    r'continueWithTask',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/Continuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _continueWithTask1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWithTask(java.util.concurrent.Executor executor, com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWithTask1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _continueWithTask1(
            reference.pointer,
            _id_continueWithTask1 as jni.JMethodIDPtr,
            executor.reference.pointer,
            continuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _id_onSuccessTask = _class.instanceMethodId(
    r'onSuccessTask',
    r'(Lcom/google/android/gms/tasks/SuccessContinuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _onSuccessTask = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task onSuccessTask(com.google.android.gms.tasks.SuccessContinuation successContinuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      onSuccessTask<$TContinuationResult extends jni.JObject>(
    jni.JObject successContinuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _onSuccessTask(
            reference.pointer,
            _id_onSuccessTask as jni.JMethodIDPtr,
            successContinuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _id_onSuccessTask1 = _class.instanceMethodId(
    r'onSuccessTask',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/SuccessContinuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _onSuccessTask1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task onSuccessTask(java.util.concurrent.Executor executor, com.google.android.gms.tasks.SuccessContinuation successContinuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      onSuccessTask1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject successContinuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _onSuccessTask1(
            reference.pointer,
            _id_onSuccessTask1 as jni.JMethodIDPtr,
            executor.reference.pointer,
            successContinuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _id_getException = _class.instanceMethodId(
    r'getException',
    r'()Ljava/lang/Exception;',
  );

  static final _getException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.lang.Exception getException()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getException() {
    return _getException(
            reference.pointer, _id_getException as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getResult = _class.instanceMethodId(
    r'getResult',
    r'()Ljava/lang/Object;',
  );

  static final _getResult = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract TResult getResult()
  /// The returned object must be released after use, by calling the [release] method.
  $TResult getResult() {
    return _getResult(reference.pointer, _id_getResult as jni.JMethodIDPtr)
        .object(TResult);
  }

  static final _id_getResult1 = _class.instanceMethodId(
    r'getResult',
    r'(Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getResult1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract TResult getResult(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $TResult getResult1<$X extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$X> X,
  }) {
    return _getResult1(reference.pointer, _id_getResult1 as jni.JMethodIDPtr,
            class0.reference.pointer)
        .object(TResult);
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Task({
    required jni.JObjType<$TResult> TResult,
  }) {
    return Task.fromReference(
        TResult,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_isCanceled = _class.instanceMethodId(
    r'isCanceled',
    r'()Z',
  );

  static final _isCanceled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return _isCanceled(reference.pointer, _id_isCanceled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isComplete = _class.instanceMethodId(
    r'isComplete',
    r'()Z',
  );

  static final _isComplete = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isComplete()
  bool isComplete() {
    return _isComplete(reference.pointer, _id_isComplete as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isSuccessful = _class.instanceMethodId(
    r'isSuccessful',
    r'()Z',
  );

  static final _isSuccessful = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isSuccessful()
  bool isSuccessful() {
    return _isSuccessful(
            reference.pointer, _id_isSuccessful as jni.JMethodIDPtr)
        .boolean;
  }
}

final class $TaskType<$TResult extends jni.JObject>
    extends jni.JObjType<Task<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $TaskType(
    this.TResult,
  );

  @override
  String get signature => r'Lcom/google/android/gms/tasks/Task;';

  @override
  Task<$TResult> fromReference(jni.JReference reference) =>
      Task.fromReference(TResult, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($TaskType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TaskType<$TResult>) &&
        other is $TaskType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.common.util.concurrent.ListenableFuture
class ListenableFuture<$V extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<ListenableFuture<$V>> $type = type(V);

  final jni.JObjType<$V> V;

  ListenableFuture.fromReference(
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/common/util/concurrent/ListenableFuture');

  /// The type which includes information such as the signature of this class.
  static $ListenableFutureType<$V> type<$V extends jni.JObject>(
    jni.JObjType<$V> V,
  ) {
    return $ListenableFutureType(
      V,
    );
  }

  static final _id_addListener = _class.instanceMethodId(
    r'addListener',
    r'(Ljava/lang/Runnable;Ljava/util/concurrent/Executor;)V',
  );

  static final _addListener = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addListener(java.lang.Runnable runnable, java.util.concurrent.Executor executor)
  void addListener(
    Runnable runnable,
    Executor executor,
  ) {
    _addListener(reference.pointer, _id_addListener as jni.JMethodIDPtr,
            runnable.reference.pointer, executor.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ListenableFutureImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'addListener(Ljava/lang/Runnable;Ljava/util/concurrent/Executor;)V') {
        _$impls[$p]!.addListener(
          $a[0].castTo(const $RunnableType(), releaseOriginal: true),
          $a[1].castTo(const $ExecutorType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ListenableFuture.implement(
    $ListenableFutureImpl<$V> $impl,
  ) {
    final $p = ReceivePort();
    final $x = ListenableFuture.fromReference(
      $impl.V,
      ProtectedJniExtensions.newPortProxy(
        r'com.google.common.util.concurrent.ListenableFuture',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ListenableFutureImpl<$V extends jni.JObject> {
  factory $ListenableFutureImpl({
    required jni.JObjType<$V> V,
    required void Function(Runnable runnable, Executor executor) addListener,
  }) = _$ListenableFutureImpl;

  jni.JObjType<$V> get V;

  void addListener(Runnable runnable, Executor executor);
}

class _$ListenableFutureImpl<$V extends jni.JObject>
    implements $ListenableFutureImpl<$V> {
  _$ListenableFutureImpl({
    required this.V,
    required void Function(Runnable runnable, Executor executor) addListener,
  }) : _addListener = addListener;

  @override
  final jni.JObjType<$V> V;

  final void Function(Runnable runnable, Executor executor) _addListener;

  void addListener(Runnable runnable, Executor executor) {
    return _addListener(runnable, executor);
  }
}

final class $ListenableFutureType<$V extends jni.JObject>
    extends jni.JObjType<ListenableFuture<$V>> {
  final jni.JObjType<$V> V;

  const $ListenableFutureType(
    this.V,
  );

  @override
  String get signature =>
      r'Lcom/google/common/util/concurrent/ListenableFuture;';

  @override
  ListenableFuture<$V> fromReference(jni.JReference reference) =>
      ListenableFuture.fromReference(V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($ListenableFutureType, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ListenableFutureType<$V>) &&
        other is $ListenableFutureType<$V> &&
        V == other.V;
  }
}

/// from: com.google.mlkit.vision.common.InputImage$ImageFormat
class InputImage_ImageFormat extends jni.JObject {
  @override
  late final jni.JObjType<InputImage_ImageFormat> $type = type;

  InputImage_ImageFormat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/common/InputImage$ImageFormat');

  /// The type which includes information such as the signature of this class.
  static const type = $InputImage_ImageFormatType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $InputImage_ImageFormatImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory InputImage_ImageFormat.implement(
    $InputImage_ImageFormatImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = InputImage_ImageFormat.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.common.InputImage$ImageFormat',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $InputImage_ImageFormatImpl {
  factory $InputImage_ImageFormatImpl() = _$InputImage_ImageFormatImpl;
}

class _$InputImage_ImageFormatImpl implements $InputImage_ImageFormatImpl {
  _$InputImage_ImageFormatImpl();
}

final class $InputImage_ImageFormatType
    extends jni.JObjType<InputImage_ImageFormat> {
  const $InputImage_ImageFormatType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/common/InputImage$ImageFormat;';

  @override
  InputImage_ImageFormat fromReference(jni.JReference reference) =>
      InputImage_ImageFormat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($InputImage_ImageFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputImage_ImageFormatType) &&
        other is $InputImage_ImageFormatType;
  }
}

/// from: com.google.mlkit.vision.common.InputImage
class InputImage extends jni.JObject {
  @override
  late final jni.JObjType<InputImage> $type = type;

  InputImage.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/common/InputImage');

  /// The type which includes information such as the signature of this class.
  static const type = $InputImageType();

  /// from: static public final int IMAGE_FORMAT_NV21
  static const IMAGE_FORMAT_NV21 = 17;

  /// from: static public final int IMAGE_FORMAT_YV12
  static const IMAGE_FORMAT_YV12 = 842094169;

  /// from: static public final int IMAGE_FORMAT_BITMAP
  static const IMAGE_FORMAT_BITMAP = -1;

  /// from: static public final int IMAGE_FORMAT_YUV_420_888
  static const IMAGE_FORMAT_YUV_420_888 = 35;
  static final _id_getFormat = _class.instanceMethodId(
    r'getFormat',
    r'()I',
  );

  static final _getFormat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getFormat()
  int getFormat() {
    return _getFormat(reference.pointer, _id_getFormat as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getHeight()
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getRotationDegrees = _class.instanceMethodId(
    r'getRotationDegrees',
    r'()I',
  );

  static final _getRotationDegrees = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getRotationDegrees()
  int getRotationDegrees() {
    return _getRotationDegrees(
            reference.pointer, _id_getRotationDegrees as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getWidth()
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getBitmapInternal = _class.instanceMethodId(
    r'getBitmapInternal',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _getBitmapInternal = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Bitmap getBitmapInternal()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBitmapInternal() {
    return _getBitmapInternal(
            reference.pointer, _id_getBitmapInternal as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getCoordinatesMatrix = _class.instanceMethodId(
    r'getCoordinatesMatrix',
    r'()Landroid/graphics/Matrix;',
  );

  static final _getCoordinatesMatrix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Matrix getCoordinatesMatrix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCoordinatesMatrix() {
    return _getCoordinatesMatrix(
            reference.pointer, _id_getCoordinatesMatrix as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getMediaImage = _class.instanceMethodId(
    r'getMediaImage',
    r'()Landroid/media/Image;',
  );

  static final _getMediaImage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.media.Image getMediaImage()
  /// The returned object must be released after use, by calling the [release] method.
  Image getMediaImage() {
    return _getMediaImage(
            reference.pointer, _id_getMediaImage as jni.JMethodIDPtr)
        .object(const $ImageType());
  }

  static final _id_fromBitmap = _class.staticMethodId(
    r'fromBitmap',
    r'(Landroid/graphics/Bitmap;I)Lcom/google/mlkit/vision/common/InputImage;',
  );

  static final _fromBitmap = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromBitmap(android.graphics.Bitmap bitmap, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromBitmap(
    jni.JObject bitmap,
    int i,
  ) {
    return _fromBitmap(_class.reference.pointer,
            _id_fromBitmap as jni.JMethodIDPtr, bitmap.reference.pointer, i)
        .object(const $InputImageType());
  }

  static final _id_fromByteArray = _class.staticMethodId(
    r'fromByteArray',
    r'([BIIII)Lcom/google/mlkit/vision/common/InputImage;',
  );

  static final _fromByteArray = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromByteArray(byte[] bs, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromByteArray(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _fromByteArray(
            _class.reference.pointer,
            _id_fromByteArray as jni.JMethodIDPtr,
            bs.reference.pointer,
            i,
            i1,
            i2,
            i3)
        .object(const $InputImageType());
  }

  static final _id_fromByteBuffer = _class.staticMethodId(
    r'fromByteBuffer',
    r'(Ljava/nio/ByteBuffer;IIII)Lcom/google/mlkit/vision/common/InputImage;',
  );

  static final _fromByteBuffer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromByteBuffer(java.nio.ByteBuffer byteBuffer, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromByteBuffer(
    jni.JByteBuffer byteBuffer,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _fromByteBuffer(
            _class.reference.pointer,
            _id_fromByteBuffer as jni.JMethodIDPtr,
            byteBuffer.reference.pointer,
            i,
            i1,
            i2,
            i3)
        .object(const $InputImageType());
  }

  static final _id_fromFilePath = _class.staticMethodId(
    r'fromFilePath',
    r'(Landroid/content/Context;Landroid/net/Uri;)Lcom/google/mlkit/vision/common/InputImage;',
  );

  static final _fromFilePath = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromFilePath(android.content.Context context, android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromFilePath(
    Context context,
    Uri uri,
  ) {
    return _fromFilePath(
            _class.reference.pointer,
            _id_fromFilePath as jni.JMethodIDPtr,
            context.reference.pointer,
            uri.reference.pointer)
        .object(const $InputImageType());
  }

  static final _id_fromMediaImage = _class.staticMethodId(
    r'fromMediaImage',
    r'(Landroid/media/Image;I)Lcom/google/mlkit/vision/common/InputImage;',
  );

  static final _fromMediaImage = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromMediaImage(android.media.Image image, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromMediaImage(
    Image image,
    int i,
  ) {
    return _fromMediaImage(_class.reference.pointer,
            _id_fromMediaImage as jni.JMethodIDPtr, image.reference.pointer, i)
        .object(const $InputImageType());
  }

  static final _id_fromMediaImage1 = _class.staticMethodId(
    r'fromMediaImage',
    r'(Landroid/media/Image;ILandroid/graphics/Matrix;)Lcom/google/mlkit/vision/common/InputImage;',
  );

  static final _fromMediaImage1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromMediaImage(android.media.Image image, int i, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromMediaImage1(
    Image image,
    int i,
    jni.JObject matrix,
  ) {
    return _fromMediaImage1(
            _class.reference.pointer,
            _id_fromMediaImage1 as jni.JMethodIDPtr,
            image.reference.pointer,
            i,
            matrix.reference.pointer)
        .object(const $InputImageType());
  }

  static final _id_getByteBuffer = _class.instanceMethodId(
    r'getByteBuffer',
    r'()Ljava/nio/ByteBuffer;',
  );

  static final _getByteBuffer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.nio.ByteBuffer getByteBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByteBuffer getByteBuffer() {
    return _getByteBuffer(
            reference.pointer, _id_getByteBuffer as jni.JMethodIDPtr)
        .object(const jni.JByteBufferType());
  }

  static final _id_getPlanes = _class.instanceMethodId(
    r'getPlanes',
    r'()[Landroid/media/Image$Plane;',
  );

  static final _getPlanes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.media.Image$Plane[] getPlanes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<Image_Plane> getPlanes() {
    return _getPlanes(reference.pointer, _id_getPlanes as jni.JMethodIDPtr)
        .object(const jni.JArrayType($Image_PlaneType()));
  }
}

final class $InputImageType extends jni.JObjType<InputImage> {
  const $InputImageType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/common/InputImage;';

  @override
  InputImage fromReference(jni.JReference reference) =>
      InputImage.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($InputImageType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputImageType) && other is $InputImageType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScanning
class BarcodeScanning extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScanning> $type = type;

  BarcodeScanning.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/barcode/BarcodeScanning');

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScanningType();
  static final _id_getClient = _class.staticMethodId(
    r'getClient',
    r'()Lcom/google/mlkit/vision/barcode/BarcodeScanner;',
  );

  static final _getClient = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public com.google.mlkit.vision.barcode.BarcodeScanner getClient()
  /// The returned object must be released after use, by calling the [release] method.
  static BarcodeScanner getClient() {
    return _getClient(
            _class.reference.pointer, _id_getClient as jni.JMethodIDPtr)
        .object(const $BarcodeScannerType());
  }

  static final _id_getClient1 = _class.staticMethodId(
    r'getClient',
    r'(Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions;)Lcom/google/mlkit/vision/barcode/BarcodeScanner;',
  );

  static final _getClient1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.barcode.BarcodeScanner getClient(com.google.mlkit.vision.barcode.BarcodeScannerOptions barcodeScannerOptions)
  /// The returned object must be released after use, by calling the [release] method.
  static BarcodeScanner getClient1(
    BarcodeScannerOptions barcodeScannerOptions,
  ) {
    return _getClient1(
            _class.reference.pointer,
            _id_getClient1 as jni.JMethodIDPtr,
            barcodeScannerOptions.reference.pointer)
        .object(const $BarcodeScannerType());
  }
}

final class $BarcodeScanningType extends jni.JObjType<BarcodeScanning> {
  const $BarcodeScanningType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/barcode/BarcodeScanning;';

  @override
  BarcodeScanning fromReference(jni.JReference reference) =>
      BarcodeScanning.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScanningType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScanningType) &&
        other is $BarcodeScanningType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScanner
class BarcodeScanner extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScanner> $type = type;

  BarcodeScanner.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/barcode/BarcodeScanner');

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerType();
  static final _id_process = _class.instanceMethodId(
    r'process',
    r'(Lcom/google/android/odml/image/MlImage;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _process = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(com.google.android.odml.image.MlImage mlImage)
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni.JList<Barcode>> process(
    jni.JObject mlImage,
  ) {
    return _process(reference.pointer, _id_process as jni.JMethodIDPtr,
            mlImage.reference.pointer)
        .object(const $TaskType(jni.JListType($BarcodeType())));
  }

  static final _id_process1 = _class.instanceMethodId(
    r'process',
    r'(Lcom/google/mlkit/vision/common/InputImage;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _process1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(com.google.mlkit.vision.common.InputImage inputImage)
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni.JList<Barcode>> process1(
    InputImage inputImage,
  ) {
    return _process1(reference.pointer, _id_process1 as jni.JMethodIDPtr,
            inputImage.reference.pointer)
        .object(const $TaskType(jni.JListType($BarcodeType())));
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $BarcodeScannerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'process(Lcom/google/android/odml/image/MlImage;)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.process(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r'process(Lcom/google/mlkit/vision/common/InputImage;)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.process1(
          $a[0].castTo(const $InputImageType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory BarcodeScanner.implement(
    $BarcodeScannerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = BarcodeScanner.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.BarcodeScanner',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $BarcodeScannerImpl {
  factory $BarcodeScannerImpl({
    required Task<jni.JList<Barcode>> Function(jni.JObject mlImage) process,
    required Task<jni.JList<Barcode>> Function(InputImage inputImage) process1,
    required void Function() close,
  }) = _$BarcodeScannerImpl;

  Task<jni.JList<Barcode>> process(jni.JObject mlImage);
  Task<jni.JList<Barcode>> process1(InputImage inputImage);
  void close();
}

class _$BarcodeScannerImpl implements $BarcodeScannerImpl {
  _$BarcodeScannerImpl({
    required Task<jni.JList<Barcode>> Function(jni.JObject mlImage) process,
    required Task<jni.JList<Barcode>> Function(InputImage inputImage) process1,
    required void Function() close,
  })  : _process = process,
        _process1 = process1,
        _close = close;

  final Task<jni.JList<Barcode>> Function(jni.JObject mlImage) _process;
  final Task<jni.JList<Barcode>> Function(InputImage inputImage) _process1;
  final void Function() _close;

  Task<jni.JList<Barcode>> process(jni.JObject mlImage) {
    return _process(mlImage);
  }

  Task<jni.JList<Barcode>> process1(InputImage inputImage) {
    return _process1(inputImage);
  }

  void close() {
    return _close();
  }
}

final class $BarcodeScannerType extends jni.JObjType<BarcodeScanner> {
  const $BarcodeScannerType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/barcode/BarcodeScanner;';

  @override
  BarcodeScanner fromReference(jni.JReference reference) =>
      BarcodeScanner.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerType) &&
        other is $BarcodeScannerType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder
class BarcodeScannerOptions_Builder extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScannerOptions_Builder> $type = type;

  BarcodeScannerOptions_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/BarcodeScannerOptions$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerOptions_BuilderType();
  static final _id_enableAllPotentialBarcodes = _class.instanceMethodId(
    r'enableAllPotentialBarcodes',
    r'()Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions$Builder;',
  );

  static final _enableAllPotentialBarcodes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder enableAllPotentialBarcodes()
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder enableAllPotentialBarcodes() {
    return _enableAllPotentialBarcodes(reference.pointer,
            _id_enableAllPotentialBarcodes as jni.JMethodIDPtr)
        .object(const $BarcodeScannerOptions_BuilderType());
  }

  static final _id_setBarcodeFormats = _class.instanceMethodId(
    r'setBarcodeFormats',
    r'(I[I)Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions$Builder;',
  );

  static final _setBarcodeFormats = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setBarcodeFormats(int i, int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setBarcodeFormats(
    int i,
    jni.JArray<jni.jint> is0,
  ) {
    return _setBarcodeFormats(reference.pointer,
            _id_setBarcodeFormats as jni.JMethodIDPtr, i, is0.reference.pointer)
        .object(const $BarcodeScannerOptions_BuilderType());
  }

  static final _id_setExecutor = _class.instanceMethodId(
    r'setExecutor',
    r'(Ljava/util/concurrent/Executor;)Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions$Builder;',
  );

  static final _setExecutor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setExecutor(java.util.concurrent.Executor executor)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setExecutor(
    Executor executor,
  ) {
    return _setExecutor(reference.pointer, _id_setExecutor as jni.JMethodIDPtr,
            executor.reference.pointer)
        .object(const $BarcodeScannerOptions_BuilderType());
  }

  static final _id_setZoomSuggestionOptions = _class.instanceMethodId(
    r'setZoomSuggestionOptions',
    r'(Lcom/google/mlkit/vision/barcode/ZoomSuggestionOptions;)Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions$Builder;',
  );

  static final _setZoomSuggestionOptions = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setZoomSuggestionOptions(com.google.mlkit.vision.barcode.ZoomSuggestionOptions zoomSuggestionOptions)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setZoomSuggestionOptions(
    jni.JObject zoomSuggestionOptions,
  ) {
    return _setZoomSuggestionOptions(
            reference.pointer,
            _id_setZoomSuggestionOptions as jni.JMethodIDPtr,
            zoomSuggestionOptions.reference.pointer)
        .object(const $BarcodeScannerOptions_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $BarcodeScannerOptionsType());
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory BarcodeScannerOptions_Builder() {
    return BarcodeScannerOptions_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $BarcodeScannerOptions_BuilderType
    extends jni.JObjType<BarcodeScannerOptions_Builder> {
  const $BarcodeScannerOptions_BuilderType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions$Builder;';

  @override
  BarcodeScannerOptions_Builder fromReference(jni.JReference reference) =>
      BarcodeScannerOptions_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerOptions_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerOptions_BuilderType) &&
        other is $BarcodeScannerOptions_BuilderType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScannerOptions
class BarcodeScannerOptions extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScannerOptions> $type = type;

  BarcodeScannerOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/BarcodeScannerOptions');

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerOptionsType();
  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_zza = _class.instanceMethodId(
    r'zza',
    r'()I',
  );

  static final _zza = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int zza()
  int zza() {
    return _zza(reference.pointer, _id_zza as jni.JMethodIDPtr).integer;
  }

  static final _id_zzb = _class.instanceMethodId(
    r'zzb',
    r'()Lcom/google/mlkit/vision/barcode/ZoomSuggestionOptions;',
  );

  static final _zzb = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final com.google.mlkit.vision.barcode.ZoomSuggestionOptions zzb()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject zzb() {
    return _zzb(reference.pointer, _id_zzb as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_zzc = _class.instanceMethodId(
    r'zzc',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _zzc = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.concurrent.Executor zzc()
  /// The returned object must be released after use, by calling the [release] method.
  Executor zzc() {
    return _zzc(reference.pointer, _id_zzc as jni.JMethodIDPtr)
        .object(const $ExecutorType());
  }

  static final _id_zzd = _class.instanceMethodId(
    r'zzd',
    r'()Z',
  );

  static final _zzd = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean zzd()
  bool zzd() {
    return _zzd(reference.pointer, _id_zzd as jni.JMethodIDPtr).boolean;
  }
}

final class $BarcodeScannerOptionsType
    extends jni.JObjType<BarcodeScannerOptions> {
  const $BarcodeScannerOptionsType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions;';

  @override
  BarcodeScannerOptions fromReference(jni.JReference reference) =>
      BarcodeScannerOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerOptionsType) &&
        other is $BarcodeScannerOptionsType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Address$AddressType
class Barcode_Address_AddressType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Address_AddressType> $type = type;

  Barcode_Address_AddressType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Address$AddressType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Address_AddressTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Address_AddressTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_Address_AddressType.implement(
    $Barcode_Address_AddressTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Address_AddressType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$Address$AddressType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Address_AddressTypeImpl {
  factory $Barcode_Address_AddressTypeImpl() =
      _$Barcode_Address_AddressTypeImpl;
}

class _$Barcode_Address_AddressTypeImpl
    implements $Barcode_Address_AddressTypeImpl {
  _$Barcode_Address_AddressTypeImpl();
}

final class $Barcode_Address_AddressTypeType
    extends jni.JObjType<Barcode_Address_AddressType> {
  const $Barcode_Address_AddressTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Address$AddressType;';

  @override
  Barcode_Address_AddressType fromReference(jni.JReference reference) =>
      Barcode_Address_AddressType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Address_AddressTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Address_AddressTypeType) &&
        other is $Barcode_Address_AddressTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Address
class Barcode_Address extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Address> $type = type;

  Barcode_Address.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Address');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_AddressType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;
  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()I',
  );

  static final _getType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer, _id_getType as jni.JMethodIDPtr).integer;
  }

  static final _id_new0 = _class.constructorId(
    r'(I[Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Address(
    int i,
    jni.JArray<jni.JString> strings,
  ) {
    return Barcode_Address.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, i, strings.reference.pointer)
        .reference);
  }

  static final _id_getAddressLines = _class.instanceMethodId(
    r'getAddressLines',
    r'()[Ljava/lang/String;',
  );

  static final _getAddressLines = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String[] getAddressLines()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getAddressLines() {
    return _getAddressLines(
            reference.pointer, _id_getAddressLines as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JStringType()));
  }
}

final class $Barcode_AddressType extends jni.JObjType<Barcode_Address> {
  const $Barcode_AddressType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Address;';

  @override
  Barcode_Address fromReference(jni.JReference reference) =>
      Barcode_Address.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_AddressType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_AddressType) &&
        other is $Barcode_AddressType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$BarcodeFormat
class Barcode_BarcodeFormat extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_BarcodeFormat> $type = type;

  Barcode_BarcodeFormat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$BarcodeFormat');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_BarcodeFormatType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_BarcodeFormatImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_BarcodeFormat.implement(
    $Barcode_BarcodeFormatImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_BarcodeFormat.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$BarcodeFormat',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_BarcodeFormatImpl {
  factory $Barcode_BarcodeFormatImpl() = _$Barcode_BarcodeFormatImpl;
}

class _$Barcode_BarcodeFormatImpl implements $Barcode_BarcodeFormatImpl {
  _$Barcode_BarcodeFormatImpl();
}

final class $Barcode_BarcodeFormatType
    extends jni.JObjType<Barcode_BarcodeFormat> {
  const $Barcode_BarcodeFormatType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$BarcodeFormat;';

  @override
  Barcode_BarcodeFormat fromReference(jni.JReference reference) =>
      Barcode_BarcodeFormat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_BarcodeFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_BarcodeFormatType) &&
        other is $Barcode_BarcodeFormatType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$BarcodeValueType
class Barcode_BarcodeValueType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_BarcodeValueType> $type = type;

  Barcode_BarcodeValueType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$BarcodeValueType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_BarcodeValueTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_BarcodeValueTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_BarcodeValueType.implement(
    $Barcode_BarcodeValueTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_BarcodeValueType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$BarcodeValueType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_BarcodeValueTypeImpl {
  factory $Barcode_BarcodeValueTypeImpl() = _$Barcode_BarcodeValueTypeImpl;
}

class _$Barcode_BarcodeValueTypeImpl implements $Barcode_BarcodeValueTypeImpl {
  _$Barcode_BarcodeValueTypeImpl();
}

final class $Barcode_BarcodeValueTypeType
    extends jni.JObjType<Barcode_BarcodeValueType> {
  const $Barcode_BarcodeValueTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$BarcodeValueType;';

  @override
  Barcode_BarcodeValueType fromReference(jni.JReference reference) =>
      Barcode_BarcodeValueType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_BarcodeValueTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_BarcodeValueTypeType) &&
        other is $Barcode_BarcodeValueTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime
class Barcode_CalendarDateTime extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_CalendarDateTime> $type = type;

  Barcode_CalendarDateTime.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_CalendarDateTimeType();
  static final _id_getDay = _class.instanceMethodId(
    r'getDay',
    r'()I',
  );

  static final _getDay = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getDay()
  int getDay() {
    return _getDay(reference.pointer, _id_getDay as jni.JMethodIDPtr).integer;
  }

  static final _id_getHours = _class.instanceMethodId(
    r'getHours',
    r'()I',
  );

  static final _getHours = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getHours()
  int getHours() {
    return _getHours(reference.pointer, _id_getHours as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getMinutes = _class.instanceMethodId(
    r'getMinutes',
    r'()I',
  );

  static final _getMinutes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getMinutes()
  int getMinutes() {
    return _getMinutes(reference.pointer, _id_getMinutes as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()I',
  );

  static final _getMonth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getMonth()
  int getMonth() {
    return _getMonth(reference.pointer, _id_getMonth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getSeconds = _class.instanceMethodId(
    r'getSeconds',
    r'()I',
  );

  static final _getSeconds = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getSeconds()
  int getSeconds() {
    return _getSeconds(reference.pointer, _id_getSeconds as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getYear = _class.instanceMethodId(
    r'getYear',
    r'()I',
  );

  static final _getYear = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getYear()
  int getYear() {
    return _getYear(reference.pointer, _id_getYear as jni.JMethodIDPtr).integer;
  }

  static final _id_getRawValue = _class.instanceMethodId(
    r'getRawValue',
    r'()Ljava/lang/String;',
  );

  static final _getRawValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getRawValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRawValue() {
    return _getRawValue(reference.pointer, _id_getRawValue as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(IIIIIIZLjava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, int i1, int i2, int i3, int i4, int i5, boolean z, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_CalendarDateTime(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    bool z,
    jni.JString string,
  ) {
    return Barcode_CalendarDateTime.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            i,
            i1,
            i2,
            i3,
            i4,
            i5,
            z ? 1 : 0,
            string.reference.pointer)
        .reference);
  }

  static final _id_isUtc = _class.instanceMethodId(
    r'isUtc',
    r'()Z',
  );

  static final _isUtc = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isUtc()
  bool isUtc() {
    return _isUtc(reference.pointer, _id_isUtc as jni.JMethodIDPtr).boolean;
  }
}

final class $Barcode_CalendarDateTimeType
    extends jni.JObjType<Barcode_CalendarDateTime> {
  const $Barcode_CalendarDateTimeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;';

  @override
  Barcode_CalendarDateTime fromReference(jni.JReference reference) =>
      Barcode_CalendarDateTime.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_CalendarDateTimeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_CalendarDateTimeType) &&
        other is $Barcode_CalendarDateTimeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$CalendarEvent
class Barcode_CalendarEvent extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_CalendarEvent> $type = type;

  Barcode_CalendarEvent.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$CalendarEvent');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_CalendarEventType();
  static final _id_getEnd = _class.instanceMethodId(
    r'getEnd',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;',
  );

  static final _getEnd = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime getEnd()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarDateTime getEnd() {
    return _getEnd(reference.pointer, _id_getEnd as jni.JMethodIDPtr)
        .object(const $Barcode_CalendarDateTimeType());
  }

  static final _id_getStart = _class.instanceMethodId(
    r'getStart',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;',
  );

  static final _getStart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime getStart()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarDateTime getStart() {
    return _getStart(reference.pointer, _id_getStart as jni.JMethodIDPtr)
        .object(const $Barcode_CalendarDateTimeType());
  }

  static final _id_getDescription = _class.instanceMethodId(
    r'getDescription',
    r'()Ljava/lang/String;',
  );

  static final _getDescription = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDescription() {
    return _getDescription(
            reference.pointer, _id_getDescription as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getLocation = _class.instanceMethodId(
    r'getLocation',
    r'()Ljava/lang/String;',
  );

  static final _getLocation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLocation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLocation() {
    return _getLocation(reference.pointer, _id_getLocation as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getOrganizer = _class.instanceMethodId(
    r'getOrganizer',
    r'()Ljava/lang/String;',
  );

  static final _getOrganizer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getOrganizer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOrganizer() {
    return _getOrganizer(
            reference.pointer, _id_getOrganizer as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getStatus = _class.instanceMethodId(
    r'getStatus',
    r'()Ljava/lang/String;',
  );

  static final _getStatus = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getStatus()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getStatus() {
    return _getStatus(reference.pointer, _id_getStatus as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSummary = _class.instanceMethodId(
    r'getSummary',
    r'()Ljava/lang/String;',
  );

  static final _getSummary = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getSummary()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSummary() {
    return _getSummary(reference.pointer, _id_getSummary as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime calendarDateTime, com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime calendarDateTime1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_CalendarEvent(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    Barcode_CalendarDateTime calendarDateTime,
    Barcode_CalendarDateTime calendarDateTime1,
  ) {
    return Barcode_CalendarEvent.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            calendarDateTime.reference.pointer,
            calendarDateTime1.reference.pointer)
        .reference);
  }
}

final class $Barcode_CalendarEventType
    extends jni.JObjType<Barcode_CalendarEvent> {
  const $Barcode_CalendarEventType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarEvent;';

  @override
  Barcode_CalendarEvent fromReference(jni.JReference reference) =>
      Barcode_CalendarEvent.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_CalendarEventType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_CalendarEventType) &&
        other is $Barcode_CalendarEventType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$ContactInfo
class Barcode_ContactInfo extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_ContactInfo> $type = type;

  Barcode_ContactInfo.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$ContactInfo');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_ContactInfoType();
  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$PersonName;',
  );

  static final _getName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$PersonName getName()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_PersonName getName() {
    return _getName(reference.pointer, _id_getName as jni.JMethodIDPtr)
        .object(const $Barcode_PersonNameType());
  }

  static final _id_getOrganization = _class.instanceMethodId(
    r'getOrganization',
    r'()Ljava/lang/String;',
  );

  static final _getOrganization = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getOrganization()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOrganization() {
    return _getOrganization(
            reference.pointer, _id_getOrganization as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/String;',
  );

  static final _getTitle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAddresses = _class.instanceMethodId(
    r'getAddresses',
    r'()Ljava/util/List;',
  );

  static final _getAddresses = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getAddresses()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Address> getAddresses() {
    return _getAddresses(
            reference.pointer, _id_getAddresses as jni.JMethodIDPtr)
        .object(const jni.JListType($Barcode_AddressType()));
  }

  static final _id_getEmails = _class.instanceMethodId(
    r'getEmails',
    r'()Ljava/util/List;',
  );

  static final _getEmails = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getEmails()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Email> getEmails() {
    return _getEmails(reference.pointer, _id_getEmails as jni.JMethodIDPtr)
        .object(const jni.JListType($Barcode_EmailType()));
  }

  static final _id_getPhones = _class.instanceMethodId(
    r'getPhones',
    r'()Ljava/util/List;',
  );

  static final _getPhones = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getPhones()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Phone> getPhones() {
    return _getPhones(reference.pointer, _id_getPhones as jni.JMethodIDPtr)
        .object(const jni.JListType($Barcode_PhoneType()));
  }

  static final _id_getUrls = _class.instanceMethodId(
    r'getUrls',
    r'()Ljava/util/List;',
  );

  static final _getUrls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getUrls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getUrls() {
    return _getUrls(reference.pointer, _id_getUrls as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_new0 = _class.constructorId(
    r'(Lcom/google/mlkit/vision/barcode/common/Barcode$PersonName;Ljava/lang/String;Ljava/lang/String;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.Barcode$PersonName personName, java.lang.String string, java.lang.String string1, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_ContactInfo(
    Barcode_PersonName personName,
    jni.JString string,
    jni.JString string1,
    jni.JList<Barcode_Phone> list,
    jni.JList<Barcode_Email> list1,
    jni.JList<jni.JString> list2,
    jni.JList<Barcode_Address> list3,
  ) {
    return Barcode_ContactInfo.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            personName.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer,
            list.reference.pointer,
            list1.reference.pointer,
            list2.reference.pointer,
            list3.reference.pointer)
        .reference);
  }
}

final class $Barcode_ContactInfoType extends jni.JObjType<Barcode_ContactInfo> {
  const $Barcode_ContactInfoType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$ContactInfo;';

  @override
  Barcode_ContactInfo fromReference(jni.JReference reference) =>
      Barcode_ContactInfo.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_ContactInfoType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_ContactInfoType) &&
        other is $Barcode_ContactInfoType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$DriverLicense
class Barcode_DriverLicense extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_DriverLicense> $type = type;

  Barcode_DriverLicense.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$DriverLicense');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_DriverLicenseType();
  static final _id_getAddressCity = _class.instanceMethodId(
    r'getAddressCity',
    r'()Ljava/lang/String;',
  );

  static final _getAddressCity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddressCity()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressCity() {
    return _getAddressCity(
            reference.pointer, _id_getAddressCity as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAddressState = _class.instanceMethodId(
    r'getAddressState',
    r'()Ljava/lang/String;',
  );

  static final _getAddressState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddressState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressState() {
    return _getAddressState(
            reference.pointer, _id_getAddressState as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAddressStreet = _class.instanceMethodId(
    r'getAddressStreet',
    r'()Ljava/lang/String;',
  );

  static final _getAddressStreet = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddressStreet()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressStreet() {
    return _getAddressStreet(
            reference.pointer, _id_getAddressStreet as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAddressZip = _class.instanceMethodId(
    r'getAddressZip',
    r'()Ljava/lang/String;',
  );

  static final _getAddressZip = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddressZip()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressZip() {
    return _getAddressZip(
            reference.pointer, _id_getAddressZip as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getBirthDate = _class.instanceMethodId(
    r'getBirthDate',
    r'()Ljava/lang/String;',
  );

  static final _getBirthDate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getBirthDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBirthDate() {
    return _getBirthDate(
            reference.pointer, _id_getBirthDate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getDocumentType = _class.instanceMethodId(
    r'getDocumentType',
    r'()Ljava/lang/String;',
  );

  static final _getDocumentType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getDocumentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDocumentType() {
    return _getDocumentType(
            reference.pointer, _id_getDocumentType as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getExpiryDate = _class.instanceMethodId(
    r'getExpiryDate',
    r'()Ljava/lang/String;',
  );

  static final _getExpiryDate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getExpiryDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getExpiryDate() {
    return _getExpiryDate(
            reference.pointer, _id_getExpiryDate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getFirstName = _class.instanceMethodId(
    r'getFirstName',
    r'()Ljava/lang/String;',
  );

  static final _getFirstName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getFirstName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFirstName() {
    return _getFirstName(
            reference.pointer, _id_getFirstName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getGender = _class.instanceMethodId(
    r'getGender',
    r'()Ljava/lang/String;',
  );

  static final _getGender = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getGender()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getGender() {
    return _getGender(reference.pointer, _id_getGender as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getIssueDate = _class.instanceMethodId(
    r'getIssueDate',
    r'()Ljava/lang/String;',
  );

  static final _getIssueDate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getIssueDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getIssueDate() {
    return _getIssueDate(
            reference.pointer, _id_getIssueDate as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getIssuingCountry = _class.instanceMethodId(
    r'getIssuingCountry',
    r'()Ljava/lang/String;',
  );

  static final _getIssuingCountry = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getIssuingCountry()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getIssuingCountry() {
    return _getIssuingCountry(
            reference.pointer, _id_getIssuingCountry as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getLastName = _class.instanceMethodId(
    r'getLastName',
    r'()Ljava/lang/String;',
  );

  static final _getLastName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLastName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLastName() {
    return _getLastName(reference.pointer, _id_getLastName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getLicenseNumber = _class.instanceMethodId(
    r'getLicenseNumber',
    r'()Ljava/lang/String;',
  );

  static final _getLicenseNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLicenseNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLicenseNumber() {
    return _getLicenseNumber(
            reference.pointer, _id_getLicenseNumber as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getMiddleName = _class.instanceMethodId(
    r'getMiddleName',
    r'()Ljava/lang/String;',
  );

  static final _getMiddleName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getMiddleName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMiddleName() {
    return _getMiddleName(
            reference.pointer, _id_getMiddleName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6, java.lang.String string7, java.lang.String string8, java.lang.String string9, java.lang.String string10, java.lang.String string11, java.lang.String string12, java.lang.String string13)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_DriverLicense(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
    jni.JString string7,
    jni.JString string8,
    jni.JString string9,
    jni.JString string10,
    jni.JString string11,
    jni.JString string12,
    jni.JString string13,
  ) {
    return Barcode_DriverLicense.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            string5.reference.pointer,
            string6.reference.pointer,
            string7.reference.pointer,
            string8.reference.pointer,
            string9.reference.pointer,
            string10.reference.pointer,
            string11.reference.pointer,
            string12.reference.pointer,
            string13.reference.pointer)
        .reference);
  }
}

final class $Barcode_DriverLicenseType
    extends jni.JObjType<Barcode_DriverLicense> {
  const $Barcode_DriverLicenseType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$DriverLicense;';

  @override
  Barcode_DriverLicense fromReference(jni.JReference reference) =>
      Barcode_DriverLicense.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_DriverLicenseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_DriverLicenseType) &&
        other is $Barcode_DriverLicenseType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Email$FormatType
class Barcode_Email_FormatType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Email_FormatType> $type = type;

  Barcode_Email_FormatType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Email$FormatType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Email_FormatTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Email_FormatTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_Email_FormatType.implement(
    $Barcode_Email_FormatTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Email_FormatType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$Email$FormatType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Email_FormatTypeImpl {
  factory $Barcode_Email_FormatTypeImpl() = _$Barcode_Email_FormatTypeImpl;
}

class _$Barcode_Email_FormatTypeImpl implements $Barcode_Email_FormatTypeImpl {
  _$Barcode_Email_FormatTypeImpl();
}

final class $Barcode_Email_FormatTypeType
    extends jni.JObjType<Barcode_Email_FormatType> {
  const $Barcode_Email_FormatTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Email$FormatType;';

  @override
  Barcode_Email_FormatType fromReference(jni.JReference reference) =>
      Barcode_Email_FormatType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Email_FormatTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Email_FormatTypeType) &&
        other is $Barcode_Email_FormatTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Email
class Barcode_Email extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Email> $type = type;

  Barcode_Email.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Email');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_EmailType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;
  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()I',
  );

  static final _getType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer, _id_getType as jni.JMethodIDPtr).integer;
  }

  static final _id_getAddress = _class.instanceMethodId(
    r'getAddress',
    r'()Ljava/lang/String;',
  );

  static final _getAddress = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getAddress()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddress() {
    return _getAddress(reference.pointer, _id_getAddress as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getBody = _class.instanceMethodId(
    r'getBody',
    r'()Ljava/lang/String;',
  );

  static final _getBody = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getBody()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBody() {
    return _getBody(reference.pointer, _id_getBody as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSubject = _class.instanceMethodId(
    r'getSubject',
    r'()Ljava/lang/String;',
  );

  static final _getSubject = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getSubject()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSubject() {
    return _getSubject(reference.pointer, _id_getSubject as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Email(
    int i,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return Barcode_Email.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            i,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer)
        .reference);
  }
}

final class $Barcode_EmailType extends jni.JObjType<Barcode_Email> {
  const $Barcode_EmailType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Email;';

  @override
  Barcode_Email fromReference(jni.JReference reference) =>
      Barcode_Email.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_EmailType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_EmailType) &&
        other is $Barcode_EmailType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$GeoPoint
class Barcode_GeoPoint extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_GeoPoint> $type = type;

  Barcode_GeoPoint.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$GeoPoint');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_GeoPointType();
  static final _id_getLat = _class.instanceMethodId(
    r'getLat',
    r'()D',
  );

  static final _getLat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public double getLat()
  double getLat() {
    return _getLat(reference.pointer, _id_getLat as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getLng = _class.instanceMethodId(
    r'getLng',
    r'()D',
  );

  static final _getLng = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public double getLng()
  double getLng() {
    return _getLng(reference.pointer, _id_getLng as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_new0 = _class.constructorId(
    r'(DD)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Double, ffi.Double)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double, double)>();

  /// from: public void <init>(double d, double d1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_GeoPoint(
    double d,
    double d1,
  ) {
    return Barcode_GeoPoint.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr, d, d1)
            .reference);
  }
}

final class $Barcode_GeoPointType extends jni.JObjType<Barcode_GeoPoint> {
  const $Barcode_GeoPointType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$GeoPoint;';

  @override
  Barcode_GeoPoint fromReference(jni.JReference reference) =>
      Barcode_GeoPoint.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_GeoPointType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_GeoPointType) &&
        other is $Barcode_GeoPointType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$PersonName
class Barcode_PersonName extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_PersonName> $type = type;

  Barcode_PersonName.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$PersonName');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_PersonNameType();
  static final _id_getFirst = _class.instanceMethodId(
    r'getFirst',
    r'()Ljava/lang/String;',
  );

  static final _getFirst = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getFirst()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFirst() {
    return _getFirst(reference.pointer, _id_getFirst as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getFormattedName = _class.instanceMethodId(
    r'getFormattedName',
    r'()Ljava/lang/String;',
  );

  static final _getFormattedName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getFormattedName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFormattedName() {
    return _getFormattedName(
            reference.pointer, _id_getFormattedName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getLast = _class.instanceMethodId(
    r'getLast',
    r'()Ljava/lang/String;',
  );

  static final _getLast = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getLast()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLast() {
    return _getLast(reference.pointer, _id_getLast as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getMiddle = _class.instanceMethodId(
    r'getMiddle',
    r'()Ljava/lang/String;',
  );

  static final _getMiddle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getMiddle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMiddle() {
    return _getMiddle(reference.pointer, _id_getMiddle as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPrefix = _class.instanceMethodId(
    r'getPrefix',
    r'()Ljava/lang/String;',
  );

  static final _getPrefix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPrefix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPrefix() {
    return _getPrefix(reference.pointer, _id_getPrefix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPronunciation = _class.instanceMethodId(
    r'getPronunciation',
    r'()Ljava/lang/String;',
  );

  static final _getPronunciation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPronunciation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPronunciation() {
    return _getPronunciation(
            reference.pointer, _id_getPronunciation as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSuffix = _class.instanceMethodId(
    r'getSuffix',
    r'()Ljava/lang/String;',
  );

  static final _getSuffix = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getSuffix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSuffix() {
    return _getSuffix(reference.pointer, _id_getSuffix as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_PersonName(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
  ) {
    return Barcode_PersonName.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            string5.reference.pointer,
            string6.reference.pointer)
        .reference);
  }
}

final class $Barcode_PersonNameType extends jni.JObjType<Barcode_PersonName> {
  const $Barcode_PersonNameType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$PersonName;';

  @override
  Barcode_PersonName fromReference(jni.JReference reference) =>
      Barcode_PersonName.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_PersonNameType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_PersonNameType) &&
        other is $Barcode_PersonNameType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Phone$FormatType
class Barcode_Phone_FormatType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Phone_FormatType> $type = type;

  Barcode_Phone_FormatType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Phone$FormatType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Phone_FormatTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Phone_FormatTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_Phone_FormatType.implement(
    $Barcode_Phone_FormatTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Phone_FormatType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$Phone$FormatType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Phone_FormatTypeImpl {
  factory $Barcode_Phone_FormatTypeImpl() = _$Barcode_Phone_FormatTypeImpl;
}

class _$Barcode_Phone_FormatTypeImpl implements $Barcode_Phone_FormatTypeImpl {
  _$Barcode_Phone_FormatTypeImpl();
}

final class $Barcode_Phone_FormatTypeType
    extends jni.JObjType<Barcode_Phone_FormatType> {
  const $Barcode_Phone_FormatTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Phone$FormatType;';

  @override
  Barcode_Phone_FormatType fromReference(jni.JReference reference) =>
      Barcode_Phone_FormatType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Phone_FormatTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Phone_FormatTypeType) &&
        other is $Barcode_Phone_FormatTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Phone
class Barcode_Phone extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Phone> $type = type;

  Barcode_Phone.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$Phone');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_PhoneType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;

  /// from: static public final int TYPE_FAX
  static const TYPE_FAX = 3;

  /// from: static public final int TYPE_MOBILE
  static const TYPE_MOBILE = 4;
  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()I',
  );

  static final _getType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer, _id_getType as jni.JMethodIDPtr).integer;
  }

  static final _id_getNumber = _class.instanceMethodId(
    r'getNumber',
    r'()Ljava/lang/String;',
  );

  static final _getNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getNumber() {
    return _getNumber(reference.pointer, _id_getNumber as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;I)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Phone(
    jni.JString string,
    int i,
  ) {
    return Barcode_Phone.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, string.reference.pointer, i)
        .reference);
  }
}

final class $Barcode_PhoneType extends jni.JObjType<Barcode_Phone> {
  const $Barcode_PhoneType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Phone;';

  @override
  Barcode_Phone fromReference(jni.JReference reference) =>
      Barcode_Phone.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_PhoneType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_PhoneType) &&
        other is $Barcode_PhoneType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Sms
class Barcode_Sms extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Sms> $type = type;

  Barcode_Sms.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/barcode/common/Barcode$Sms');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_SmsType();
  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getMessage()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMessage() {
    return _getMessage(reference.pointer, _id_getMessage as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPhoneNumber = _class.instanceMethodId(
    r'getPhoneNumber',
    r'()Ljava/lang/String;',
  );

  static final _getPhoneNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPhoneNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPhoneNumber() {
    return _getPhoneNumber(
            reference.pointer, _id_getPhoneNumber as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Sms(
    jni.JString string,
    jni.JString string1,
  ) {
    return Barcode_Sms.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .reference);
  }
}

final class $Barcode_SmsType extends jni.JObjType<Barcode_Sms> {
  const $Barcode_SmsType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$Sms;';

  @override
  Barcode_Sms fromReference(jni.JReference reference) =>
      Barcode_Sms.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_SmsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_SmsType) && other is $Barcode_SmsType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$UrlBookmark
class Barcode_UrlBookmark extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_UrlBookmark> $type = type;

  Barcode_UrlBookmark.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$UrlBookmark');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_UrlBookmarkType();
  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/String;',
  );

  static final _getTitle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getUrl = _class.instanceMethodId(
    r'getUrl',
    r'()Ljava/lang/String;',
  );

  static final _getUrl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUrl() {
    return _getUrl(reference.pointer, _id_getUrl as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_UrlBookmark(
    jni.JString string,
    jni.JString string1,
  ) {
    return Barcode_UrlBookmark.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .reference);
  }
}

final class $Barcode_UrlBookmarkType extends jni.JObjType<Barcode_UrlBookmark> {
  const $Barcode_UrlBookmarkType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$UrlBookmark;';

  @override
  Barcode_UrlBookmark fromReference(jni.JReference reference) =>
      Barcode_UrlBookmark.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_UrlBookmarkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_UrlBookmarkType) &&
        other is $Barcode_UrlBookmarkType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$WiFi$EncryptionType
class Barcode_WiFi_EncryptionType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_WiFi_EncryptionType> $type = type;

  Barcode_WiFi_EncryptionType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$WiFi$EncryptionType');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_WiFi_EncryptionTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_WiFi_EncryptionTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Barcode_WiFi_EncryptionType.implement(
    $Barcode_WiFi_EncryptionTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_WiFi_EncryptionType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.barcode.common.Barcode$WiFi$EncryptionType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_WiFi_EncryptionTypeImpl {
  factory $Barcode_WiFi_EncryptionTypeImpl() =
      _$Barcode_WiFi_EncryptionTypeImpl;
}

class _$Barcode_WiFi_EncryptionTypeImpl
    implements $Barcode_WiFi_EncryptionTypeImpl {
  _$Barcode_WiFi_EncryptionTypeImpl();
}

final class $Barcode_WiFi_EncryptionTypeType
    extends jni.JObjType<Barcode_WiFi_EncryptionType> {
  const $Barcode_WiFi_EncryptionTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi$EncryptionType;';

  @override
  Barcode_WiFi_EncryptionType fromReference(jni.JReference reference) =>
      Barcode_WiFi_EncryptionType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_WiFi_EncryptionTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_WiFi_EncryptionTypeType) &&
        other is $Barcode_WiFi_EncryptionTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$WiFi
class Barcode_WiFi extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_WiFi> $type = type;

  Barcode_WiFi.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/barcode/common/Barcode$WiFi');

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_WiFiType();

  /// from: static public final int TYPE_OPEN
  static const TYPE_OPEN = 1;

  /// from: static public final int TYPE_WPA
  static const TYPE_WPA = 2;

  /// from: static public final int TYPE_WEP
  static const TYPE_WEP = 3;
  static final _id_getEncryptionType = _class.instanceMethodId(
    r'getEncryptionType',
    r'()I',
  );

  static final _getEncryptionType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getEncryptionType()
  int getEncryptionType() {
    return _getEncryptionType(
            reference.pointer, _id_getEncryptionType as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPassword = _class.instanceMethodId(
    r'getPassword',
    r'()Ljava/lang/String;',
  );

  static final _getPassword = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getPassword()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPassword() {
    return _getPassword(reference.pointer, _id_getPassword as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSsid = _class.instanceMethodId(
    r'getSsid',
    r'()Ljava/lang/String;',
  );

  static final _getSsid = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getSsid()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSsid() {
    return _getSsid(reference.pointer, _id_getSsid as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;I)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_WiFi(
    jni.JString string,
    jni.JString string1,
    int i,
  ) {
    return Barcode_WiFi.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer,
            i)
        .reference);
  }
}

final class $Barcode_WiFiType extends jni.JObjType<Barcode_WiFi> {
  const $Barcode_WiFiType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi;';

  @override
  Barcode_WiFi fromReference(jni.JReference reference) =>
      Barcode_WiFi.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_WiFiType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_WiFiType) &&
        other is $Barcode_WiFiType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode
class Barcode extends jni.JObject {
  @override
  late final jni.JObjType<Barcode> $type = type;

  Barcode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/barcode/common/Barcode');

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeType();

  /// from: static public final int FORMAT_UNKNOWN
  static const FORMAT_UNKNOWN = -1;

  /// from: static public final int FORMAT_ALL_FORMATS
  static const FORMAT_ALL_FORMATS = 0;

  /// from: static public final int FORMAT_CODE_128
  static const FORMAT_CODE_128 = 1;

  /// from: static public final int FORMAT_CODE_39
  static const FORMAT_CODE_39 = 2;

  /// from: static public final int FORMAT_CODE_93
  static const FORMAT_CODE_93 = 4;

  /// from: static public final int FORMAT_CODABAR
  static const FORMAT_CODABAR = 8;

  /// from: static public final int FORMAT_DATA_MATRIX
  static const FORMAT_DATA_MATRIX = 16;

  /// from: static public final int FORMAT_EAN_13
  static const FORMAT_EAN_13 = 32;

  /// from: static public final int FORMAT_EAN_8
  static const FORMAT_EAN_8 = 64;

  /// from: static public final int FORMAT_ITF
  static const FORMAT_ITF = 128;

  /// from: static public final int FORMAT_QR_CODE
  static const FORMAT_QR_CODE = 256;

  /// from: static public final int FORMAT_UPC_A
  static const FORMAT_UPC_A = 512;

  /// from: static public final int FORMAT_UPC_E
  static const FORMAT_UPC_E = 1024;

  /// from: static public final int FORMAT_PDF417
  static const FORMAT_PDF417 = 2048;

  /// from: static public final int FORMAT_AZTEC
  static const FORMAT_AZTEC = 4096;

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_CONTACT_INFO
  static const TYPE_CONTACT_INFO = 1;

  /// from: static public final int TYPE_EMAIL
  static const TYPE_EMAIL = 2;

  /// from: static public final int TYPE_ISBN
  static const TYPE_ISBN = 3;

  /// from: static public final int TYPE_PHONE
  static const TYPE_PHONE = 4;

  /// from: static public final int TYPE_PRODUCT
  static const TYPE_PRODUCT = 5;

  /// from: static public final int TYPE_SMS
  static const TYPE_SMS = 6;

  /// from: static public final int TYPE_TEXT
  static const TYPE_TEXT = 7;

  /// from: static public final int TYPE_URL
  static const TYPE_URL = 8;

  /// from: static public final int TYPE_WIFI
  static const TYPE_WIFI = 9;

  /// from: static public final int TYPE_GEO
  static const TYPE_GEO = 10;

  /// from: static public final int TYPE_CALENDAR_EVENT
  static const TYPE_CALENDAR_EVENT = 11;

  /// from: static public final int TYPE_DRIVER_LICENSE
  static const TYPE_DRIVER_LICENSE = 12;
  static final _id_getFormat = _class.instanceMethodId(
    r'getFormat',
    r'()I',
  );

  static final _getFormat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getFormat()
  int getFormat() {
    return _getFormat(reference.pointer, _id_getFormat as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getValueType = _class.instanceMethodId(
    r'getValueType',
    r'()I',
  );

  static final _getValueType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getValueType()
  int getValueType() {
    return _getValueType(
            reference.pointer, _id_getValueType as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getBoundingBox = _class.instanceMethodId(
    r'getBoundingBox',
    r'()Landroid/graphics/Rect;',
  );

  static final _getBoundingBox = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Rect getBoundingBox()
  /// The returned object must be released after use, by calling the [release] method.
  Rect getBoundingBox() {
    return _getBoundingBox(
            reference.pointer, _id_getBoundingBox as jni.JMethodIDPtr)
        .object(const $RectType());
  }

  static final _id_getCalendarEvent = _class.instanceMethodId(
    r'getCalendarEvent',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarEvent;',
  );

  static final _getCalendarEvent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarEvent getCalendarEvent()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarEvent getCalendarEvent() {
    return _getCalendarEvent(
            reference.pointer, _id_getCalendarEvent as jni.JMethodIDPtr)
        .object(const $Barcode_CalendarEventType());
  }

  static final _id_getContactInfo = _class.instanceMethodId(
    r'getContactInfo',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$ContactInfo;',
  );

  static final _getContactInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$ContactInfo getContactInfo()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_ContactInfo getContactInfo() {
    return _getContactInfo(
            reference.pointer, _id_getContactInfo as jni.JMethodIDPtr)
        .object(const $Barcode_ContactInfoType());
  }

  static final _id_getDriverLicense = _class.instanceMethodId(
    r'getDriverLicense',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$DriverLicense;',
  );

  static final _getDriverLicense = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$DriverLicense getDriverLicense()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_DriverLicense getDriverLicense() {
    return _getDriverLicense(
            reference.pointer, _id_getDriverLicense as jni.JMethodIDPtr)
        .object(const $Barcode_DriverLicenseType());
  }

  static final _id_getEmail = _class.instanceMethodId(
    r'getEmail',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$Email;',
  );

  static final _getEmail = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Email getEmail()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Email getEmail() {
    return _getEmail(reference.pointer, _id_getEmail as jni.JMethodIDPtr)
        .object(const $Barcode_EmailType());
  }

  static final _id_getGeoPoint = _class.instanceMethodId(
    r'getGeoPoint',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$GeoPoint;',
  );

  static final _getGeoPoint = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$GeoPoint getGeoPoint()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_GeoPoint getGeoPoint() {
    return _getGeoPoint(reference.pointer, _id_getGeoPoint as jni.JMethodIDPtr)
        .object(const $Barcode_GeoPointType());
  }

  static final _id_getPhone = _class.instanceMethodId(
    r'getPhone',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$Phone;',
  );

  static final _getPhone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Phone getPhone()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Phone getPhone() {
    return _getPhone(reference.pointer, _id_getPhone as jni.JMethodIDPtr)
        .object(const $Barcode_PhoneType());
  }

  static final _id_getSms = _class.instanceMethodId(
    r'getSms',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$Sms;',
  );

  static final _getSms = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Sms getSms()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Sms getSms() {
    return _getSms(reference.pointer, _id_getSms as jni.JMethodIDPtr)
        .object(const $Barcode_SmsType());
  }

  static final _id_getUrl = _class.instanceMethodId(
    r'getUrl',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$UrlBookmark;',
  );

  static final _getUrl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$UrlBookmark getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_UrlBookmark getUrl() {
    return _getUrl(reference.pointer, _id_getUrl as jni.JMethodIDPtr)
        .object(const $Barcode_UrlBookmarkType());
  }

  static final _id_getWifi = _class.instanceMethodId(
    r'getWifi',
    r'()Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi;',
  );

  static final _getWifi = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$WiFi getWifi()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_WiFi getWifi() {
    return _getWifi(reference.pointer, _id_getWifi as jni.JMethodIDPtr)
        .object(const $Barcode_WiFiType());
  }

  static final _id_getDisplayValue = _class.instanceMethodId(
    r'getDisplayValue',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getDisplayValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDisplayValue() {
    return _getDisplayValue(
            reference.pointer, _id_getDisplayValue as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getRawValue = _class.instanceMethodId(
    r'getRawValue',
    r'()Ljava/lang/String;',
  );

  static final _getRawValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getRawValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRawValue() {
    return _getRawValue(reference.pointer, _id_getRawValue as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lcom/google/mlkit/vision/barcode/common/internal/BarcodeSource;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.internal.BarcodeSource barcodeSource)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode(
    jni.JObject barcodeSource,
  ) {
    return Barcode.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, barcodeSource.reference.pointer)
        .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Lcom/google/mlkit/vision/barcode/common/internal/BarcodeSource;Landroid/graphics/Matrix;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.internal.BarcodeSource barcodeSource, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode.new1(
    jni.JObject barcodeSource,
    jni.JObject matrix,
  ) {
    return Barcode.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            barcodeSource.reference.pointer,
            matrix.reference.pointer)
        .reference);
  }

  static final _id_getRawBytes = _class.instanceMethodId(
    r'getRawBytes',
    r'()[B',
  );

  static final _getRawBytes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public byte[] getRawBytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getRawBytes() {
    return _getRawBytes(reference.pointer, _id_getRawBytes as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_getCornerPoints = _class.instanceMethodId(
    r'getCornerPoints',
    r'()[Landroid/graphics/Point;',
  );

  static final _getCornerPoints = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Point[] getCornerPoints()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<Point> getCornerPoints() {
    return _getCornerPoints(
            reference.pointer, _id_getCornerPoints as jni.JMethodIDPtr)
        .object(const jni.JArrayType($PointType()));
  }
}

final class $BarcodeType extends jni.JObjType<Barcode> {
  const $BarcodeType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/barcode/common/Barcode;';

  @override
  Barcode fromReference(jni.JReference reference) =>
      Barcode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeType) && other is $BarcodeType;
  }
}

/// from: com.google.mlkit.vision.face.Face
class Face extends jni.JObject {
  @override
  late final jni.JObjType<Face> $type = type;

  Face.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/face/Face');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceType();
  static final _id_getHeadEulerAngleX = _class.instanceMethodId(
    r'getHeadEulerAngleX',
    r'()F',
  );

  static final _getHeadEulerAngleX = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public float getHeadEulerAngleX()
  double getHeadEulerAngleX() {
    return _getHeadEulerAngleX(
            reference.pointer, _id_getHeadEulerAngleX as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getHeadEulerAngleY = _class.instanceMethodId(
    r'getHeadEulerAngleY',
    r'()F',
  );

  static final _getHeadEulerAngleY = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public float getHeadEulerAngleY()
  double getHeadEulerAngleY() {
    return _getHeadEulerAngleY(
            reference.pointer, _id_getHeadEulerAngleY as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getHeadEulerAngleZ = _class.instanceMethodId(
    r'getHeadEulerAngleZ',
    r'()F',
  );

  static final _getHeadEulerAngleZ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public float getHeadEulerAngleZ()
  double getHeadEulerAngleZ() {
    return _getHeadEulerAngleZ(
            reference.pointer, _id_getHeadEulerAngleZ as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getBoundingBox = _class.instanceMethodId(
    r'getBoundingBox',
    r'()Landroid/graphics/Rect;',
  );

  static final _getBoundingBox = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Rect getBoundingBox()
  /// The returned object must be released after use, by calling the [release] method.
  Rect getBoundingBox() {
    return _getBoundingBox(
            reference.pointer, _id_getBoundingBox as jni.JMethodIDPtr)
        .object(const $RectType());
  }

  static final _id_getContour = _class.instanceMethodId(
    r'getContour',
    r'(I)Lcom/google/mlkit/vision/face/FaceContour;',
  );

  static final _getContour = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.mlkit.vision.face.FaceContour getContour(int i)
  /// The returned object must be released after use, by calling the [release] method.
  FaceContour getContour(
    int i,
  ) {
    return _getContour(reference.pointer, _id_getContour as jni.JMethodIDPtr, i)
        .object(const $FaceContourType());
  }

  static final _id_getLandmark = _class.instanceMethodId(
    r'getLandmark',
    r'(I)Lcom/google/mlkit/vision/face/FaceLandmark;',
  );

  static final _getLandmark = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.mlkit.vision.face.FaceLandmark getLandmark(int i)
  /// The returned object must be released after use, by calling the [release] method.
  FaceLandmark getLandmark(
    int i,
  ) {
    return _getLandmark(
            reference.pointer, _id_getLandmark as jni.JMethodIDPtr, i)
        .object(const $FaceLandmarkType());
  }

  static final _id_getLeftEyeOpenProbability = _class.instanceMethodId(
    r'getLeftEyeOpenProbability',
    r'()Ljava/lang/Float;',
  );

  static final _getLeftEyeOpenProbability = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Float getLeftEyeOpenProbability()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JFloat getLeftEyeOpenProbability() {
    return _getLeftEyeOpenProbability(reference.pointer,
            _id_getLeftEyeOpenProbability as jni.JMethodIDPtr)
        .object(const jni.JFloatType());
  }

  static final _id_getRightEyeOpenProbability = _class.instanceMethodId(
    r'getRightEyeOpenProbability',
    r'()Ljava/lang/Float;',
  );

  static final _getRightEyeOpenProbability = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Float getRightEyeOpenProbability()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JFloat getRightEyeOpenProbability() {
    return _getRightEyeOpenProbability(reference.pointer,
            _id_getRightEyeOpenProbability as jni.JMethodIDPtr)
        .object(const jni.JFloatType());
  }

  static final _id_getSmilingProbability = _class.instanceMethodId(
    r'getSmilingProbability',
    r'()Ljava/lang/Float;',
  );

  static final _getSmilingProbability = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Float getSmilingProbability()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JFloat getSmilingProbability() {
    return _getSmilingProbability(
            reference.pointer, _id_getSmilingProbability as jni.JMethodIDPtr)
        .object(const jni.JFloatType());
  }

  static final _id_getTrackingId = _class.instanceMethodId(
    r'getTrackingId',
    r'()Ljava/lang/Integer;',
  );

  static final _getTrackingId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Integer getTrackingId()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger getTrackingId() {
    return _getTrackingId(
            reference.pointer, _id_getTrackingId as jni.JMethodIDPtr)
        .object(const jni.JIntegerType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getAllContours = _class.instanceMethodId(
    r'getAllContours',
    r'()Ljava/util/List;',
  );

  static final _getAllContours = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getAllContours()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<FaceContour> getAllContours() {
    return _getAllContours(
            reference.pointer, _id_getAllContours as jni.JMethodIDPtr)
        .object(const jni.JListType($FaceContourType()));
  }

  static final _id_getAllLandmarks = _class.instanceMethodId(
    r'getAllLandmarks',
    r'()Ljava/util/List;',
  );

  static final _getAllLandmarks = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getAllLandmarks()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<FaceLandmark> getAllLandmarks() {
    return _getAllLandmarks(
            reference.pointer, _id_getAllLandmarks as jni.JMethodIDPtr)
        .object(const jni.JListType($FaceLandmarkType()));
  }

  static final _id_zza = _class.instanceMethodId(
    r'zza',
    r'()Landroid/util/SparseArray;',
  );

  static final _zza = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.util.SparseArray zza()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject zza() {
    return _zza(reference.pointer, _id_zza as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lcom/google/android/gms/internal/mlkit_vision_face/zzf;Landroid/graphics/Matrix;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.android.gms.internal.mlkit_vision_face.zzf zzf, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  factory Face(
    jni.JObject zzf,
    jni.JObject matrix,
  ) {
    return Face.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            zzf.reference.pointer,
            matrix.reference.pointer)
        .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Lcom/google/android/gms/internal/mlkit_vision_face/zzow;Landroid/graphics/Matrix;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.android.gms.internal.mlkit_vision_face.zzow zzow, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  factory Face.new1(
    jni.JObject zzow,
    jni.JObject matrix,
  ) {
    return Face.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            zzow.reference.pointer,
            matrix.reference.pointer)
        .reference);
  }

  static final _id_zzb = _class.instanceMethodId(
    r'zzb',
    r'(Landroid/util/SparseArray;)V',
  );

  static final _zzb = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void zzb(android.util.SparseArray sparseArray)
  void zzb(
    jni.JObject sparseArray,
  ) {
    _zzb(reference.pointer, _id_zzb as jni.JMethodIDPtr,
            sparseArray.reference.pointer)
        .check();
  }

  static final _id_zzc = _class.instanceMethodId(
    r'zzc',
    r'(I)V',
  );

  static final _zzc = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void zzc(int i)
  void zzc(
    int i,
  ) {
    _zzc(reference.pointer, _id_zzc as jni.JMethodIDPtr, i).check();
  }
}

final class $FaceType extends jni.JObjType<Face> {
  const $FaceType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/face/Face;';

  @override
  Face fromReference(jni.JReference reference) => Face.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceType) && other is $FaceType;
  }
}

/// from: com.google.mlkit.vision.face.FaceContour$ContourType
class FaceContour_ContourType extends jni.JObject {
  @override
  late final jni.JObjType<FaceContour_ContourType> $type = type;

  FaceContour_ContourType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/face/FaceContour$ContourType');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceContour_ContourTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FaceContour_ContourTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory FaceContour_ContourType.implement(
    $FaceContour_ContourTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FaceContour_ContourType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.face.FaceContour$ContourType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FaceContour_ContourTypeImpl {
  factory $FaceContour_ContourTypeImpl() = _$FaceContour_ContourTypeImpl;
}

class _$FaceContour_ContourTypeImpl implements $FaceContour_ContourTypeImpl {
  _$FaceContour_ContourTypeImpl();
}

final class $FaceContour_ContourTypeType
    extends jni.JObjType<FaceContour_ContourType> {
  const $FaceContour_ContourTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/face/FaceContour$ContourType;';

  @override
  FaceContour_ContourType fromReference(jni.JReference reference) =>
      FaceContour_ContourType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceContour_ContourTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceContour_ContourTypeType) &&
        other is $FaceContour_ContourTypeType;
  }
}

/// from: com.google.mlkit.vision.face.FaceContour
class FaceContour extends jni.JObject {
  @override
  late final jni.JObjType<FaceContour> $type = type;

  FaceContour.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/face/FaceContour');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceContourType();

  /// from: static public final int FACE
  static const FACE = 1;

  /// from: static public final int LEFT_EYEBROW_TOP
  static const LEFT_EYEBROW_TOP = 2;

  /// from: static public final int LEFT_EYEBROW_BOTTOM
  static const LEFT_EYEBROW_BOTTOM = 3;

  /// from: static public final int RIGHT_EYEBROW_TOP
  static const RIGHT_EYEBROW_TOP = 4;

  /// from: static public final int RIGHT_EYEBROW_BOTTOM
  static const RIGHT_EYEBROW_BOTTOM = 5;

  /// from: static public final int LEFT_EYE
  static const LEFT_EYE = 6;

  /// from: static public final int RIGHT_EYE
  static const RIGHT_EYE = 7;

  /// from: static public final int UPPER_LIP_TOP
  static const UPPER_LIP_TOP = 8;

  /// from: static public final int UPPER_LIP_BOTTOM
  static const UPPER_LIP_BOTTOM = 9;

  /// from: static public final int LOWER_LIP_TOP
  static const LOWER_LIP_TOP = 10;

  /// from: static public final int LOWER_LIP_BOTTOM
  static const LOWER_LIP_BOTTOM = 11;

  /// from: static public final int NOSE_BRIDGE
  static const NOSE_BRIDGE = 12;

  /// from: static public final int NOSE_BOTTOM
  static const NOSE_BOTTOM = 13;

  /// from: static public final int LEFT_CHEEK
  static const LEFT_CHEEK = 14;

  /// from: static public final int RIGHT_CHEEK
  static const RIGHT_CHEEK = 15;
  static final _id_getFaceContourType = _class.instanceMethodId(
    r'getFaceContourType',
    r'()I',
  );

  static final _getFaceContourType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getFaceContourType()
  int getFaceContourType() {
    return _getFaceContourType(
            reference.pointer, _id_getFaceContourType as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getPoints = _class.instanceMethodId(
    r'getPoints',
    r'()Ljava/util/List;',
  );

  static final _getPoints = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List getPoints()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getPoints() {
    return _getPoints(reference.pointer, _id_getPoints as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_new0 = _class.constructorId(
    r'(ILjava/util/List;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  factory FaceContour(
    int i,
    jni.JList<jni.JObject> list,
  ) {
    return FaceContour.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, i, list.reference.pointer)
        .reference);
  }
}

final class $FaceContourType extends jni.JObjType<FaceContour> {
  const $FaceContourType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/face/FaceContour;';

  @override
  FaceContour fromReference(jni.JReference reference) =>
      FaceContour.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceContourType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceContourType) && other is $FaceContourType;
  }
}

/// from: com.google.mlkit.vision.face.FaceDetection
class FaceDetection extends jni.JObject {
  @override
  late final jni.JObjType<FaceDetection> $type = type;

  FaceDetection.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/face/FaceDetection');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceDetectionType();
  static final _id_getClient = _class.staticMethodId(
    r'getClient',
    r'()Lcom/google/mlkit/vision/face/FaceDetector;',
  );

  static final _getClient = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public com.google.mlkit.vision.face.FaceDetector getClient()
  /// The returned object must be released after use, by calling the [release] method.
  static FaceDetector getClient() {
    return _getClient(
            _class.reference.pointer, _id_getClient as jni.JMethodIDPtr)
        .object(const $FaceDetectorType());
  }

  static final _id_getClient1 = _class.staticMethodId(
    r'getClient',
    r'(Lcom/google/mlkit/vision/face/FaceDetectorOptions;)Lcom/google/mlkit/vision/face/FaceDetector;',
  );

  static final _getClient1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.face.FaceDetector getClient(com.google.mlkit.vision.face.FaceDetectorOptions faceDetectorOptions)
  /// The returned object must be released after use, by calling the [release] method.
  static FaceDetector getClient1(
    FaceDetectorOptions faceDetectorOptions,
  ) {
    return _getClient1(
            _class.reference.pointer,
            _id_getClient1 as jni.JMethodIDPtr,
            faceDetectorOptions.reference.pointer)
        .object(const $FaceDetectorType());
  }
}

final class $FaceDetectionType extends jni.JObjType<FaceDetection> {
  const $FaceDetectionType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/face/FaceDetection;';

  @override
  FaceDetection fromReference(jni.JReference reference) =>
      FaceDetection.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceDetectionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceDetectionType) &&
        other is $FaceDetectionType;
  }
}

/// from: com.google.mlkit.vision.face.FaceDetector
class FaceDetector extends jni.JObject {
  @override
  late final jni.JObjType<FaceDetector> $type = type;

  FaceDetector.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/face/FaceDetector');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceDetectorType();
  static final _id_process = _class.instanceMethodId(
    r'process',
    r'(Lcom/google/android/odml/image/MlImage;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _process = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(com.google.android.odml.image.MlImage mlImage)
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni.JList<Face>> process(
    jni.JObject mlImage,
  ) {
    return _process(reference.pointer, _id_process as jni.JMethodIDPtr,
            mlImage.reference.pointer)
        .object(const $TaskType(jni.JListType($FaceType())));
  }

  static final _id_process1 = _class.instanceMethodId(
    r'process',
    r'(Lcom/google/mlkit/vision/common/InputImage;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _process1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(com.google.mlkit.vision.common.InputImage inputImage)
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni.JList<Face>> process1(
    InputImage inputImage,
  ) {
    return _process1(reference.pointer, _id_process1 as jni.JMethodIDPtr,
            inputImage.reference.pointer)
        .object(const $TaskType(jni.JListType($FaceType())));
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FaceDetectorImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'process(Lcom/google/android/odml/image/MlImage;)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.process(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r'process(Lcom/google/mlkit/vision/common/InputImage;)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.process1(
          $a[0].castTo(const $InputImageType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory FaceDetector.implement(
    $FaceDetectorImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FaceDetector.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.face.FaceDetector',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FaceDetectorImpl {
  factory $FaceDetectorImpl({
    required Task<jni.JList<Face>> Function(jni.JObject mlImage) process,
    required Task<jni.JList<Face>> Function(InputImage inputImage) process1,
    required void Function() close,
  }) = _$FaceDetectorImpl;

  Task<jni.JList<Face>> process(jni.JObject mlImage);
  Task<jni.JList<Face>> process1(InputImage inputImage);
  void close();
}

class _$FaceDetectorImpl implements $FaceDetectorImpl {
  _$FaceDetectorImpl({
    required Task<jni.JList<Face>> Function(jni.JObject mlImage) process,
    required Task<jni.JList<Face>> Function(InputImage inputImage) process1,
    required void Function() close,
  })  : _process = process,
        _process1 = process1,
        _close = close;

  final Task<jni.JList<Face>> Function(jni.JObject mlImage) _process;
  final Task<jni.JList<Face>> Function(InputImage inputImage) _process1;
  final void Function() _close;

  Task<jni.JList<Face>> process(jni.JObject mlImage) {
    return _process(mlImage);
  }

  Task<jni.JList<Face>> process1(InputImage inputImage) {
    return _process1(inputImage);
  }

  void close() {
    return _close();
  }
}

final class $FaceDetectorType extends jni.JObjType<FaceDetector> {
  const $FaceDetectorType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/face/FaceDetector;';

  @override
  FaceDetector fromReference(jni.JReference reference) =>
      FaceDetector.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceDetectorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceDetectorType) &&
        other is $FaceDetectorType;
  }
}

/// from: com.google.mlkit.vision.face.FaceDetectorOptions$Builder
class FaceDetectorOptions_Builder extends jni.JObject {
  @override
  late final jni.JObjType<FaceDetectorOptions_Builder> $type = type;

  FaceDetectorOptions_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/face/FaceDetectorOptions$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceDetectorOptions_BuilderType();
  static final _id_enableTracking = _class.instanceMethodId(
    r'enableTracking',
    r'()Lcom/google/mlkit/vision/face/FaceDetectorOptions$Builder;',
  );

  static final _enableTracking = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.face.FaceDetectorOptions$Builder enableTracking()
  /// The returned object must be released after use, by calling the [release] method.
  FaceDetectorOptions_Builder enableTracking() {
    return _enableTracking(
            reference.pointer, _id_enableTracking as jni.JMethodIDPtr)
        .object(const $FaceDetectorOptions_BuilderType());
  }

  static final _id_setClassificationMode = _class.instanceMethodId(
    r'setClassificationMode',
    r'(I)Lcom/google/mlkit/vision/face/FaceDetectorOptions$Builder;',
  );

  static final _setClassificationMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.mlkit.vision.face.FaceDetectorOptions$Builder setClassificationMode(int i)
  /// The returned object must be released after use, by calling the [release] method.
  FaceDetectorOptions_Builder setClassificationMode(
    int i,
  ) {
    return _setClassificationMode(
            reference.pointer, _id_setClassificationMode as jni.JMethodIDPtr, i)
        .object(const $FaceDetectorOptions_BuilderType());
  }

  static final _id_setContourMode = _class.instanceMethodId(
    r'setContourMode',
    r'(I)Lcom/google/mlkit/vision/face/FaceDetectorOptions$Builder;',
  );

  static final _setContourMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.mlkit.vision.face.FaceDetectorOptions$Builder setContourMode(int i)
  /// The returned object must be released after use, by calling the [release] method.
  FaceDetectorOptions_Builder setContourMode(
    int i,
  ) {
    return _setContourMode(
            reference.pointer, _id_setContourMode as jni.JMethodIDPtr, i)
        .object(const $FaceDetectorOptions_BuilderType());
  }

  static final _id_setExecutor = _class.instanceMethodId(
    r'setExecutor',
    r'(Ljava/util/concurrent/Executor;)Lcom/google/mlkit/vision/face/FaceDetectorOptions$Builder;',
  );

  static final _setExecutor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.face.FaceDetectorOptions$Builder setExecutor(java.util.concurrent.Executor executor)
  /// The returned object must be released after use, by calling the [release] method.
  FaceDetectorOptions_Builder setExecutor(
    Executor executor,
  ) {
    return _setExecutor(reference.pointer, _id_setExecutor as jni.JMethodIDPtr,
            executor.reference.pointer)
        .object(const $FaceDetectorOptions_BuilderType());
  }

  static final _id_setLandmarkMode = _class.instanceMethodId(
    r'setLandmarkMode',
    r'(I)Lcom/google/mlkit/vision/face/FaceDetectorOptions$Builder;',
  );

  static final _setLandmarkMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.mlkit.vision.face.FaceDetectorOptions$Builder setLandmarkMode(int i)
  /// The returned object must be released after use, by calling the [release] method.
  FaceDetectorOptions_Builder setLandmarkMode(
    int i,
  ) {
    return _setLandmarkMode(
            reference.pointer, _id_setLandmarkMode as jni.JMethodIDPtr, i)
        .object(const $FaceDetectorOptions_BuilderType());
  }

  static final _id_setMinFaceSize = _class.instanceMethodId(
    r'setMinFaceSize',
    r'(F)Lcom/google/mlkit/vision/face/FaceDetectorOptions$Builder;',
  );

  static final _setMinFaceSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: public com.google.mlkit.vision.face.FaceDetectorOptions$Builder setMinFaceSize(float f)
  /// The returned object must be released after use, by calling the [release] method.
  FaceDetectorOptions_Builder setMinFaceSize(
    double f,
  ) {
    return _setMinFaceSize(
            reference.pointer, _id_setMinFaceSize as jni.JMethodIDPtr, f)
        .object(const $FaceDetectorOptions_BuilderType());
  }

  static final _id_setPerformanceMode = _class.instanceMethodId(
    r'setPerformanceMode',
    r'(I)Lcom/google/mlkit/vision/face/FaceDetectorOptions$Builder;',
  );

  static final _setPerformanceMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.mlkit.vision.face.FaceDetectorOptions$Builder setPerformanceMode(int i)
  /// The returned object must be released after use, by calling the [release] method.
  FaceDetectorOptions_Builder setPerformanceMode(
    int i,
  ) {
    return _setPerformanceMode(
            reference.pointer, _id_setPerformanceMode as jni.JMethodIDPtr, i)
        .object(const $FaceDetectorOptions_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lcom/google/mlkit/vision/face/FaceDetectorOptions;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.mlkit.vision.face.FaceDetectorOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  FaceDetectorOptions build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $FaceDetectorOptionsType());
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory FaceDetectorOptions_Builder() {
    return FaceDetectorOptions_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $FaceDetectorOptions_BuilderType
    extends jni.JObjType<FaceDetectorOptions_Builder> {
  const $FaceDetectorOptions_BuilderType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/face/FaceDetectorOptions$Builder;';

  @override
  FaceDetectorOptions_Builder fromReference(jni.JReference reference) =>
      FaceDetectorOptions_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceDetectorOptions_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceDetectorOptions_BuilderType) &&
        other is $FaceDetectorOptions_BuilderType;
  }
}

/// from: com.google.mlkit.vision.face.FaceDetectorOptions$ClassificationMode
class FaceDetectorOptions_ClassificationMode extends jni.JObject {
  @override
  late final jni.JObjType<FaceDetectorOptions_ClassificationMode> $type = type;

  FaceDetectorOptions_ClassificationMode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/face/FaceDetectorOptions$ClassificationMode');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceDetectorOptions_ClassificationModeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FaceDetectorOptions_ClassificationModeImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory FaceDetectorOptions_ClassificationMode.implement(
    $FaceDetectorOptions_ClassificationModeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FaceDetectorOptions_ClassificationMode.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.face.FaceDetectorOptions$ClassificationMode',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FaceDetectorOptions_ClassificationModeImpl {
  factory $FaceDetectorOptions_ClassificationModeImpl() =
      _$FaceDetectorOptions_ClassificationModeImpl;
}

class _$FaceDetectorOptions_ClassificationModeImpl
    implements $FaceDetectorOptions_ClassificationModeImpl {
  _$FaceDetectorOptions_ClassificationModeImpl();
}

final class $FaceDetectorOptions_ClassificationModeType
    extends jni.JObjType<FaceDetectorOptions_ClassificationMode> {
  const $FaceDetectorOptions_ClassificationModeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/face/FaceDetectorOptions$ClassificationMode;';

  @override
  FaceDetectorOptions_ClassificationMode fromReference(
          jni.JReference reference) =>
      FaceDetectorOptions_ClassificationMode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceDetectorOptions_ClassificationModeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceDetectorOptions_ClassificationModeType) &&
        other is $FaceDetectorOptions_ClassificationModeType;
  }
}

/// from: com.google.mlkit.vision.face.FaceDetectorOptions$ContourMode
class FaceDetectorOptions_ContourMode extends jni.JObject {
  @override
  late final jni.JObjType<FaceDetectorOptions_ContourMode> $type = type;

  FaceDetectorOptions_ContourMode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/face/FaceDetectorOptions$ContourMode');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceDetectorOptions_ContourModeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FaceDetectorOptions_ContourModeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory FaceDetectorOptions_ContourMode.implement(
    $FaceDetectorOptions_ContourModeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FaceDetectorOptions_ContourMode.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.face.FaceDetectorOptions$ContourMode',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FaceDetectorOptions_ContourModeImpl {
  factory $FaceDetectorOptions_ContourModeImpl() =
      _$FaceDetectorOptions_ContourModeImpl;
}

class _$FaceDetectorOptions_ContourModeImpl
    implements $FaceDetectorOptions_ContourModeImpl {
  _$FaceDetectorOptions_ContourModeImpl();
}

final class $FaceDetectorOptions_ContourModeType
    extends jni.JObjType<FaceDetectorOptions_ContourMode> {
  const $FaceDetectorOptions_ContourModeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/face/FaceDetectorOptions$ContourMode;';

  @override
  FaceDetectorOptions_ContourMode fromReference(jni.JReference reference) =>
      FaceDetectorOptions_ContourMode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceDetectorOptions_ContourModeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceDetectorOptions_ContourModeType) &&
        other is $FaceDetectorOptions_ContourModeType;
  }
}

/// from: com.google.mlkit.vision.face.FaceDetectorOptions$LandmarkMode
class FaceDetectorOptions_LandmarkMode extends jni.JObject {
  @override
  late final jni.JObjType<FaceDetectorOptions_LandmarkMode> $type = type;

  FaceDetectorOptions_LandmarkMode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/face/FaceDetectorOptions$LandmarkMode');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceDetectorOptions_LandmarkModeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FaceDetectorOptions_LandmarkModeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory FaceDetectorOptions_LandmarkMode.implement(
    $FaceDetectorOptions_LandmarkModeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FaceDetectorOptions_LandmarkMode.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.face.FaceDetectorOptions$LandmarkMode',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FaceDetectorOptions_LandmarkModeImpl {
  factory $FaceDetectorOptions_LandmarkModeImpl() =
      _$FaceDetectorOptions_LandmarkModeImpl;
}

class _$FaceDetectorOptions_LandmarkModeImpl
    implements $FaceDetectorOptions_LandmarkModeImpl {
  _$FaceDetectorOptions_LandmarkModeImpl();
}

final class $FaceDetectorOptions_LandmarkModeType
    extends jni.JObjType<FaceDetectorOptions_LandmarkMode> {
  const $FaceDetectorOptions_LandmarkModeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/face/FaceDetectorOptions$LandmarkMode;';

  @override
  FaceDetectorOptions_LandmarkMode fromReference(jni.JReference reference) =>
      FaceDetectorOptions_LandmarkMode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceDetectorOptions_LandmarkModeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceDetectorOptions_LandmarkModeType) &&
        other is $FaceDetectorOptions_LandmarkModeType;
  }
}

/// from: com.google.mlkit.vision.face.FaceDetectorOptions$PerformanceMode
class FaceDetectorOptions_PerformanceMode extends jni.JObject {
  @override
  late final jni.JObjType<FaceDetectorOptions_PerformanceMode> $type = type;

  FaceDetectorOptions_PerformanceMode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/face/FaceDetectorOptions$PerformanceMode');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceDetectorOptions_PerformanceModeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FaceDetectorOptions_PerformanceModeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory FaceDetectorOptions_PerformanceMode.implement(
    $FaceDetectorOptions_PerformanceModeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FaceDetectorOptions_PerformanceMode.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.face.FaceDetectorOptions$PerformanceMode',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FaceDetectorOptions_PerformanceModeImpl {
  factory $FaceDetectorOptions_PerformanceModeImpl() =
      _$FaceDetectorOptions_PerformanceModeImpl;
}

class _$FaceDetectorOptions_PerformanceModeImpl
    implements $FaceDetectorOptions_PerformanceModeImpl {
  _$FaceDetectorOptions_PerformanceModeImpl();
}

final class $FaceDetectorOptions_PerformanceModeType
    extends jni.JObjType<FaceDetectorOptions_PerformanceMode> {
  const $FaceDetectorOptions_PerformanceModeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/face/FaceDetectorOptions$PerformanceMode;';

  @override
  FaceDetectorOptions_PerformanceMode fromReference(jni.JReference reference) =>
      FaceDetectorOptions_PerformanceMode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceDetectorOptions_PerformanceModeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceDetectorOptions_PerformanceModeType) &&
        other is $FaceDetectorOptions_PerformanceModeType;
  }
}

/// from: com.google.mlkit.vision.face.FaceDetectorOptions
class FaceDetectorOptions extends jni.JObject {
  @override
  late final jni.JObjType<FaceDetectorOptions> $type = type;

  FaceDetectorOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/face/FaceDetectorOptions');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceDetectorOptionsType();

  /// from: static public final int LANDMARK_MODE_NONE
  static const LANDMARK_MODE_NONE = 1;

  /// from: static public final int LANDMARK_MODE_ALL
  static const LANDMARK_MODE_ALL = 2;

  /// from: static public final int CONTOUR_MODE_NONE
  static const CONTOUR_MODE_NONE = 1;

  /// from: static public final int CONTOUR_MODE_ALL
  static const CONTOUR_MODE_ALL = 2;

  /// from: static public final int CLASSIFICATION_MODE_NONE
  static const CLASSIFICATION_MODE_NONE = 1;

  /// from: static public final int CLASSIFICATION_MODE_ALL
  static const CLASSIFICATION_MODE_ALL = 2;

  /// from: static public final int PERFORMANCE_MODE_FAST
  static const PERFORMANCE_MODE_FAST = 1;

  /// from: static public final int PERFORMANCE_MODE_ACCURATE
  static const PERFORMANCE_MODE_ACCURATE = 2;
  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_zza = _class.instanceMethodId(
    r'zza',
    r'()F',
  );

  static final _zza = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final float zza()
  double zza() {
    return _zza(reference.pointer, _id_zza as jni.JMethodIDPtr).float;
  }

  static final _id_zzb = _class.instanceMethodId(
    r'zzb',
    r'()I',
  );

  static final _zzb = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int zzb()
  int zzb() {
    return _zzb(reference.pointer, _id_zzb as jni.JMethodIDPtr).integer;
  }

  static final _id_zzc = _class.instanceMethodId(
    r'zzc',
    r'()I',
  );

  static final _zzc = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int zzc()
  int zzc() {
    return _zzc(reference.pointer, _id_zzc as jni.JMethodIDPtr).integer;
  }

  static final _id_zzd = _class.instanceMethodId(
    r'zzd',
    r'()I',
  );

  static final _zzd = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int zzd()
  int zzd() {
    return _zzd(reference.pointer, _id_zzd as jni.JMethodIDPtr).integer;
  }

  static final _id_zze = _class.instanceMethodId(
    r'zze',
    r'()I',
  );

  static final _zze = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int zze()
  int zze() {
    return _zze(reference.pointer, _id_zze as jni.JMethodIDPtr).integer;
  }

  static final _id_zzf = _class.instanceMethodId(
    r'zzf',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _zzf = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.concurrent.Executor zzf()
  /// The returned object must be released after use, by calling the [release] method.
  Executor zzf() {
    return _zzf(reference.pointer, _id_zzf as jni.JMethodIDPtr)
        .object(const $ExecutorType());
  }

  static final _id_zzg = _class.instanceMethodId(
    r'zzg',
    r'()Z',
  );

  static final _zzg = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean zzg()
  bool zzg() {
    return _zzg(reference.pointer, _id_zzg as jni.JMethodIDPtr).boolean;
  }
}

final class $FaceDetectorOptionsType extends jni.JObjType<FaceDetectorOptions> {
  const $FaceDetectorOptionsType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/face/FaceDetectorOptions;';

  @override
  FaceDetectorOptions fromReference(jni.JReference reference) =>
      FaceDetectorOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceDetectorOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceDetectorOptionsType) &&
        other is $FaceDetectorOptionsType;
  }
}

/// from: com.google.mlkit.vision.face.FaceLandmark$LandmarkType
class FaceLandmark_LandmarkType extends jni.JObject {
  @override
  late final jni.JObjType<FaceLandmark_LandmarkType> $type = type;

  FaceLandmark_LandmarkType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/face/FaceLandmark$LandmarkType');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceLandmark_LandmarkTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FaceLandmark_LandmarkTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory FaceLandmark_LandmarkType.implement(
    $FaceLandmark_LandmarkTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = FaceLandmark_LandmarkType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.face.FaceLandmark$LandmarkType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FaceLandmark_LandmarkTypeImpl {
  factory $FaceLandmark_LandmarkTypeImpl() = _$FaceLandmark_LandmarkTypeImpl;
}

class _$FaceLandmark_LandmarkTypeImpl
    implements $FaceLandmark_LandmarkTypeImpl {
  _$FaceLandmark_LandmarkTypeImpl();
}

final class $FaceLandmark_LandmarkTypeType
    extends jni.JObjType<FaceLandmark_LandmarkType> {
  const $FaceLandmark_LandmarkTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/face/FaceLandmark$LandmarkType;';

  @override
  FaceLandmark_LandmarkType fromReference(jni.JReference reference) =>
      FaceLandmark_LandmarkType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceLandmark_LandmarkTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceLandmark_LandmarkTypeType) &&
        other is $FaceLandmark_LandmarkTypeType;
  }
}

/// from: com.google.mlkit.vision.face.FaceLandmark
class FaceLandmark extends jni.JObject {
  @override
  late final jni.JObjType<FaceLandmark> $type = type;

  FaceLandmark.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/face/FaceLandmark');

  /// The type which includes information such as the signature of this class.
  static const type = $FaceLandmarkType();

  /// from: static public final int MOUTH_BOTTOM
  static const MOUTH_BOTTOM = 0;

  /// from: static public final int MOUTH_RIGHT
  static const MOUTH_RIGHT = 11;

  /// from: static public final int MOUTH_LEFT
  static const MOUTH_LEFT = 5;

  /// from: static public final int RIGHT_EYE
  static const RIGHT_EYE = 10;

  /// from: static public final int LEFT_EYE
  static const LEFT_EYE = 4;

  /// from: static public final int RIGHT_EAR
  static const RIGHT_EAR = 9;

  /// from: static public final int LEFT_EAR
  static const LEFT_EAR = 3;

  /// from: static public final int RIGHT_CHEEK
  static const RIGHT_CHEEK = 7;

  /// from: static public final int LEFT_CHEEK
  static const LEFT_CHEEK = 1;

  /// from: static public final int NOSE_BASE
  static const NOSE_BASE = 6;
  static final _id_getLandmarkType = _class.instanceMethodId(
    r'getLandmarkType',
    r'()I',
  );

  static final _getLandmarkType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getLandmarkType()
  int getLandmarkType() {
    return _getLandmarkType(
            reference.pointer, _id_getLandmarkType as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPosition = _class.instanceMethodId(
    r'getPosition',
    r'()Landroid/graphics/PointF;',
  );

  static final _getPosition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.PointF getPosition()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getPosition() {
    return _getPosition(reference.pointer, _id_getPosition as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $FaceLandmarkType extends jni.JObjType<FaceLandmark> {
  const $FaceLandmarkType();

  @override
  String get signature => r'Lcom/google/mlkit/vision/face/FaceLandmark;';

  @override
  FaceLandmark fromReference(jni.JReference reference) =>
      FaceLandmark.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FaceLandmarkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FaceLandmarkType) &&
        other is $FaceLandmarkType;
  }
}

/// from: com.google.mlkit.vision.interfaces.Detector$DetectorType
class Detector_DetectorType extends jni.JObject {
  @override
  late final jni.JObjType<Detector_DetectorType> $type = type;

  Detector_DetectorType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/google/mlkit/vision/interfaces/Detector$DetectorType');

  /// The type which includes information such as the signature of this class.
  static const type = $Detector_DetectorTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Detector_DetectorTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Detector_DetectorType.implement(
    $Detector_DetectorTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Detector_DetectorType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.interfaces.Detector$DetectorType',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Detector_DetectorTypeImpl {
  factory $Detector_DetectorTypeImpl() = _$Detector_DetectorTypeImpl;
}

class _$Detector_DetectorTypeImpl implements $Detector_DetectorTypeImpl {
  _$Detector_DetectorTypeImpl();
}

final class $Detector_DetectorTypeType
    extends jni.JObjType<Detector_DetectorType> {
  const $Detector_DetectorTypeType();

  @override
  String get signature =>
      r'Lcom/google/mlkit/vision/interfaces/Detector$DetectorType;';

  @override
  Detector_DetectorType fromReference(jni.JReference reference) =>
      Detector_DetectorType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Detector_DetectorTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Detector_DetectorTypeType) &&
        other is $Detector_DetectorTypeType;
  }
}

/// from: com.google.mlkit.vision.interfaces.Detector
class Detector<$DetectionResultT extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Detector<$DetectionResultT>> $type =
      type(DetectionResultT);

  final jni.JObjType<$DetectionResultT> DetectionResultT;

  Detector.fromReference(
    this.DetectionResultT,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/google/mlkit/vision/interfaces/Detector');

  /// The type which includes information such as the signature of this class.
  static $DetectorType<$DetectionResultT>
      type<$DetectionResultT extends jni.JObject>(
    jni.JObjType<$DetectionResultT> DetectionResultT,
  ) {
    return $DetectorType(
      DetectionResultT,
    );
  }

  /// from: static public final int TYPE_BARCODE_SCANNING
  static const TYPE_BARCODE_SCANNING = 1;

  /// from: static public final int TYPE_FACE_DETECTION
  static const TYPE_FACE_DETECTION = 2;

  /// from: static public final int TYPE_IMAGE_LABELING
  static const TYPE_IMAGE_LABELING = 3;

  /// from: static public final int TYPE_TEXT_RECOGNITION
  static const TYPE_TEXT_RECOGNITION = 4;

  /// from: static public final int TYPE_OBJECT_DETECTION
  static const TYPE_OBJECT_DETECTION = 5;

  /// from: static public final int TYPE_POSE_DETECTION
  static const TYPE_POSE_DETECTION = 6;

  /// from: static public final int TYPE_SEGMENTATION
  static const TYPE_SEGMENTATION = 7;

  /// from: static public final int TYPE_SELFIE_FACE_DETECTION
  static const TYPE_SELFIE_FACE_DETECTION = 8;

  /// from: static public final int TYPE_IMAGE_CAPTIONING
  static const TYPE_IMAGE_CAPTIONING = 9;

  /// from: static public final int TYPE_DOCUMENT_DETECTION
  static const TYPE_DOCUMENT_DETECTION = 10;
  static final _id_getDetectorType = _class.instanceMethodId(
    r'getDetectorType',
    r'()I',
  );

  static final _getDetectorType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract int getDetectorType()
  int getDetectorType() {
    return _getDetectorType(
            reference.pointer, _id_getDetectorType as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_process = _class.instanceMethodId(
    r'process',
    r'(Landroid/graphics/Bitmap;I)Lcom/google/android/gms/tasks/Task;',
  );

  static final _process = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(android.graphics.Bitmap bitmap, int i)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$DetectionResultT> process(
    jni.JObject bitmap,
    int i,
  ) {
    return _process(reference.pointer, _id_process as jni.JMethodIDPtr,
            bitmap.reference.pointer, i)
        .object($TaskType(DetectionResultT));
  }

  static final _id_process1 = _class.instanceMethodId(
    r'process',
    r'(Landroid/media/Image;I)Lcom/google/android/gms/tasks/Task;',
  );

  static final _process1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(android.media.Image image, int i)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$DetectionResultT> process1(
    Image image,
    int i,
  ) {
    return _process1(reference.pointer, _id_process1 as jni.JMethodIDPtr,
            image.reference.pointer, i)
        .object($TaskType(DetectionResultT));
  }

  static final _id_process2 = _class.instanceMethodId(
    r'process',
    r'(Landroid/media/Image;ILandroid/graphics/Matrix;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _process2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(android.media.Image image, int i, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$DetectionResultT> process2(
    Image image,
    int i,
    jni.JObject matrix,
  ) {
    return _process2(reference.pointer, _id_process2 as jni.JMethodIDPtr,
            image.reference.pointer, i, matrix.reference.pointer)
        .object($TaskType(DetectionResultT));
  }

  static final _id_process3 = _class.instanceMethodId(
    r'process',
    r'(Ljava/nio/ByteBuffer;IIII)Lcom/google/android/gms/tasks/Task;',
  );

  static final _process3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(java.nio.ByteBuffer byteBuffer, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$DetectionResultT> process3(
    jni.JByteBuffer byteBuffer,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _process3(reference.pointer, _id_process3 as jni.JMethodIDPtr,
            byteBuffer.reference.pointer, i, i1, i2, i3)
        .object($TaskType(DetectionResultT));
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $DetectorImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getDetectorType()I') {
        final $r = _$impls[$p]!.getDetectorType();
        return jni.JInteger($r).reference.toPointer();
      }
      if ($d ==
          r'process(Landroid/graphics/Bitmap;I)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.process(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r'process(Landroid/media/Image;I)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.process1(
          $a[0].castTo(const $ImageType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r'process(Landroid/media/Image;ILandroid/graphics/Matrix;)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.process2(
          $a[0].castTo(const $ImageType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r'process(Ljava/nio/ByteBuffer;IIII)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.process3(
          $a[0].castTo(const jni.JByteBufferType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[3]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Detector.implement(
    $DetectorImpl<$DetectionResultT> $impl,
  ) {
    final $p = ReceivePort();
    final $x = Detector.fromReference(
      $impl.DetectionResultT,
      ProtectedJniExtensions.newPortProxy(
        r'com.google.mlkit.vision.interfaces.Detector',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $DetectorImpl<$DetectionResultT extends jni.JObject> {
  factory $DetectorImpl({
    required jni.JObjType<$DetectionResultT> DetectionResultT,
    required int Function() getDetectorType,
    required Task<$DetectionResultT> Function(jni.JObject bitmap, int i)
        process,
    required Task<$DetectionResultT> Function(Image image, int i) process1,
    required Task<$DetectionResultT> Function(
            Image image, int i, jni.JObject matrix)
        process2,
    required Task<$DetectionResultT> Function(
            jni.JByteBuffer byteBuffer, int i, int i1, int i2, int i3)
        process3,
  }) = _$DetectorImpl;

  jni.JObjType<$DetectionResultT> get DetectionResultT;

  int getDetectorType();
  Task<$DetectionResultT> process(jni.JObject bitmap, int i);
  Task<$DetectionResultT> process1(Image image, int i);
  Task<$DetectionResultT> process2(Image image, int i, jni.JObject matrix);
  Task<$DetectionResultT> process3(
      jni.JByteBuffer byteBuffer, int i, int i1, int i2, int i3);
}

class _$DetectorImpl<$DetectionResultT extends jni.JObject>
    implements $DetectorImpl<$DetectionResultT> {
  _$DetectorImpl({
    required this.DetectionResultT,
    required int Function() getDetectorType,
    required Task<$DetectionResultT> Function(jni.JObject bitmap, int i)
        process,
    required Task<$DetectionResultT> Function(Image image, int i) process1,
    required Task<$DetectionResultT> Function(
            Image image, int i, jni.JObject matrix)
        process2,
    required Task<$DetectionResultT> Function(
            jni.JByteBuffer byteBuffer, int i, int i1, int i2, int i3)
        process3,
  })  : _getDetectorType = getDetectorType,
        _process = process,
        _process1 = process1,
        _process2 = process2,
        _process3 = process3;

  @override
  final jni.JObjType<$DetectionResultT> DetectionResultT;

  final int Function() _getDetectorType;
  final Task<$DetectionResultT> Function(jni.JObject bitmap, int i) _process;
  final Task<$DetectionResultT> Function(Image image, int i) _process1;
  final Task<$DetectionResultT> Function(Image image, int i, jni.JObject matrix)
      _process2;
  final Task<$DetectionResultT> Function(
      jni.JByteBuffer byteBuffer, int i, int i1, int i2, int i3) _process3;

  int getDetectorType() {
    return _getDetectorType();
  }

  Task<$DetectionResultT> process(jni.JObject bitmap, int i) {
    return _process(bitmap, i);
  }

  Task<$DetectionResultT> process1(Image image, int i) {
    return _process1(image, i);
  }

  Task<$DetectionResultT> process2(Image image, int i, jni.JObject matrix) {
    return _process2(image, i, matrix);
  }

  Task<$DetectionResultT> process3(
      jni.JByteBuffer byteBuffer, int i, int i1, int i2, int i3) {
    return _process3(byteBuffer, i, i1, i2, i3);
  }
}

final class $DetectorType<$DetectionResultT extends jni.JObject>
    extends jni.JObjType<Detector<$DetectionResultT>> {
  final jni.JObjType<$DetectionResultT> DetectionResultT;

  const $DetectorType(
    this.DetectionResultT,
  );

  @override
  String get signature => r'Lcom/google/mlkit/vision/interfaces/Detector;';

  @override
  Detector<$DetectionResultT> fromReference(jni.JReference reference) =>
      Detector.fromReference(DetectionResultT, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($DetectorType, DetectionResultT);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DetectorType<$DetectionResultT>) &&
        other is $DetectorType<$DetectionResultT> &&
        DetectionResultT == other.DetectionResultT;
  }
}

/// from: java.lang.Runnable
class Runnable extends jni.JObject {
  @override
  late final jni.JObjType<Runnable> $type = type;

  Runnable.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'java/lang/Runnable');

  /// The type which includes information such as the signature of this class.
  static const type = $RunnableType();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'()V',
  );

  static final _run = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void run()
  void run() {
    _run(reference.pointer, _id_run as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $RunnableImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()V') {
        _$impls[$p]!.run();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Runnable.implement(
    $RunnableImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Runnable.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'java.lang.Runnable',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $RunnableImpl {
  factory $RunnableImpl({
    required void Function() run,
  }) = _$RunnableImpl;

  void run();
}

class _$RunnableImpl implements $RunnableImpl {
  _$RunnableImpl({
    required void Function() run,
  }) : _run = run;

  final void Function() _run;

  void run() {
    return _run();
  }
}

final class $RunnableType extends jni.JObjType<Runnable> {
  const $RunnableType();

  @override
  String get signature => r'Ljava/lang/Runnable;';

  @override
  Runnable fromReference(jni.JReference reference) =>
      Runnable.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RunnableType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RunnableType) && other is $RunnableType;
  }
}

/// from: java.util.concurrent.Executor
class Executor extends jni.JObject {
  @override
  late final jni.JObjType<Executor> $type = type;

  Executor.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'java/util/concurrent/Executor');

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorType();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Ljava/lang/Runnable;)V',
  );

  static final _execute = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void execute(java.lang.Runnable runnable)
  void execute(
    Runnable runnable,
  ) {
    _execute(reference.pointer, _id_execute as jni.JMethodIDPtr,
            runnable.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ExecutorImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'execute(Ljava/lang/Runnable;)V') {
        _$impls[$p]!.execute(
          $a[0].castTo(const $RunnableType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Executor.implement(
    $ExecutorImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Executor.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'java.util.concurrent.Executor',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ExecutorImpl {
  factory $ExecutorImpl({
    required void Function(Runnable runnable) execute,
  }) = _$ExecutorImpl;

  void execute(Runnable runnable);
}

class _$ExecutorImpl implements $ExecutorImpl {
  _$ExecutorImpl({
    required void Function(Runnable runnable) execute,
  }) : _execute = execute;

  final void Function(Runnable runnable) _execute;

  void execute(Runnable runnable) {
    return _execute(runnable);
  }
}

final class $ExecutorType extends jni.JObjType<Executor> {
  const $ExecutorType();

  @override
  String get signature => r'Ljava/util/concurrent/Executor;';

  @override
  Executor fromReference(jni.JReference reference) =>
      Executor.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExecutorType) && other is $ExecutorType;
  }
}

/// from: java.util.concurrent.Executors
class Executors extends jni.JObject {
  @override
  late final jni.JObjType<Executors> $type = type;

  Executors.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'java/util/concurrent/Executors');

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorsType();
  static final _id_newFixedThreadPool = _class.staticMethodId(
    r'newFixedThreadPool',
    r'(I)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newFixedThreadPool = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newFixedThreadPool(
    int i,
  ) {
    return _newFixedThreadPool(_class.reference.pointer,
            _id_newFixedThreadPool as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_newWorkStealingPool = _class.staticMethodId(
    r'newWorkStealingPool',
    r'(I)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newWorkStealingPool = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newWorkStealingPool(
    int i,
  ) {
    return _newWorkStealingPool(_class.reference.pointer,
            _id_newWorkStealingPool as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_newWorkStealingPool1 = _class.staticMethodId(
    r'newWorkStealingPool',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newWorkStealingPool1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newWorkStealingPool1() {
    return _newWorkStealingPool1(_class.reference.pointer,
            _id_newWorkStealingPool1 as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_newFixedThreadPool1 = _class.staticMethodId(
    r'newFixedThreadPool',
    r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newFixedThreadPool1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newFixedThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) {
    return _newFixedThreadPool1(
            _class.reference.pointer,
            _id_newFixedThreadPool1 as jni.JMethodIDPtr,
            i,
            threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_newSingleThreadExecutor = _class.staticMethodId(
    r'newSingleThreadExecutor',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newSingleThreadExecutor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadExecutor() {
    return _newSingleThreadExecutor(_class.reference.pointer,
            _id_newSingleThreadExecutor as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_newSingleThreadExecutor1 = _class.staticMethodId(
    r'newSingleThreadExecutor',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newSingleThreadExecutor1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadExecutor1(
    jni.JObject threadFactory,
  ) {
    return _newSingleThreadExecutor1(
            _class.reference.pointer,
            _id_newSingleThreadExecutor1 as jni.JMethodIDPtr,
            threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_newCachedThreadPool = _class.staticMethodId(
    r'newCachedThreadPool',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newCachedThreadPool = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newCachedThreadPool() {
    return _newCachedThreadPool(_class.reference.pointer,
            _id_newCachedThreadPool as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_newCachedThreadPool1 = _class.staticMethodId(
    r'newCachedThreadPool',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newCachedThreadPool1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newCachedThreadPool1(
    jni.JObject threadFactory,
  ) {
    return _newCachedThreadPool1(
            _class.reference.pointer,
            _id_newCachedThreadPool1 as jni.JMethodIDPtr,
            threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_newSingleThreadScheduledExecutor = _class.staticMethodId(
    r'newSingleThreadScheduledExecutor',
    r'()Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newSingleThreadScheduledExecutor =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadScheduledExecutor() {
    return _newSingleThreadScheduledExecutor(_class.reference.pointer,
            _id_newSingleThreadScheduledExecutor as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_newSingleThreadScheduledExecutor1 = _class.staticMethodId(
    r'newSingleThreadScheduledExecutor',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newSingleThreadScheduledExecutor1 =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadScheduledExecutor1(
    jni.JObject threadFactory,
  ) {
    return _newSingleThreadScheduledExecutor1(
            _class.reference.pointer,
            _id_newSingleThreadScheduledExecutor1 as jni.JMethodIDPtr,
            threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_newScheduledThreadPool = _class.staticMethodId(
    r'newScheduledThreadPool',
    r'(I)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newScheduledThreadPool = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newScheduledThreadPool(
    int i,
  ) {
    return _newScheduledThreadPool(_class.reference.pointer,
            _id_newScheduledThreadPool as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_newScheduledThreadPool1 = _class.staticMethodId(
    r'newScheduledThreadPool',
    r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newScheduledThreadPool1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newScheduledThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) {
    return _newScheduledThreadPool1(
            _class.reference.pointer,
            _id_newScheduledThreadPool1 as jni.JMethodIDPtr,
            i,
            threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_unconfigurableExecutorService = _class.staticMethodId(
    r'unconfigurableExecutorService',
    r'(Ljava/util/concurrent/ExecutorService;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _unconfigurableExecutorService = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService executorService)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject unconfigurableExecutorService(
    jni.JObject executorService,
  ) {
    return _unconfigurableExecutorService(
            _class.reference.pointer,
            _id_unconfigurableExecutorService as jni.JMethodIDPtr,
            executorService.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_unconfigurableScheduledExecutorService =
      _class.staticMethodId(
    r'unconfigurableScheduledExecutorService',
    r'(Ljava/util/concurrent/ScheduledExecutorService;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _unconfigurableScheduledExecutorService =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService scheduledExecutorService)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject unconfigurableScheduledExecutorService(
    jni.JObject scheduledExecutorService,
  ) {
    return _unconfigurableScheduledExecutorService(
            _class.reference.pointer,
            _id_unconfigurableScheduledExecutorService as jni.JMethodIDPtr,
            scheduledExecutorService.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_defaultThreadFactory = _class.staticMethodId(
    r'defaultThreadFactory',
    r'()Ljava/util/concurrent/ThreadFactory;',
  );

  static final _defaultThreadFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.util.concurrent.ThreadFactory defaultThreadFactory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject defaultThreadFactory() {
    return _defaultThreadFactory(_class.reference.pointer,
            _id_defaultThreadFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_privilegedThreadFactory = _class.staticMethodId(
    r'privilegedThreadFactory',
    r'()Ljava/util/concurrent/ThreadFactory;',
  );

  static final _privilegedThreadFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.util.concurrent.ThreadFactory privilegedThreadFactory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject privilegedThreadFactory() {
    return _privilegedThreadFactory(_class.reference.pointer,
            _id_privilegedThreadFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_callable = _class.staticMethodId(
    r'callable',
    r'(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;',
  );

  static final _callable = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable, T object)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable<$T extends jni.JObject>(
    Runnable runnable,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return _callable(_class.reference.pointer, _id_callable as jni.JMethodIDPtr,
            runnable.reference.pointer, object.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_callable1 = _class.staticMethodId(
    r'callable',
    r'(Ljava/lang/Runnable;)Ljava/util/concurrent/Callable;',
  );

  static final _callable1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable1(
    Runnable runnable,
  ) {
    return _callable1(_class.reference.pointer,
            _id_callable1 as jni.JMethodIDPtr, runnable.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_callable2 = _class.staticMethodId(
    r'callable',
    r'(Ljava/security/PrivilegedAction;)Ljava/util/concurrent/Callable;',
  );

  static final _callable2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedAction privilegedAction)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable2(
    jni.JObject privilegedAction,
  ) {
    return _callable2(
            _class.reference.pointer,
            _id_callable2 as jni.JMethodIDPtr,
            privilegedAction.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_callable3 = _class.staticMethodId(
    r'callable',
    r'(Ljava/security/PrivilegedExceptionAction;)Ljava/util/concurrent/Callable;',
  );

  static final _callable3 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction privilegedExceptionAction)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable3(
    jni.JObject privilegedExceptionAction,
  ) {
    return _callable3(
            _class.reference.pointer,
            _id_callable3 as jni.JMethodIDPtr,
            privilegedExceptionAction.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_privilegedCallable = _class.staticMethodId(
    r'privilegedCallable',
    r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;',
  );

  static final _privilegedCallable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject privilegedCallable<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) {
    return _privilegedCallable(
            _class.reference.pointer,
            _id_privilegedCallable as jni.JMethodIDPtr,
            callable.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_privilegedCallableUsingCurrentClassLoader =
      _class.staticMethodId(
    r'privilegedCallableUsingCurrentClassLoader',
    r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;',
  );

  static final _privilegedCallableUsingCurrentClassLoader =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject
      privilegedCallableUsingCurrentClassLoader<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) {
    return _privilegedCallableUsingCurrentClassLoader(
            _class.reference.pointer,
            _id_privilegedCallableUsingCurrentClassLoader as jni.JMethodIDPtr,
            callable.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $ExecutorsType extends jni.JObjType<Executors> {
  const $ExecutorsType();

  @override
  String get signature => r'Ljava/util/concurrent/Executors;';

  @override
  Executors fromReference(jni.JReference reference) =>
      Executors.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExecutorsType) && other is $ExecutorsType;
  }
}

/// from: java.util.concurrent.Future
class Future<$V extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Future<$V>> $type = type(V);

  final jni.JObjType<$V> V;

  Future.fromReference(
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'java/util/concurrent/Future');

  /// The type which includes information such as the signature of this class.
  static $FutureType<$V> type<$V extends jni.JObject>(
    jni.JObjType<$V> V,
  ) {
    return $FutureType(
      V,
    );
  }

  static final _id_cancel = _class.instanceMethodId(
    r'cancel',
    r'(Z)Z',
  );

  static final _cancel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract boolean cancel(boolean z)
  bool cancel(
    bool z,
  ) {
    return _cancel(reference.pointer, _id_cancel as jni.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_isCancelled = _class.instanceMethodId(
    r'isCancelled',
    r'()Z',
  );

  static final _isCancelled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isCancelled()
  bool isCancelled() {
    return _isCancelled(reference.pointer, _id_isCancelled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isDone = _class.instanceMethodId(
    r'isDone',
    r'()Z',
  );

  static final _isDone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isDone()
  bool isDone() {
    return _isDone(reference.pointer, _id_isDone as jni.JMethodIDPtr).boolean;
  }

  static final _id_get0 = _class.instanceMethodId(
    r'get',
    r'()Ljava/lang/Object;',
  );

  static final _get0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract V get()
  /// The returned object must be released after use, by calling the [release] method.
  $V get0() {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr).object(V);
  }

  static final _id_get1 = _class.instanceMethodId(
    r'get',
    r'(JLjava/util/concurrent/TimeUnit;)Ljava/lang/Object;',
  );

  static final _get1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract V get(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  $V get1(
    int j,
    jni.JObject timeUnit,
  ) {
    return _get1(reference.pointer, _id_get1 as jni.JMethodIDPtr, j,
            timeUnit.reference.pointer)
        .object(V);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FutureImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'cancel(Z)Z') {
        final $r = _$impls[$p]!.cancel(
          $a[0]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'isCancelled()Z') {
        final $r = _$impls[$p]!.isCancelled();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'isDone()Z') {
        final $r = _$impls[$p]!.isDone();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'get()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.get0();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'get(JLjava/util/concurrent/TimeUnit;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.get1(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Future.implement(
    $FutureImpl<$V> $impl,
  ) {
    final $p = ReceivePort();
    final $x = Future.fromReference(
      $impl.V,
      ProtectedJniExtensions.newPortProxy(
        r'java.util.concurrent.Future',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FutureImpl<$V extends jni.JObject> {
  factory $FutureImpl({
    required jni.JObjType<$V> V,
    required bool Function(bool z) cancel,
    required bool Function() isCancelled,
    required bool Function() isDone,
    required $V Function() get0,
    required $V Function(int j, jni.JObject timeUnit) get1,
  }) = _$FutureImpl;

  jni.JObjType<$V> get V;

  bool cancel(bool z);
  bool isCancelled();
  bool isDone();
  $V get0();
  $V get1(int j, jni.JObject timeUnit);
}

class _$FutureImpl<$V extends jni.JObject> implements $FutureImpl<$V> {
  _$FutureImpl({
    required this.V,
    required bool Function(bool z) cancel,
    required bool Function() isCancelled,
    required bool Function() isDone,
    required $V Function() get0,
    required $V Function(int j, jni.JObject timeUnit) get1,
  })  : _cancel = cancel,
        _isCancelled = isCancelled,
        _isDone = isDone,
        _get0 = get0,
        _get1 = get1;

  @override
  final jni.JObjType<$V> V;

  final bool Function(bool z) _cancel;
  final bool Function() _isCancelled;
  final bool Function() _isDone;
  final $V Function() _get0;
  final $V Function(int j, jni.JObject timeUnit) _get1;

  bool cancel(bool z) {
    return _cancel(z);
  }

  bool isCancelled() {
    return _isCancelled();
  }

  bool isDone() {
    return _isDone();
  }

  $V get0() {
    return _get0();
  }

  $V get1(int j, jni.JObject timeUnit) {
    return _get1(j, timeUnit);
  }
}

final class $FutureType<$V extends jni.JObject>
    extends jni.JObjType<Future<$V>> {
  final jni.JObjType<$V> V;

  const $FutureType(
    this.V,
  );

  @override
  String get signature => r'Ljava/util/concurrent/Future;';

  @override
  Future<$V> fromReference(jni.JReference reference) =>
      Future.fromReference(V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($FutureType, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FutureType<$V>) &&
        other is $FutureType<$V> &&
        V == other.V;
  }
}

/// from: dev.hebei.camerax_android.MyImageAnalysis$Companion
class MyImageAnalysis_Companion extends jni.JObject {
  @override
  late final jni.JObjType<MyImageAnalysis_Companion> $type = type;

  MyImageAnalysis_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageAnalysis$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageAnalysis_CompanionType();
  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageAnalysis_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return MyImageAnalysis_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $MyImageAnalysis_CompanionType
    extends jni.JObjType<MyImageAnalysis_Companion> {
  const $MyImageAnalysis_CompanionType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageAnalysis$Companion;';

  @override
  MyImageAnalysis_Companion fromReference(jni.JReference reference) =>
      MyImageAnalysis_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageAnalysis_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageAnalysis_CompanionType) &&
        other is $MyImageAnalysis_CompanionType;
  }
}

/// from: dev.hebei.camerax_android.MyImageAnalysis$MyAnalyzer
class MyImageAnalysis_MyAnalyzer extends jni.JObject {
  @override
  late final jni.JObjType<MyImageAnalysis_MyAnalyzer> $type = type;

  MyImageAnalysis_MyAnalyzer.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageAnalysis$MyAnalyzer');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageAnalysis_MyAnalyzerType();
  static final _id_analyze = _class.instanceMethodId(
    r'analyze',
    r'(Landroidx/camera/core/ImageProxy;)V',
  );

  static final _analyze = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void analyze(androidx.camera.core.ImageProxy imageProxy)
  void analyze(
    ImageProxy imageProxy,
  ) {
    _analyze(reference.pointer, _id_analyze as jni.JMethodIDPtr,
            imageProxy.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyImageAnalysis_MyAnalyzerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'analyze(Landroidx/camera/core/ImageProxy;)V') {
        _$impls[$p]!.analyze(
          $a[0].castTo(const $ImageProxyType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MyImageAnalysis_MyAnalyzer.implement(
    $MyImageAnalysis_MyAnalyzerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyImageAnalysis_MyAnalyzer.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'dev.hebei.camerax_android.MyImageAnalysis$MyAnalyzer',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MyImageAnalysis_MyAnalyzerImpl {
  factory $MyImageAnalysis_MyAnalyzerImpl({
    required void Function(ImageProxy imageProxy) analyze,
  }) = _$MyImageAnalysis_MyAnalyzerImpl;

  void analyze(ImageProxy imageProxy);
}

class _$MyImageAnalysis_MyAnalyzerImpl
    implements $MyImageAnalysis_MyAnalyzerImpl {
  _$MyImageAnalysis_MyAnalyzerImpl({
    required void Function(ImageProxy imageProxy) analyze,
  }) : _analyze = analyze;

  final void Function(ImageProxy imageProxy) _analyze;

  void analyze(ImageProxy imageProxy) {
    return _analyze(imageProxy);
  }
}

final class $MyImageAnalysis_MyAnalyzerType
    extends jni.JObjType<MyImageAnalysis_MyAnalyzer> {
  const $MyImageAnalysis_MyAnalyzerType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageAnalysis$MyAnalyzer;';

  @override
  MyImageAnalysis_MyAnalyzer fromReference(jni.JReference reference) =>
      MyImageAnalysis_MyAnalyzer.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageAnalysis_MyAnalyzerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageAnalysis_MyAnalyzerType) &&
        other is $MyImageAnalysis_MyAnalyzerType;
  }
}

/// from: dev.hebei.camerax_android.MyImageAnalysis$MyAnalyzerImpl
class MyImageAnalysis_MyAnalyzerImpl extends jni.JObject {
  @override
  late final jni.JObjType<MyImageAnalysis_MyAnalyzerImpl> $type = type;

  MyImageAnalysis_MyAnalyzerImpl.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageAnalysis$MyAnalyzerImpl');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageAnalysis_MyAnalyzerImplType();
  static final _id_new0 = _class.constructorId(
    r'(Ldev/hebei/camerax_android/MyImageAnalysis$MyAnalyzer;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(dev.hebei.camerax_android.MyImageAnalysis$MyAnalyzer myAnalyzer)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageAnalysis_MyAnalyzerImpl(
    MyImageAnalysis_MyAnalyzer myAnalyzer,
  ) {
    return MyImageAnalysis_MyAnalyzerImpl.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            myAnalyzer.reference.pointer)
        .reference);
  }

  static final _id_analyze = _class.instanceMethodId(
    r'analyze',
    r'(Landroidx/camera/core/ImageProxy;)V',
  );

  static final _analyze = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void analyze(androidx.camera.core.ImageProxy imageProxy)
  void analyze(
    ImageProxy imageProxy,
  ) {
    _analyze(reference.pointer, _id_analyze as jni.JMethodIDPtr,
            imageProxy.reference.pointer)
        .check();
  }
}

final class $MyImageAnalysis_MyAnalyzerImplType
    extends jni.JObjType<MyImageAnalysis_MyAnalyzerImpl> {
  const $MyImageAnalysis_MyAnalyzerImplType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageAnalysis$MyAnalyzerImpl;';

  @override
  MyImageAnalysis_MyAnalyzerImpl fromReference(jni.JReference reference) =>
      MyImageAnalysis_MyAnalyzerImpl.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageAnalysis_MyAnalyzerImplType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageAnalysis_MyAnalyzerImplType) &&
        other is $MyImageAnalysis_MyAnalyzerImplType;
  }
}

/// from: dev.hebei.camerax_android.MyImageAnalysis
class MyImageAnalysis extends jni.JObject {
  @override
  late final jni.JObjType<MyImageAnalysis> $type = type;

  MyImageAnalysis.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'dev/hebei/camerax_android/MyImageAnalysis');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageAnalysisType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Ldev/hebei/camerax_android/MyImageAnalysis$Companion;',
  );

  /// from: static public final dev.hebei.camerax_android.MyImageAnalysis$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static MyImageAnalysis_Companion get Companion =>
      _id_Companion.get(_class, const $MyImageAnalysis_CompanionType());

  /// from: static public final int STRATEGY_KEEP_ONLY_LATEST
  static const STRATEGY_KEEP_ONLY_LATEST = 0;

  /// from: static public final int STRATEGY_BLOCK_PRODUCER
  static const STRATEGY_BLOCK_PRODUCER = 1;

  /// from: static public final int COORDINATE_SYSTEM_ORIGINAL
  static const COORDINATE_SYSTEM_ORIGINAL = 0;

  /// from: static public final int COORDINATE_SYSTEM_SENSOR
  static const COORDINATE_SYSTEM_SENSOR = 2;

  /// from: static public final int COORDINATE_SYSTEM_VIEW_REFERENCED
  static const COORDINATE_SYSTEM_VIEW_REFERENCED = 1;

  /// from: static public final int OUTPUT_IMAGE_FORMAT_YUV_420_888
  static const OUTPUT_IMAGE_FORMAT_YUV_420_888 = 1;

  /// from: static public final int OUTPUT_IMAGE_FORMAT_RGBA_8888
  static const OUTPUT_IMAGE_FORMAT_RGBA_8888 = 2;
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageAnalysis() {
    return MyImageAnalysis.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyImageAnalysisType extends jni.JObjType<MyImageAnalysis> {
  const $MyImageAnalysisType();

  @override
  String get signature => r'Ldev/hebei/camerax_android/MyImageAnalysis;';

  @override
  MyImageAnalysis fromReference(jni.JReference reference) =>
      MyImageAnalysis.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageAnalysisType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageAnalysisType) &&
        other is $MyImageAnalysisType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$Companion
class MyImageCapture_Companion extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_Companion> $type = type;

  MyImageCapture_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'dev/hebei/camerax_android/MyImageCapture$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_CompanionType();
  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return MyImageCapture_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $MyImageCapture_CompanionType
    extends jni.JObjType<MyImageCapture_Companion> {
  const $MyImageCapture_CompanionType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$Companion;';

  @override
  MyImageCapture_Companion fromReference(jni.JReference reference) =>
      MyImageCapture_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCapture_CompanionType) &&
        other is $MyImageCapture_CompanionType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOnImageCapturedCallback
class MyImageCapture_MyOnImageCapturedCallback extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOnImageCapturedCallback> $type =
      type;

  MyImageCapture_MyOnImageCapturedCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOnImageCapturedCallbackType();
  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void onCaptureStarted()
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract void onCaptureProcessProgressed(int i)
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onCaptureSuccess = _class.instanceMethodId(
    r'onCaptureSuccess',
    r'(Landroidx/camera/core/ImageProxy;)V',
  );

  static final _onCaptureSuccess = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onCaptureSuccess(androidx.camera.core.ImageProxy imageProxy)
  void onCaptureSuccess(
    ImageProxy imageProxy,
  ) {
    _onCaptureSuccess(
            reference.pointer,
            _id_onCaptureSuccess as jni.JMethodIDPtr,
            imageProxy.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onError(androidx.camera.core.ImageCaptureException imageCaptureException)
  void onError(
    jni.JObject imageCaptureException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            imageCaptureException.reference.pointer)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)
  void onPostviewBitmapAvailable(
    jni.JObject bitmap,
  ) {
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyImageCapture_MyOnImageCapturedCallbackImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCaptureStarted()V') {
        _$impls[$p]!.onCaptureStarted();
        return jni.nullptr;
      }
      if ($d == r'onCaptureProcessProgressed(I)V') {
        _$impls[$p]!.onCaptureProcessProgressed(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onCaptureSuccess(Landroidx/camera/core/ImageProxy;)V') {
        _$impls[$p]!.onCaptureSuccess(
          $a[0].castTo(const $ImageProxyType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Landroidx/camera/core/ImageCaptureException;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onPostviewBitmapAvailable(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onPostviewBitmapAvailable(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MyImageCapture_MyOnImageCapturedCallback.implement(
    $MyImageCapture_MyOnImageCapturedCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyImageCapture_MyOnImageCapturedCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'dev.hebei.camerax_android.MyImageCapture$MyOnImageCapturedCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MyImageCapture_MyOnImageCapturedCallbackImpl {
  factory $MyImageCapture_MyOnImageCapturedCallbackImpl({
    required void Function() onCaptureStarted,
    required void Function(int i) onCaptureProcessProgressed,
    required void Function(ImageProxy imageProxy) onCaptureSuccess,
    required void Function(jni.JObject imageCaptureException) onError,
    required void Function(jni.JObject bitmap) onPostviewBitmapAvailable,
  }) = _$MyImageCapture_MyOnImageCapturedCallbackImpl;

  void onCaptureStarted();
  void onCaptureProcessProgressed(int i);
  void onCaptureSuccess(ImageProxy imageProxy);
  void onError(jni.JObject imageCaptureException);
  void onPostviewBitmapAvailable(jni.JObject bitmap);
}

class _$MyImageCapture_MyOnImageCapturedCallbackImpl
    implements $MyImageCapture_MyOnImageCapturedCallbackImpl {
  _$MyImageCapture_MyOnImageCapturedCallbackImpl({
    required void Function() onCaptureStarted,
    required void Function(int i) onCaptureProcessProgressed,
    required void Function(ImageProxy imageProxy) onCaptureSuccess,
    required void Function(jni.JObject imageCaptureException) onError,
    required void Function(jni.JObject bitmap) onPostviewBitmapAvailable,
  })  : _onCaptureStarted = onCaptureStarted,
        _onCaptureProcessProgressed = onCaptureProcessProgressed,
        _onCaptureSuccess = onCaptureSuccess,
        _onError = onError,
        _onPostviewBitmapAvailable = onPostviewBitmapAvailable;

  final void Function() _onCaptureStarted;
  final void Function(int i) _onCaptureProcessProgressed;
  final void Function(ImageProxy imageProxy) _onCaptureSuccess;
  final void Function(jni.JObject imageCaptureException) _onError;
  final void Function(jni.JObject bitmap) _onPostviewBitmapAvailable;

  void onCaptureStarted() {
    return _onCaptureStarted();
  }

  void onCaptureProcessProgressed(int i) {
    return _onCaptureProcessProgressed(i);
  }

  void onCaptureSuccess(ImageProxy imageProxy) {
    return _onCaptureSuccess(imageProxy);
  }

  void onError(jni.JObject imageCaptureException) {
    return _onError(imageCaptureException);
  }

  void onPostviewBitmapAvailable(jni.JObject bitmap) {
    return _onPostviewBitmapAvailable(bitmap);
  }
}

final class $MyImageCapture_MyOnImageCapturedCallbackType
    extends jni.JObjType<MyImageCapture_MyOnImageCapturedCallback> {
  const $MyImageCapture_MyOnImageCapturedCallbackType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallback;';

  @override
  MyImageCapture_MyOnImageCapturedCallback fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOnImageCapturedCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOnImageCapturedCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyImageCapture_MyOnImageCapturedCallbackType) &&
        other is $MyImageCapture_MyOnImageCapturedCallbackType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOnImageCapturedCallbackImpl
class MyImageCapture_MyOnImageCapturedCallbackImpl extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOnImageCapturedCallbackImpl> $type =
      type;

  MyImageCapture_MyOnImageCapturedCallbackImpl.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallbackImpl');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOnImageCapturedCallbackImplType();
  static final _id_new0 = _class.constructorId(
    r'(Ldev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallback;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(dev.hebei.camerax_android.MyImageCapture$MyOnImageCapturedCallback myOnImageCapturedCallback)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOnImageCapturedCallbackImpl(
    MyImageCapture_MyOnImageCapturedCallback myOnImageCapturedCallback,
  ) {
    return MyImageCapture_MyOnImageCapturedCallbackImpl.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            myOnImageCapturedCallback.reference.pointer)
        .reference);
  }

  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onCaptureStarted()
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onCaptureProcessProgressed(int i)
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onCaptureSuccess = _class.instanceMethodId(
    r'onCaptureSuccess',
    r'(Landroidx/camera/core/ImageProxy;)V',
  );

  static final _onCaptureSuccess = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onCaptureSuccess(androidx.camera.core.ImageProxy imageProxy)
  void onCaptureSuccess(
    ImageProxy imageProxy,
  ) {
    _onCaptureSuccess(
            reference.pointer,
            _id_onCaptureSuccess as jni.JMethodIDPtr,
            imageProxy.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onError(androidx.camera.core.ImageCaptureException imageCaptureException)
  void onError(
    jni.JObject imageCaptureException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            imageCaptureException.reference.pointer)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)
  void onPostviewBitmapAvailable(
    jni.JObject bitmap,
  ) {
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }
}

final class $MyImageCapture_MyOnImageCapturedCallbackImplType
    extends jni.JObjType<MyImageCapture_MyOnImageCapturedCallbackImpl> {
  const $MyImageCapture_MyOnImageCapturedCallbackImplType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOnImageCapturedCallbackImpl;';

  @override
  MyImageCapture_MyOnImageCapturedCallbackImpl fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOnImageCapturedCallbackImpl.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($MyImageCapture_MyOnImageCapturedCallbackImplType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyImageCapture_MyOnImageCapturedCallbackImplType) &&
        other is $MyImageCapture_MyOnImageCapturedCallbackImplType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOnImageSavedCallback
class MyImageCapture_MyOnImageSavedCallback extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOnImageSavedCallback> $type = type;

  MyImageCapture_MyOnImageSavedCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOnImageSavedCallbackType();
  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void onCaptureStarted()
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract void onCaptureProcessProgressed(int i)
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onImageSaved = _class.instanceMethodId(
    r'onImageSaved',
    r'(Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileResults;)V',
  );

  static final _onImageSaved = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onImageSaved(dev.hebei.camerax_android.MyImageCapture$MyOutputFileResults myOutputFileResults)
  void onImageSaved(
    MyImageCapture_MyOutputFileResults myOutputFileResults,
  ) {
    _onImageSaved(reference.pointer, _id_onImageSaved as jni.JMethodIDPtr,
            myOutputFileResults.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onError(androidx.camera.core.ImageCaptureException imageCaptureException)
  void onError(
    jni.JObject imageCaptureException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            imageCaptureException.reference.pointer)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)
  void onPostviewBitmapAvailable(
    jni.JObject bitmap,
  ) {
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyImageCapture_MyOnImageSavedCallbackImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCaptureStarted()V') {
        _$impls[$p]!.onCaptureStarted();
        return jni.nullptr;
      }
      if ($d == r'onCaptureProcessProgressed(I)V') {
        _$impls[$p]!.onCaptureProcessProgressed(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onImageSaved(Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileResults;)V') {
        _$impls[$p]!.onImageSaved(
          $a[0].castTo(const $MyImageCapture_MyOutputFileResultsType(),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onError(Landroidx/camera/core/ImageCaptureException;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onPostviewBitmapAvailable(Landroid/graphics/Bitmap;)V') {
        _$impls[$p]!.onPostviewBitmapAvailable(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MyImageCapture_MyOnImageSavedCallback.implement(
    $MyImageCapture_MyOnImageSavedCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyImageCapture_MyOnImageSavedCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'dev.hebei.camerax_android.MyImageCapture$MyOnImageSavedCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MyImageCapture_MyOnImageSavedCallbackImpl {
  factory $MyImageCapture_MyOnImageSavedCallbackImpl({
    required void Function() onCaptureStarted,
    required void Function(int i) onCaptureProcessProgressed,
    required void Function(
            MyImageCapture_MyOutputFileResults myOutputFileResults)
        onImageSaved,
    required void Function(jni.JObject imageCaptureException) onError,
    required void Function(jni.JObject bitmap) onPostviewBitmapAvailable,
  }) = _$MyImageCapture_MyOnImageSavedCallbackImpl;

  void onCaptureStarted();
  void onCaptureProcessProgressed(int i);
  void onImageSaved(MyImageCapture_MyOutputFileResults myOutputFileResults);
  void onError(jni.JObject imageCaptureException);
  void onPostviewBitmapAvailable(jni.JObject bitmap);
}

class _$MyImageCapture_MyOnImageSavedCallbackImpl
    implements $MyImageCapture_MyOnImageSavedCallbackImpl {
  _$MyImageCapture_MyOnImageSavedCallbackImpl({
    required void Function() onCaptureStarted,
    required void Function(int i) onCaptureProcessProgressed,
    required void Function(
            MyImageCapture_MyOutputFileResults myOutputFileResults)
        onImageSaved,
    required void Function(jni.JObject imageCaptureException) onError,
    required void Function(jni.JObject bitmap) onPostviewBitmapAvailable,
  })  : _onCaptureStarted = onCaptureStarted,
        _onCaptureProcessProgressed = onCaptureProcessProgressed,
        _onImageSaved = onImageSaved,
        _onError = onError,
        _onPostviewBitmapAvailable = onPostviewBitmapAvailable;

  final void Function() _onCaptureStarted;
  final void Function(int i) _onCaptureProcessProgressed;
  final void Function(MyImageCapture_MyOutputFileResults myOutputFileResults)
      _onImageSaved;
  final void Function(jni.JObject imageCaptureException) _onError;
  final void Function(jni.JObject bitmap) _onPostviewBitmapAvailable;

  void onCaptureStarted() {
    return _onCaptureStarted();
  }

  void onCaptureProcessProgressed(int i) {
    return _onCaptureProcessProgressed(i);
  }

  void onImageSaved(MyImageCapture_MyOutputFileResults myOutputFileResults) {
    return _onImageSaved(myOutputFileResults);
  }

  void onError(jni.JObject imageCaptureException) {
    return _onError(imageCaptureException);
  }

  void onPostviewBitmapAvailable(jni.JObject bitmap) {
    return _onPostviewBitmapAvailable(bitmap);
  }
}

final class $MyImageCapture_MyOnImageSavedCallbackType
    extends jni.JObjType<MyImageCapture_MyOnImageSavedCallback> {
  const $MyImageCapture_MyOnImageSavedCallbackType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallback;';

  @override
  MyImageCapture_MyOnImageSavedCallback fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOnImageSavedCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOnImageSavedCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCapture_MyOnImageSavedCallbackType) &&
        other is $MyImageCapture_MyOnImageSavedCallbackType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOnImageSavedCallbackImpl
class MyImageCapture_MyOnImageSavedCallbackImpl extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOnImageSavedCallbackImpl> $type =
      type;

  MyImageCapture_MyOnImageSavedCallbackImpl.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallbackImpl');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOnImageSavedCallbackImplType();
  static final _id_new0 = _class.constructorId(
    r'(Ldev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallback;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(dev.hebei.camerax_android.MyImageCapture$MyOnImageSavedCallback myOnImageSavedCallback)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOnImageSavedCallbackImpl(
    MyImageCapture_MyOnImageSavedCallback myOnImageSavedCallback,
  ) {
    return MyImageCapture_MyOnImageSavedCallbackImpl.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            myOnImageSavedCallback.reference.pointer)
        .reference);
  }

  static final _id_onCaptureStarted = _class.instanceMethodId(
    r'onCaptureStarted',
    r'()V',
  );

  static final _onCaptureStarted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void onCaptureStarted()
  void onCaptureStarted() {
    _onCaptureStarted(
            reference.pointer, _id_onCaptureStarted as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onCaptureProcessProgressed = _class.instanceMethodId(
    r'onCaptureProcessProgressed',
    r'(I)V',
  );

  static final _onCaptureProcessProgressed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void onCaptureProcessProgressed(int i)
  void onCaptureProcessProgressed(
    int i,
  ) {
    _onCaptureProcessProgressed(reference.pointer,
            _id_onCaptureProcessProgressed as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_onImageSaved = _class.instanceMethodId(
    r'onImageSaved',
    r'(Landroidx/camera/core/ImageCapture$OutputFileResults;)V',
  );

  static final _onImageSaved = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onImageSaved(androidx.camera.core.ImageCapture$OutputFileResults outputFileResults)
  void onImageSaved(
    jni.JObject outputFileResults,
  ) {
    _onImageSaved(reference.pointer, _id_onImageSaved as jni.JMethodIDPtr,
            outputFileResults.reference.pointer)
        .check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onError(androidx.camera.core.ImageCaptureException imageCaptureException)
  void onError(
    jni.JObject imageCaptureException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            imageCaptureException.reference.pointer)
        .check();
  }

  static final _id_onPostviewBitmapAvailable = _class.instanceMethodId(
    r'onPostviewBitmapAvailable',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onPostviewBitmapAvailable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPostviewBitmapAvailable(android.graphics.Bitmap bitmap)
  void onPostviewBitmapAvailable(
    jni.JObject bitmap,
  ) {
    _onPostviewBitmapAvailable(
            reference.pointer,
            _id_onPostviewBitmapAvailable as jni.JMethodIDPtr,
            bitmap.reference.pointer)
        .check();
  }
}

final class $MyImageCapture_MyOnImageSavedCallbackImplType
    extends jni.JObjType<MyImageCapture_MyOnImageSavedCallbackImpl> {
  const $MyImageCapture_MyOnImageSavedCallbackImplType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOnImageSavedCallbackImpl;';

  @override
  MyImageCapture_MyOnImageSavedCallbackImpl fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOnImageSavedCallbackImpl.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOnImageSavedCallbackImplType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyImageCapture_MyOnImageSavedCallbackImplType) &&
        other is $MyImageCapture_MyOnImageSavedCallbackImplType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOutputFileOptions$MyBuilder
class MyImageCapture_MyOutputFileOptions_MyBuilder extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOutputFileOptions_MyBuilder> $type =
      type;

  MyImageCapture_MyOutputFileOptions_MyBuilder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOutputFileOptions$MyBuilder');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOutputFileOptions_MyBuilderType();
  static final _id_new0 = _class.constructorId(
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/content/ContentValues;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ContentResolver contentResolver, android.net.Uri uri, android.content.ContentValues contentValues)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOutputFileOptions_MyBuilder(
    ContentResolver contentResolver,
    Uri uri,
    ContentValues contentValues,
  ) {
    return MyImageCapture_MyOutputFileOptions_MyBuilder.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer,
            contentValues.reference.pointer)
        .reference);
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroidx/camera/core/ImageCapture$OutputFileOptions;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final androidx.camera.core.ImageCapture$OutputFileOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $MyImageCapture_MyOutputFileOptions_MyBuilderType
    extends jni.JObjType<MyImageCapture_MyOutputFileOptions_MyBuilder> {
  const $MyImageCapture_MyOutputFileOptions_MyBuilderType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileOptions$MyBuilder;';

  @override
  MyImageCapture_MyOutputFileOptions_MyBuilder fromReference(
          jni.JReference reference) =>
      MyImageCapture_MyOutputFileOptions_MyBuilder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($MyImageCapture_MyOutputFileOptions_MyBuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyImageCapture_MyOutputFileOptions_MyBuilderType) &&
        other is $MyImageCapture_MyOutputFileOptions_MyBuilderType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOutputFileOptions
class MyImageCapture_MyOutputFileOptions extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOutputFileOptions> $type = type;

  MyImageCapture_MyOutputFileOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOutputFileOptions');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOutputFileOptionsType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOutputFileOptions() {
    return MyImageCapture_MyOutputFileOptions.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyImageCapture_MyOutputFileOptionsType
    extends jni.JObjType<MyImageCapture_MyOutputFileOptions> {
  const $MyImageCapture_MyOutputFileOptionsType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileOptions;';

  @override
  MyImageCapture_MyOutputFileOptions fromReference(jni.JReference reference) =>
      MyImageCapture_MyOutputFileOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOutputFileOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCapture_MyOutputFileOptionsType) &&
        other is $MyImageCapture_MyOutputFileOptionsType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture$MyOutputFileResults
class MyImageCapture_MyOutputFileResults extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture_MyOutputFileResults> $type = type;

  MyImageCapture_MyOutputFileResults.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyImageCapture$MyOutputFileResults');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCapture_MyOutputFileResultsType();
  static final _id_new0 = _class.constructorId(
    r'(Landroidx/camera/core/ImageCapture$OutputFileResults;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(androidx.camera.core.ImageCapture$OutputFileResults outputFileResults)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture_MyOutputFileResults(
    jni.JObject outputFileResults,
  ) {
    return MyImageCapture_MyOutputFileResults.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            outputFileResults.reference.pointer)
        .reference);
  }

  static final _id_getSavedUri = _class.instanceMethodId(
    r'getSavedUri',
    r'()Landroid/net/Uri;',
  );

  static final _getSavedUri = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final android.net.Uri getSavedUri()
  /// The returned object must be released after use, by calling the [release] method.
  Uri getSavedUri() {
    return _getSavedUri(reference.pointer, _id_getSavedUri as jni.JMethodIDPtr)
        .object(const $UriType());
  }
}

final class $MyImageCapture_MyOutputFileResultsType
    extends jni.JObjType<MyImageCapture_MyOutputFileResults> {
  const $MyImageCapture_MyOutputFileResultsType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyImageCapture$MyOutputFileResults;';

  @override
  MyImageCapture_MyOutputFileResults fromReference(jni.JReference reference) =>
      MyImageCapture_MyOutputFileResults.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCapture_MyOutputFileResultsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCapture_MyOutputFileResultsType) &&
        other is $MyImageCapture_MyOutputFileResultsType;
  }
}

/// from: dev.hebei.camerax_android.MyImageCapture
class MyImageCapture extends jni.JObject {
  @override
  late final jni.JObjType<MyImageCapture> $type = type;

  MyImageCapture.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'dev/hebei/camerax_android/MyImageCapture');

  /// The type which includes information such as the signature of this class.
  static const type = $MyImageCaptureType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Ldev/hebei/camerax_android/MyImageCapture$Companion;',
  );

  /// from: static public final dev.hebei.camerax_android.MyImageCapture$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static MyImageCapture_Companion get Companion =>
      _id_Companion.get(_class, const $MyImageCapture_CompanionType());

  /// from: static public final int CAPTURE_MODE_MINIMIZE_LATENCY
  static const CAPTURE_MODE_MINIMIZE_LATENCY = 1;

  /// from: static public final int CAPTURE_MODE_MAXIMIZE_QUALITY
  static const CAPTURE_MODE_MAXIMIZE_QUALITY = 0;

  /// from: static public final int FLASH_MODE_AUTO
  static const FLASH_MODE_AUTO = 0;

  /// from: static public final int FLASH_MODE_OFF
  static const FLASH_MODE_OFF = 2;

  /// from: static public final int FLASH_MODE_ON
  static const FLASH_MODE_ON = 1;

  /// from: static public final int FLASH_MODE_SCREEN
  static const FLASH_MODE_SCREEN = 3;
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyImageCapture() {
    return MyImageCapture.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyImageCaptureType extends jni.JObjType<MyImageCapture> {
  const $MyImageCaptureType();

  @override
  String get signature => r'Ldev/hebei/camerax_android/MyImageCapture;';

  @override
  MyImageCapture fromReference(jni.JReference reference) =>
      MyImageCapture.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyImageCaptureType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyImageCaptureType) &&
        other is $MyImageCaptureType;
  }
}

/// from: dev.hebei.camerax_android.MyMediaStoreOutputOptions$MyBuilder
class MyMediaStoreOutputOptions_MyBuilder extends jni.JObject {
  @override
  late final jni.JObjType<MyMediaStoreOutputOptions_MyBuilder> $type = type;

  MyMediaStoreOutputOptions_MyBuilder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyMediaStoreOutputOptions$MyBuilder');

  /// The type which includes information such as the signature of this class.
  static const type = $MyMediaStoreOutputOptions_MyBuilderType();
  static final _id_new0 = _class.constructorId(
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ContentResolver contentResolver, android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMediaStoreOutputOptions_MyBuilder(
    ContentResolver contentResolver,
    Uri uri,
  ) {
    return MyMediaStoreOutputOptions_MyBuilder.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            contentResolver.reference.pointer,
            uri.reference.pointer)
        .reference);
  }

  static final _id_setContentValues = _class.instanceMethodId(
    r'setContentValues',
    r'(Landroid/content/ContentValues;)Ldev/hebei/camerax_android/MyMediaStoreOutputOptions$MyBuilder;',
  );

  static final _setContentValues = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final dev.hebei.camerax_android.MyMediaStoreOutputOptions$MyBuilder setContentValues(android.content.ContentValues contentValues)
  /// The returned object must be released after use, by calling the [release] method.
  MyMediaStoreOutputOptions_MyBuilder setContentValues(
    ContentValues contentValues,
  ) {
    return _setContentValues(
            reference.pointer,
            _id_setContentValues as jni.JMethodIDPtr,
            contentValues.reference.pointer)
        .object(const $MyMediaStoreOutputOptions_MyBuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroidx/camera/video/MediaStoreOutputOptions;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final androidx.camera.video.MediaStoreOutputOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $MyMediaStoreOutputOptions_MyBuilderType
    extends jni.JObjType<MyMediaStoreOutputOptions_MyBuilder> {
  const $MyMediaStoreOutputOptions_MyBuilderType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyMediaStoreOutputOptions$MyBuilder;';

  @override
  MyMediaStoreOutputOptions_MyBuilder fromReference(jni.JReference reference) =>
      MyMediaStoreOutputOptions_MyBuilder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyMediaStoreOutputOptions_MyBuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMediaStoreOutputOptions_MyBuilderType) &&
        other is $MyMediaStoreOutputOptions_MyBuilderType;
  }
}

/// from: dev.hebei.camerax_android.MyMediaStoreOutputOptions
class MyMediaStoreOutputOptions extends jni.JObject {
  @override
  late final jni.JObjType<MyMediaStoreOutputOptions> $type = type;

  MyMediaStoreOutputOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyMediaStoreOutputOptions');

  /// The type which includes information such as the signature of this class.
  static const type = $MyMediaStoreOutputOptionsType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMediaStoreOutputOptions() {
    return MyMediaStoreOutputOptions.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyMediaStoreOutputOptionsType
    extends jni.JObjType<MyMediaStoreOutputOptions> {
  const $MyMediaStoreOutputOptionsType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyMediaStoreOutputOptions;';

  @override
  MyMediaStoreOutputOptions fromReference(jni.JReference reference) =>
      MyMediaStoreOutputOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyMediaStoreOutputOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMediaStoreOutputOptionsType) &&
        other is $MyMediaStoreOutputOptionsType;
  }
}

/// from: dev.hebei.camerax_android.MyPermissionsManager$MyPermissionsResultCallback
class MyPermissionsManager_MyPermissionsResultCallback extends jni.JObject {
  @override
  late final jni.JObjType<MyPermissionsManager_MyPermissionsResultCallback>
      $type = type;

  MyPermissionsManager_MyPermissionsResultCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyPermissionsManager$MyPermissionsResultCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $MyPermissionsManager_MyPermissionsResultCallbackType();
  static final _id_onPermissionsResult = _class.instanceMethodId(
    r'onPermissionsResult',
    r'(Z)V',
  );

  static final _onPermissionsResult = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract void onPermissionsResult(boolean z)
  void onPermissionsResult(
    bool z,
  ) {
    _onPermissionsResult(reference.pointer,
            _id_onPermissionsResult as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyPermissionsManager_MyPermissionsResultCallbackImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onPermissionsResult(Z)V') {
        _$impls[$p]!.onPermissionsResult(
          $a[0]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MyPermissionsManager_MyPermissionsResultCallback.implement(
    $MyPermissionsManager_MyPermissionsResultCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyPermissionsManager_MyPermissionsResultCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'dev.hebei.camerax_android.MyPermissionsManager$MyPermissionsResultCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MyPermissionsManager_MyPermissionsResultCallbackImpl {
  factory $MyPermissionsManager_MyPermissionsResultCallbackImpl({
    required void Function(bool z) onPermissionsResult,
  }) = _$MyPermissionsManager_MyPermissionsResultCallbackImpl;

  void onPermissionsResult(bool z);
}

class _$MyPermissionsManager_MyPermissionsResultCallbackImpl
    implements $MyPermissionsManager_MyPermissionsResultCallbackImpl {
  _$MyPermissionsManager_MyPermissionsResultCallbackImpl({
    required void Function(bool z) onPermissionsResult,
  }) : _onPermissionsResult = onPermissionsResult;

  final void Function(bool z) _onPermissionsResult;

  void onPermissionsResult(bool z) {
    return _onPermissionsResult(z);
  }
}

final class $MyPermissionsManager_MyPermissionsResultCallbackType
    extends jni.JObjType<MyPermissionsManager_MyPermissionsResultCallback> {
  const $MyPermissionsManager_MyPermissionsResultCallbackType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyPermissionsManager$MyPermissionsResultCallback;';

  @override
  MyPermissionsManager_MyPermissionsResultCallback fromReference(
          jni.JReference reference) =>
      MyPermissionsManager_MyPermissionsResultCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($MyPermissionsManager_MyPermissionsResultCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($MyPermissionsManager_MyPermissionsResultCallbackType) &&
        other is $MyPermissionsManager_MyPermissionsResultCallbackType;
  }
}

/// from: dev.hebei.camerax_android.MyPermissionsManager
class MyPermissionsManager extends jni.JObject {
  @override
  late final jni.JObjType<MyPermissionsManager> $type = type;

  MyPermissionsManager.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'dev/hebei/camerax_android/MyPermissionsManager');

  /// The type which includes information such as the signature of this class.
  static const type = $MyPermissionsManagerType();
  static final _id_INSTANCE = _class.staticFieldId(
    r'INSTANCE',
    r'Ldev/hebei/camerax_android/MyPermissionsManager;',
  );

  /// from: static public final dev.hebei.camerax_android.MyPermissionsManager INSTANCE
  /// The returned object must be released after use, by calling the [release] method.
  static MyPermissionsManager get INSTANCE =>
      _id_INSTANCE.get(_class, const $MyPermissionsManagerType());

  static final _id_checkPermissions = _class.instanceMethodId(
    r'checkPermissions',
    r'([Ljava/lang/String;)Z',
  );

  static final _checkPermissions = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean checkPermissions(java.lang.String[] strings)
  bool checkPermissions(
    jni.JArray<jni.JString> strings,
  ) {
    return _checkPermissions(reference.pointer,
            _id_checkPermissions as jni.JMethodIDPtr, strings.reference.pointer)
        .boolean;
  }

  static final _id_requestPermissions = _class.instanceMethodId(
    r'requestPermissions',
    r'([Ljava/lang/String;Ldev/hebei/camerax_android/MyPermissionsManager$MyPermissionsResultCallback;)V',
  );

  static final _requestPermissions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void requestPermissions(java.lang.String[] strings, dev.hebei.camerax_android.MyPermissionsManager$MyPermissionsResultCallback myPermissionsResultCallback)
  void requestPermissions(
    jni.JArray<jni.JString> strings,
    MyPermissionsManager_MyPermissionsResultCallback
        myPermissionsResultCallback,
  ) {
    _requestPermissions(
            reference.pointer,
            _id_requestPermissions as jni.JMethodIDPtr,
            strings.reference.pointer,
            myPermissionsResultCallback.reference.pointer)
        .check();
  }
}

final class $MyPermissionsManagerType
    extends jni.JObjType<MyPermissionsManager> {
  const $MyPermissionsManagerType();

  @override
  String get signature => r'Ldev/hebei/camerax_android/MyPermissionsManager;';

  @override
  MyPermissionsManager fromReference(jni.JReference reference) =>
      MyPermissionsManager.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyPermissionsManagerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyPermissionsManagerType) &&
        other is $MyPermissionsManagerType;
  }
}

/// from: dev.hebei.camerax_android.MyPreviewView$MyFactory
class MyPreviewView_MyFactory extends jni.JObject {
  @override
  late final jni.JObjType<MyPreviewView_MyFactory> $type = type;

  MyPreviewView_MyFactory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'dev/hebei/camerax_android/MyPreviewView$MyFactory');

  /// The type which includes information such as the signature of this class.
  static const type = $MyPreviewView_MyFactoryType();
  static final _id_INSTANCE = _class.staticFieldId(
    r'INSTANCE',
    r'Ldev/hebei/camerax_android/MyPreviewView$MyFactory;',
  );

  /// from: static public final dev.hebei.camerax_android.MyPreviewView$MyFactory INSTANCE
  /// The returned object must be released after use, by calling the [release] method.
  static MyPreviewView_MyFactory get INSTANCE =>
      _id_INSTANCE.get(_class, const $MyPreviewView_MyFactoryType());

  static final _id_create = _class.instanceMethodId(
    r'create',
    r'(Landroid/content/Context;ILjava/lang/Object;)Lio/flutter/plugin/platform/PlatformView;',
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public io.flutter.plugin.platform.PlatformView create(android.content.Context context, int i, java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject create(
    Context context,
    int i,
    jni.JObject object,
  ) {
    return _create(reference.pointer, _id_create as jni.JMethodIDPtr,
            context.reference.pointer, i, object.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_addView = _class.instanceMethodId(
    r'addView',
    r'(ILdev/hebei/camerax_android/MyPreviewView;)V',
  );

  static final _addView = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void addView(int i, dev.hebei.camerax_android.MyPreviewView myPreviewView)
  void addView(
    int i,
    MyPreviewView myPreviewView,
  ) {
    _addView(reference.pointer, _id_addView as jni.JMethodIDPtr, i,
            myPreviewView.reference.pointer)
        .check();
  }

  static final _id_retrieveView = _class.instanceMethodId(
    r'retrieveView',
    r'(I)Ldev/hebei/camerax_android/MyPreviewView;',
  );

  static final _retrieveView = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final dev.hebei.camerax_android.MyPreviewView retrieveView(int i)
  /// The returned object must be released after use, by calling the [release] method.
  MyPreviewView retrieveView(
    int i,
  ) {
    return _retrieveView(
            reference.pointer, _id_retrieveView as jni.JMethodIDPtr, i)
        .object(const $MyPreviewViewType());
  }

  static final _id_removeView = _class.instanceMethodId(
    r'removeView',
    r'(I)Ldev/hebei/camerax_android/MyPreviewView;',
  );

  static final _removeView = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final dev.hebei.camerax_android.MyPreviewView removeView(int i)
  /// The returned object must be released after use, by calling the [release] method.
  MyPreviewView removeView(
    int i,
  ) {
    return _removeView(reference.pointer, _id_removeView as jni.JMethodIDPtr, i)
        .object(const $MyPreviewViewType());
  }
}

final class $MyPreviewView_MyFactoryType
    extends jni.JObjType<MyPreviewView_MyFactory> {
  const $MyPreviewView_MyFactoryType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyPreviewView$MyFactory;';

  @override
  MyPreviewView_MyFactory fromReference(jni.JReference reference) =>
      MyPreviewView_MyFactory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyPreviewView_MyFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyPreviewView_MyFactoryType) &&
        other is $MyPreviewView_MyFactoryType;
  }
}

/// from: dev.hebei.camerax_android.MyPreviewView$MyScaleType
class MyPreviewView_MyScaleType extends jni.JObject {
  @override
  late final jni.JObjType<MyPreviewView_MyScaleType> $type = type;

  MyPreviewView_MyScaleType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyPreviewView$MyScaleType');

  /// The type which includes information such as the signature of this class.
  static const type = $MyPreviewView_MyScaleTypeType();
  static final _id_FILL_START = _class.staticFieldId(
    r'FILL_START',
    r'Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  /// from: static public final dev.hebei.camerax_android.MyPreviewView$MyScaleType FILL_START
  /// The returned object must be released after use, by calling the [release] method.
  static MyPreviewView_MyScaleType get FILL_START =>
      _id_FILL_START.get(_class, const $MyPreviewView_MyScaleTypeType());

  static final _id_FILL_CENTER = _class.staticFieldId(
    r'FILL_CENTER',
    r'Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  /// from: static public final dev.hebei.camerax_android.MyPreviewView$MyScaleType FILL_CENTER
  /// The returned object must be released after use, by calling the [release] method.
  static MyPreviewView_MyScaleType get FILL_CENTER =>
      _id_FILL_CENTER.get(_class, const $MyPreviewView_MyScaleTypeType());

  static final _id_FILL_END = _class.staticFieldId(
    r'FILL_END',
    r'Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  /// from: static public final dev.hebei.camerax_android.MyPreviewView$MyScaleType FILL_END
  /// The returned object must be released after use, by calling the [release] method.
  static MyPreviewView_MyScaleType get FILL_END =>
      _id_FILL_END.get(_class, const $MyPreviewView_MyScaleTypeType());

  static final _id_FIT_START = _class.staticFieldId(
    r'FIT_START',
    r'Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  /// from: static public final dev.hebei.camerax_android.MyPreviewView$MyScaleType FIT_START
  /// The returned object must be released after use, by calling the [release] method.
  static MyPreviewView_MyScaleType get FIT_START =>
      _id_FIT_START.get(_class, const $MyPreviewView_MyScaleTypeType());

  static final _id_FIT_CENTER = _class.staticFieldId(
    r'FIT_CENTER',
    r'Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  /// from: static public final dev.hebei.camerax_android.MyPreviewView$MyScaleType FIT_CENTER
  /// The returned object must be released after use, by calling the [release] method.
  static MyPreviewView_MyScaleType get FIT_CENTER =>
      _id_FIT_CENTER.get(_class, const $MyPreviewView_MyScaleTypeType());

  static final _id_FIT_END = _class.staticFieldId(
    r'FIT_END',
    r'Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  /// from: static public final dev.hebei.camerax_android.MyPreviewView$MyScaleType FIT_END
  /// The returned object must be released after use, by calling the [release] method.
  static MyPreviewView_MyScaleType get FIT_END =>
      _id_FIT_END.get(_class, const $MyPreviewView_MyScaleTypeType());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public dev.hebei.camerax_android.MyPreviewView$MyScaleType[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<MyPreviewView_MyScaleType> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($MyPreviewView_MyScaleTypeType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public dev.hebei.camerax_android.MyPreviewView$MyScaleType valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static MyPreviewView_MyScaleType valueOf(
    jni.JString string,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $MyPreviewView_MyScaleTypeType());
  }
}

final class $MyPreviewView_MyScaleTypeType
    extends jni.JObjType<MyPreviewView_MyScaleType> {
  const $MyPreviewView_MyScaleTypeType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;';

  @override
  MyPreviewView_MyScaleType fromReference(jni.JReference reference) =>
      MyPreviewView_MyScaleType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyPreviewView_MyScaleTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyPreviewView_MyScaleTypeType) &&
        other is $MyPreviewView_MyScaleTypeType;
  }
}

/// from: dev.hebei.camerax_android.MyPreviewView$WhenMappings
class MyPreviewView_WhenMappings extends jni.JObject {
  @override
  late final jni.JObjType<MyPreviewView_WhenMappings> $type = type;

  MyPreviewView_WhenMappings.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'dev/hebei/camerax_android/MyPreviewView$WhenMappings');

  /// The type which includes information such as the signature of this class.
  static const type = $MyPreviewView_WhenMappingsType();
}

final class $MyPreviewView_WhenMappingsType
    extends jni.JObjType<MyPreviewView_WhenMappings> {
  const $MyPreviewView_WhenMappingsType();

  @override
  String get signature =>
      r'Ldev/hebei/camerax_android/MyPreviewView$WhenMappings;';

  @override
  MyPreviewView_WhenMappings fromReference(jni.JReference reference) =>
      MyPreviewView_WhenMappings.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyPreviewView_WhenMappingsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyPreviewView_WhenMappingsType) &&
        other is $MyPreviewView_WhenMappingsType;
  }
}

/// from: dev.hebei.camerax_android.MyPreviewView
class MyPreviewView extends jni.JObject {
  @override
  late final jni.JObjType<MyPreviewView> $type = type;

  MyPreviewView.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'dev/hebei/camerax_android/MyPreviewView');

  /// The type which includes information such as the signature of this class.
  static const type = $MyPreviewViewType();
  static final _id_new0 = _class.constructorId(
    r'(Landroid/content/Context;ILjava/lang/Object;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, int i, java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyPreviewView(
    Context context,
    int i,
    jni.JObject object,
  ) {
    return MyPreviewView.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            context.reference.pointer,
            i,
            object.reference.pointer)
        .reference);
  }

  static final _id_getView = _class.instanceMethodId(
    r'getView',
    r'()Landroid/view/View;',
  );

  static final _getView = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.view.View getView()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getView() {
    return _getView(reference.pointer, _id_getView as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_dispose = _class.instanceMethodId(
    r'dispose',
    r'()V',
  );

  static final _dispose = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void dispose()
  void dispose() {
    _dispose(reference.pointer, _id_dispose as jni.JMethodIDPtr).check();
  }

  static final _id_getController = _class.instanceMethodId(
    r'getController',
    r'()Landroidx/camera/view/CameraController;',
  );

  static final _getController = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final androidx.camera.view.CameraController getController()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController getController() {
    return _getController(
            reference.pointer, _id_getController as jni.JMethodIDPtr)
        .object(const $CameraControllerType());
  }

  static final _id_setController = _class.instanceMethodId(
    r'setController',
    r'(Landroidx/camera/view/CameraController;)V',
  );

  static final _setController = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void setController(androidx.camera.view.CameraController cameraController)
  void setController(
    CameraController cameraController,
  ) {
    _setController(reference.pointer, _id_setController as jni.JMethodIDPtr,
            cameraController.reference.pointer)
        .check();
  }

  static final _id_getScaleType = _class.instanceMethodId(
    r'getScaleType',
    r'()Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;',
  );

  static final _getScaleType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final dev.hebei.camerax_android.MyPreviewView$MyScaleType getScaleType()
  /// The returned object must be released after use, by calling the [release] method.
  MyPreviewView_MyScaleType getScaleType() {
    return _getScaleType(
            reference.pointer, _id_getScaleType as jni.JMethodIDPtr)
        .object(const $MyPreviewView_MyScaleTypeType());
  }

  static final _id_setScaleType = _class.instanceMethodId(
    r'setScaleType',
    r'(Ldev/hebei/camerax_android/MyPreviewView$MyScaleType;)V',
  );

  static final _setScaleType = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void setScaleType(dev.hebei.camerax_android.MyPreviewView$MyScaleType myScaleType)
  void setScaleType(
    MyPreviewView_MyScaleType myScaleType,
  ) {
    _setScaleType(reference.pointer, _id_setScaleType as jni.JMethodIDPtr,
            myScaleType.reference.pointer)
        .check();
  }
}

final class $MyPreviewViewType extends jni.JObjType<MyPreviewView> {
  const $MyPreviewViewType();

  @override
  String get signature => r'Ldev/hebei/camerax_android/MyPreviewView;';

  @override
  MyPreviewView fromReference(jni.JReference reference) =>
      MyPreviewView.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyPreviewViewType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyPreviewViewType) &&
        other is $MyPreviewViewType;
  }
}
