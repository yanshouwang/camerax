// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: androidx.core.content.ContextCompat
class ContextCompat extends jni.JObject {
  @override
  late final jni.JObjType<ContextCompat> $type = type;

  ContextCompat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/core/content/ContextCompat");

  /// The type which includes information such as the signature of this class.
  static const type = $ContextCompatType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ContextCompat() {
    return ContextCompat.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getAttributionTag = _class.staticMethodId(
    r"getAttributionTag",
    r"(Landroid/content/Context;)Ljava/lang/String;",
  );

  static final _getAttributionTag = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getAttributionTag(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getAttributionTag(
    jni.JObject context,
  ) {
    return _getAttributionTag(
            _class.reference.pointer,
            _id_getAttributionTag as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_startActivities = _class.staticMethodId(
    r"startActivities",
    r"(Landroid/content/Context;[Landroid/content/Intent;)Z",
  );

  static final _startActivities = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticBooleanMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean startActivities(android.content.Context context, android.content.Intent[] intents)
  static bool startActivities(
    jni.JObject context,
    jni.JArray<jni.JObject> intents,
  ) {
    return _startActivities(
            _class.reference.pointer,
            _id_startActivities as jni.JMethodIDPtr,
            context.reference.pointer,
            intents.reference.pointer)
        .boolean;
  }

  static final _id_startActivities1 = _class.staticMethodId(
    r"startActivities",
    r"(Landroid/content/Context;[Landroid/content/Intent;Landroid/os/Bundle;)Z",
  );

  static final _startActivities1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticBooleanMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean startActivities(android.content.Context context, android.content.Intent[] intents, android.os.Bundle options)
  static bool startActivities1(
    jni.JObject context,
    jni.JArray<jni.JObject> intents,
    jni.JObject options,
  ) {
    return _startActivities1(
            _class.reference.pointer,
            _id_startActivities1 as jni.JMethodIDPtr,
            context.reference.pointer,
            intents.reference.pointer,
            options.reference.pointer)
        .boolean;
  }

  static final _id_startActivity = _class.staticMethodId(
    r"startActivity",
    r"(Landroid/content/Context;Landroid/content/Intent;Landroid/os/Bundle;)V",
  );

  static final _startActivity = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void startActivity(android.content.Context context, android.content.Intent intent, android.os.Bundle options)
  static void startActivity(
    jni.JObject context,
    jni.JObject intent,
    jni.JObject options,
  ) {
    _startActivity(
            _class.reference.pointer,
            _id_startActivity as jni.JMethodIDPtr,
            context.reference.pointer,
            intent.reference.pointer,
            options.reference.pointer)
        .check();
  }

  static final _id_getDataDir = _class.staticMethodId(
    r"getDataDir",
    r"(Landroid/content/Context;)Ljava/io/File;",
  );

  static final _getDataDir = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File getDataDir(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getDataDir(
    jni.JObject context,
  ) {
    return _getDataDir(_class.reference.pointer,
            _id_getDataDir as jni.JMethodIDPtr, context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getObbDirs = _class.staticMethodId(
    r"getObbDirs",
    r"(Landroid/content/Context;)[Ljava/io/File;",
  );

  static final _getObbDirs = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File[] getObbDirs(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> getObbDirs(
    jni.JObject context,
  ) {
    return _getObbDirs(_class.reference.pointer,
            _id_getObbDirs as jni.JMethodIDPtr, context.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getExternalFilesDirs = _class.staticMethodId(
    r"getExternalFilesDirs",
    r"(Landroid/content/Context;Ljava/lang/String;)[Ljava/io/File;",
  );

  static final _getExternalFilesDirs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File[] getExternalFilesDirs(android.content.Context context, java.lang.String type)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> getExternalFilesDirs(
    jni.JObject context,
    jni.JString type0,
  ) {
    return _getExternalFilesDirs(
            _class.reference.pointer,
            _id_getExternalFilesDirs as jni.JMethodIDPtr,
            context.reference.pointer,
            type0.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getExternalCacheDirs = _class.staticMethodId(
    r"getExternalCacheDirs",
    r"(Landroid/content/Context;)[Ljava/io/File;",
  );

  static final _getExternalCacheDirs = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File[] getExternalCacheDirs(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> getExternalCacheDirs(
    jni.JObject context,
  ) {
    return _getExternalCacheDirs(
            _class.reference.pointer,
            _id_getExternalCacheDirs as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_getDrawable = _class.staticMethodId(
    r"getDrawable",
    r"(Landroid/content/Context;I)Landroid/graphics/drawable/Drawable;",
  );

  static final _getDrawable = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int32)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.drawable.Drawable getDrawable(android.content.Context context, int id)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getDrawable(
    jni.JObject context,
    int id,
  ) {
    return _getDrawable(_class.reference.pointer,
            _id_getDrawable as jni.JMethodIDPtr, context.reference.pointer, id)
        .object(const jni.JObjectType());
  }

  static final _id_getColorStateList = _class.staticMethodId(
    r"getColorStateList",
    r"(Landroid/content/Context;I)Landroid/content/res/ColorStateList;",
  );

  static final _getColorStateList = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int32)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.content.res.ColorStateList getColorStateList(android.content.Context context, int id)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getColorStateList(
    jni.JObject context,
    int id,
  ) {
    return _getColorStateList(
            _class.reference.pointer,
            _id_getColorStateList as jni.JMethodIDPtr,
            context.reference.pointer,
            id)
        .object(const jni.JObjectType());
  }

  static final _id_getColor = _class.staticMethodId(
    r"getColor",
    r"(Landroid/content/Context;I)I",
  );

  static final _getColor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int32)>)>>(
          "globalEnv_CallStaticIntMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public int getColor(android.content.Context context, int id)
  static int getColor(
    jni.JObject context,
    int id,
  ) {
    return _getColor(_class.reference.pointer, _id_getColor as jni.JMethodIDPtr,
            context.reference.pointer, id)
        .integer;
  }

  static final _id_checkSelfPermission = _class.staticMethodId(
    r"checkSelfPermission",
    r"(Landroid/content/Context;Ljava/lang/String;)I",
  );

  static final _checkSelfPermission = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticIntMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public int checkSelfPermission(android.content.Context context, java.lang.String permission)
  static int checkSelfPermission(
    jni.JObject context,
    jni.JString permission,
  ) {
    return _checkSelfPermission(
            _class.reference.pointer,
            _id_checkSelfPermission as jni.JMethodIDPtr,
            context.reference.pointer,
            permission.reference.pointer)
        .integer;
  }

  static final _id_getNoBackupFilesDir = _class.staticMethodId(
    r"getNoBackupFilesDir",
    r"(Landroid/content/Context;)Ljava/io/File;",
  );

  static final _getNoBackupFilesDir = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File getNoBackupFilesDir(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getNoBackupFilesDir(
    jni.JObject context,
  ) {
    return _getNoBackupFilesDir(
            _class.reference.pointer,
            _id_getNoBackupFilesDir as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getCodeCacheDir = _class.staticMethodId(
    r"getCodeCacheDir",
    r"(Landroid/content/Context;)Ljava/io/File;",
  );

  static final _getCodeCacheDir = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File getCodeCacheDir(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getCodeCacheDir(
    jni.JObject context,
  ) {
    return _getCodeCacheDir(_class.reference.pointer,
            _id_getCodeCacheDir as jni.JMethodIDPtr, context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_createDeviceProtectedStorageContext = _class.staticMethodId(
    r"createDeviceProtectedStorageContext",
    r"(Landroid/content/Context;)Landroid/content/Context;",
  );

  static final _createDeviceProtectedStorageContext =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JniResult Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              "globalEnv_CallStaticObjectMethod")
          .asFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Context createDeviceProtectedStorageContext(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject createDeviceProtectedStorageContext(
    jni.JObject context,
  ) {
    return _createDeviceProtectedStorageContext(
            _class.reference.pointer,
            _id_createDeviceProtectedStorageContext as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_isDeviceProtectedStorage = _class.staticMethodId(
    r"isDeviceProtectedStorage",
    r"(Landroid/content/Context;)Z",
  );

  static final _isDeviceProtectedStorage = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticBooleanMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isDeviceProtectedStorage(android.content.Context context)
  static bool isDeviceProtectedStorage(
    jni.JObject context,
  ) {
    return _isDeviceProtectedStorage(
            _class.reference.pointer,
            _id_isDeviceProtectedStorage as jni.JMethodIDPtr,
            context.reference.pointer)
        .boolean;
  }

  static final _id_getMainExecutor = _class.staticMethodId(
    r"getMainExecutor",
    r"(Landroid/content/Context;)Ljava/util/concurrent/Executor;",
  );

  static final _getMainExecutor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Executor getMainExecutor(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject getMainExecutor(
    jni.JObject context,
  ) {
    return _getMainExecutor(_class.reference.pointer,
            _id_getMainExecutor as jni.JMethodIDPtr, context.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_startForegroundService = _class.staticMethodId(
    r"startForegroundService",
    r"(Landroid/content/Context;Landroid/content/Intent;)V",
  );

  static final _startForegroundService = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void startForegroundService(android.content.Context context, android.content.Intent intent)
  static void startForegroundService(
    jni.JObject context,
    jni.JObject intent,
  ) {
    _startForegroundService(
            _class.reference.pointer,
            _id_startForegroundService as jni.JMethodIDPtr,
            context.reference.pointer,
            intent.reference.pointer)
        .check();
  }

  static final _id_getSystemService = _class.staticMethodId(
    r"getSystemService",
    r"(Landroid/content/Context;Ljava/lang/Class;)Ljava/lang/Object;",
  );

  static final _getSystemService = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public T getSystemService(android.content.Context context, java.lang.Class serviceClass)
  /// The returned object must be released after use, by calling the [release] method.
  static $T getSystemService<$T extends jni.JObject>(
    jni.JObject context,
    jni.JObject serviceClass, {
    required jni.JObjType<$T> T,
  }) {
    return _getSystemService(
            _class.reference.pointer,
            _id_getSystemService as jni.JMethodIDPtr,
            context.reference.pointer,
            serviceClass.reference.pointer)
        .object(T);
  }

  static final _id_getSystemServiceName = _class.staticMethodId(
    r"getSystemServiceName",
    r"(Landroid/content/Context;Ljava/lang/Class;)Ljava/lang/String;",
  );

  static final _getSystemServiceName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getSystemServiceName(android.content.Context context, java.lang.Class serviceClass)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getSystemServiceName(
    jni.JObject context,
    jni.JObject serviceClass,
  ) {
    return _getSystemServiceName(
            _class.reference.pointer,
            _id_getSystemServiceName as jni.JMethodIDPtr,
            context.reference.pointer,
            serviceClass.reference.pointer)
        .object(const jni.JStringType());
  }
}

final class $ContextCompatType extends jni.JObjType<ContextCompat> {
  const $ContextCompatType();

  @override
  String get signature => r"Landroidx/core/content/ContextCompat;";

  @override
  ContextCompat fromReference(jni.JReference reference) =>
      ContextCompat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ContextCompatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ContextCompatType) &&
        other is $ContextCompatType;
  }
}

/// from: androidx.camera.core.CameraSelector$Builder
class CameraSelector_Builder extends jni.JObject {
  @override
  late final jni.JObjType<CameraSelector_Builder> $type = type;

  CameraSelector_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/core/CameraSelector$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $CameraSelector_BuilderType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraSelector_Builder() {
    return CameraSelector_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_requireLensFacing = _class.instanceMethodId(
    r"requireLensFacing",
    r"(I)Landroidx/camera/core/CameraSelector$Builder;",
  );

  static final _requireLensFacing = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public androidx.camera.core.CameraSelector$Builder requireLensFacing(int i)
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector_Builder requireLensFacing(
    int i,
  ) {
    return _requireLensFacing(
            reference.pointer, _id_requireLensFacing as jni.JMethodIDPtr, i)
        .object(const $CameraSelector_BuilderType());
  }

  static final _id_addCameraFilter = _class.instanceMethodId(
    r"addCameraFilter",
    r"(Landroidx/camera/core/CameraFilter;)Landroidx/camera/core/CameraSelector$Builder;",
  );

  static final _addCameraFilter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.core.CameraSelector$Builder addCameraFilter(androidx.camera.core.CameraFilter cameraFilter)
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector_Builder addCameraFilter(
    jni.JObject cameraFilter,
  ) {
    return _addCameraFilter(
            reference.pointer,
            _id_addCameraFilter as jni.JMethodIDPtr,
            cameraFilter.reference.pointer)
        .object(const $CameraSelector_BuilderType());
  }

  static final _id_fromSelector = _class.staticMethodId(
    r"fromSelector",
    r"(Landroidx/camera/core/CameraSelector;)Landroidx/camera/core/CameraSelector$Builder;",
  );

  static final _fromSelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public androidx.camera.core.CameraSelector$Builder fromSelector(androidx.camera.core.CameraSelector cameraSelector)
  /// The returned object must be released after use, by calling the [release] method.
  static CameraSelector_Builder fromSelector(
    CameraSelector cameraSelector,
  ) {
    return _fromSelector(
            _class.reference.pointer,
            _id_fromSelector as jni.JMethodIDPtr,
            cameraSelector.reference.pointer)
        .object(const $CameraSelector_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r"build",
    r"()Landroidx/camera/core/CameraSelector;",
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraSelector build()
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $CameraSelectorType());
  }
}

final class $CameraSelector_BuilderType
    extends jni.JObjType<CameraSelector_Builder> {
  const $CameraSelector_BuilderType();

  @override
  String get signature => r"Landroidx/camera/core/CameraSelector$Builder;";

  @override
  CameraSelector_Builder fromReference(jni.JReference reference) =>
      CameraSelector_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraSelector_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraSelector_BuilderType) &&
        other is $CameraSelector_BuilderType;
  }
}

/// from: androidx.camera.core.CameraSelector$LensFacing
class CameraSelector_LensFacing extends jni.JObject {
  @override
  late final jni.JObjType<CameraSelector_LensFacing> $type = type;

  CameraSelector_LensFacing.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/core/CameraSelector$LensFacing");

  /// The type which includes information such as the signature of this class.
  static const type = $CameraSelector_LensFacingType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CameraSelector_LensFacingImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory CameraSelector_LensFacing.implement(
    $CameraSelector_LensFacingImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = CameraSelector_LensFacing.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"androidx.camera.core.CameraSelector$LensFacing",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CameraSelector_LensFacingImpl {
  factory $CameraSelector_LensFacingImpl() = _$CameraSelector_LensFacingImpl;
}

class _$CameraSelector_LensFacingImpl
    implements $CameraSelector_LensFacingImpl {
  _$CameraSelector_LensFacingImpl();
}

final class $CameraSelector_LensFacingType
    extends jni.JObjType<CameraSelector_LensFacing> {
  const $CameraSelector_LensFacingType();

  @override
  String get signature => r"Landroidx/camera/core/CameraSelector$LensFacing;";

  @override
  CameraSelector_LensFacing fromReference(jni.JReference reference) =>
      CameraSelector_LensFacing.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraSelector_LensFacingType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraSelector_LensFacingType) &&
        other is $CameraSelector_LensFacingType;
  }
}

/// from: androidx.camera.core.CameraSelector
class CameraSelector extends jni.JObject {
  @override
  late final jni.JObjType<CameraSelector> $type = type;

  CameraSelector.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/core/CameraSelector");

  /// The type which includes information such as the signature of this class.
  static const type = $CameraSelectorType();

  /// from: static public final int LENS_FACING_UNKNOWN
  static const LENS_FACING_UNKNOWN = -1;

  /// from: static public final int LENS_FACING_FRONT
  static const LENS_FACING_FRONT = 0;

  /// from: static public final int LENS_FACING_BACK
  static const LENS_FACING_BACK = 1;

  /// from: static public final int LENS_FACING_EXTERNAL
  static const LENS_FACING_EXTERNAL = 2;
  static final _id_DEFAULT_FRONT_CAMERA = _class.staticFieldId(
    r"DEFAULT_FRONT_CAMERA",
    r"Landroidx/camera/core/CameraSelector;",
  );

  /// from: static public final androidx.camera.core.CameraSelector DEFAULT_FRONT_CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static CameraSelector get DEFAULT_FRONT_CAMERA =>
      _id_DEFAULT_FRONT_CAMERA.get(_class, const $CameraSelectorType());

  static final _id_DEFAULT_BACK_CAMERA = _class.staticFieldId(
    r"DEFAULT_BACK_CAMERA",
    r"Landroidx/camera/core/CameraSelector;",
  );

  /// from: static public final androidx.camera.core.CameraSelector DEFAULT_BACK_CAMERA
  /// The returned object must be released after use, by calling the [release] method.
  static CameraSelector get DEFAULT_BACK_CAMERA =>
      _id_DEFAULT_BACK_CAMERA.get(_class, const $CameraSelectorType());

  static final _id_select = _class.instanceMethodId(
    r"select",
    r"(Ljava/util/LinkedHashSet;)Landroidx/camera/core/impl/CameraInternal;",
  );

  static final _select = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.core.impl.CameraInternal select(java.util.LinkedHashSet linkedHashSet)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject select(
    jni.JObject linkedHashSet,
  ) {
    return _select(reference.pointer, _id_select as jni.JMethodIDPtr,
            linkedHashSet.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_filter = _class.instanceMethodId(
    r"filter",
    r"(Ljava/util/List;)Ljava/util/List;",
  );

  static final _filter = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List filter(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> filter(
    jni.JList<jni.JObject> list,
  ) {
    return _filter(reference.pointer, _id_filter as jni.JMethodIDPtr,
            list.reference.pointer)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_filter1 = _class.instanceMethodId(
    r"filter",
    r"(Ljava/util/LinkedHashSet;)Ljava/util/LinkedHashSet;",
  );

  static final _filter1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.LinkedHashSet filter(java.util.LinkedHashSet linkedHashSet)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject filter1(
    jni.JObject linkedHashSet,
  ) {
    return _filter1(reference.pointer, _id_filter1 as jni.JMethodIDPtr,
            linkedHashSet.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getCameraFilterSet = _class.instanceMethodId(
    r"getCameraFilterSet",
    r"()Ljava/util/LinkedHashSet;",
  );

  static final _getCameraFilterSet = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.LinkedHashSet getCameraFilterSet()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCameraFilterSet() {
    return _getCameraFilterSet(
            reference.pointer, _id_getCameraFilterSet as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getLensFacing = _class.instanceMethodId(
    r"getLensFacing",
    r"()Ljava/lang/Integer;",
  );

  static final _getLensFacing = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Integer getLensFacing()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger getLensFacing() {
    return _getLensFacing(
            reference.pointer, _id_getLensFacing as jni.JMethodIDPtr)
        .object(const jni.JIntegerType());
  }
}

final class $CameraSelectorType extends jni.JObjType<CameraSelector> {
  const $CameraSelectorType();

  @override
  String get signature => r"Landroidx/camera/core/CameraSelector;";

  @override
  CameraSelector fromReference(jni.JReference reference) =>
      CameraSelector.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraSelectorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraSelectorType) &&
        other is $CameraSelectorType;
  }
}

/// from: androidx.camera.core.ZoomState
class ZoomState extends jni.JObject {
  @override
  late final jni.JObjType<ZoomState> $type = type;

  ZoomState.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"androidx/camera/core/ZoomState");

  /// The type which includes information such as the signature of this class.
  static const type = $ZoomStateType();
  static final _id_getZoomRatio = _class.instanceMethodId(
    r"getZoomRatio",
    r"()F",
  );

  static final _getZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallFloatMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract float getZoomRatio()
  double getZoomRatio() {
    return _getZoomRatio(
            reference.pointer, _id_getZoomRatio as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getMaxZoomRatio = _class.instanceMethodId(
    r"getMaxZoomRatio",
    r"()F",
  );

  static final _getMaxZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallFloatMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract float getMaxZoomRatio()
  double getMaxZoomRatio() {
    return _getMaxZoomRatio(
            reference.pointer, _id_getMaxZoomRatio as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getMinZoomRatio = _class.instanceMethodId(
    r"getMinZoomRatio",
    r"()F",
  );

  static final _getMinZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallFloatMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract float getMinZoomRatio()
  double getMinZoomRatio() {
    return _getMinZoomRatio(
            reference.pointer, _id_getMinZoomRatio as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getLinearZoom = _class.instanceMethodId(
    r"getLinearZoom",
    r"()F",
  );

  static final _getLinearZoom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallFloatMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract float getLinearZoom()
  double getLinearZoom() {
    return _getLinearZoom(
            reference.pointer, _id_getLinearZoom as jni.JMethodIDPtr)
        .float;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ZoomStateImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"getZoomRatio()F") {
        final $r = _$impls[$p]!.getZoomRatio();
        return jni.JFloat($r).reference.toPointer();
      }
      if ($d == r"getMaxZoomRatio()F") {
        final $r = _$impls[$p]!.getMaxZoomRatio();
        return jni.JFloat($r).reference.toPointer();
      }
      if ($d == r"getMinZoomRatio()F") {
        final $r = _$impls[$p]!.getMinZoomRatio();
        return jni.JFloat($r).reference.toPointer();
      }
      if ($d == r"getLinearZoom()F") {
        final $r = _$impls[$p]!.getLinearZoom();
        return jni.JFloat($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory ZoomState.implement(
    $ZoomStateImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ZoomState.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"androidx.camera.core.ZoomState",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ZoomStateImpl {
  factory $ZoomStateImpl({
    required double Function() getZoomRatio,
    required double Function() getMaxZoomRatio,
    required double Function() getMinZoomRatio,
    required double Function() getLinearZoom,
  }) = _$ZoomStateImpl;

  double getZoomRatio();
  double getMaxZoomRatio();
  double getMinZoomRatio();
  double getLinearZoom();
}

class _$ZoomStateImpl implements $ZoomStateImpl {
  _$ZoomStateImpl({
    required double Function() getZoomRatio,
    required double Function() getMaxZoomRatio,
    required double Function() getMinZoomRatio,
    required double Function() getLinearZoom,
  })  : _getZoomRatio = getZoomRatio,
        _getMaxZoomRatio = getMaxZoomRatio,
        _getMinZoomRatio = getMinZoomRatio,
        _getLinearZoom = getLinearZoom;

  final double Function() _getZoomRatio;
  final double Function() _getMaxZoomRatio;
  final double Function() _getMinZoomRatio;
  final double Function() _getLinearZoom;

  double getZoomRatio() {
    return _getZoomRatio();
  }

  double getMaxZoomRatio() {
    return _getMaxZoomRatio();
  }

  double getMinZoomRatio() {
    return _getMinZoomRatio();
  }

  double getLinearZoom() {
    return _getLinearZoom();
  }
}

final class $ZoomStateType extends jni.JObjType<ZoomState> {
  const $ZoomStateType();

  @override
  String get signature => r"Landroidx/camera/core/ZoomState;";

  @override
  ZoomState fromReference(jni.JReference reference) =>
      ZoomState.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZoomStateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoomStateType) && other is $ZoomStateType;
  }
}

/// from: androidx.camera.view.CameraController$OutputSize$OutputAspectRatio
class CameraController_OutputSize_OutputAspectRatio extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_OutputSize_OutputAspectRatio> $type =
      type;

  CameraController_OutputSize_OutputAspectRatio.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"androidx/camera/view/CameraController$OutputSize$OutputAspectRatio");

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_OutputSize_OutputAspectRatioType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CameraController_OutputSize_OutputAspectRatioImpl>
      _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory CameraController_OutputSize_OutputAspectRatio.implement(
    $CameraController_OutputSize_OutputAspectRatioImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = CameraController_OutputSize_OutputAspectRatio.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"androidx.camera.view.CameraController$OutputSize$OutputAspectRatio",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CameraController_OutputSize_OutputAspectRatioImpl {
  factory $CameraController_OutputSize_OutputAspectRatioImpl() =
      _$CameraController_OutputSize_OutputAspectRatioImpl;
}

class _$CameraController_OutputSize_OutputAspectRatioImpl
    implements $CameraController_OutputSize_OutputAspectRatioImpl {
  _$CameraController_OutputSize_OutputAspectRatioImpl();
}

final class $CameraController_OutputSize_OutputAspectRatioType
    extends jni.JObjType<CameraController_OutputSize_OutputAspectRatio> {
  const $CameraController_OutputSize_OutputAspectRatioType();

  @override
  String get signature =>
      r"Landroidx/camera/view/CameraController$OutputSize$OutputAspectRatio;";

  @override
  CameraController_OutputSize_OutputAspectRatio fromReference(
          jni.JReference reference) =>
      CameraController_OutputSize_OutputAspectRatio.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($CameraController_OutputSize_OutputAspectRatioType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($CameraController_OutputSize_OutputAspectRatioType) &&
        other is $CameraController_OutputSize_OutputAspectRatioType;
  }
}

/// from: androidx.camera.view.CameraController$OutputSize
class CameraController_OutputSize extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_OutputSize> $type = type;

  CameraController_OutputSize.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/view/CameraController$OutputSize");

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_OutputSizeType();

  /// from: static public final int UNASSIGNED_ASPECT_RATIO
  static const UNASSIGNED_ASPECT_RATIO = -1;
  static final _id_new0 = _class.constructorId(
    r"(I)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void <init>(int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraController_OutputSize(
    int i,
  ) {
    return CameraController_OutputSize.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr, i)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"(Landroid/util/Size;)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.util.Size size)
  /// The returned object must be released after use, by calling the [release] method.
  factory CameraController_OutputSize.new1(
    jni.JObject size,
  ) {
    return CameraController_OutputSize.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            size.reference.pointer)
        .reference);
  }

  static final _id_getAspectRatio = _class.instanceMethodId(
    r"getAspectRatio",
    r"()I",
  );

  static final _getAspectRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getAspectRatio()
  int getAspectRatio() {
    return _getAspectRatio(
            reference.pointer, _id_getAspectRatio as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getResolution = _class.instanceMethodId(
    r"getResolution",
    r"()Landroid/util/Size;",
  );

  static final _getResolution = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.util.Size getResolution()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getResolution() {
    return _getResolution(
            reference.pointer, _id_getResolution as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r"toString",
    r"()Ljava/lang/String;",
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $CameraController_OutputSizeType
    extends jni.JObjType<CameraController_OutputSize> {
  const $CameraController_OutputSizeType();

  @override
  String get signature => r"Landroidx/camera/view/CameraController$OutputSize;";

  @override
  CameraController_OutputSize fromReference(jni.JReference reference) =>
      CameraController_OutputSize.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraController_OutputSizeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController_OutputSizeType) &&
        other is $CameraController_OutputSizeType;
  }
}

/// from: androidx.camera.view.CameraController$UseCases
class CameraController_UseCases extends jni.JObject {
  @override
  late final jni.JObjType<CameraController_UseCases> $type = type;

  CameraController_UseCases.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/view/CameraController$UseCases");

  /// The type which includes information such as the signature of this class.
  static const type = $CameraController_UseCasesType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CameraController_UseCasesImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory CameraController_UseCases.implement(
    $CameraController_UseCasesImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = CameraController_UseCases.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"androidx.camera.view.CameraController$UseCases",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CameraController_UseCasesImpl {
  factory $CameraController_UseCasesImpl() = _$CameraController_UseCasesImpl;
}

class _$CameraController_UseCasesImpl
    implements $CameraController_UseCasesImpl {
  _$CameraController_UseCasesImpl();
}

final class $CameraController_UseCasesType
    extends jni.JObjType<CameraController_UseCases> {
  const $CameraController_UseCasesType();

  @override
  String get signature => r"Landroidx/camera/view/CameraController$UseCases;";

  @override
  CameraController_UseCases fromReference(jni.JReference reference) =>
      CameraController_UseCases.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraController_UseCasesType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraController_UseCasesType) &&
        other is $CameraController_UseCasesType;
  }
}

/// from: androidx.camera.view.CameraController
class CameraController extends jni.JObject {
  @override
  late final jni.JObjType<CameraController> $type = type;

  CameraController.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/view/CameraController");

  /// The type which includes information such as the signature of this class.
  static const type = $CameraControllerType();

  /// from: static public final int COORDINATE_SYSTEM_VIEW_REFERENCED
  static const COORDINATE_SYSTEM_VIEW_REFERENCED = 1;

  /// from: static public final int TAP_TO_FOCUS_NOT_STARTED
  static const TAP_TO_FOCUS_NOT_STARTED = 0;

  /// from: static public final int TAP_TO_FOCUS_STARTED
  static const TAP_TO_FOCUS_STARTED = 1;

  /// from: static public final int TAP_TO_FOCUS_FOCUSED
  static const TAP_TO_FOCUS_FOCUSED = 2;

  /// from: static public final int TAP_TO_FOCUS_NOT_FOCUSED
  static const TAP_TO_FOCUS_NOT_FOCUSED = 3;

  /// from: static public final int TAP_TO_FOCUS_FAILED
  static const TAP_TO_FOCUS_FAILED = 4;

  /// from: static public final int IMAGE_CAPTURE
  static const IMAGE_CAPTURE = 1;

  /// from: static public final int IMAGE_ANALYSIS
  static const IMAGE_ANALYSIS = 2;

  /// from: static public final int VIDEO_CAPTURE
  static const VIDEO_CAPTURE = 4;
  static final _id_getInitializationFuture = _class.instanceMethodId(
    r"getInitializationFuture",
    r"()Lcom/google/common/util/concurrent/ListenableFuture;",
  );

  static final _getInitializationFuture = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.google.common.util.concurrent.ListenableFuture getInitializationFuture()
  /// The returned object must be released after use, by calling the [release] method.
  ListenableFuture<jni.JObject> getInitializationFuture() {
    return _getInitializationFuture(
            reference.pointer, _id_getInitializationFuture as jni.JMethodIDPtr)
        .object(const $ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setEnabledUseCases = _class.instanceMethodId(
    r"setEnabledUseCases",
    r"(I)V",
  );

  static final _setEnabledUseCases = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setEnabledUseCases(int i)
  void setEnabledUseCases(
    int i,
  ) {
    _setEnabledUseCases(
            reference.pointer, _id_setEnabledUseCases as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setPreviewTargetSize = _class.instanceMethodId(
    r"setPreviewTargetSize",
    r"(Landroidx/camera/view/CameraController$OutputSize;)V",
  );

  static final _setPreviewTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setPreviewTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setPreviewTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setPreviewTargetSize(
            reference.pointer,
            _id_setPreviewTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getPreviewTargetSize = _class.instanceMethodId(
    r"getPreviewTargetSize",
    r"()Landroidx/camera/view/CameraController$OutputSize;",
  );

  static final _getPreviewTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getPreviewTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getPreviewTargetSize() {
    return _getPreviewTargetSize(
            reference.pointer, _id_getPreviewTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_isImageCaptureEnabled = _class.instanceMethodId(
    r"isImageCaptureEnabled",
    r"()Z",
  );

  static final _isImageCaptureEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isImageCaptureEnabled()
  bool isImageCaptureEnabled() {
    return _isImageCaptureEnabled(
            reference.pointer, _id_isImageCaptureEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getImageCaptureFlashMode = _class.instanceMethodId(
    r"getImageCaptureFlashMode",
    r"()I",
  );

  static final _getImageCaptureFlashMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageCaptureFlashMode()
  int getImageCaptureFlashMode() {
    return _getImageCaptureFlashMode(
            reference.pointer, _id_getImageCaptureFlashMode as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageCaptureFlashMode = _class.instanceMethodId(
    r"setImageCaptureFlashMode",
    r"(I)V",
  );

  static final _setImageCaptureFlashMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageCaptureFlashMode(int i)
  void setImageCaptureFlashMode(
    int i,
  ) {
    _setImageCaptureFlashMode(reference.pointer,
            _id_setImageCaptureFlashMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_takePicture = _class.instanceMethodId(
    r"takePicture",
    r"(Landroidx/camera/core/ImageCapture$OutputFileOptions;Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageSavedCallback;)V",
  );

  static final _takePicture = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void takePicture(androidx.camera.core.ImageCapture$OutputFileOptions outputFileOptions, java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageSavedCallback onImageSavedCallback)
  void takePicture(
    jni.JObject outputFileOptions,
    jni.JObject executor,
    jni.JObject onImageSavedCallback,
  ) {
    _takePicture(
            reference.pointer,
            _id_takePicture as jni.JMethodIDPtr,
            outputFileOptions.reference.pointer,
            executor.reference.pointer,
            onImageSavedCallback.reference.pointer)
        .check();
  }

  static final _id_takePicture1 = _class.instanceMethodId(
    r"takePicture",
    r"(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageCapturedCallback;)V",
  );

  static final _takePicture1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void takePicture(java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageCapturedCallback onImageCapturedCallback)
  void takePicture1(
    jni.JObject executor,
    jni.JObject onImageCapturedCallback,
  ) {
    _takePicture1(
            reference.pointer,
            _id_takePicture1 as jni.JMethodIDPtr,
            executor.reference.pointer,
            onImageCapturedCallback.reference.pointer)
        .check();
  }

  static final _id_setImageCaptureMode = _class.instanceMethodId(
    r"setImageCaptureMode",
    r"(I)V",
  );

  static final _setImageCaptureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageCaptureMode(int i)
  void setImageCaptureMode(
    int i,
  ) {
    _setImageCaptureMode(
            reference.pointer, _id_setImageCaptureMode as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getImageCaptureMode = _class.instanceMethodId(
    r"getImageCaptureMode",
    r"()I",
  );

  static final _getImageCaptureMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageCaptureMode()
  int getImageCaptureMode() {
    return _getImageCaptureMode(
            reference.pointer, _id_getImageCaptureMode as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageCaptureTargetSize = _class.instanceMethodId(
    r"setImageCaptureTargetSize",
    r"(Landroidx/camera/view/CameraController$OutputSize;)V",
  );

  static final _setImageCaptureTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageCaptureTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setImageCaptureTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setImageCaptureTargetSize(
            reference.pointer,
            _id_setImageCaptureTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getImageCaptureTargetSize = _class.instanceMethodId(
    r"getImageCaptureTargetSize",
    r"()Landroidx/camera/view/CameraController$OutputSize;",
  );

  static final _getImageCaptureTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getImageCaptureTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getImageCaptureTargetSize() {
    return _getImageCaptureTargetSize(reference.pointer,
            _id_getImageCaptureTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_setImageCaptureIoExecutor = _class.instanceMethodId(
    r"setImageCaptureIoExecutor",
    r"(Ljava/util/concurrent/Executor;)V",
  );

  static final _setImageCaptureIoExecutor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageCaptureIoExecutor(java.util.concurrent.Executor executor)
  void setImageCaptureIoExecutor(
    jni.JObject executor,
  ) {
    _setImageCaptureIoExecutor(
            reference.pointer,
            _id_setImageCaptureIoExecutor as jni.JMethodIDPtr,
            executor.reference.pointer)
        .check();
  }

  static final _id_getImageCaptureIoExecutor = _class.instanceMethodId(
    r"getImageCaptureIoExecutor",
    r"()Ljava/util/concurrent/Executor;",
  );

  static final _getImageCaptureIoExecutor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.concurrent.Executor getImageCaptureIoExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getImageCaptureIoExecutor() {
    return _getImageCaptureIoExecutor(reference.pointer,
            _id_getImageCaptureIoExecutor as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_isImageAnalysisEnabled = _class.instanceMethodId(
    r"isImageAnalysisEnabled",
    r"()Z",
  );

  static final _isImageAnalysisEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isImageAnalysisEnabled()
  bool isImageAnalysisEnabled() {
    return _isImageAnalysisEnabled(
            reference.pointer, _id_isImageAnalysisEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setImageAnalysisAnalyzer = _class.instanceMethodId(
    r"setImageAnalysisAnalyzer",
    r"(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageAnalysis$Analyzer;)V",
  );

  static final _setImageAnalysisAnalyzer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisAnalyzer(java.util.concurrent.Executor executor, androidx.camera.core.ImageAnalysis$Analyzer analyzer)
  void setImageAnalysisAnalyzer(
    jni.JObject executor,
    jni.JObject analyzer,
  ) {
    _setImageAnalysisAnalyzer(
            reference.pointer,
            _id_setImageAnalysisAnalyzer as jni.JMethodIDPtr,
            executor.reference.pointer,
            analyzer.reference.pointer)
        .check();
  }

  static final _id_clearImageAnalysisAnalyzer = _class.instanceMethodId(
    r"clearImageAnalysisAnalyzer",
    r"()V",
  );

  static final _clearImageAnalysisAnalyzer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void clearImageAnalysisAnalyzer()
  void clearImageAnalysisAnalyzer() {
    _clearImageAnalysisAnalyzer(reference.pointer,
            _id_clearImageAnalysisAnalyzer as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getImageAnalysisBackpressureStrategy =
      _class.instanceMethodId(
    r"getImageAnalysisBackpressureStrategy",
    r"()I",
  );

  static final _getImageAnalysisBackpressureStrategy =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>("globalEnv_CallIntMethod")
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public int getImageAnalysisBackpressureStrategy()
  int getImageAnalysisBackpressureStrategy() {
    return _getImageAnalysisBackpressureStrategy(reference.pointer,
            _id_getImageAnalysisBackpressureStrategy as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageAnalysisBackpressureStrategy =
      _class.instanceMethodId(
    r"setImageAnalysisBackpressureStrategy",
    r"(I)V",
  );

  static final _setImageAnalysisBackpressureStrategy =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallVoidMethod")
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageAnalysisBackpressureStrategy(int i)
  void setImageAnalysisBackpressureStrategy(
    int i,
  ) {
    _setImageAnalysisBackpressureStrategy(reference.pointer,
            _id_setImageAnalysisBackpressureStrategy as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_setImageAnalysisImageQueueDepth = _class.instanceMethodId(
    r"setImageAnalysisImageQueueDepth",
    r"(I)V",
  );

  static final _setImageAnalysisImageQueueDepth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setImageAnalysisImageQueueDepth(int i)
  void setImageAnalysisImageQueueDepth(
    int i,
  ) {
    _setImageAnalysisImageQueueDepth(reference.pointer,
            _id_setImageAnalysisImageQueueDepth as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getImageAnalysisImageQueueDepth = _class.instanceMethodId(
    r"getImageAnalysisImageQueueDepth",
    r"()I",
  );

  static final _getImageAnalysisImageQueueDepth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getImageAnalysisImageQueueDepth()
  int getImageAnalysisImageQueueDepth() {
    return _getImageAnalysisImageQueueDepth(reference.pointer,
            _id_getImageAnalysisImageQueueDepth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setImageAnalysisTargetSize = _class.instanceMethodId(
    r"setImageAnalysisTargetSize",
    r"(Landroidx/camera/view/CameraController$OutputSize;)V",
  );

  static final _setImageAnalysisTargetSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisTargetSize(androidx.camera.view.CameraController$OutputSize outputSize)
  void setImageAnalysisTargetSize(
    CameraController_OutputSize outputSize,
  ) {
    _setImageAnalysisTargetSize(
            reference.pointer,
            _id_setImageAnalysisTargetSize as jni.JMethodIDPtr,
            outputSize.reference.pointer)
        .check();
  }

  static final _id_getImageAnalysisTargetSize = _class.instanceMethodId(
    r"getImageAnalysisTargetSize",
    r"()Landroidx/camera/view/CameraController$OutputSize;",
  );

  static final _getImageAnalysisTargetSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController$OutputSize getImageAnalysisTargetSize()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController_OutputSize getImageAnalysisTargetSize() {
    return _getImageAnalysisTargetSize(reference.pointer,
            _id_getImageAnalysisTargetSize as jni.JMethodIDPtr)
        .object(const $CameraController_OutputSizeType());
  }

  static final _id_setImageAnalysisBackgroundExecutor = _class.instanceMethodId(
    r"setImageAnalysisBackgroundExecutor",
    r"(Ljava/util/concurrent/Executor;)V",
  );

  static final _setImageAnalysisBackgroundExecutor =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              "globalEnv_CallVoidMethod")
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public void setImageAnalysisBackgroundExecutor(java.util.concurrent.Executor executor)
  void setImageAnalysisBackgroundExecutor(
    jni.JObject executor,
  ) {
    _setImageAnalysisBackgroundExecutor(
            reference.pointer,
            _id_setImageAnalysisBackgroundExecutor as jni.JMethodIDPtr,
            executor.reference.pointer)
        .check();
  }

  static final _id_getImageAnalysisBackgroundExecutor = _class.instanceMethodId(
    r"getImageAnalysisBackgroundExecutor",
    r"()Ljava/util/concurrent/Executor;",
  );

  static final _getImageAnalysisBackgroundExecutor =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>("globalEnv_CallObjectMethod")
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: public java.util.concurrent.Executor getImageAnalysisBackgroundExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getImageAnalysisBackgroundExecutor() {
    return _getImageAnalysisBackgroundExecutor(reference.pointer,
            _id_getImageAnalysisBackgroundExecutor as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_isVideoCaptureEnabled = _class.instanceMethodId(
    r"isVideoCaptureEnabled",
    r"()Z",
  );

  static final _isVideoCaptureEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isVideoCaptureEnabled()
  bool isVideoCaptureEnabled() {
    return _isVideoCaptureEnabled(
            reference.pointer, _id_isVideoCaptureEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_startRecording = _class.instanceMethodId(
    r"startRecording",
    r"(Landroidx/camera/video/FileOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;",
  );

  static final _startRecording = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.FileOutputOptions fileOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startRecording(
    jni.JObject fileOutputOptions,
    jni.JObject audioConfig,
    jni.JObject executor,
    jni.JObject consumer,
  ) {
    return _startRecording(
            reference.pointer,
            _id_startRecording as jni.JMethodIDPtr,
            fileOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_startRecording1 = _class.instanceMethodId(
    r"startRecording",
    r"(Landroidx/camera/video/FileDescriptorOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;",
  );

  static final _startRecording1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.FileDescriptorOutputOptions fileDescriptorOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startRecording1(
    jni.JObject fileDescriptorOutputOptions,
    jni.JObject audioConfig,
    jni.JObject executor,
    jni.JObject consumer,
  ) {
    return _startRecording1(
            reference.pointer,
            _id_startRecording1 as jni.JMethodIDPtr,
            fileDescriptorOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_startRecording2 = _class.instanceMethodId(
    r"startRecording",
    r"(Landroidx/camera/video/MediaStoreOutputOptions;Landroidx/camera/view/video/AudioConfig;Ljava/util/concurrent/Executor;Landroidx/core/util/Consumer;)Landroidx/camera/video/Recording;",
  );

  static final _startRecording2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public androidx.camera.video.Recording startRecording(androidx.camera.video.MediaStoreOutputOptions mediaStoreOutputOptions, androidx.camera.view.video.AudioConfig audioConfig, java.util.concurrent.Executor executor, androidx.core.util.Consumer consumer)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject startRecording2(
    jni.JObject mediaStoreOutputOptions,
    jni.JObject audioConfig,
    jni.JObject executor,
    jni.JObject consumer,
  ) {
    return _startRecording2(
            reference.pointer,
            _id_startRecording2 as jni.JMethodIDPtr,
            mediaStoreOutputOptions.reference.pointer,
            audioConfig.reference.pointer,
            executor.reference.pointer,
            consumer.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_isRecording = _class.instanceMethodId(
    r"isRecording",
    r"()Z",
  );

  static final _isRecording = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isRecording()
  bool isRecording() {
    return _isRecording(reference.pointer, _id_isRecording as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setVideoCaptureQualitySelector = _class.instanceMethodId(
    r"setVideoCaptureQualitySelector",
    r"(Landroidx/camera/video/QualitySelector;)V",
  );

  static final _setVideoCaptureQualitySelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setVideoCaptureQualitySelector(androidx.camera.video.QualitySelector qualitySelector)
  void setVideoCaptureQualitySelector(
    jni.JObject qualitySelector,
  ) {
    _setVideoCaptureQualitySelector(
            reference.pointer,
            _id_setVideoCaptureQualitySelector as jni.JMethodIDPtr,
            qualitySelector.reference.pointer)
        .check();
  }

  static final _id_getVideoCaptureQualitySelector = _class.instanceMethodId(
    r"getVideoCaptureQualitySelector",
    r"()Landroidx/camera/video/QualitySelector;",
  );

  static final _getVideoCaptureQualitySelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.video.QualitySelector getVideoCaptureQualitySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getVideoCaptureQualitySelector() {
    return _getVideoCaptureQualitySelector(reference.pointer,
            _id_getVideoCaptureQualitySelector as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setCameraSelector = _class.instanceMethodId(
    r"setCameraSelector",
    r"(Landroidx/camera/core/CameraSelector;)V",
  );

  static final _setCameraSelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setCameraSelector(androidx.camera.core.CameraSelector cameraSelector)
  void setCameraSelector(
    CameraSelector cameraSelector,
  ) {
    _setCameraSelector(
            reference.pointer,
            _id_setCameraSelector as jni.JMethodIDPtr,
            cameraSelector.reference.pointer)
        .check();
  }

  static final _id_hasCamera = _class.instanceMethodId(
    r"hasCamera",
    r"(Landroidx/camera/core/CameraSelector;)Z",
  );

  static final _hasCamera = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasCamera(androidx.camera.core.CameraSelector cameraSelector)
  bool hasCamera(
    CameraSelector cameraSelector,
  ) {
    return _hasCamera(reference.pointer, _id_hasCamera as jni.JMethodIDPtr,
            cameraSelector.reference.pointer)
        .boolean;
  }

  static final _id_getCameraSelector = _class.instanceMethodId(
    r"getCameraSelector",
    r"()Landroidx/camera/core/CameraSelector;",
  );

  static final _getCameraSelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraSelector getCameraSelector()
  /// The returned object must be released after use, by calling the [release] method.
  CameraSelector getCameraSelector() {
    return _getCameraSelector(
            reference.pointer, _id_getCameraSelector as jni.JMethodIDPtr)
        .object(const $CameraSelectorType());
  }

  static final _id_isPinchToZoomEnabled = _class.instanceMethodId(
    r"isPinchToZoomEnabled",
    r"()Z",
  );

  static final _isPinchToZoomEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isPinchToZoomEnabled()
  bool isPinchToZoomEnabled() {
    return _isPinchToZoomEnabled(
            reference.pointer, _id_isPinchToZoomEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPinchToZoomEnabled = _class.instanceMethodId(
    r"setPinchToZoomEnabled",
    r"(Z)V",
  );

  static final _setPinchToZoomEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Uint8,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setPinchToZoomEnabled(boolean z)
  void setPinchToZoomEnabled(
    bool z,
  ) {
    _setPinchToZoomEnabled(reference.pointer,
            _id_setPinchToZoomEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isTapToFocusEnabled = _class.instanceMethodId(
    r"isTapToFocusEnabled",
    r"()Z",
  );

  static final _isTapToFocusEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isTapToFocusEnabled()
  bool isTapToFocusEnabled() {
    return _isTapToFocusEnabled(
            reference.pointer, _id_isTapToFocusEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setTapToFocusEnabled = _class.instanceMethodId(
    r"setTapToFocusEnabled",
    r"(Z)V",
  );

  static final _setTapToFocusEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Uint8,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setTapToFocusEnabled(boolean z)
  void setTapToFocusEnabled(
    bool z,
  ) {
    _setTapToFocusEnabled(reference.pointer,
            _id_setTapToFocusEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getTapToFocusState = _class.instanceMethodId(
    r"getTapToFocusState",
    r"()Landroidx/lifecycle/LiveData;",
  );

  static final _getTapToFocusState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getTapToFocusState()
  /// The returned object must be released after use, by calling the [release] method.
  LiveData<jni.JInteger> getTapToFocusState() {
    return _getTapToFocusState(
            reference.pointer, _id_getTapToFocusState as jni.JMethodIDPtr)
        .object(const $LiveDataType(jni.JIntegerType()));
  }

  static final _id_getZoomState = _class.instanceMethodId(
    r"getZoomState",
    r"()Landroidx/lifecycle/LiveData;",
  );

  static final _getZoomState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getZoomState()
  /// The returned object must be released after use, by calling the [release] method.
  LiveData<ZoomState> getZoomState() {
    return _getZoomState(
            reference.pointer, _id_getZoomState as jni.JMethodIDPtr)
        .object(const $LiveDataType($ZoomStateType()));
  }

  static final _id_getCameraInfo = _class.instanceMethodId(
    r"getCameraInfo",
    r"()Landroidx/camera/core/CameraInfo;",
  );

  static final _getCameraInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraInfo getCameraInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCameraInfo() {
    return _getCameraInfo(
            reference.pointer, _id_getCameraInfo as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getCameraControl = _class.instanceMethodId(
    r"getCameraControl",
    r"()Landroidx/camera/core/CameraControl;",
  );

  static final _getCameraControl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.CameraControl getCameraControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCameraControl() {
    return _getCameraControl(
            reference.pointer, _id_getCameraControl as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setZoomRatio = _class.instanceMethodId(
    r"setZoomRatio",
    r"(F)Lcom/google/common/util/concurrent/ListenableFuture;",
  );

  static final _setZoomRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Float,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture setZoomRatio(float f)
  /// The returned object must be released after use, by calling the [release] method.
  ListenableFuture<jni.JObject> setZoomRatio(
    double f,
  ) {
    return _setZoomRatio(
            reference.pointer, _id_setZoomRatio as jni.JMethodIDPtr, f)
        .object(const $ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setLinearZoom = _class.instanceMethodId(
    r"setLinearZoom",
    r"(F)Lcom/google/common/util/concurrent/ListenableFuture;",
  );

  static final _setLinearZoom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Float,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture setLinearZoom(float f)
  /// The returned object must be released after use, by calling the [release] method.
  ListenableFuture<jni.JObject> setLinearZoom(
    double f,
  ) {
    return _setLinearZoom(
            reference.pointer, _id_setLinearZoom as jni.JMethodIDPtr, f)
        .object(const $ListenableFutureType(jni.JObjectType()));
  }

  static final _id_getTorchState = _class.instanceMethodId(
    r"getTorchState",
    r"()Landroidx/lifecycle/LiveData;",
  );

  static final _getTorchState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getTorchState()
  /// The returned object must be released after use, by calling the [release] method.
  LiveData<jni.JInteger> getTorchState() {
    return _getTorchState(
            reference.pointer, _id_getTorchState as jni.JMethodIDPtr)
        .object(const $LiveDataType(jni.JIntegerType()));
  }

  static final _id_enableTorch = _class.instanceMethodId(
    r"enableTorch",
    r"(Z)Lcom/google/common/util/concurrent/ListenableFuture;",
  );

  static final _enableTorch = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Uint8,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public com.google.common.util.concurrent.ListenableFuture enableTorch(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  ListenableFuture<jni.JObject> enableTorch(
    bool z,
  ) {
    return _enableTorch(
            reference.pointer, _id_enableTorch as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $ListenableFutureType(jni.JObjectType()));
  }

  static final _id_setEffects = _class.instanceMethodId(
    r"setEffects",
    r"(Ljava/util/Set;)V",
  );

  static final _setEffects = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setEffects(java.util.Set set)
  void setEffects(
    jni.JSet<jni.JObject> set0,
  ) {
    _setEffects(reference.pointer, _id_setEffects as jni.JMethodIDPtr,
            set0.reference.pointer)
        .check();
  }

  static final _id_clearEffects = _class.instanceMethodId(
    r"clearEffects",
    r"()V",
  );

  static final _clearEffects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void clearEffects()
  void clearEffects() {
    _clearEffects(reference.pointer, _id_clearEffects as jni.JMethodIDPtr)
        .check();
  }

  static final _id_createUseCaseGroup = _class.instanceMethodId(
    r"createUseCaseGroup",
    r"()Landroidx/camera/core/UseCaseGroup;",
  );

  static final _createUseCaseGroup = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected androidx.camera.core.UseCaseGroup createUseCaseGroup()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createUseCaseGroup() {
    return _createUseCaseGroup(
            reference.pointer, _id_createUseCaseGroup as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $CameraControllerType extends jni.JObjType<CameraController> {
  const $CameraControllerType();

  @override
  String get signature => r"Landroidx/camera/view/CameraController;";

  @override
  CameraController fromReference(jni.JReference reference) =>
      CameraController.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CameraControllerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CameraControllerType) &&
        other is $CameraControllerType;
  }
}

/// from: androidx.camera.view.LifecycleCameraController
class LifecycleCameraController extends CameraController {
  @override
  late final jni.JObjType<LifecycleCameraController> $type = type;

  LifecycleCameraController.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/view/LifecycleCameraController");

  /// The type which includes information such as the signature of this class.
  static const type = $LifecycleCameraControllerType();
  static final _id_new0 = _class.constructorId(
    r"(Landroid/content/Context;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory LifecycleCameraController(
    jni.JObject context,
  ) {
    return LifecycleCameraController.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            context.reference.pointer)
        .reference);
  }

  static final _id_bindToLifecycle = _class.instanceMethodId(
    r"bindToLifecycle",
    r"(Landroidx/lifecycle/LifecycleOwner;)V",
  );

  static final _bindToLifecycle = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void bindToLifecycle(androidx.lifecycle.LifecycleOwner lifecycleOwner)
  void bindToLifecycle(
    LifecycleOwner lifecycleOwner,
  ) {
    _bindToLifecycle(reference.pointer, _id_bindToLifecycle as jni.JMethodIDPtr,
            lifecycleOwner.reference.pointer)
        .check();
  }

  static final _id_unbind = _class.instanceMethodId(
    r"unbind",
    r"()V",
  );

  static final _unbind = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void unbind()
  void unbind() {
    _unbind(reference.pointer, _id_unbind as jni.JMethodIDPtr).check();
  }
}

final class $LifecycleCameraControllerType
    extends jni.JObjType<LifecycleCameraController> {
  const $LifecycleCameraControllerType();

  @override
  String get signature => r"Landroidx/camera/view/LifecycleCameraController;";

  @override
  LifecycleCameraController fromReference(jni.JReference reference) =>
      LifecycleCameraController.fromReference(reference);

  @override
  jni.JObjType get superType => const $CameraControllerType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($LifecycleCameraControllerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($LifecycleCameraControllerType) &&
        other is $LifecycleCameraControllerType;
  }
}

/// from: androidx.camera.view.PreviewView$ImplementationMode
class PreviewView_ImplementationMode extends jni.JObject {
  @override
  late final jni.JObjType<PreviewView_ImplementationMode> $type = type;

  PreviewView_ImplementationMode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"androidx/camera/view/PreviewView$ImplementationMode");

  /// The type which includes information such as the signature of this class.
  static const type = $PreviewView_ImplementationModeType();
  static final _id_PERFORMANCE = _class.staticFieldId(
    r"PERFORMANCE",
    r"Landroidx/camera/view/PreviewView$ImplementationMode;",
  );

  /// from: static public final androidx.camera.view.PreviewView$ImplementationMode PERFORMANCE
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ImplementationMode get PERFORMANCE =>
      _id_PERFORMANCE.get(_class, const $PreviewView_ImplementationModeType());

  static final _id_COMPATIBLE = _class.staticFieldId(
    r"COMPATIBLE",
    r"Landroidx/camera/view/PreviewView$ImplementationMode;",
  );

  /// from: static public final androidx.camera.view.PreviewView$ImplementationMode COMPATIBLE
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ImplementationMode get COMPATIBLE =>
      _id_COMPATIBLE.get(_class, const $PreviewView_ImplementationModeType());

  static final _id_values = _class.staticMethodId(
    r"values",
    r"()[Landroidx/camera/view/PreviewView$ImplementationMode;",
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public androidx.camera.view.PreviewView$ImplementationMode[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<PreviewView_ImplementationMode> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($PreviewView_ImplementationModeType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r"valueOf",
    r"(Ljava/lang/String;)Landroidx/camera/view/PreviewView$ImplementationMode;",
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public androidx.camera.view.PreviewView$ImplementationMode valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ImplementationMode valueOf(
    jni.JString string,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $PreviewView_ImplementationModeType());
  }
}

final class $PreviewView_ImplementationModeType
    extends jni.JObjType<PreviewView_ImplementationMode> {
  const $PreviewView_ImplementationModeType();

  @override
  String get signature =>
      r"Landroidx/camera/view/PreviewView$ImplementationMode;";

  @override
  PreviewView_ImplementationMode fromReference(jni.JReference reference) =>
      PreviewView_ImplementationMode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PreviewView_ImplementationModeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PreviewView_ImplementationModeType) &&
        other is $PreviewView_ImplementationModeType;
  }
}

/// from: androidx.camera.view.PreviewView$OnFrameUpdateListener
class PreviewView_OnFrameUpdateListener extends jni.JObject {
  @override
  late final jni.JObjType<PreviewView_OnFrameUpdateListener> $type = type;

  PreviewView_OnFrameUpdateListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"androidx/camera/view/PreviewView$OnFrameUpdateListener");

  /// The type which includes information such as the signature of this class.
  static const type = $PreviewView_OnFrameUpdateListenerType();
  static final _id_onFrameUpdate = _class.instanceMethodId(
    r"onFrameUpdate",
    r"(J)V",
  );

  static final _onFrameUpdate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract void onFrameUpdate(long j)
  void onFrameUpdate(
    int j,
  ) {
    _onFrameUpdate(reference.pointer, _id_onFrameUpdate as jni.JMethodIDPtr, j)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PreviewView_OnFrameUpdateListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFrameUpdate(J)V") {
        _$impls[$p]!.onFrameUpdate(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PreviewView_OnFrameUpdateListener.implement(
    $PreviewView_OnFrameUpdateListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PreviewView_OnFrameUpdateListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"androidx.camera.view.PreviewView$OnFrameUpdateListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $PreviewView_OnFrameUpdateListenerImpl {
  factory $PreviewView_OnFrameUpdateListenerImpl({
    required void Function(int j) onFrameUpdate,
  }) = _$PreviewView_OnFrameUpdateListenerImpl;

  void onFrameUpdate(int j);
}

class _$PreviewView_OnFrameUpdateListenerImpl
    implements $PreviewView_OnFrameUpdateListenerImpl {
  _$PreviewView_OnFrameUpdateListenerImpl({
    required void Function(int j) onFrameUpdate,
  }) : _onFrameUpdate = onFrameUpdate;

  final void Function(int j) _onFrameUpdate;

  void onFrameUpdate(int j) {
    return _onFrameUpdate(j);
  }
}

final class $PreviewView_OnFrameUpdateListenerType
    extends jni.JObjType<PreviewView_OnFrameUpdateListener> {
  const $PreviewView_OnFrameUpdateListenerType();

  @override
  String get signature =>
      r"Landroidx/camera/view/PreviewView$OnFrameUpdateListener;";

  @override
  PreviewView_OnFrameUpdateListener fromReference(jni.JReference reference) =>
      PreviewView_OnFrameUpdateListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PreviewView_OnFrameUpdateListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PreviewView_OnFrameUpdateListenerType) &&
        other is $PreviewView_OnFrameUpdateListenerType;
  }
}

/// from: androidx.camera.view.PreviewView$ScaleType
class PreviewView_ScaleType extends jni.JObject {
  @override
  late final jni.JObjType<PreviewView_ScaleType> $type = type;

  PreviewView_ScaleType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/view/PreviewView$ScaleType");

  /// The type which includes information such as the signature of this class.
  static const type = $PreviewView_ScaleTypeType();
  static final _id_FILL_START = _class.staticFieldId(
    r"FILL_START",
    r"Landroidx/camera/view/PreviewView$ScaleType;",
  );

  /// from: static public final androidx.camera.view.PreviewView$ScaleType FILL_START
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ScaleType get FILL_START =>
      _id_FILL_START.get(_class, const $PreviewView_ScaleTypeType());

  static final _id_FILL_CENTER = _class.staticFieldId(
    r"FILL_CENTER",
    r"Landroidx/camera/view/PreviewView$ScaleType;",
  );

  /// from: static public final androidx.camera.view.PreviewView$ScaleType FILL_CENTER
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ScaleType get FILL_CENTER =>
      _id_FILL_CENTER.get(_class, const $PreviewView_ScaleTypeType());

  static final _id_FILL_END = _class.staticFieldId(
    r"FILL_END",
    r"Landroidx/camera/view/PreviewView$ScaleType;",
  );

  /// from: static public final androidx.camera.view.PreviewView$ScaleType FILL_END
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ScaleType get FILL_END =>
      _id_FILL_END.get(_class, const $PreviewView_ScaleTypeType());

  static final _id_FIT_START = _class.staticFieldId(
    r"FIT_START",
    r"Landroidx/camera/view/PreviewView$ScaleType;",
  );

  /// from: static public final androidx.camera.view.PreviewView$ScaleType FIT_START
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ScaleType get FIT_START =>
      _id_FIT_START.get(_class, const $PreviewView_ScaleTypeType());

  static final _id_FIT_CENTER = _class.staticFieldId(
    r"FIT_CENTER",
    r"Landroidx/camera/view/PreviewView$ScaleType;",
  );

  /// from: static public final androidx.camera.view.PreviewView$ScaleType FIT_CENTER
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ScaleType get FIT_CENTER =>
      _id_FIT_CENTER.get(_class, const $PreviewView_ScaleTypeType());

  static final _id_FIT_END = _class.staticFieldId(
    r"FIT_END",
    r"Landroidx/camera/view/PreviewView$ScaleType;",
  );

  /// from: static public final androidx.camera.view.PreviewView$ScaleType FIT_END
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ScaleType get FIT_END =>
      _id_FIT_END.get(_class, const $PreviewView_ScaleTypeType());

  static final _id_values = _class.staticMethodId(
    r"values",
    r"()[Landroidx/camera/view/PreviewView$ScaleType;",
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public androidx.camera.view.PreviewView$ScaleType[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<PreviewView_ScaleType> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($PreviewView_ScaleTypeType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r"valueOf",
    r"(Ljava/lang/String;)Landroidx/camera/view/PreviewView$ScaleType;",
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public androidx.camera.view.PreviewView$ScaleType valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_ScaleType valueOf(
    jni.JString string,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $PreviewView_ScaleTypeType());
  }
}

final class $PreviewView_ScaleTypeType
    extends jni.JObjType<PreviewView_ScaleType> {
  const $PreviewView_ScaleTypeType();

  @override
  String get signature => r"Landroidx/camera/view/PreviewView$ScaleType;";

  @override
  PreviewView_ScaleType fromReference(jni.JReference reference) =>
      PreviewView_ScaleType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PreviewView_ScaleTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PreviewView_ScaleTypeType) &&
        other is $PreviewView_ScaleTypeType;
  }
}

/// from: androidx.camera.view.PreviewView$StreamState
class PreviewView_StreamState extends jni.JObject {
  @override
  late final jni.JObjType<PreviewView_StreamState> $type = type;

  PreviewView_StreamState.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/camera/view/PreviewView$StreamState");

  /// The type which includes information such as the signature of this class.
  static const type = $PreviewView_StreamStateType();
  static final _id_IDLE = _class.staticFieldId(
    r"IDLE",
    r"Landroidx/camera/view/PreviewView$StreamState;",
  );

  /// from: static public final androidx.camera.view.PreviewView$StreamState IDLE
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_StreamState get IDLE =>
      _id_IDLE.get(_class, const $PreviewView_StreamStateType());

  static final _id_STREAMING = _class.staticFieldId(
    r"STREAMING",
    r"Landroidx/camera/view/PreviewView$StreamState;",
  );

  /// from: static public final androidx.camera.view.PreviewView$StreamState STREAMING
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_StreamState get STREAMING =>
      _id_STREAMING.get(_class, const $PreviewView_StreamStateType());

  static final _id_values = _class.staticMethodId(
    r"values",
    r"()[Landroidx/camera/view/PreviewView$StreamState;",
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public androidx.camera.view.PreviewView$StreamState[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<PreviewView_StreamState> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($PreviewView_StreamStateType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r"valueOf",
    r"(Ljava/lang/String;)Landroidx/camera/view/PreviewView$StreamState;",
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public androidx.camera.view.PreviewView$StreamState valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewView_StreamState valueOf(
    jni.JString string,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $PreviewView_StreamStateType());
  }
}

final class $PreviewView_StreamStateType
    extends jni.JObjType<PreviewView_StreamState> {
  const $PreviewView_StreamStateType();

  @override
  String get signature => r"Landroidx/camera/view/PreviewView$StreamState;";

  @override
  PreviewView_StreamState fromReference(jni.JReference reference) =>
      PreviewView_StreamState.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PreviewView_StreamStateType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PreviewView_StreamStateType) &&
        other is $PreviewView_StreamStateType;
  }
}

/// from: androidx.camera.view.PreviewView
class PreviewView extends jni.JObject {
  @override
  late final jni.JObjType<PreviewView> $type = type;

  PreviewView.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"androidx/camera/view/PreviewView");

  /// The type which includes information such as the signature of this class.
  static const type = $PreviewViewType();
  static final _id_new0 = _class.constructorId(
    r"(Landroid/content/Context;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory PreviewView(
    jni.JObject context,
  ) {
    return PreviewView.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, context.reference.pointer)
        .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet)
  /// The returned object must be released after use, by calling the [release] method.
  factory PreviewView.new1(
    jni.JObject context,
    jni.JObject attributeSet,
  ) {
    return PreviewView.fromReference(_new1(
            _class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr,
            context.reference.pointer,
            attributeSet.reference.pointer)
        .reference);
  }

  static final _id_new2 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;I)V",
  );

  static final _new2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory PreviewView.new2(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
  ) {
    return PreviewView.fromReference(_new2(
            _class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr,
            context.reference.pointer,
            attributeSet.reference.pointer,
            i)
        .reference);
  }

  static final _id_new3 = _class.constructorId(
    r"(Landroid/content/Context;Landroid/util/AttributeSet;II)V",
  );

  static final _new3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Int32
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attributeSet, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory PreviewView.new3(
    jni.JObject context,
    jni.JObject attributeSet,
    int i,
    int i1,
  ) {
    return PreviewView.fromReference(_new3(
            _class.reference.pointer,
            _id_new3 as jni.JMethodIDPtr,
            context.reference.pointer,
            attributeSet.reference.pointer,
            i,
            i1)
        .reference);
  }

  static final _id_onAttachedToWindow = _class.instanceMethodId(
    r"onAttachedToWindow",
    r"()V",
  );

  static final _onAttachedToWindow = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onAttachedToWindow()
  void onAttachedToWindow() {
    _onAttachedToWindow(
            reference.pointer, _id_onAttachedToWindow as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onDetachedFromWindow = _class.instanceMethodId(
    r"onDetachedFromWindow",
    r"()V",
  );

  static final _onDetachedFromWindow = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onDetachedFromWindow()
  void onDetachedFromWindow() {
    _onDetachedFromWindow(
            reference.pointer, _id_onDetachedFromWindow as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r"onTouchEvent",
    r"(Landroid/view/MotionEvent;)Z",
  );

  static final _onTouchEvent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTouchEvent(android.view.MotionEvent motionEvent)
  bool onTouchEvent(
    jni.JObject motionEvent,
  ) {
    return _onTouchEvent(reference.pointer,
            _id_onTouchEvent as jni.JMethodIDPtr, motionEvent.reference.pointer)
        .boolean;
  }

  static final _id_performClick = _class.instanceMethodId(
    r"performClick",
    r"()Z",
  );

  static final _performClick = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean performClick()
  bool performClick() {
    return _performClick(
            reference.pointer, _id_performClick as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setImplementationMode = _class.instanceMethodId(
    r"setImplementationMode",
    r"(Landroidx/camera/view/PreviewView$ImplementationMode;)V",
  );

  static final _setImplementationMode = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setImplementationMode(androidx.camera.view.PreviewView$ImplementationMode implementationMode)
  void setImplementationMode(
    PreviewView_ImplementationMode implementationMode,
  ) {
    _setImplementationMode(
            reference.pointer,
            _id_setImplementationMode as jni.JMethodIDPtr,
            implementationMode.reference.pointer)
        .check();
  }

  static final _id_getImplementationMode = _class.instanceMethodId(
    r"getImplementationMode",
    r"()Landroidx/camera/view/PreviewView$ImplementationMode;",
  );

  static final _getImplementationMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.PreviewView$ImplementationMode getImplementationMode()
  /// The returned object must be released after use, by calling the [release] method.
  PreviewView_ImplementationMode getImplementationMode() {
    return _getImplementationMode(
            reference.pointer, _id_getImplementationMode as jni.JMethodIDPtr)
        .object(const $PreviewView_ImplementationModeType());
  }

  static final _id_getSurfaceProvider = _class.instanceMethodId(
    r"getSurfaceProvider",
    r"()Landroidx/camera/core/Preview$SurfaceProvider;",
  );

  static final _getSurfaceProvider = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.Preview$SurfaceProvider getSurfaceProvider()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSurfaceProvider() {
    return _getSurfaceProvider(
            reference.pointer, _id_getSurfaceProvider as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setScaleType = _class.instanceMethodId(
    r"setScaleType",
    r"(Landroidx/camera/view/PreviewView$ScaleType;)V",
  );

  static final _setScaleType = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setScaleType(androidx.camera.view.PreviewView$ScaleType scaleType)
  void setScaleType(
    PreviewView_ScaleType scaleType,
  ) {
    _setScaleType(reference.pointer, _id_setScaleType as jni.JMethodIDPtr,
            scaleType.reference.pointer)
        .check();
  }

  static final _id_getScaleType = _class.instanceMethodId(
    r"getScaleType",
    r"()Landroidx/camera/view/PreviewView$ScaleType;",
  );

  static final _getScaleType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.PreviewView$ScaleType getScaleType()
  /// The returned object must be released after use, by calling the [release] method.
  PreviewView_ScaleType getScaleType() {
    return _getScaleType(
            reference.pointer, _id_getScaleType as jni.JMethodIDPtr)
        .object(const $PreviewView_ScaleTypeType());
  }

  static final _id_getMeteringPointFactory = _class.instanceMethodId(
    r"getMeteringPointFactory",
    r"()Landroidx/camera/core/MeteringPointFactory;",
  );

  static final _getMeteringPointFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.MeteringPointFactory getMeteringPointFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getMeteringPointFactory() {
    return _getMeteringPointFactory(
            reference.pointer, _id_getMeteringPointFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getPreviewStreamState = _class.instanceMethodId(
    r"getPreviewStreamState",
    r"()Landroidx/lifecycle/LiveData;",
  );

  static final _getPreviewStreamState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.lifecycle.LiveData getPreviewStreamState()
  /// The returned object must be released after use, by calling the [release] method.
  LiveData<PreviewView_StreamState> getPreviewStreamState() {
    return _getPreviewStreamState(
            reference.pointer, _id_getPreviewStreamState as jni.JMethodIDPtr)
        .object(const $LiveDataType($PreviewView_StreamStateType()));
  }

  static final _id_getBitmap = _class.instanceMethodId(
    r"getBitmap",
    r"()Landroid/graphics/Bitmap;",
  );

  static final _getBitmap = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Bitmap getBitmap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBitmap() {
    return _getBitmap(reference.pointer, _id_getBitmap as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getViewPort = _class.instanceMethodId(
    r"getViewPort",
    r"()Landroidx/camera/core/ViewPort;",
  );

  static final _getViewPort = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.core.ViewPort getViewPort()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getViewPort() {
    return _getViewPort(reference.pointer, _id_getViewPort as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getViewPort1 = _class.instanceMethodId(
    r"getViewPort",
    r"(I)Landroidx/camera/core/ViewPort;",
  );

  static final _getViewPort1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public androidx.camera.core.ViewPort getViewPort(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getViewPort1(
    int i,
  ) {
    return _getViewPort1(
            reference.pointer, _id_getViewPort1 as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_setFrameUpdateListener = _class.instanceMethodId(
    r"setFrameUpdateListener",
    r"(Ljava/util/concurrent/Executor;Landroidx/camera/view/PreviewView$OnFrameUpdateListener;)V",
  );

  static final _setFrameUpdateListener = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setFrameUpdateListener(java.util.concurrent.Executor executor, androidx.camera.view.PreviewView$OnFrameUpdateListener onFrameUpdateListener)
  void setFrameUpdateListener(
    jni.JObject executor,
    PreviewView_OnFrameUpdateListener onFrameUpdateListener,
  ) {
    _setFrameUpdateListener(
            reference.pointer,
            _id_setFrameUpdateListener as jni.JMethodIDPtr,
            executor.reference.pointer,
            onFrameUpdateListener.reference.pointer)
        .check();
  }

  static final _id_setController = _class.instanceMethodId(
    r"setController",
    r"(Landroidx/camera/view/CameraController;)V",
  );

  static final _setController = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setController(androidx.camera.view.CameraController cameraController)
  void setController(
    CameraController cameraController,
  ) {
    _setController(reference.pointer, _id_setController as jni.JMethodIDPtr,
            cameraController.reference.pointer)
        .check();
  }

  static final _id_getController = _class.instanceMethodId(
    r"getController",
    r"()Landroidx/camera/view/CameraController;",
  );

  static final _getController = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.CameraController getController()
  /// The returned object must be released after use, by calling the [release] method.
  CameraController getController() {
    return _getController(
            reference.pointer, _id_getController as jni.JMethodIDPtr)
        .object(const $CameraControllerType());
  }

  static final _id_getOutputTransform = _class.instanceMethodId(
    r"getOutputTransform",
    r"()Landroidx/camera/view/transform/OutputTransform;",
  );

  static final _getOutputTransform = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public androidx.camera.view.transform.OutputTransform getOutputTransform()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getOutputTransform() {
    return _getOutputTransform(
            reference.pointer, _id_getOutputTransform as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getSensorToViewTransform = _class.instanceMethodId(
    r"getSensorToViewTransform",
    r"()Landroid/graphics/Matrix;",
  );

  static final _getSensorToViewTransform = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public android.graphics.Matrix getSensorToViewTransform()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getSensorToViewTransform() {
    return _getSensorToViewTransform(
            reference.pointer, _id_getSensorToViewTransform as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $PreviewViewType extends jni.JObjType<PreviewView> {
  const $PreviewViewType();

  @override
  String get signature => r"Landroidx/camera/view/PreviewView;";

  @override
  PreviewView fromReference(jni.JReference reference) =>
      PreviewView.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PreviewViewType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PreviewViewType) && other is $PreviewViewType;
  }
}

/// from: androidx.lifecycle.LifecycleOwner
class LifecycleOwner extends jni.JObject {
  @override
  late final jni.JObjType<LifecycleOwner> $type = type;

  LifecycleOwner.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"androidx/lifecycle/LifecycleOwner");

  /// The type which includes information such as the signature of this class.
  static const type = $LifecycleOwnerType();
  static final _id_getLifecycle = _class.instanceMethodId(
    r"getLifecycle",
    r"()Landroidx/lifecycle/Lifecycle;",
  );

  static final _getLifecycle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract androidx.lifecycle.Lifecycle getLifecycle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLifecycle() {
    return _getLifecycle(
            reference.pointer, _id_getLifecycle as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $LifecycleOwnerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"getLifecycle()Landroidx/lifecycle/Lifecycle;") {
        final $r = _$impls[$p]!.getLifecycle();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory LifecycleOwner.implement(
    $LifecycleOwnerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = LifecycleOwner.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"androidx.lifecycle.LifecycleOwner",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $LifecycleOwnerImpl {
  factory $LifecycleOwnerImpl({
    required jni.JObject Function() getLifecycle,
  }) = _$LifecycleOwnerImpl;

  jni.JObject getLifecycle();
}

class _$LifecycleOwnerImpl implements $LifecycleOwnerImpl {
  _$LifecycleOwnerImpl({
    required jni.JObject Function() getLifecycle,
  }) : _getLifecycle = getLifecycle;

  final jni.JObject Function() _getLifecycle;

  jni.JObject getLifecycle() {
    return _getLifecycle();
  }
}

final class $LifecycleOwnerType extends jni.JObjType<LifecycleOwner> {
  const $LifecycleOwnerType();

  @override
  String get signature => r"Landroidx/lifecycle/LifecycleOwner;";

  @override
  LifecycleOwner fromReference(jni.JReference reference) =>
      LifecycleOwner.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($LifecycleOwnerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($LifecycleOwnerType) &&
        other is $LifecycleOwnerType;
  }
}

/// from: androidx.lifecycle.LiveData
class LiveData<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<LiveData<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  LiveData.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"androidx/lifecycle/LiveData");

  /// The type which includes information such as the signature of this class.
  static $LiveDataType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $LiveDataType(
      T,
    );
  }

  static final _id_new0 = _class.constructorId(
    r"(Ljava/lang/Object;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T object)
  /// The returned object must be released after use, by calling the [release] method.
  factory LiveData(
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return LiveData.fromReference(
        T,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                object.reference.pointer)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"()V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory LiveData.new1({
    required jni.JObjType<$T> T,
  }) {
    return LiveData.fromReference(
        T,
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_observe = _class.instanceMethodId(
    r"observe",
    r"(Landroidx/lifecycle/LifecycleOwner;Landroidx/lifecycle/Observer;)V",
  );

  static final _observe = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void observe(androidx.lifecycle.LifecycleOwner lifecycleOwner, androidx.lifecycle.Observer observer)
  void observe(
    LifecycleOwner lifecycleOwner,
    Observer<$T> observer,
  ) {
    _observe(reference.pointer, _id_observe as jni.JMethodIDPtr,
            lifecycleOwner.reference.pointer, observer.reference.pointer)
        .check();
  }

  static final _id_observeForever = _class.instanceMethodId(
    r"observeForever",
    r"(Landroidx/lifecycle/Observer;)V",
  );

  static final _observeForever = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void observeForever(androidx.lifecycle.Observer observer)
  void observeForever(
    Observer<$T> observer,
  ) {
    _observeForever(reference.pointer, _id_observeForever as jni.JMethodIDPtr,
            observer.reference.pointer)
        .check();
  }

  static final _id_removeObserver = _class.instanceMethodId(
    r"removeObserver",
    r"(Landroidx/lifecycle/Observer;)V",
  );

  static final _removeObserver = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void removeObserver(androidx.lifecycle.Observer observer)
  void removeObserver(
    Observer<$T> observer,
  ) {
    _removeObserver(reference.pointer, _id_removeObserver as jni.JMethodIDPtr,
            observer.reference.pointer)
        .check();
  }

  static final _id_removeObservers = _class.instanceMethodId(
    r"removeObservers",
    r"(Landroidx/lifecycle/LifecycleOwner;)V",
  );

  static final _removeObservers = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void removeObservers(androidx.lifecycle.LifecycleOwner lifecycleOwner)
  void removeObservers(
    LifecycleOwner lifecycleOwner,
  ) {
    _removeObservers(reference.pointer, _id_removeObservers as jni.JMethodIDPtr,
            lifecycleOwner.reference.pointer)
        .check();
  }

  static final _id_postValue = _class.instanceMethodId(
    r"postValue",
    r"(Ljava/lang/Object;)V",
  );

  static final _postValue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void postValue(T object)
  void postValue(
    $T object,
  ) {
    _postValue(reference.pointer, _id_postValue as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  static final _id_setValue = _class.instanceMethodId(
    r"setValue",
    r"(Ljava/lang/Object;)V",
  );

  static final _setValue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void setValue(T object)
  void setValue(
    $T object,
  ) {
    _setValue(reference.pointer, _id_setValue as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  static final _id_getValue = _class.instanceMethodId(
    r"getValue",
    r"()Ljava/lang/Object;",
  );

  static final _getValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public T getValue()
  /// The returned object must be released after use, by calling the [release] method.
  $T getValue() {
    return _getValue(reference.pointer, _id_getValue as jni.JMethodIDPtr)
        .object(T);
  }

  static final _id_onActive = _class.instanceMethodId(
    r"onActive",
    r"()V",
  );

  static final _onActive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onActive()
  void onActive() {
    _onActive(reference.pointer, _id_onActive as jni.JMethodIDPtr).check();
  }

  static final _id_onInactive = _class.instanceMethodId(
    r"onInactive",
    r"()V",
  );

  static final _onInactive = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: protected void onInactive()
  void onInactive() {
    _onInactive(reference.pointer, _id_onInactive as jni.JMethodIDPtr).check();
  }

  static final _id_hasObservers = _class.instanceMethodId(
    r"hasObservers",
    r"()Z",
  );

  static final _hasObservers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean hasObservers()
  bool hasObservers() {
    return _hasObservers(
            reference.pointer, _id_hasObservers as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_hasActiveObservers = _class.instanceMethodId(
    r"hasActiveObservers",
    r"()Z",
  );

  static final _hasActiveObservers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean hasActiveObservers()
  bool hasActiveObservers() {
    return _hasActiveObservers(
            reference.pointer, _id_hasActiveObservers as jni.JMethodIDPtr)
        .boolean;
  }
}

final class $LiveDataType<$T extends jni.JObject>
    extends jni.JObjType<LiveData<$T>> {
  final jni.JObjType<$T> T;

  const $LiveDataType(
    this.T,
  );

  @override
  String get signature => r"Landroidx/lifecycle/LiveData;";

  @override
  LiveData<$T> fromReference(jni.JReference reference) =>
      LiveData.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($LiveDataType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($LiveDataType<$T>) &&
        other is $LiveDataType<$T> &&
        T == other.T;
  }
}

/// from: androidx.lifecycle.Observer
class Observer<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Observer<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  Observer.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"androidx/lifecycle/Observer");

  /// The type which includes information such as the signature of this class.
  static $ObserverType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $ObserverType(
      T,
    );
  }

  static final _id_onChanged = _class.instanceMethodId(
    r"onChanged",
    r"(Ljava/lang/Object;)V",
  );

  static final _onChanged = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onChanged(T object)
  void onChanged(
    $T object,
  ) {
    _onChanged(reference.pointer, _id_onChanged as jni.JMethodIDPtr,
            object.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ObserverImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onChanged(Ljava/lang/Object;)V") {
        _$impls[$p]!.onChanged(
          $a[0].castTo(_$impls[$p]!.T, releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Observer.implement(
    $ObserverImpl<$T> $impl,
  ) {
    final $p = ReceivePort();
    final $x = Observer.fromReference(
      $impl.T,
      ProtectedJniExtensions.newPortProxy(
        r"androidx.lifecycle.Observer",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ObserverImpl<$T extends jni.JObject> {
  factory $ObserverImpl({
    required jni.JObjType<$T> T,
    required void Function($T object) onChanged,
  }) = _$ObserverImpl;

  jni.JObjType<$T> get T;

  void onChanged($T object);
}

class _$ObserverImpl<$T extends jni.JObject> implements $ObserverImpl<$T> {
  _$ObserverImpl({
    required this.T,
    required void Function($T object) onChanged,
  }) : _onChanged = onChanged;

  @override
  final jni.JObjType<$T> T;

  final void Function($T object) _onChanged;

  void onChanged($T object) {
    return _onChanged(object);
  }
}

final class $ObserverType<$T extends jni.JObject>
    extends jni.JObjType<Observer<$T>> {
  final jni.JObjType<$T> T;

  const $ObserverType(
    this.T,
  );

  @override
  String get signature => r"Landroidx/lifecycle/Observer;";

  @override
  Observer<$T> fromReference(jni.JReference reference) =>
      Observer.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($ObserverType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObserverType<$T>) &&
        other is $ObserverType<$T> &&
        T == other.T;
  }
}

/// from: com.google.common.util.concurrent.ListenableFuture
class ListenableFuture<$V extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<ListenableFuture<$V>> $type = type(V);

  final jni.JObjType<$V> V;

  ListenableFuture.fromReference(
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/google/common/util/concurrent/ListenableFuture");

  /// The type which includes information such as the signature of this class.
  static $ListenableFutureType<$V> type<$V extends jni.JObject>(
    jni.JObjType<$V> V,
  ) {
    return $ListenableFutureType(
      V,
    );
  }

  static final _id_addListener = _class.instanceMethodId(
    r"addListener",
    r"(Ljava/lang/Runnable;Ljava/util/concurrent/Executor;)V",
  );

  static final _addListener = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addListener(java.lang.Runnable runnable, java.util.concurrent.Executor executor)
  void addListener(
    Runnable runnable,
    jni.JObject executor,
  ) {
    _addListener(reference.pointer, _id_addListener as jni.JMethodIDPtr,
            runnable.reference.pointer, executor.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ListenableFutureImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"addListener(Ljava/lang/Runnable;Ljava/util/concurrent/Executor;)V") {
        _$impls[$p]!.addListener(
          $a[0].castTo(const $RunnableType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory ListenableFuture.implement(
    $ListenableFutureImpl<$V> $impl,
  ) {
    final $p = ReceivePort();
    final $x = ListenableFuture.fromReference(
      $impl.V,
      ProtectedJniExtensions.newPortProxy(
        r"com.google.common.util.concurrent.ListenableFuture",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ListenableFutureImpl<$V extends jni.JObject> {
  factory $ListenableFutureImpl({
    required jni.JObjType<$V> V,
    required void Function(Runnable runnable, jni.JObject executor) addListener,
  }) = _$ListenableFutureImpl;

  jni.JObjType<$V> get V;

  void addListener(Runnable runnable, jni.JObject executor);
}

class _$ListenableFutureImpl<$V extends jni.JObject>
    implements $ListenableFutureImpl<$V> {
  _$ListenableFutureImpl({
    required this.V,
    required void Function(Runnable runnable, jni.JObject executor) addListener,
  }) : _addListener = addListener;

  @override
  final jni.JObjType<$V> V;

  final void Function(Runnable runnable, jni.JObject executor) _addListener;

  void addListener(Runnable runnable, jni.JObject executor) {
    return _addListener(runnable, executor);
  }
}

final class $ListenableFutureType<$V extends jni.JObject>
    extends jni.JObjType<ListenableFuture<$V>> {
  final jni.JObjType<$V> V;

  const $ListenableFutureType(
    this.V,
  );

  @override
  String get signature =>
      r"Lcom/google/common/util/concurrent/ListenableFuture;";

  @override
  ListenableFuture<$V> fromReference(jni.JReference reference) =>
      ListenableFuture.fromReference(V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($ListenableFutureType, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ListenableFutureType<$V>) &&
        other is $ListenableFutureType<$V> &&
        V == other.V;
  }
}

/// from: java.lang.Runnable
class Runnable extends jni.JObject {
  @override
  late final jni.JObjType<Runnable> $type = type;

  Runnable.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"java/lang/Runnable");

  /// The type which includes information such as the signature of this class.
  static const type = $RunnableType();
  static final _id_run = _class.instanceMethodId(
    r"run",
    r"()V",
  );

  static final _run = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void run()
  void run() {
    _run(reference.pointer, _id_run as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $RunnableImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"run()V") {
        _$impls[$p]!.run();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Runnable.implement(
    $RunnableImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Runnable.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"java.lang.Runnable",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $RunnableImpl {
  factory $RunnableImpl({
    required void Function() run,
  }) = _$RunnableImpl;

  void run();
}

class _$RunnableImpl implements $RunnableImpl {
  _$RunnableImpl({
    required void Function() run,
  }) : _run = run;

  final void Function() _run;

  void run() {
    return _run();
  }
}

final class $RunnableType extends jni.JObjType<Runnable> {
  const $RunnableType();

  @override
  String get signature => r"Ljava/lang/Runnable;";

  @override
  Runnable fromReference(jni.JReference reference) =>
      Runnable.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RunnableType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RunnableType) && other is $RunnableType;
  }
}

/// from: java.util.concurrent.Future
class Future<$V extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Future<$V>> $type = type(V);

  final jni.JObjType<$V> V;

  Future.fromReference(
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"java/util/concurrent/Future");

  /// The type which includes information such as the signature of this class.
  static $FutureType<$V> type<$V extends jni.JObject>(
    jni.JObjType<$V> V,
  ) {
    return $FutureType(
      V,
    );
  }

  static final _id_cancel = _class.instanceMethodId(
    r"cancel",
    r"(Z)Z",
  );

  static final _cancel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Uint8,)>)>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public abstract boolean cancel(boolean z)
  bool cancel(
    bool z,
  ) {
    return _cancel(reference.pointer, _id_cancel as jni.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_isCancelled = _class.instanceMethodId(
    r"isCancelled",
    r"()Z",
  );

  static final _isCancelled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isCancelled()
  bool isCancelled() {
    return _isCancelled(reference.pointer, _id_isCancelled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isDone = _class.instanceMethodId(
    r"isDone",
    r"()Z",
  );

  static final _isDone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isDone()
  bool isDone() {
    return _isDone(reference.pointer, _id_isDone as jni.JMethodIDPtr).boolean;
  }

  static final _id_get0 = _class.instanceMethodId(
    r"get",
    r"()Ljava/lang/Object;",
  );

  static final _get0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract V get()
  /// The returned object must be released after use, by calling the [release] method.
  $V get0() {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr).object(V);
  }

  static final _id_get1 = _class.instanceMethodId(
    r"get",
    r"(JLjava/util/concurrent/TimeUnit;)Ljava/lang/Object;",
  );

  static final _get1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract V get(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  $V get1(
    int j,
    jni.JObject timeUnit,
  ) {
    return _get1(reference.pointer, _id_get1 as jni.JMethodIDPtr, j,
            timeUnit.reference.pointer)
        .object(V);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $FutureImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"cancel(Z)Z") {
        final $r = _$impls[$p]!.cancel(
          $a[0]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r"isCancelled()Z") {
        final $r = _$impls[$p]!.isCancelled();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r"isDone()Z") {
        final $r = _$impls[$p]!.isDone();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r"get()Ljava/lang/Object;") {
        final $r = _$impls[$p]!.get0();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"get(JLjava/util/concurrent/TimeUnit;)Ljava/lang/Object;") {
        final $r = _$impls[$p]!.get1(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Future.implement(
    $FutureImpl<$V> $impl,
  ) {
    final $p = ReceivePort();
    final $x = Future.fromReference(
      $impl.V,
      ProtectedJniExtensions.newPortProxy(
        r"java.util.concurrent.Future",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $FutureImpl<$V extends jni.JObject> {
  factory $FutureImpl({
    required jni.JObjType<$V> V,
    required bool Function(bool z) cancel,
    required bool Function() isCancelled,
    required bool Function() isDone,
    required $V Function() get0,
    required $V Function(int j, jni.JObject timeUnit) get1,
  }) = _$FutureImpl;

  jni.JObjType<$V> get V;

  bool cancel(bool z);
  bool isCancelled();
  bool isDone();
  $V get0();
  $V get1(int j, jni.JObject timeUnit);
}

class _$FutureImpl<$V extends jni.JObject> implements $FutureImpl<$V> {
  _$FutureImpl({
    required this.V,
    required bool Function(bool z) cancel,
    required bool Function() isCancelled,
    required bool Function() isDone,
    required $V Function() get0,
    required $V Function(int j, jni.JObject timeUnit) get1,
  })  : _cancel = cancel,
        _isCancelled = isCancelled,
        _isDone = isDone,
        _get0 = get0,
        _get1 = get1;

  @override
  final jni.JObjType<$V> V;

  final bool Function(bool z) _cancel;
  final bool Function() _isCancelled;
  final bool Function() _isDone;
  final $V Function() _get0;
  final $V Function(int j, jni.JObject timeUnit) _get1;

  bool cancel(bool z) {
    return _cancel(z);
  }

  bool isCancelled() {
    return _isCancelled();
  }

  bool isDone() {
    return _isDone();
  }

  $V get0() {
    return _get0();
  }

  $V get1(int j, jni.JObject timeUnit) {
    return _get1(j, timeUnit);
  }
}

final class $FutureType<$V extends jni.JObject>
    extends jni.JObjType<Future<$V>> {
  final jni.JObjType<$V> V;

  const $FutureType(
    this.V,
  );

  @override
  String get signature => r"Ljava/util/concurrent/Future;";

  @override
  Future<$V> fromReference(jni.JReference reference) =>
      Future.fromReference(V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($FutureType, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FutureType<$V>) &&
        other is $FutureType<$V> &&
        V == other.V;
  }
}

/// from: dev.hebei.camerax_android.PreviewViewFactory
class PreviewViewFactory extends jni.JObject {
  @override
  late final jni.JObjType<PreviewViewFactory> $type = type;

  PreviewViewFactory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"dev/hebei/camerax_android/PreviewViewFactory");

  /// The type which includes information such as the signature of this class.
  static const type = $PreviewViewFactoryType();
  static final _id_INSTANCE = _class.staticFieldId(
    r"INSTANCE",
    r"Ldev/hebei/camerax_android/PreviewViewFactory;",
  );

  /// from: static public final dev.hebei.camerax_android.PreviewViewFactory INSTANCE
  /// The returned object must be released after use, by calling the [release] method.
  static PreviewViewFactory get INSTANCE =>
      _id_INSTANCE.get(_class, const $PreviewViewFactoryType());

  static final _id_create = _class.instanceMethodId(
    r"create",
    r"(Landroid/content/Context;ILjava/lang/Object;)Lio/flutter/plugin/platform/PlatformView;",
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public io.flutter.plugin.platform.PlatformView create(android.content.Context context, int i, java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject create(
    jni.JObject context,
    int i,
    jni.JObject object,
  ) {
    return _create(reference.pointer, _id_create as jni.JMethodIDPtr,
            context.reference.pointer, i, object.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_retrieveView = _class.instanceMethodId(
    r"retrieveView",
    r"(I)Landroidx/camera/view/PreviewView;",
  );

  static final _retrieveView = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final androidx.camera.view.PreviewView retrieveView(int i)
  /// The returned object must be released after use, by calling the [release] method.
  PreviewView retrieveView(
    int i,
  ) {
    return _retrieveView(
            reference.pointer, _id_retrieveView as jni.JMethodIDPtr, i)
        .object(const $PreviewViewType());
  }
}

final class $PreviewViewFactoryType extends jni.JObjType<PreviewViewFactory> {
  const $PreviewViewFactoryType();

  @override
  String get signature => r"Ldev/hebei/camerax_android/PreviewViewFactory;";

  @override
  PreviewViewFactory fromReference(jni.JReference reference) =>
      PreviewViewFactory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PreviewViewFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PreviewViewFactoryType) &&
        other is $PreviewViewFactoryType;
  }
}
