// Autogenerated from Pigeon (v25.3.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class CameraXError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "CameraXError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? CameraXError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> CameraXError {
  return CameraXError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Handles the callback when an object is deallocated.
protocol CameraXPigeonInternalFinalizerDelegate: AnyObject {
  /// Invoked when the strong reference of an object is deallocated in an `InstanceManager`.
  func onDeinit(identifier: Int64)
}


// Attaches to an object to receive a callback when the object is deallocated.
internal final class CameraXPigeonInternalFinalizer {
  private static let associatedObjectKey = malloc(1)!

  private let identifier: Int64
  // Reference to the delegate is weak because the callback should be ignored if the
  // `InstanceManager` is deallocated.
  private weak var delegate: CameraXPigeonInternalFinalizerDelegate?

  private init(identifier: Int64, delegate: CameraXPigeonInternalFinalizerDelegate) {
    self.identifier = identifier
    self.delegate = delegate
  }

  internal static func attach(
    to instance: AnyObject, identifier: Int64, delegate: CameraXPigeonInternalFinalizerDelegate
  ) {
    let finalizer = CameraXPigeonInternalFinalizer(identifier: identifier, delegate: delegate)
    objc_setAssociatedObject(instance, associatedObjectKey, finalizer, .OBJC_ASSOCIATION_RETAIN)
  }

  static func detach(from instance: AnyObject) {
    objc_setAssociatedObject(instance, associatedObjectKey, nil, .OBJC_ASSOCIATION_ASSIGN)
  }

  deinit {
    delegate?.onDeinit(identifier: identifier)
  }
}


/// Maintains instances used to communicate with the corresponding objects in Dart.
///
/// Objects stored in this container are represented by an object in Dart that is also stored in
/// an InstanceManager with the same identifier.
///
/// When an instance is added with an identifier, either can be used to retrieve the other.
///
/// Added instances are added as a weak reference and a strong reference. When the strong
/// reference is removed and the weak reference is deallocated,`CameraXPigeonInternalFinalizerDelegate.onDeinit`
/// is called with the instance's identifier. However, if the strong reference is removed and then the identifier is
/// retrieved with the intention to pass the identifier to Dart (e.g. by calling `identifierWithStrongReference`),
/// the strong reference to the instance is re-added. The strong reference will then need to be removed manually
/// again.
///
/// Accessing and inserting to an InstanceManager is thread safe.
final class CameraXPigeonInstanceManager {
  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously from Dart.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  private static let minHostCreatedIdentifier: Int64 = 65536

  private let lockQueue = DispatchQueue(label: "CameraXPigeonInstanceManager")
  private let identifiers: NSMapTable<AnyObject, NSNumber> = NSMapTable(
    keyOptions: [.weakMemory, .objectPointerPersonality], valueOptions: .strongMemory)
  private let weakInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.weakMemory, .objectPointerPersonality])
  private let strongInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.strongMemory, .objectPointerPersonality])
  private let finalizerDelegate: CameraXPigeonInternalFinalizerDelegate
  private var nextIdentifier: Int64 = minHostCreatedIdentifier

  public init(finalizerDelegate: CameraXPigeonInternalFinalizerDelegate) {
    self.finalizerDelegate = finalizerDelegate
  }

  /// Adds a new instance that was instantiated from Dart.
  ///
  /// The same instance can be added multiple times, but each identifier must be unique. This allows
  /// two objects that are equivalent (e.g. conforms to `Equatable`)  to both be added.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored
  ///   - identifier: the identifier to be paired with instance. This value must be >= 0 and unique
  func addDartCreatedInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    lockQueue.async {
      self.addInstance(instance, withIdentifier: identifier)
    }
  }

  /// Adds a new instance that was instantiated from the host platform.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored. This must be unique to all other added instances.
  /// - Returns: the unique identifier (>= 0) stored with instance
  func addHostCreatedInstance(_ instance: AnyObject) -> Int64 {
    assert(!containsInstance(instance), "Instance of \(instance) has already been added.")
    var identifier: Int64 = -1
    lockQueue.sync {
      identifier = nextIdentifier
      nextIdentifier += 1
      self.addInstance(instance, withIdentifier: identifier)
    }
    return identifier
  }

  /// Removes `instanceIdentifier` and its associated strongly referenced instance, if present, from the manager.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier paired to an instance.
  /// - Returns: removed instance if the manager contains the given identifier, otherwise `nil` if
  ///   the manager doesn't contain the value
  func removeInstance<T: AnyObject>(withIdentifier instanceIdentifier: Int64) throws -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = strongInstances.object(forKey: NSNumber(value: instanceIdentifier))
      strongInstances.removeObject(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier associated with an instance
  /// - Returns: the instance associated with `instanceIdentifier` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func instance<T: AnyObject>(forIdentifier instanceIdentifier: Int64) -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = weakInstances.object(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  private func addInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    assert(identifier >= 0)
    assert(
      weakInstances.object(forKey: identifier as NSNumber) == nil,
      "Identifier has already been added: \(identifier)")
    identifiers.setObject(NSNumber(value: identifier), forKey: instance)
    weakInstances.setObject(instance, forKey: NSNumber(value: identifier))
    strongInstances.setObject(instance, forKey: NSNumber(value: identifier))
    CameraXPigeonInternalFinalizer.attach(to: instance, identifier: identifier, delegate: finalizerDelegate)
  }

  /// Retrieves the identifier paired with an instance.
  ///
  /// If the manager contains a strong reference to `instance`, it will return the identifier
  /// associated with `instance`. If the manager contains only a weak reference to `instance`, a new
  /// strong reference to `instance` will be added and will need to be removed again with `removeInstance`.
  ///
  /// If this method returns a nonnull identifier, this method also expects the Dart
  /// `CameraXPigeonInstanceManager` to have, or recreate, a weak reference to the Dart instance the
  /// identifier is associated with.
  ///
  /// - Parameters:
  ///   - instance: an instance that may be stored in the manager
  /// - Returns: the identifier associated with `instance` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func identifierWithStrongReference(forInstance instance: AnyObject) -> Int64? {
    var identifier: Int64? = nil
    lockQueue.sync {
      if let existingIdentifier = identifiers.object(forKey: instance)?.int64Value {
        strongInstances.setObject(instance, forKey: NSNumber(value: existingIdentifier))
        identifier = existingIdentifier
      }
    }
    return identifier
  }

  /// Whether this manager contains the given `instance`.
  ///
  /// - Parameters:
  ///   - instance: the instance whose presence in this manager is to be tested
  /// - Returns: whether this manager contains the given `instance`
  func containsInstance(_ instance: AnyObject) -> Bool {
    var containsInstance = false
    lockQueue.sync {
      containsInstance = identifiers.object(forKey: instance) != nil
    }
    return containsInstance
  }

  /// Removes all of the instances from this manager.
  ///
  /// The manager will be empty after this call returns.
  func removeAllObjects() throws {
    lockQueue.sync {
      identifiers.removeAllObjects()
      weakInstances.removeAllObjects()
      strongInstances.removeAllObjects()
      nextIdentifier = CameraXPigeonInstanceManager.minHostCreatedIdentifier
    }
  }

  /// The number of instances stored as a strong reference.
  ///
  /// For debugging and testing purposes.
  internal var strongInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = strongInstances.count
    }
    return count
  }

  /// The number of instances stored as a weak reference.
  ///
  /// For debugging and testing purposes. NSMapTables that store keys or objects as weak
  /// reference will be reclaimed non-deterministically.
  internal var weakInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = weakInstances.count
    }
    return count
  }
}


private class CameraXPigeonInstanceManagerApi {
  /// The codec used for serializing messages.
  var codec: FlutterStandardMessageCodec { CameraXPigeonCodec.shared }

  /// Handles sending and receiving messages with Dart.
  unowned let binaryMessenger: FlutterBinaryMessenger

  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  /// Sets up an instance of `CameraXPigeonInstanceManagerApi` to handle messages through the `binaryMessenger`.
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, instanceManager: CameraXPigeonInstanceManager?) {
    let codec = CameraXPigeonCodec.shared
    let removeStrongReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.removeStrongReference", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      removeStrongReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! Int64
        do {
          let _: AnyObject? = try instanceManager.removeInstance(withIdentifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStrongReferenceChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.clear", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      clearChannel.setMessageHandler { _, reply in
        do {
          try instanceManager.removeAllObjects()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
  }

  /// Sends a message to the Dart `InstanceManager` to remove the strong reference of the instance associated with `identifier`.
  func removeStrongReference(identifier identifierArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.removeStrongReference"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
protocol CameraXPigeonProxyApiDelegate {
  /// An implementation of [PigeonApiPermissionManagerApi] used to add a new Dart instance of
  /// `PermissionManagerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPermissionManagerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiPermissionManagerApi
  /// An implementation of [PigeonApiAutoCloseableApi] used to add a new Dart instance of
  /// `AutoCloseableApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAutoCloseableApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiAutoCloseableApi
  /// An implementation of [PigeonApiCloseableApi] used to add a new Dart instance of
  /// `CloseableApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCloseableApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCloseableApi
  /// An implementation of [PigeonApiLocationApi] used to add a new Dart instance of
  /// `LocationApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiLocationApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiLocationApi
  /// An implementation of [PigeonApiSizeApi] used to add a new Dart instance of
  /// `SizeApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSizeApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiSizeApi
  /// An implementation of [PigeonApiPointApi] used to add a new Dart instance of
  /// `PointApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPointApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiPointApi
  /// An implementation of [PigeonApiPointFApi] used to add a new Dart instance of
  /// `PointFApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPointFApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiPointFApi
  /// An implementation of [PigeonApiRectApi] used to add a new Dart instance of
  /// `RectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRectApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiRectApi
  /// An implementation of [PigeonApiIntRangeApi] used to add a new Dart instance of
  /// `IntRangeApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiIntRangeApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiIntRangeApi
  /// An implementation of [PigeonApiLongRangeApi] used to add a new Dart instance of
  /// `LongRangeApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiLongRangeApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiLongRangeApi
  /// An implementation of [PigeonApiCameraSelectorApi] used to add a new Dart instance of
  /// `CameraSelectorApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraSelectorApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCameraSelectorApi
  /// An implementation of [PigeonApiCameraStateLiveDataApi] used to add a new Dart instance of
  /// `CameraStateLiveDataApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraStateLiveDataApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCameraStateLiveDataApi
  /// An implementation of [PigeonApiCameraStateObserverApi] used to add a new Dart instance of
  /// `CameraStateObserverApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraStateObserverApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCameraStateObserverApi
  /// An implementation of [PigeonApiTorchStateLiveDataApi] used to add a new Dart instance of
  /// `TorchStateLiveDataApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiTorchStateLiveDataApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiTorchStateLiveDataApi
  /// An implementation of [PigeonApiTorchStateObserverApi] used to add a new Dart instance of
  /// `TorchStateObserverApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiTorchStateObserverApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiTorchStateObserverApi
  /// An implementation of [PigeonApiZoomStateApi] used to add a new Dart instance of
  /// `ZoomStateApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiZoomStateApi
  /// An implementation of [PigeonApiZoomStateLiveDataApi] used to add a new Dart instance of
  /// `ZoomStateLiveDataApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateLiveDataApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiZoomStateLiveDataApi
  /// An implementation of [PigeonApiZoomStateObserverApi] used to add a new Dart instance of
  /// `ZoomStateObserverApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateObserverApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiZoomStateObserverApi
  /// An implementation of [PigeonApiExposureStateApi] used to add a new Dart instance of
  /// `ExposureStateApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiExposureStateApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiExposureStateApi
  /// An implementation of [PigeonApiMeteringPointApi] used to add a new Dart instance of
  /// `MeteringPointApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMeteringPointApi
  /// An implementation of [PigeonApiMeteringPointFactoryApi] used to add a new Dart instance of
  /// `MeteringPointFactoryApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointFactoryApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMeteringPointFactoryApi
  /// An implementation of [PigeonApiSurfaceOrientedMeteringPointFactoryApi] used to add a new Dart instance of
  /// `SurfaceOrientedMeteringPointFactoryApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSurfaceOrientedMeteringPointFactoryApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiSurfaceOrientedMeteringPointFactoryApi
  /// An implementation of [PigeonApiMeteringPointTupleApi] used to add a new Dart instance of
  /// `MeteringPointTupleApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointTupleApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMeteringPointTupleApi
  /// An implementation of [PigeonApiDurationTupleApi] used to add a new Dart instance of
  /// `DurationTupleApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiDurationTupleApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiDurationTupleApi
  /// An implementation of [PigeonApiFocusMeteringActionApi] used to add a new Dart instance of
  /// `FocusMeteringActionApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFocusMeteringActionApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFocusMeteringActionApi
  /// An implementation of [PigeonApiFocusMeteringResultApi] used to add a new Dart instance of
  /// `FocusMeteringResultApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFocusMeteringResultApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFocusMeteringResultApi
  /// An implementation of [PigeonApiDynamicRangeApi] used to add a new Dart instance of
  /// `DynamicRangeApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiDynamicRangeApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiDynamicRangeApi
  /// An implementation of [PigeonApiCameraInfoApi] used to add a new Dart instance of
  /// `CameraInfoApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraInfoApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCameraInfoApi
  /// An implementation of [PigeonApiCameraControlApi] used to add a new Dart instance of
  /// `CameraControlApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraControlApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCameraControlApi
  /// An implementation of [PigeonApiAspectRatioStrategyApi] used to add a new Dart instance of
  /// `AspectRatioStrategyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAspectRatioStrategyApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiAspectRatioStrategyApi
  /// An implementation of [PigeonApiResolutionFilterApi] used to add a new Dart instance of
  /// `ResolutionFilterApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiResolutionFilterApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiResolutionFilterApi
  /// An implementation of [PigeonApiResolutionStrategyApi] used to add a new Dart instance of
  /// `ResolutionStrategyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiResolutionStrategyApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiResolutionStrategyApi
  /// An implementation of [PigeonApiResolutionSelectorApi] used to add a new Dart instance of
  /// `ResolutionSelectorApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiResolutionSelectorApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiResolutionSelectorApi
  /// An implementation of [PigeonApiImageInfoApi] used to add a new Dart instance of
  /// `ImageInfoApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageInfoApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiImageInfoApi
  /// An implementation of [PigeonApiPlaneProxyApi] used to add a new Dart instance of
  /// `PlaneProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPlaneProxyApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiPlaneProxyApi
  /// An implementation of [PigeonApiImageProxyApi] used to add a new Dart instance of
  /// `ImageProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageProxyApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiImageProxyApi
  /// An implementation of [PigeonApiMetadataApi] used to add a new Dart instance of
  /// `MetadataApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMetadataApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMetadataApi
  /// An implementation of [PigeonApiOutputFileOptionsApi] used to add a new Dart instance of
  /// `OutputFileOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputFileOptionsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiOutputFileOptionsApi
  /// An implementation of [PigeonApiOutputFileResultsApi] used to add a new Dart instance of
  /// `OutputFileResultsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputFileResultsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiOutputFileResultsApi
  /// An implementation of [PigeonApiOnImageCapturedCallbackApi] used to add a new Dart instance of
  /// `OnImageCapturedCallbackApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOnImageCapturedCallbackApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiOnImageCapturedCallbackApi
  /// An implementation of [PigeonApiOnImageSavedCallbackApi] used to add a new Dart instance of
  /// `OnImageSavedCallbackApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOnImageSavedCallbackApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiOnImageSavedCallbackApi
  /// An implementation of [PigeonApiAnalyzerApi] used to add a new Dart instance of
  /// `AnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAnalyzerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiAnalyzerApi
  /// An implementation of [PigeonApiImageAnalyzerApi] used to add a new Dart instance of
  /// `ImageAnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageAnalyzerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiImageAnalyzerApi
  /// An implementation of [PigeonApiJpegAnalyzerApi] used to add a new Dart instance of
  /// `JpegAnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiJpegAnalyzerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiJpegAnalyzerApi
  /// An implementation of [PigeonApiDetectorApi] used to add a new Dart instance of
  /// `DetectorApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiDetectorApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiDetectorApi
  /// An implementation of [PigeonApiAddressApi] used to add a new Dart instance of
  /// `AddressApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAddressApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiAddressApi
  /// An implementation of [PigeonApiCalendarDateTimeApi] used to add a new Dart instance of
  /// `CalendarDateTimeApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCalendarDateTimeApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCalendarDateTimeApi
  /// An implementation of [PigeonApiCalendarEventApi] used to add a new Dart instance of
  /// `CalendarEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCalendarEventApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCalendarEventApi
  /// An implementation of [PigeonApiContactInfoApi] used to add a new Dart instance of
  /// `ContactInfoApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiContactInfoApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiContactInfoApi
  /// An implementation of [PigeonApiDriverLicenseApi] used to add a new Dart instance of
  /// `DriverLicenseApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiDriverLicenseApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiDriverLicenseApi
  /// An implementation of [PigeonApiEmailApi] used to add a new Dart instance of
  /// `EmailApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiEmailApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiEmailApi
  /// An implementation of [PigeonApiGeoPointApi] used to add a new Dart instance of
  /// `GeoPointApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiGeoPointApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiGeoPointApi
  /// An implementation of [PigeonApiPersonNameApi] used to add a new Dart instance of
  /// `PersonNameApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPersonNameApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiPersonNameApi
  /// An implementation of [PigeonApiPhoneApi] used to add a new Dart instance of
  /// `PhoneApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPhoneApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiPhoneApi
  /// An implementation of [PigeonApiSmsApi] used to add a new Dart instance of
  /// `SmsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSmsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiSmsApi
  /// An implementation of [PigeonApiUrlBookmarkApi] used to add a new Dart instance of
  /// `UrlBookmarkApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiUrlBookmarkApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiUrlBookmarkApi
  /// An implementation of [PigeonApiWiFiApi] used to add a new Dart instance of
  /// `WiFiApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWiFiApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiWiFiApi
  /// An implementation of [PigeonApiBarcodeApi] used to add a new Dart instance of
  /// `BarcodeApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiBarcodeApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiBarcodeApi
  /// An implementation of [PigeonApiZoomCallbackApi] used to add a new Dart instance of
  /// `ZoomCallbackApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomCallbackApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiZoomCallbackApi
  /// An implementation of [PigeonApiZoomSuggestionOptionsApi] used to add a new Dart instance of
  /// `ZoomSuggestionOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomSuggestionOptionsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiZoomSuggestionOptionsApi
  /// An implementation of [PigeonApiBarcodeScannerOptionsApi] used to add a new Dart instance of
  /// `BarcodeScannerOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiBarcodeScannerOptionsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiBarcodeScannerOptionsApi
  /// An implementation of [PigeonApiMlImageApi] used to add a new Dart instance of
  /// `MlImageApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMlImageApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMlImageApi
  /// An implementation of [PigeonApiInputImageApi] used to add a new Dart instance of
  /// `InputImageApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiInputImageApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiInputImageApi
  /// An implementation of [PigeonApiBarcodeScannerApi] used to add a new Dart instance of
  /// `BarcodeScannerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiBarcodeScannerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiBarcodeScannerApi
  /// An implementation of [PigeonApiFaceDetectorOptionsApi] used to add a new Dart instance of
  /// `FaceDetectorOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFaceDetectorOptionsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFaceDetectorOptionsApi
  /// An implementation of [PigeonApiFaceContourApi] used to add a new Dart instance of
  /// `FaceContourApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFaceContourApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFaceContourApi
  /// An implementation of [PigeonApiFaceLandmarkApi] used to add a new Dart instance of
  /// `FaceLandmarkApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFaceLandmarkApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFaceLandmarkApi
  /// An implementation of [PigeonApiFaceApi] used to add a new Dart instance of
  /// `FaceApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFaceApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFaceApi
  /// An implementation of [PigeonApiFaceDetectorApi] used to add a new Dart instance of
  /// `FaceDetectorApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFaceDetectorApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFaceDetectorApi
  /// An implementation of [PigeonApiMlKitAnalyzerResultApi] used to add a new Dart instance of
  /// `MlKitAnalyzerResultApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMlKitAnalyzerResultApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMlKitAnalyzerResultApi
  /// An implementation of [PigeonApiMlKitAnalyzerResultConsumerApi] used to add a new Dart instance of
  /// `MlKitAnalyzerResultConsumerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMlKitAnalyzerResultConsumerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMlKitAnalyzerResultConsumerApi
  /// An implementation of [PigeonApiMlKitAnalyzerApi] used to add a new Dart instance of
  /// `MlKitAnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMlKitAnalyzerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMlKitAnalyzerApi
  /// An implementation of [PigeonApiQualityApi] used to add a new Dart instance of
  /// `QualityApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiQualityApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiQualityApi
  /// An implementation of [PigeonApiFallbackStrategyApi] used to add a new Dart instance of
  /// `FallbackStrategyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFallbackStrategyApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFallbackStrategyApi
  /// An implementation of [PigeonApiQualitySelectorApi] used to add a new Dart instance of
  /// `QualitySelectorApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiQualitySelectorApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiQualitySelectorApi
  /// An implementation of [PigeonApiFileOutputOptionsApi] used to add a new Dart instance of
  /// `FileOutputOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFileOutputOptionsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiFileOutputOptionsApi
  /// An implementation of [PigeonApiAudioConfigApi] used to add a new Dart instance of
  /// `AudioConfigApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAudioConfigApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiAudioConfigApi
  /// An implementation of [PigeonApiAudioStatsApi] used to add a new Dart instance of
  /// `AudioStatsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAudioStatsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiAudioStatsApi
  /// An implementation of [PigeonApiRecordingStatsApi] used to add a new Dart instance of
  /// `RecordingStatsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRecordingStatsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiRecordingStatsApi
  /// An implementation of [PigeonApiVideoRecordEventApi] used to add a new Dart instance of
  /// `VideoRecordEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordEventApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventApi
  /// An implementation of [PigeonApiVideoRecordStatusEventApi] used to add a new Dart instance of
  /// `VideoRecordStatusEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordStatusEventApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiVideoRecordStatusEventApi
  /// An implementation of [PigeonApiVideoRecordStartEventApi] used to add a new Dart instance of
  /// `VideoRecordStartEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordStartEventApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiVideoRecordStartEventApi
  /// An implementation of [PigeonApiVideoRecordPauseEventApi] used to add a new Dart instance of
  /// `VideoRecordPauseEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordPauseEventApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiVideoRecordPauseEventApi
  /// An implementation of [PigeonApiVideoRecordResumeEventApi] used to add a new Dart instance of
  /// `VideoRecordResumeEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordResumeEventApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiVideoRecordResumeEventApi
  /// An implementation of [PigeonApiOutputResultsApi] used to add a new Dart instance of
  /// `OutputResultsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputResultsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiOutputResultsApi
  /// An implementation of [PigeonApiVideoRecordFinalizeEventApi] used to add a new Dart instance of
  /// `VideoRecordFinalizeEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordFinalizeEventApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiVideoRecordFinalizeEventApi
  /// An implementation of [PigeonApiVideoRecordEventConsumerApi] used to add a new Dart instance of
  /// `VideoRecordEventConsumerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordEventConsumerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventConsumerApi
  /// An implementation of [PigeonApiRecordingApi] used to add a new Dart instance of
  /// `RecordingApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRecordingApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiRecordingApi
  /// An implementation of [PigeonApiCameraControllerApi] used to add a new Dart instance of
  /// `CameraControllerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraControllerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCameraControllerApi
  /// An implementation of [PigeonApiLifecycleCameraControllerApi] used to add a new Dart instance of
  /// `LifecycleCameraControllerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiLifecycleCameraControllerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiLifecycleCameraControllerApi
  /// An implementation of [PigeonApiPreviewViewApi] used to add a new Dart instance of
  /// `PreviewViewApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPreviewViewApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiPreviewViewApi
  /// An implementation of [PigeonApiCamera2CameraControlApi] used to add a new Dart instance of
  /// `Camera2CameraControlApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCamera2CameraControlApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCamera2CameraControlApi
  /// An implementation of [PigeonApiCamera2CameraInfoApi] used to add a new Dart instance of
  /// `Camera2CameraInfoApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCamera2CameraInfoApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCamera2CameraInfoApi
  /// An implementation of [PigeonApiCaptureRequestOptionsApi] used to add a new Dart instance of
  /// `CaptureRequestOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCaptureRequestOptionsApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCaptureRequestOptionsApi
}

extension CameraXPigeonProxyApiDelegate {
  func pigeonApiCloseableApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiCloseableApi {
    return PigeonApiCloseableApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateCloseableApi())
  }
  func pigeonApiAnalyzerApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiAnalyzerApi {
    return PigeonApiAnalyzerApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateAnalyzerApi())
  }
  func pigeonApiDetectorApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiDetectorApi {
    return PigeonApiDetectorApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateDetectorApi())
  }
  func pigeonApiMlImageApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiMlImageApi {
    return PigeonApiMlImageApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateMlImageApi())
  }
  func pigeonApiInputImageApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiInputImageApi {
    return PigeonApiInputImageApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateInputImageApi())
  }
  func pigeonApiVideoRecordEventApi(_ registrar: CameraXPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventApi {
    return PigeonApiVideoRecordEventApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateVideoRecordEventApi())
  }
}

open class CameraXPigeonProxyApiRegistrar {
  let binaryMessenger: FlutterBinaryMessenger
  let apiDelegate: CameraXPigeonProxyApiDelegate
  let instanceManager: CameraXPigeonInstanceManager
  /// Whether APIs should ignore calling to Dart.
  public var ignoreCallsToDart = false
  private var _codec: FlutterStandardMessageCodec?
  var codec: FlutterStandardMessageCodec {
    if _codec == nil {
      _codec = FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: self))
    }
    return _codec!
  }

  private class InstanceManagerApiFinalizerDelegate: CameraXPigeonInternalFinalizerDelegate {
    let api: CameraXPigeonInstanceManagerApi

    init(_ api: CameraXPigeonInstanceManagerApi) {
      self.api = api
    }

    public func onDeinit(identifier: Int64) {
      api.removeStrongReference(identifier: identifier) {
        _ in
      }
    }
  }

  init(binaryMessenger: FlutterBinaryMessenger, apiDelegate: CameraXPigeonProxyApiDelegate) {
    self.binaryMessenger = binaryMessenger
    self.apiDelegate = apiDelegate
    self.instanceManager = CameraXPigeonInstanceManager(
      finalizerDelegate: InstanceManagerApiFinalizerDelegate(
        CameraXPigeonInstanceManagerApi(binaryMessenger: binaryMessenger)))
  }

  func setUp() {
    CameraXPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: instanceManager)
    PigeonApiPermissionManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPermissionManagerApi(self))
    PigeonApiAutoCloseableApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAutoCloseableApi(self))
    PigeonApiLocationApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiLocationApi(self))
    PigeonApiSizeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiSizeApi(self))
    PigeonApiPointApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPointApi(self))
    PigeonApiPointFApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPointFApi(self))
    PigeonApiRectApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRectApi(self))
    PigeonApiIntRangeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiIntRangeApi(self))
    PigeonApiLongRangeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiLongRangeApi(self))
    PigeonApiCameraSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraSelectorApi(self))
    PigeonApiCameraStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraStateLiveDataApi(self))
    PigeonApiCameraStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraStateObserverApi(self))
    PigeonApiTorchStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiTorchStateLiveDataApi(self))
    PigeonApiTorchStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiTorchStateObserverApi(self))
    PigeonApiZoomStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiZoomStateLiveDataApi(self))
    PigeonApiZoomStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiZoomStateObserverApi(self))
    PigeonApiMeteringPointFactoryApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMeteringPointFactoryApi(self))
    PigeonApiSurfaceOrientedMeteringPointFactoryApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiSurfaceOrientedMeteringPointFactoryApi(self))
    PigeonApiMeteringPointTupleApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMeteringPointTupleApi(self))
    PigeonApiDurationTupleApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiDurationTupleApi(self))
    PigeonApiFocusMeteringActionApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFocusMeteringActionApi(self))
    PigeonApiDynamicRangeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiDynamicRangeApi(self))
    PigeonApiCameraInfoApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraInfoApi(self))
    PigeonApiCameraControlApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraControlApi(self))
    PigeonApiAspectRatioStrategyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAspectRatioStrategyApi(self))
    PigeonApiResolutionFilterApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiResolutionFilterApi(self))
    PigeonApiResolutionStrategyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiResolutionStrategyApi(self))
    PigeonApiResolutionSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiResolutionSelectorApi(self))
    PigeonApiImageProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiImageProxyApi(self))
    PigeonApiMetadataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMetadataApi(self))
    PigeonApiOutputFileOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOutputFileOptionsApi(self))
    PigeonApiOnImageCapturedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOnImageCapturedCallbackApi(self))
    PigeonApiOnImageSavedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOnImageSavedCallbackApi(self))
    PigeonApiImageAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiImageAnalyzerApi(self))
    PigeonApiJpegAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiJpegAnalyzerApi(self))
    PigeonApiZoomCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiZoomCallbackApi(self))
    PigeonApiZoomSuggestionOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiZoomSuggestionOptionsApi(self))
    PigeonApiBarcodeScannerOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiBarcodeScannerOptionsApi(self))
    PigeonApiBarcodeScannerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiBarcodeScannerApi(self))
    PigeonApiFaceDetectorOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFaceDetectorOptionsApi(self))
    PigeonApiFaceApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFaceApi(self))
    PigeonApiFaceDetectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFaceDetectorApi(self))
    PigeonApiMlKitAnalyzerResultApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMlKitAnalyzerResultApi(self))
    PigeonApiMlKitAnalyzerResultConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMlKitAnalyzerResultConsumerApi(self))
    PigeonApiMlKitAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMlKitAnalyzerApi(self))
    PigeonApiQualityApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiQualityApi(self))
    PigeonApiFallbackStrategyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFallbackStrategyApi(self))
    PigeonApiQualitySelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiQualitySelectorApi(self))
    PigeonApiFileOutputOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFileOutputOptionsApi(self))
    PigeonApiAudioConfigApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAudioConfigApi(self))
    PigeonApiVideoRecordEventConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiVideoRecordEventConsumerApi(self))
    PigeonApiRecordingApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRecordingApi(self))
    PigeonApiCameraControllerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraControllerApi(self))
    PigeonApiLifecycleCameraControllerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiLifecycleCameraControllerApi(self))
    PigeonApiPreviewViewApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPreviewViewApi(self))
    PigeonApiCamera2CameraControlApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCamera2CameraControlApi(self))
    PigeonApiCamera2CameraInfoApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCamera2CameraInfoApi(self))
    PigeonApiCaptureRequestOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCaptureRequestOptionsApi(self))
  }
  func tearDown() {
    CameraXPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: nil)
    PigeonApiPermissionManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAutoCloseableApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiLocationApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiSizeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPointApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPointFApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRectApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiIntRangeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiLongRangeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiTorchStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiTorchStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiZoomStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiZoomStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMeteringPointFactoryApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiSurfaceOrientedMeteringPointFactoryApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMeteringPointTupleApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiDurationTupleApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFocusMeteringActionApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiDynamicRangeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraInfoApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraControlApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAspectRatioStrategyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiResolutionFilterApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiResolutionStrategyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiResolutionSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiImageProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMetadataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOutputFileOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOnImageCapturedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOnImageSavedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiImageAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiJpegAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiZoomCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiZoomSuggestionOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiBarcodeScannerOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiBarcodeScannerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFaceDetectorOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFaceApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFaceDetectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMlKitAnalyzerResultApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMlKitAnalyzerResultConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMlKitAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiQualityApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFallbackStrategyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiQualitySelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFileOutputOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAudioConfigApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiVideoRecordEventConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRecordingApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraControllerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiLifecycleCameraControllerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPreviewViewApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCamera2CameraControlApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCamera2CameraInfoApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCaptureRequestOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
  }
}
private class CameraXPigeonInternalProxyApiCodecReaderWriter: FlutterStandardReaderWriter {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar

  private class CameraXPigeonInternalProxyApiCodecReader: CameraXPigeonCodecReader {
    unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar

    init(data: Data, pigeonRegistrar: CameraXPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func readValue(ofType type: UInt8) -> Any? {
      switch type {
      case 128:
        let identifier = self.readValue()
        let instance: AnyObject? = pigeonRegistrar.instanceManager.instance(
          forIdentifier: identifier is Int64 ? identifier as! Int64 : Int64(identifier as! Int32))
        if instance == nil {
          print("Failed to find instance with identifier: \(identifier!)")
        }
        return instance
      default:
        return super.readValue(ofType: type)
      }
    }
  }

  private class CameraXPigeonInternalProxyApiCodecWriter: CameraXPigeonCodecWriter {
    unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar

    init(data: NSMutableData, pigeonRegistrar: CameraXPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func writeValue(_ value: Any) {
      if value is [Any] || value is Bool || value is Data || value is [AnyHashable: Any] || value is Double || value is FlutterStandardTypedData || value is Int64 || value is String || value is PermissionApi || value is LensFacingApi || value is CameraStateApi || value is TorchStateApi || value is MeteringModeApi || value is TimeUnitApi || value is AspectRatioApi || value is BitDepthApi || value is EncodingApi || value is ScaleTypeApi || value is UseCaseApi || value is ResolutionModeApi || value is AspectRatioFallbackRuleApi || value is ResolutionFallbackRuleApi || value is CaptureModeApi || value is FlashModeApi || value is BackpressureStrategyApi || value is CoordinateSystemApi || value is ImageFormatApi || value is MirrorModeApi || value is AudioStateApi || value is VideoRecordFinalizeEventErrorApi || value is BarcodeFormatApi || value is BarcodeValueTypeApi || value is AddressTypeApi || value is EmailTypeApi || value is PhoneTypeApi || value is WiFiEncryptionTypeApi || value is FaceClassificationModeApi || value is FaceContourModeApi || value is FaceLandmarkModeApi || value is FacePerformanceModeApi || value is FaceContourTypeApi || value is FaceLandmarkTypeApi || value is ControlModeApi || value is ControlAeModeApi || value is ControlAfModeApi || value is ControlAwbModeApi {
        super.writeValue(value)
        return
      }


      if let instance = value as? PermissionManagerApi {
        pigeonRegistrar.apiDelegate.pigeonApiPermissionManagerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? LocationApi {
        pigeonRegistrar.apiDelegate.pigeonApiLocationApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? SizeApi {
        pigeonRegistrar.apiDelegate.pigeonApiSizeApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PointApi {
        pigeonRegistrar.apiDelegate.pigeonApiPointApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PointFApi {
        pigeonRegistrar.apiDelegate.pigeonApiPointFApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RectApi {
        pigeonRegistrar.apiDelegate.pigeonApiRectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? IntRangeApi {
        pigeonRegistrar.apiDelegate.pigeonApiIntRangeApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? LongRangeApi {
        pigeonRegistrar.apiDelegate.pigeonApiLongRangeApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraSelectorApi {
        pigeonRegistrar.apiDelegate.pigeonApiCameraSelectorApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraStateLiveDataApi {
        pigeonRegistrar.apiDelegate.pigeonApiCameraStateLiveDataApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraStateObserverApi {
        pigeonRegistrar.apiDelegate.pigeonApiCameraStateObserverApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? TorchStateLiveDataApi {
        pigeonRegistrar.apiDelegate.pigeonApiTorchStateLiveDataApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? TorchStateObserverApi {
        pigeonRegistrar.apiDelegate.pigeonApiTorchStateObserverApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomStateApi {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomStateLiveDataApi {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateLiveDataApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomStateObserverApi {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateObserverApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ExposureStateApi {
        pigeonRegistrar.apiDelegate.pigeonApiExposureStateApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPointApi {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? SurfaceOrientedMeteringPointFactoryApi {
        pigeonRegistrar.apiDelegate.pigeonApiSurfaceOrientedMeteringPointFactoryApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPointFactoryApi {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointFactoryApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPointTupleApi {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointTupleApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? DurationTupleApi {
        pigeonRegistrar.apiDelegate.pigeonApiDurationTupleApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FocusMeteringActionApi {
        pigeonRegistrar.apiDelegate.pigeonApiFocusMeteringActionApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FocusMeteringResultApi {
        pigeonRegistrar.apiDelegate.pigeonApiFocusMeteringResultApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? DynamicRangeApi {
        pigeonRegistrar.apiDelegate.pigeonApiDynamicRangeApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraInfoApi {
        pigeonRegistrar.apiDelegate.pigeonApiCameraInfoApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraControlApi {
        pigeonRegistrar.apiDelegate.pigeonApiCameraControlApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AspectRatioStrategyApi {
        pigeonRegistrar.apiDelegate.pigeonApiAspectRatioStrategyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ResolutionFilterApi {
        pigeonRegistrar.apiDelegate.pigeonApiResolutionFilterApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ResolutionStrategyApi {
        pigeonRegistrar.apiDelegate.pigeonApiResolutionStrategyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ResolutionSelectorApi {
        pigeonRegistrar.apiDelegate.pigeonApiResolutionSelectorApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageInfoApi {
        pigeonRegistrar.apiDelegate.pigeonApiImageInfoApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PlaneProxyApi {
        pigeonRegistrar.apiDelegate.pigeonApiPlaneProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageProxyApi {
        pigeonRegistrar.apiDelegate.pigeonApiImageProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MetadataApi {
        pigeonRegistrar.apiDelegate.pigeonApiMetadataApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OutputFileOptionsApi {
        pigeonRegistrar.apiDelegate.pigeonApiOutputFileOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OutputFileResultsApi {
        pigeonRegistrar.apiDelegate.pigeonApiOutputFileResultsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OnImageCapturedCallbackApi {
        pigeonRegistrar.apiDelegate.pigeonApiOnImageCapturedCallbackApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OnImageSavedCallbackApi {
        pigeonRegistrar.apiDelegate.pigeonApiOnImageSavedCallbackApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageAnalyzerApi {
        pigeonRegistrar.apiDelegate.pigeonApiImageAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? JpegAnalyzerApi {
        pigeonRegistrar.apiDelegate.pigeonApiJpegAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AddressApi {
        pigeonRegistrar.apiDelegate.pigeonApiAddressApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CalendarDateTimeApi {
        pigeonRegistrar.apiDelegate.pigeonApiCalendarDateTimeApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CalendarEventApi {
        pigeonRegistrar.apiDelegate.pigeonApiCalendarEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ContactInfoApi {
        pigeonRegistrar.apiDelegate.pigeonApiContactInfoApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? DriverLicenseApi {
        pigeonRegistrar.apiDelegate.pigeonApiDriverLicenseApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? EmailApi {
        pigeonRegistrar.apiDelegate.pigeonApiEmailApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? GeoPointApi {
        pigeonRegistrar.apiDelegate.pigeonApiGeoPointApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PersonNameApi {
        pigeonRegistrar.apiDelegate.pigeonApiPersonNameApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PhoneApi {
        pigeonRegistrar.apiDelegate.pigeonApiPhoneApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? SmsApi {
        pigeonRegistrar.apiDelegate.pigeonApiSmsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? UrlBookmarkApi {
        pigeonRegistrar.apiDelegate.pigeonApiUrlBookmarkApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WiFiApi {
        pigeonRegistrar.apiDelegate.pigeonApiWiFiApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? BarcodeApi {
        pigeonRegistrar.apiDelegate.pigeonApiBarcodeApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomCallbackApi {
        pigeonRegistrar.apiDelegate.pigeonApiZoomCallbackApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomSuggestionOptionsApi {
        pigeonRegistrar.apiDelegate.pigeonApiZoomSuggestionOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? BarcodeScannerOptionsApi {
        pigeonRegistrar.apiDelegate.pigeonApiBarcodeScannerOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MlImageApi {
        pigeonRegistrar.apiDelegate.pigeonApiMlImageApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? InputImageApi {
        pigeonRegistrar.apiDelegate.pigeonApiInputImageApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? BarcodeScannerApi {
        pigeonRegistrar.apiDelegate.pigeonApiBarcodeScannerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FaceDetectorOptionsApi {
        pigeonRegistrar.apiDelegate.pigeonApiFaceDetectorOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FaceContourApi {
        pigeonRegistrar.apiDelegate.pigeonApiFaceContourApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FaceLandmarkApi {
        pigeonRegistrar.apiDelegate.pigeonApiFaceLandmarkApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FaceApi {
        pigeonRegistrar.apiDelegate.pigeonApiFaceApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FaceDetectorApi {
        pigeonRegistrar.apiDelegate.pigeonApiFaceDetectorApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? DetectorApi {
        pigeonRegistrar.apiDelegate.pigeonApiDetectorApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CloseableApi {
        pigeonRegistrar.apiDelegate.pigeonApiCloseableApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AutoCloseableApi {
        pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MlKitAnalyzerResultApi {
        pigeonRegistrar.apiDelegate.pigeonApiMlKitAnalyzerResultApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MlKitAnalyzerResultConsumerApi {
        pigeonRegistrar.apiDelegate.pigeonApiMlKitAnalyzerResultConsumerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MlKitAnalyzerApi {
        pigeonRegistrar.apiDelegate.pigeonApiMlKitAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AnalyzerApi {
        pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? QualityApi {
        pigeonRegistrar.apiDelegate.pigeonApiQualityApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FallbackStrategyApi {
        pigeonRegistrar.apiDelegate.pigeonApiFallbackStrategyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? QualitySelectorApi {
        pigeonRegistrar.apiDelegate.pigeonApiQualitySelectorApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FileOutputOptionsApi {
        pigeonRegistrar.apiDelegate.pigeonApiFileOutputOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AudioConfigApi {
        pigeonRegistrar.apiDelegate.pigeonApiAudioConfigApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AudioStatsApi {
        pigeonRegistrar.apiDelegate.pigeonApiAudioStatsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RecordingStatsApi {
        pigeonRegistrar.apiDelegate.pigeonApiRecordingStatsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordStatusEventApi {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordStatusEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordStartEventApi {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordStartEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordPauseEventApi {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordPauseEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordResumeEventApi {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordResumeEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OutputResultsApi {
        pigeonRegistrar.apiDelegate.pigeonApiOutputResultsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordFinalizeEventApi {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordFinalizeEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEventApi {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEventConsumerApi {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventConsumerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RecordingApi {
        pigeonRegistrar.apiDelegate.pigeonApiRecordingApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? LifecycleCameraControllerApi {
        pigeonRegistrar.apiDelegate.pigeonApiLifecycleCameraControllerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraControllerApi {
        pigeonRegistrar.apiDelegate.pigeonApiCameraControllerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PreviewViewApi {
        pigeonRegistrar.apiDelegate.pigeonApiPreviewViewApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Camera2CameraControlApi {
        pigeonRegistrar.apiDelegate.pigeonApiCamera2CameraControlApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Camera2CameraInfoApi {
        pigeonRegistrar.apiDelegate.pigeonApiCamera2CameraInfoApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CaptureRequestOptionsApi {
        pigeonRegistrar.apiDelegate.pigeonApiCaptureRequestOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as AnyObject?, pigeonRegistrar.instanceManager.containsInstance(instance)
      {
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance)!)
      } else {
        print("Unsupported value: \(value) of \(type(of: value))")
        assert(false, "Unsupported value for CameraXPigeonInternalProxyApiCodecWriter")
      }

    }
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar) {
    self.pigeonRegistrar = pigeonRegistrar
  }

  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraXPigeonInternalProxyApiCodecReader(data: data, pigeonRegistrar: pigeonRegistrar)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraXPigeonInternalProxyApiCodecWriter(data: data, pigeonRegistrar: pigeonRegistrar)
  }
}

enum PermissionApi: Int {
  case album = 0
  case audio = 1
  case video = 2
}

enum LensFacingApi: Int {
  case unknown = 0
  case front = 1
  case back = 2
  case external = 3
}

enum CameraStateApi: Int {
  case pendingOpen = 0
  case opening = 1
  case open = 2
  case closing = 3
  case closed = 4
}

enum TorchStateApi: Int {
  case off = 0
  case on = 1
}

enum MeteringModeApi: Int {
  case af = 0
  case ae = 1
  case awb = 2
}

enum TimeUnitApi: Int {
  case nanoseconds = 0
  case microseconds = 1
  case milliseconds = 2
  case seconds = 3
  case minutes = 4
  case hours = 5
  case days = 6
}

enum AspectRatioApi: Int {
  case ratioDefault = 0
  case ratio43 = 1
  case ratio169 = 2
}

enum BitDepthApi: Int {
  case bitDepthUnspecified = 0
  case bitDepth8Bit = 1
  case bitDepth10Bit = 2
}

enum EncodingApi: Int {
  case unspecified = 0
  case sdr = 1
  case hdrUnspecified = 2
  case hlg = 3
  case hdr10 = 4
  case hdr10Plus = 5
  case dolbyVision = 6
}

enum ScaleTypeApi: Int {
  case fillStart = 0
  case fillCenter = 1
  case fillEnd = 2
  case fitStart = 3
  case fitCenter = 4
  case fitEnd = 5
}

enum UseCaseApi: Int {
  case imageCapture = 0
  case imageAnalysis = 1
  case videoCapture = 2
}

enum ResolutionModeApi: Int {
  case preferCaptureRateOverHigherResolution = 0
  case preferHigherResolutionOverCaptureRate = 1
}

enum AspectRatioFallbackRuleApi: Int {
  case none = 0
  case auto = 1
}

enum ResolutionFallbackRuleApi: Int {
  case none = 0
  case closestHigherThenLower = 1
  case closestHigher = 2
  case closestLowerThenHigher = 3
  case closestLower = 4
}

enum CaptureModeApi: Int {
  case maximizeQuality = 0
  case minimizeLatency = 1
  case zeroShutterLag = 2
}

enum FlashModeApi: Int {
  case auto = 0
  case on = 1
  case off = 2
  case screen = 3
}

enum BackpressureStrategyApi: Int {
  case keepOnlyLatest = 0
  case blockProducer = 1
}

enum CoordinateSystemApi: Int {
  case original = 0
  case sensor = 1
  case viewReferenced = 2
}

enum ImageFormatApi: Int {
  case yuv420888 = 0
  case rgba8888 = 1
  case jpeg = 2
  case jpegR = 3
}

enum MirrorModeApi: Int {
  case off = 0
  case on = 1
  case onFrontOnly = 2
}

enum AudioStateApi: Int {
  case active = 0
  case disabled = 1
  case sourceSilenced = 2
  case encoderError = 3
  case sourceError = 4
  case muted = 5
}

enum VideoRecordFinalizeEventErrorApi: Int {
  case none = 0
  case unknown = 1
  case fileSizeLimitReached = 2
  case insufficientStorage = 3
  case sourceInactive = 4
  case invalidOuputOptions = 5
  case encodingFailed = 6
  case recorderError = 7
  case noValidData = 8
  case durationLimitReached = 9
  case recordingGarbageCollected = 10
}

enum BarcodeFormatApi: Int {
  case unknown = 0
  case all = 1
  case code128 = 2
  case code39 = 3
  case code93 = 4
  case codabar = 5
  case dataMatrix = 6
  case ean13 = 7
  case ean8 = 8
  case itf = 9
  case qrCode = 10
  case upcA = 11
  case upcE = 12
  case pdf417 = 13
  case aztec = 14
}

enum BarcodeValueTypeApi: Int {
  case unknown = 0
  case contactInfo = 1
  case email = 2
  case isbn = 3
  case phone = 4
  case product = 5
  case sms = 6
  case text = 7
  case url = 8
  case wifi = 9
  case geo = 10
  case calendarEvent = 11
  case driverLicense = 12
}

enum AddressTypeApi: Int {
  case unknown = 0
  case work = 1
  case home = 2
}

enum EmailTypeApi: Int {
  case unknown = 0
  case work = 1
  case home = 2
}

enum PhoneTypeApi: Int {
  case unknown = 0
  case work = 1
  case home = 2
  case fax = 3
  case mobile = 4
}

enum WiFiEncryptionTypeApi: Int {
  case open = 0
  case wpa = 1
  case wep = 2
}

enum FaceClassificationModeApi: Int {
  case none = 0
  case all = 1
}

enum FaceContourModeApi: Int {
  case none = 0
  case all = 1
}

enum FaceLandmarkModeApi: Int {
  case none = 0
  case all = 1
}

enum FacePerformanceModeApi: Int {
  case fast = 0
  case accurate = 1
}

enum FaceContourTypeApi: Int {
  case face = 0
  case leftCheek = 1
  case leftEye = 2
  case leftEyebrowBottom = 3
  case leftEyebrowTop = 4
  case lowerLipBottom = 5
  case lowerLipTop = 6
  case noseBottom = 7
  case noseBridge = 8
  case rightCheek = 9
  case rightEye = 10
  case rightEyebrowBottom = 11
  case rightEyebrowTop = 12
  case upperLipBottom = 13
  case upperLipTop = 14
}

enum FaceLandmarkTypeApi: Int {
  case leftCheek = 0
  case leftEar = 1
  case leftEye = 2
  case mouthBottom = 3
  case mouthLeft = 4
  case mouthRight = 5
  case noseBase = 6
  case rightCheek = 7
  case rightEar = 8
  case rightEye = 9
}

enum ControlModeApi: Int {
  case auto = 0
  case off = 1
  case offKeepState = 2
  case useExtendedSceneMode = 3
  case useSceneMode = 4
}

enum ControlAeModeApi: Int {
  case off = 0
  case on = 1
  case onAlwaysFlash = 2
  case onAutoFlash = 3
  case onAutoFlashRedeye = 4
  case onExternalFlash = 5
  case onLowLightBoostBrightnessPriority = 6
}

enum ControlAfModeApi: Int {
  case auto = 0
  case continuousPicture = 1
  case edof = 2
  case macro = 3
  case off = 4
}

enum ControlAwbModeApi: Int {
  case auto = 0
  case cloudyDaylight = 1
  case daylight = 2
  case fluorescent = 3
  case incandesecent = 4
  case off = 5
  case shade = 6
  case twilight = 7
  case warmFluorescent = 8
}

private class CameraXPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PermissionApi(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return LensFacingApi(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CameraStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TorchStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MeteringModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TimeUnitApi(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AspectRatioApi(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BitDepthApi(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return EncodingApi(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ScaleTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UseCaseApi(rawValue: enumResultAsInt)
      }
      return nil
    case 140:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResolutionModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 141:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AspectRatioFallbackRuleApi(rawValue: enumResultAsInt)
      }
      return nil
    case 142:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResolutionFallbackRuleApi(rawValue: enumResultAsInt)
      }
      return nil
    case 143:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CaptureModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 144:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FlashModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 145:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BackpressureStrategyApi(rawValue: enumResultAsInt)
      }
      return nil
    case 146:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CoordinateSystemApi(rawValue: enumResultAsInt)
      }
      return nil
    case 147:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageFormatApi(rawValue: enumResultAsInt)
      }
      return nil
    case 148:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MirrorModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 149:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AudioStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 150:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VideoRecordFinalizeEventErrorApi(rawValue: enumResultAsInt)
      }
      return nil
    case 151:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BarcodeFormatApi(rawValue: enumResultAsInt)
      }
      return nil
    case 152:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BarcodeValueTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 153:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AddressTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 154:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return EmailTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 155:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PhoneTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 156:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return WiFiEncryptionTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 157:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FaceClassificationModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 158:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FaceContourModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 159:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FaceLandmarkModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 160:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FacePerformanceModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 161:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FaceContourTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 162:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FaceLandmarkTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 163:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 164:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAeModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 165:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAfModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 166:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAwbModeApi(rawValue: enumResultAsInt)
      }
      return nil
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class CameraXPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PermissionApi {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? LensFacingApi {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? CameraStateApi {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? TorchStateApi {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? MeteringModeApi {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? TimeUnitApi {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? AspectRatioApi {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? BitDepthApi {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? EncodingApi {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? ScaleTypeApi {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? UseCaseApi {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResolutionModeApi {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? AspectRatioFallbackRuleApi {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResolutionFallbackRuleApi {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else if let value = value as? CaptureModeApi {
      super.writeByte(143)
      super.writeValue(value.rawValue)
    } else if let value = value as? FlashModeApi {
      super.writeByte(144)
      super.writeValue(value.rawValue)
    } else if let value = value as? BackpressureStrategyApi {
      super.writeByte(145)
      super.writeValue(value.rawValue)
    } else if let value = value as? CoordinateSystemApi {
      super.writeByte(146)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageFormatApi {
      super.writeByte(147)
      super.writeValue(value.rawValue)
    } else if let value = value as? MirrorModeApi {
      super.writeByte(148)
      super.writeValue(value.rawValue)
    } else if let value = value as? AudioStateApi {
      super.writeByte(149)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoRecordFinalizeEventErrorApi {
      super.writeByte(150)
      super.writeValue(value.rawValue)
    } else if let value = value as? BarcodeFormatApi {
      super.writeByte(151)
      super.writeValue(value.rawValue)
    } else if let value = value as? BarcodeValueTypeApi {
      super.writeByte(152)
      super.writeValue(value.rawValue)
    } else if let value = value as? AddressTypeApi {
      super.writeByte(153)
      super.writeValue(value.rawValue)
    } else if let value = value as? EmailTypeApi {
      super.writeByte(154)
      super.writeValue(value.rawValue)
    } else if let value = value as? PhoneTypeApi {
      super.writeByte(155)
      super.writeValue(value.rawValue)
    } else if let value = value as? WiFiEncryptionTypeApi {
      super.writeByte(156)
      super.writeValue(value.rawValue)
    } else if let value = value as? FaceClassificationModeApi {
      super.writeByte(157)
      super.writeValue(value.rawValue)
    } else if let value = value as? FaceContourModeApi {
      super.writeByte(158)
      super.writeValue(value.rawValue)
    } else if let value = value as? FaceLandmarkModeApi {
      super.writeByte(159)
      super.writeValue(value.rawValue)
    } else if let value = value as? FacePerformanceModeApi {
      super.writeByte(160)
      super.writeValue(value.rawValue)
    } else if let value = value as? FaceContourTypeApi {
      super.writeByte(161)
      super.writeValue(value.rawValue)
    } else if let value = value as? FaceLandmarkTypeApi {
      super.writeByte(162)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlModeApi {
      super.writeByte(163)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAeModeApi {
      super.writeByte(164)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAfModeApi {
      super.writeByte(165)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAwbModeApi {
      super.writeByte(166)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class CameraXPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraXPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraXPigeonCodecWriter(data: data)
  }
}

class CameraXPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = CameraXPigeonCodec(readerWriter: CameraXPigeonCodecReaderWriter())
}

protocol PigeonApiDelegatePermissionManagerApi {
  func instance(pigeonApi: PigeonApiPermissionManagerApi) throws -> PermissionManagerApi
  func checkPermissioin(pigeonApi: PigeonApiPermissionManagerApi, pigeonInstance: PermissionManagerApi, permission: PermissionApi) throws -> Bool
  func requestPermissions(pigeonApi: PigeonApiPermissionManagerApi, pigeonInstance: PermissionManagerApi, permissions: [PermissionApi], completion: @escaping (Result<Bool, Error>) -> Void)
}

protocol PigeonApiProtocolPermissionManagerApi {
}

final class PigeonApiPermissionManagerApi: PigeonApiProtocolPermissionManagerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePermissionManagerApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePermissionManagerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPermissionManagerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let instanceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.instance", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      instanceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.instance(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      instanceChannel.setMessageHandler(nil)
    }
    let checkPermissioinChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.checkPermissioin", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      checkPermissioinChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PermissionManagerApi
        let permissionArg = args[1] as! PermissionApi
        do {
          let result = try api.pigeonDelegate.checkPermissioin(pigeonApi: api, pigeonInstance: pigeonInstanceArg, permission: permissionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      checkPermissioinChannel.setMessageHandler(nil)
    }
    let requestPermissionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.requestPermissions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestPermissionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PermissionManagerApi
        let permissionsArg = args[1] as! [PermissionApi]
        api.pigeonDelegate.requestPermissions(pigeonApi: api, pigeonInstance: pigeonInstanceArg, permissions: permissionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      requestPermissionsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PermissionManagerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PermissionManagerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAutoCloseableApi {
  func close(pigeonApi: PigeonApiAutoCloseableApi, pigeonInstance: AutoCloseableApi) throws
}

protocol PigeonApiProtocolAutoCloseableApi {
}

final class PigeonApiAutoCloseableApi: PigeonApiProtocolAutoCloseableApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAutoCloseableApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAutoCloseableApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAutoCloseableApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let closeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AutoCloseableApi.close", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! AutoCloseableApi
        do {
          try api.pigeonDelegate.close(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      closeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AutoCloseableApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AutoCloseableApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AutoCloseableApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateCloseableApi {
}

protocol PigeonApiProtocolCloseableApi {
}

final class PigeonApiCloseableApi: PigeonApiProtocolCloseableApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCloseableApi
  ///An implementation of [AutoCloseableApi] used to access callback methods
  var pigeonApiAutoCloseableApi: PigeonApiAutoCloseableApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCloseableApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CloseableApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CloseableApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CloseableApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateLocationApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiLocationApi, latitude: Double, longitude: Double) throws -> LocationApi
  func latitude(pigeonApi: PigeonApiLocationApi, pigeonInstance: LocationApi) throws -> Double
  func longitude(pigeonApi: PigeonApiLocationApi, pigeonInstance: LocationApi) throws -> Double
}

protocol PigeonApiProtocolLocationApi {
}

final class PigeonApiLocationApi: PigeonApiProtocolLocationApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateLocationApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateLocationApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiLocationApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.LocationApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let latitudeArg = args[1] as! Double
        let longitudeArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, latitude: latitudeArg, longitude: longitudeArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of LocationApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: LocationApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let latitudeArg = try! pigeonDelegate.latitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let longitudeArg = try! pigeonDelegate.longitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.LocationApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, latitudeArg, longitudeArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSizeApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiSizeApi, width: Int64, height: Int64) throws -> SizeApi
  func width(pigeonApi: PigeonApiSizeApi, pigeonInstance: SizeApi) throws -> Int64
  func height(pigeonApi: PigeonApiSizeApi, pigeonInstance: SizeApi) throws -> Int64
}

protocol PigeonApiProtocolSizeApi {
}

final class PigeonApiSizeApi: PigeonApiProtocolSizeApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSizeApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSizeApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiSizeApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.SizeApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let widthArg = args[1] as! Int64
        let heightArg = args[2] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, width: widthArg, height: heightArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of SizeApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: SizeApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SizeApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, widthArg, heightArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePointApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPointApi, x: Int64, y: Int64) throws -> PointApi
  func x(pigeonApi: PigeonApiPointApi, pigeonInstance: PointApi) throws -> Int64
  func y(pigeonApi: PigeonApiPointApi, pigeonInstance: PointApi) throws -> Int64
}

protocol PigeonApiProtocolPointApi {
}

final class PigeonApiPointApi: PigeonApiProtocolPointApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePointApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePointApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPointApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PointApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let xArg = args[1] as! Int64
        let yArg = args[2] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, x: xArg, y: yArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PointApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PointApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let xArg = try! pigeonDelegate.x(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yArg = try! pigeonDelegate.y(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PointApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, xArg, yArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePointFApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPointFApi, x: Double, y: Double) throws -> PointFApi
  func x(pigeonApi: PigeonApiPointFApi, pigeonInstance: PointFApi) throws -> Double
  func y(pigeonApi: PigeonApiPointFApi, pigeonInstance: PointFApi) throws -> Double
}

protocol PigeonApiProtocolPointFApi {
}

final class PigeonApiPointFApi: PigeonApiProtocolPointFApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePointFApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePointFApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPointFApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PointFApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, x: xArg, y: yArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PointFApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PointFApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let xArg = try! pigeonDelegate.x(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yArg = try! pigeonDelegate.y(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PointFApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, xArg, yArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRectApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiRectApi, left: Int64, top: Int64, right: Int64, bottom: Int64) throws -> RectApi
  func left(pigeonApi: PigeonApiRectApi, pigeonInstance: RectApi) throws -> Int64
  func top(pigeonApi: PigeonApiRectApi, pigeonInstance: RectApi) throws -> Int64
  func right(pigeonApi: PigeonApiRectApi, pigeonInstance: RectApi) throws -> Int64
  func bottom(pigeonApi: PigeonApiRectApi, pigeonInstance: RectApi) throws -> Int64
}

protocol PigeonApiProtocolRectApi {
}

final class PigeonApiRectApi: PigeonApiProtocolRectApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRectApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRectApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RectApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let leftArg = args[1] as! Int64
        let topArg = args[2] as! Int64
        let rightArg = args[3] as! Int64
        let bottomArg = args[4] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, left: leftArg, top: topArg, right: rightArg, bottom: bottomArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RectApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RectApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let leftArg = try! pigeonDelegate.left(pigeonApi: self, pigeonInstance: pigeonInstance)
      let topArg = try! pigeonDelegate.top(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rightArg = try! pigeonDelegate.right(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bottomArg = try! pigeonDelegate.bottom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, leftArg, topArg, rightArg, bottomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateIntRangeApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiIntRangeApi, lower: Int64, upper: Int64) throws -> IntRangeApi
  func lower(pigeonApi: PigeonApiIntRangeApi, pigeonInstance: IntRangeApi) throws -> Int64
  func upper(pigeonApi: PigeonApiIntRangeApi, pigeonInstance: IntRangeApi) throws -> Int64
}

protocol PigeonApiProtocolIntRangeApi {
}

final class PigeonApiIntRangeApi: PigeonApiProtocolIntRangeApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateIntRangeApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateIntRangeApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiIntRangeApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.IntRangeApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let lowerArg = args[1] as! Int64
        let upperArg = args[2] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, lower: lowerArg, upper: upperArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of IntRangeApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: IntRangeApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let lowerArg = try! pigeonDelegate.lower(pigeonApi: self, pigeonInstance: pigeonInstance)
      let upperArg = try! pigeonDelegate.upper(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.IntRangeApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, lowerArg, upperArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateLongRangeApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiLongRangeApi, lower: Int64, upper: Int64) throws -> LongRangeApi
  func lower(pigeonApi: PigeonApiLongRangeApi, pigeonInstance: LongRangeApi) throws -> Int64
  func upper(pigeonApi: PigeonApiLongRangeApi, pigeonInstance: LongRangeApi) throws -> Int64
}

protocol PigeonApiProtocolLongRangeApi {
}

final class PigeonApiLongRangeApi: PigeonApiProtocolLongRangeApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateLongRangeApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateLongRangeApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiLongRangeApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.LongRangeApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let lowerArg = args[1] as! Int64
        let upperArg = args[2] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, lower: lowerArg, upper: upperArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of LongRangeApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: LongRangeApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let lowerArg = try! pigeonDelegate.lower(pigeonApi: self, pigeonInstance: pigeonInstance)
      let upperArg = try! pigeonDelegate.upper(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.LongRangeApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, lowerArg, upperArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraSelectorApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraSelectorApi, lensFacing: LensFacingApi?) throws -> CameraSelectorApi
  func front(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelectorApi
  func back(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelectorApi
  func external(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelectorApi
}

protocol PigeonApiProtocolCameraSelectorApi {
}

final class PigeonApiCameraSelectorApi: PigeonApiProtocolCameraSelectorApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraSelectorApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraSelectorApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraSelectorApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let lensFacingArg: LensFacingApi? = nilOrValue(args[1])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, lensFacing: lensFacingArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let frontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.front", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      frontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.front(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      frontChannel.setMessageHandler(nil)
    }
    let backChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.back", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      backChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.back(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      backChannel.setMessageHandler(nil)
    }
    let externalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.external", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      externalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.external(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      externalChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraSelectorApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraSelectorApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraStateLiveDataApi {
  func getValue(pigeonApi: PigeonApiCameraStateLiveDataApi, pigeonInstance: CameraStateLiveDataApi) throws -> CameraStateApi?
  func observe(pigeonApi: PigeonApiCameraStateLiveDataApi, pigeonInstance: CameraStateLiveDataApi, observer: CameraStateObserverApi) throws
  func removeObserver(pigeonApi: PigeonApiCameraStateLiveDataApi, pigeonInstance: CameraStateLiveDataApi, observer: CameraStateObserverApi) throws
}

protocol PigeonApiProtocolCameraStateLiveDataApi {
}

final class PigeonApiCameraStateLiveDataApi: PigeonApiProtocolCameraStateLiveDataApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraStateLiveDataApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraStateLiveDataApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraStateLiveDataApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateLiveDataApi.getValue", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraStateLiveDataApi
        do {
          let result = try api.pigeonDelegate.getValue(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getValueChannel.setMessageHandler(nil)
    }
    let observeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateLiveDataApi.observe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraStateLiveDataApi
        let observerArg = args[1] as! CameraStateObserverApi
        do {
          try api.pigeonDelegate.observe(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateLiveDataApi.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraStateLiveDataApi
        let observerArg = args[1] as! CameraStateObserverApi
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraStateLiveDataApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraStateLiveDataApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraStateLiveDataApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraStateObserverApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraStateObserverApi) throws -> CameraStateObserverApi
}

protocol PigeonApiProtocolCameraStateObserverApi {
  func onChanged(pigeonInstance pigeonInstanceArg: CameraStateObserverApi, value valueArg: CameraStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiCameraStateObserverApi: PigeonApiProtocolCameraStateObserverApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraStateObserverApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraStateObserverApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraStateObserverApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateObserverApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraStateObserverApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraStateObserverApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of CameraStateObserverApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: CameraStateObserverApi, value valueArg: CameraStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraStateObserverApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateTorchStateLiveDataApi {
  func getValue(pigeonApi: PigeonApiTorchStateLiveDataApi, pigeonInstance: TorchStateLiveDataApi) throws -> TorchStateApi?
  func observe(pigeonApi: PigeonApiTorchStateLiveDataApi, pigeonInstance: TorchStateLiveDataApi, observer: TorchStateObserverApi) throws
  func removeObserver(pigeonApi: PigeonApiTorchStateLiveDataApi, pigeonInstance: TorchStateLiveDataApi, observer: TorchStateObserverApi) throws
}

protocol PigeonApiProtocolTorchStateLiveDataApi {
}

final class PigeonApiTorchStateLiveDataApi: PigeonApiProtocolTorchStateLiveDataApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateTorchStateLiveDataApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateTorchStateLiveDataApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiTorchStateLiveDataApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateLiveDataApi.getValue", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! TorchStateLiveDataApi
        do {
          let result = try api.pigeonDelegate.getValue(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getValueChannel.setMessageHandler(nil)
    }
    let observeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateLiveDataApi.observe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! TorchStateLiveDataApi
        let observerArg = args[1] as! TorchStateObserverApi
        do {
          try api.pigeonDelegate.observe(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateLiveDataApi.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! TorchStateLiveDataApi
        let observerArg = args[1] as! TorchStateObserverApi
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of TorchStateLiveDataApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: TorchStateLiveDataApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.TorchStateLiveDataApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateTorchStateObserverApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiTorchStateObserverApi) throws -> TorchStateObserverApi
}

protocol PigeonApiProtocolTorchStateObserverApi {
  func onChanged(pigeonInstance pigeonInstanceArg: TorchStateObserverApi, value valueArg: TorchStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiTorchStateObserverApi: PigeonApiProtocolTorchStateObserverApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateTorchStateObserverApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateTorchStateObserverApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiTorchStateObserverApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateObserverApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of TorchStateObserverApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: TorchStateObserverApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of TorchStateObserverApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: TorchStateObserverApi, value valueArg: TorchStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.TorchStateObserverApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateZoomStateApi {
  func minZoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomStateApi) throws -> Double
  func maxZoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomStateApi) throws -> Double
  func zoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomStateApi) throws -> Double
  func linearZoom(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomStateApi) throws -> Double
}

protocol PigeonApiProtocolZoomStateApi {
}

final class PigeonApiZoomStateApi: PigeonApiProtocolZoomStateApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ZoomStateApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let minZoomRatioArg = try! pigeonDelegate.minZoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let maxZoomRatioArg = try! pigeonDelegate.maxZoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let zoomRatioArg = try! pigeonDelegate.zoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let linearZoomArg = try! pigeonDelegate.linearZoom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, minZoomRatioArg, maxZoomRatioArg, zoomRatioArg, linearZoomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateZoomStateLiveDataApi {
  func getValue(pigeonApi: PigeonApiZoomStateLiveDataApi, pigeonInstance: ZoomStateLiveDataApi) throws -> ZoomStateApi?
  func observe(pigeonApi: PigeonApiZoomStateLiveDataApi, pigeonInstance: ZoomStateLiveDataApi, observer: ZoomStateObserverApi) throws
  func removeObserver(pigeonApi: PigeonApiZoomStateLiveDataApi, pigeonInstance: ZoomStateLiveDataApi, observer: ZoomStateObserverApi) throws
}

protocol PigeonApiProtocolZoomStateLiveDataApi {
}

final class PigeonApiZoomStateLiveDataApi: PigeonApiProtocolZoomStateLiveDataApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateLiveDataApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateLiveDataApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiZoomStateLiveDataApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateLiveDataApi.getValue", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ZoomStateLiveDataApi
        do {
          let result = try api.pigeonDelegate.getValue(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getValueChannel.setMessageHandler(nil)
    }
    let observeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateLiveDataApi.observe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ZoomStateLiveDataApi
        let observerArg = args[1] as! ZoomStateObserverApi
        do {
          try api.pigeonDelegate.observe(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateLiveDataApi.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ZoomStateLiveDataApi
        let observerArg = args[1] as! ZoomStateObserverApi
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ZoomStateLiveDataApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomStateLiveDataApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateLiveDataApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateZoomStateObserverApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiZoomStateObserverApi) throws -> ZoomStateObserverApi
}

protocol PigeonApiProtocolZoomStateObserverApi {
  func onChanged(pigeonInstance pigeonInstanceArg: ZoomStateObserverApi, value valueArg: ZoomStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiZoomStateObserverApi: PigeonApiProtocolZoomStateObserverApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateObserverApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateObserverApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiZoomStateObserverApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateObserverApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ZoomStateObserverApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomStateObserverApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ZoomStateObserverApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: ZoomStateObserverApi, value valueArg: ZoomStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateObserverApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateExposureStateApi {
  func exposureCompensationIndex(pigeonApi: PigeonApiExposureStateApi, pigeonInstance: ExposureStateApi) throws -> Int64
  func exposureCompensationRange(pigeonApi: PigeonApiExposureStateApi, pigeonInstance: ExposureStateApi) throws -> IntRangeApi
  func exposureCompensationStep(pigeonApi: PigeonApiExposureStateApi, pigeonInstance: ExposureStateApi) throws -> Double
  func isExposureCompensationSupported(pigeonApi: PigeonApiExposureStateApi, pigeonInstance: ExposureStateApi) throws -> Bool
}

protocol PigeonApiProtocolExposureStateApi {
}

final class PigeonApiExposureStateApi: PigeonApiProtocolExposureStateApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateExposureStateApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateExposureStateApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ExposureStateApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ExposureStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let exposureCompensationIndexArg = try! pigeonDelegate.exposureCompensationIndex(pigeonApi: self, pigeonInstance: pigeonInstance)
      let exposureCompensationRangeArg = try! pigeonDelegate.exposureCompensationRange(pigeonApi: self, pigeonInstance: pigeonInstance)
      let exposureCompensationStepArg = try! pigeonDelegate.exposureCompensationStep(pigeonApi: self, pigeonInstance: pigeonInstance)
      let isExposureCompensationSupportedArg = try! pigeonDelegate.isExposureCompensationSupported(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ExposureStateApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, exposureCompensationIndexArg, exposureCompensationRangeArg, exposureCompensationStepArg, isExposureCompensationSupportedArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMeteringPointApi {
  func size(pigeonApi: PigeonApiMeteringPointApi, pigeonInstance: MeteringPointApi) throws -> Double
}

protocol PigeonApiProtocolMeteringPointApi {
}

final class PigeonApiMeteringPointApi: PigeonApiProtocolMeteringPointApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of MeteringPointApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPointApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let sizeArg = try! pigeonDelegate.size(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, sizeArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMeteringPointFactoryApi {
  func createPoint(pigeonApi: PigeonApiMeteringPointFactoryApi, pigeonInstance: MeteringPointFactoryApi, x: Double, y: Double, size: Double?) throws -> MeteringPointApi
}

protocol PigeonApiProtocolMeteringPointFactoryApi {
}

final class PigeonApiMeteringPointFactoryApi: PigeonApiProtocolMeteringPointFactoryApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointFactoryApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointFactoryApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMeteringPointFactoryApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let createPointChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MeteringPointFactoryApi.createPoint", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createPointChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! MeteringPointFactoryApi
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        let sizeArg: Double? = nilOrValue(args[3])
        do {
          let result = try api.pigeonDelegate.createPoint(pigeonApi: api, pigeonInstance: pigeonInstanceArg, x: xArg, y: yArg, size: sizeArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createPointChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MeteringPointFactoryApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPointFactoryApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointFactoryApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSurfaceOrientedMeteringPointFactoryApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiSurfaceOrientedMeteringPointFactoryApi, width: Double, height: Double) throws -> SurfaceOrientedMeteringPointFactoryApi
}

protocol PigeonApiProtocolSurfaceOrientedMeteringPointFactoryApi {
}

final class PigeonApiSurfaceOrientedMeteringPointFactoryApi: PigeonApiProtocolSurfaceOrientedMeteringPointFactoryApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSurfaceOrientedMeteringPointFactoryApi
  ///An implementation of [MeteringPointFactoryApi] used to access callback methods
  var pigeonApiMeteringPointFactoryApi: PigeonApiMeteringPointFactoryApi {
    return pigeonRegistrar.apiDelegate.pigeonApiMeteringPointFactoryApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSurfaceOrientedMeteringPointFactoryApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiSurfaceOrientedMeteringPointFactoryApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.SurfaceOrientedMeteringPointFactoryApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let widthArg = args[1] as! Double
        let heightArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, width: widthArg, height: heightArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of SurfaceOrientedMeteringPointFactoryApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: SurfaceOrientedMeteringPointFactoryApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SurfaceOrientedMeteringPointFactoryApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMeteringPointTupleApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiMeteringPointTupleApi, point: MeteringPointApi, modes: [MeteringModeApi]?) throws -> MeteringPointTupleApi
}

protocol PigeonApiProtocolMeteringPointTupleApi {
}

final class PigeonApiMeteringPointTupleApi: PigeonApiProtocolMeteringPointTupleApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointTupleApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointTupleApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMeteringPointTupleApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MeteringPointTupleApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let pointArg = args[1] as! MeteringPointApi
        let modesArg: [MeteringModeApi]? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, point: pointArg, modes: modesArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MeteringPointTupleApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPointTupleApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointTupleApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateDurationTupleApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiDurationTupleApi, duration: Int64, timeUnit: TimeUnitApi) throws -> DurationTupleApi
}

protocol PigeonApiProtocolDurationTupleApi {
}

final class PigeonApiDurationTupleApi: PigeonApiProtocolDurationTupleApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateDurationTupleApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateDurationTupleApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiDurationTupleApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.DurationTupleApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let durationArg = args[1] as! Int64
        let timeUnitArg = args[2] as! TimeUnitApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, duration: durationArg, timeUnit: timeUnitArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of DurationTupleApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: DurationTupleApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.DurationTupleApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFocusMeteringActionApi {
  func build(pigeonApi: PigeonApiFocusMeteringActionApi, first: MeteringPointTupleApi, others: [MeteringPointTupleApi]?, disableAutoCancel: Bool?, autoCancelDuration: DurationTupleApi?) throws -> FocusMeteringActionApi
  func getAutoCancelDurationInMillis(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringActionApi) throws -> Int64
  func getMeteringPointsAe(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringActionApi) throws -> [MeteringPointApi]
  func getMeteringPointsAf(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringActionApi) throws -> [MeteringPointApi]
  func getMeteringPointsAwb(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringActionApi) throws -> [MeteringPointApi]
  func isAutoCancelEnabled(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringActionApi) throws -> Bool
}

protocol PigeonApiProtocolFocusMeteringActionApi {
}

final class PigeonApiFocusMeteringActionApi: PigeonApiProtocolFocusMeteringActionApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFocusMeteringActionApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFocusMeteringActionApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFocusMeteringActionApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let firstArg = args[1] as! MeteringPointTupleApi
        let othersArg: [MeteringPointTupleApi]? = nilOrValue(args[2])
        let disableAutoCancelArg: Bool? = nilOrValue(args[3])
        let autoCancelDurationArg: DurationTupleApi? = nilOrValue(args[4])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, first: firstArg, others: othersArg, disableAutoCancel: disableAutoCancelArg, autoCancelDuration: autoCancelDurationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
    let getAutoCancelDurationInMillisChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.getAutoCancelDurationInMillis", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAutoCancelDurationInMillisChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringActionApi
        do {
          let result = try api.pigeonDelegate.getAutoCancelDurationInMillis(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAutoCancelDurationInMillisChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.getMeteringPointsAe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringActionApi
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAe(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAeChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.getMeteringPointsAf", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringActionApi
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAf(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAfChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAwbChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.getMeteringPointsAwb", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAwbChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringActionApi
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAwb(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAwbChannel.setMessageHandler(nil)
    }
    let isAutoCancelEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.isAutoCancelEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isAutoCancelEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringActionApi
        do {
          let result = try api.pigeonDelegate.isAutoCancelEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isAutoCancelEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FocusMeteringActionApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FocusMeteringActionApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFocusMeteringResultApi {
  func isFocusSuccessful(pigeonApi: PigeonApiFocusMeteringResultApi, pigeonInstance: FocusMeteringResultApi) throws -> Bool
}

protocol PigeonApiProtocolFocusMeteringResultApi {
}

final class PigeonApiFocusMeteringResultApi: PigeonApiProtocolFocusMeteringResultApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFocusMeteringResultApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFocusMeteringResultApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of FocusMeteringResultApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FocusMeteringResultApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let isFocusSuccessfulArg = try! pigeonDelegate.isFocusSuccessful(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FocusMeteringResultApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, isFocusSuccessfulArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateDynamicRangeApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiDynamicRangeApi, encoding: EncodingApi, bitDepth: BitDepthApi) throws -> DynamicRangeApi
  func encoding(pigeonApi: PigeonApiDynamicRangeApi, pigeonInstance: DynamicRangeApi) throws -> EncodingApi
  func bitDepth(pigeonApi: PigeonApiDynamicRangeApi, pigeonInstance: DynamicRangeApi) throws -> BitDepthApi
}

protocol PigeonApiProtocolDynamicRangeApi {
}

final class PigeonApiDynamicRangeApi: PigeonApiProtocolDynamicRangeApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateDynamicRangeApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateDynamicRangeApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiDynamicRangeApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.DynamicRangeApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let encodingArg = args[1] as! EncodingApi
        let bitDepthArg = args[2] as! BitDepthApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, encoding: encodingArg, bitDepth: bitDepthArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of DynamicRangeApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: DynamicRangeApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let encodingArg = try! pigeonDelegate.encoding(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bitDepthArg = try! pigeonDelegate.bitDepth(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.DynamicRangeApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, encodingArg, bitDepthArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraInfoApi {
  func mustPlayShutterSound(pigeonApi: PigeonApiCameraInfoApi) throws -> Bool
  func getCameraSelector(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> CameraSelectorApi
  func getCameraState(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> CameraStateLiveDataApi
  func getTorchState(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> TorchStateLiveDataApi
  func getZoomState(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> ZoomStateLiveDataApi
  func getExposureState(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> ExposureStateApi
  func getIntrinsticZoomRatio(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> Double
  func getLensFacing(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> LensFacingApi
  func getPhysicalCameraInfos(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> [CameraInfoApi]
  func getSensorRotationDegrees(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> Int64
  func getSupportedFrameRateRanges(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> [IntRangeApi]
  func isLogicalMultiCameraSupported(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> Bool
  func isZslSupported(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> Bool
  func hasFlashUnit(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi) throws -> Bool
  func isFocusMeteringSupported(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi, action: FocusMeteringActionApi) throws -> Bool
  func querySupportedDynamicRanges(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfoApi, candidateDynamicRanges: [DynamicRangeApi]) throws -> [DynamicRangeApi]
}

protocol PigeonApiProtocolCameraInfoApi {
}

final class PigeonApiCameraInfoApi: PigeonApiProtocolCameraInfoApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraInfoApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraInfoApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraInfoApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let mustPlayShutterSoundChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.mustPlayShutterSound", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      mustPlayShutterSoundChannel.setMessageHandler { _, reply in
        do {
          let result = try api.pigeonDelegate.mustPlayShutterSound(pigeonApi: api)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      mustPlayShutterSoundChannel.setMessageHandler(nil)
    }
    let getCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraSelectorChannel.setMessageHandler(nil)
    }
    let getCameraStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getCameraState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getCameraState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraStateChannel.setMessageHandler(nil)
    }
    let getTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTorchStateChannel.setMessageHandler(nil)
    }
    let getZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getZoomStateChannel.setMessageHandler(nil)
    }
    let getExposureStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getExposureState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getExposureStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getExposureState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getExposureStateChannel.setMessageHandler(nil)
    }
    let getIntrinsticZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getIntrinsticZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIntrinsticZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getIntrinsticZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getIntrinsticZoomRatioChannel.setMessageHandler(nil)
    }
    let getLensFacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getLensFacing", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getLensFacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getLensFacing(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getLensFacingChannel.setMessageHandler(nil)
    }
    let getPhysicalCameraInfosChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getPhysicalCameraInfos", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPhysicalCameraInfosChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getPhysicalCameraInfos(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPhysicalCameraInfosChannel.setMessageHandler(nil)
    }
    let getSensorRotationDegreesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getSensorRotationDegrees", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSensorRotationDegreesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getSensorRotationDegrees(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSensorRotationDegreesChannel.setMessageHandler(nil)
    }
    let getSupportedFrameRateRangesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getSupportedFrameRateRanges", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSupportedFrameRateRangesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getSupportedFrameRateRanges(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSupportedFrameRateRangesChannel.setMessageHandler(nil)
    }
    let isLogicalMultiCameraSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.isLogicalMultiCameraSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isLogicalMultiCameraSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.isLogicalMultiCameraSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isLogicalMultiCameraSupportedChannel.setMessageHandler(nil)
    }
    let isZslSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.isZslSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isZslSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.isZslSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isZslSupportedChannel.setMessageHandler(nil)
    }
    let hasFlashUnitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.hasFlashUnit", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasFlashUnitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        do {
          let result = try api.pigeonDelegate.hasFlashUnit(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasFlashUnitChannel.setMessageHandler(nil)
    }
    let isFocusMeteringSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.isFocusMeteringSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isFocusMeteringSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        let actionArg = args[1] as! FocusMeteringActionApi
        do {
          let result = try api.pigeonDelegate.isFocusMeteringSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg, action: actionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isFocusMeteringSupportedChannel.setMessageHandler(nil)
    }
    let querySupportedDynamicRangesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.querySupportedDynamicRanges", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      querySupportedDynamicRangesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfoApi
        let candidateDynamicRangesArg = args[1] as! [DynamicRangeApi]
        do {
          let result = try api.pigeonDelegate.querySupportedDynamicRanges(pigeonApi: api, pigeonInstance: pigeonInstanceArg, candidateDynamicRanges: candidateDynamicRangesArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      querySupportedDynamicRangesChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraInfoApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraInfoApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraInfoApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraControlApi {
  func enableTorch(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControlApi, torch: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func setZoomRatio(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControlApi, ratio: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func setLinearZoom(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControlApi, linearZoom: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func startFocusAndMetering(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControlApi, action: FocusMeteringActionApi, completion: @escaping (Result<FocusMeteringResultApi, Error>) -> Void)
  func cancelFocusAndMetering(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControlApi, completion: @escaping (Result<Void, Error>) -> Void)
  func setExposureCompensationIndex(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControlApi, value: Int64, completion: @escaping (Result<Int64, Error>) -> Void)
}

protocol PigeonApiProtocolCameraControlApi {
}

final class PigeonApiCameraControlApi: PigeonApiProtocolCameraControlApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraControlApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraControlApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraControlApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let enableTorchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.enableTorch", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableTorchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControlApi
        let torchArg = args[1] as! Bool
        api.pigeonDelegate.enableTorch(pigeonApi: api, pigeonInstance: pigeonInstanceArg, torch: torchArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      enableTorchChannel.setMessageHandler(nil)
    }
    let setZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.setZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControlApi
        let ratioArg = args[1] as! Double
        api.pigeonDelegate.setZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg, ratio: ratioArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setZoomRatioChannel.setMessageHandler(nil)
    }
    let setLinearZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.setLinearZoom", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLinearZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControlApi
        let linearZoomArg = args[1] as! Double
        api.pigeonDelegate.setLinearZoom(pigeonApi: api, pigeonInstance: pigeonInstanceArg, linearZoom: linearZoomArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLinearZoomChannel.setMessageHandler(nil)
    }
    let startFocusAndMeteringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.startFocusAndMetering", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startFocusAndMeteringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControlApi
        let actionArg = args[1] as! FocusMeteringActionApi
        api.pigeonDelegate.startFocusAndMetering(pigeonApi: api, pigeonInstance: pigeonInstanceArg, action: actionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startFocusAndMeteringChannel.setMessageHandler(nil)
    }
    let cancelFocusAndMeteringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.cancelFocusAndMetering", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelFocusAndMeteringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControlApi
        api.pigeonDelegate.cancelFocusAndMetering(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      cancelFocusAndMeteringChannel.setMessageHandler(nil)
    }
    let setExposureCompensationIndexChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.setExposureCompensationIndex", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposureCompensationIndexChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControlApi
        let valueArg = args[1] as! Int64
        api.pigeonDelegate.setExposureCompensationIndex(pigeonApi: api, pigeonInstance: pigeonInstanceArg, value: valueArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setExposureCompensationIndexChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraControlApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraControlApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraControlApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAspectRatioStrategyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiAspectRatioStrategyApi, preferredAspectRatio: AspectRatioApi, fallbackRule: AspectRatioFallbackRuleApi) throws -> AspectRatioStrategyApi
  func preferredAspectRatio(pigeonApi: PigeonApiAspectRatioStrategyApi, pigeonInstance: AspectRatioStrategyApi) throws -> AspectRatioApi
  func fallbackRule(pigeonApi: PigeonApiAspectRatioStrategyApi, pigeonInstance: AspectRatioStrategyApi) throws -> AspectRatioFallbackRuleApi
}

protocol PigeonApiProtocolAspectRatioStrategyApi {
}

final class PigeonApiAspectRatioStrategyApi: PigeonApiProtocolAspectRatioStrategyApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAspectRatioStrategyApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAspectRatioStrategyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAspectRatioStrategyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AspectRatioStrategyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let preferredAspectRatioArg = args[1] as! AspectRatioApi
        let fallbackRuleArg = args[2] as! AspectRatioFallbackRuleApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, preferredAspectRatio: preferredAspectRatioArg, fallbackRule: fallbackRuleArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AspectRatioStrategyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AspectRatioStrategyApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let preferredAspectRatioArg = try! pigeonDelegate.preferredAspectRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let fallbackRuleArg = try! pigeonDelegate.fallbackRule(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AspectRatioStrategyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, preferredAspectRatioArg, fallbackRuleArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateResolutionFilterApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiResolutionFilterApi) throws -> ResolutionFilterApi
}

protocol PigeonApiProtocolResolutionFilterApi {
  func filter(pigeonInstance pigeonInstanceArg: ResolutionFilterApi, supportedSizes supportedSizesArg: [SizeApi], rotationDegrees rotationDegreesArg: Int64, completion: @escaping (Result<[SizeApi], CameraXError>) -> Void)
}

final class PigeonApiResolutionFilterApi: PigeonApiProtocolResolutionFilterApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateResolutionFilterApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateResolutionFilterApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiResolutionFilterApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionFilterApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ResolutionFilterApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ResolutionFilterApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ResolutionFilterApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func filter(pigeonInstance pigeonInstanceArg: ResolutionFilterApi, supportedSizes supportedSizesArg: [SizeApi], rotationDegrees rotationDegreesArg: Int64, completion: @escaping (Result<[SizeApi], CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ResolutionFilterApi.filter"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, supportedSizesArg, rotationDegreesArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(CameraXError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! [SizeApi]
        completion(.success(result))
      }
    }
  }

}
protocol PigeonApiDelegateResolutionStrategyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiResolutionStrategyApi, boundSize: SizeApi?, fallbackRule: ResolutionFallbackRuleApi) throws -> ResolutionStrategyApi
  func boundSize(pigeonApi: PigeonApiResolutionStrategyApi, pigeonInstance: ResolutionStrategyApi) throws -> SizeApi?
  func fallbackRule(pigeonApi: PigeonApiResolutionStrategyApi, pigeonInstance: ResolutionStrategyApi) throws -> ResolutionFallbackRuleApi
}

protocol PigeonApiProtocolResolutionStrategyApi {
}

final class PigeonApiResolutionStrategyApi: PigeonApiProtocolResolutionStrategyApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateResolutionStrategyApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateResolutionStrategyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiResolutionStrategyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionStrategyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let boundSizeArg: SizeApi? = nilOrValue(args[1])
        let fallbackRuleArg = args[2] as! ResolutionFallbackRuleApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, boundSize: boundSizeArg, fallbackRule: fallbackRuleArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ResolutionStrategyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ResolutionStrategyApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let boundSizeArg = try! pigeonDelegate.boundSize(pigeonApi: self, pigeonInstance: pigeonInstance)
      let fallbackRuleArg = try! pigeonDelegate.fallbackRule(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ResolutionStrategyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, boundSizeArg, fallbackRuleArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateResolutionSelectorApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiResolutionSelectorApi, allowedResolutionMode: ResolutionModeApi, aspectRatioStrategy: AspectRatioStrategyApi, resolutionFilter: ResolutionFilterApi?, resolutionStrategy: ResolutionStrategyApi?) throws -> ResolutionSelectorApi
  func allowedResolutionMode(pigeonApi: PigeonApiResolutionSelectorApi, pigeonInstance: ResolutionSelectorApi) throws -> ResolutionModeApi
  func aspectRatioStrategy(pigeonApi: PigeonApiResolutionSelectorApi, pigeonInstance: ResolutionSelectorApi) throws -> AspectRatioStrategyApi
  func resolutionFilter(pigeonApi: PigeonApiResolutionSelectorApi, pigeonInstance: ResolutionSelectorApi) throws -> ResolutionFilterApi?
  func resolutionStrategy(pigeonApi: PigeonApiResolutionSelectorApi, pigeonInstance: ResolutionSelectorApi) throws -> ResolutionStrategyApi?
}

protocol PigeonApiProtocolResolutionSelectorApi {
}

final class PigeonApiResolutionSelectorApi: PigeonApiProtocolResolutionSelectorApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateResolutionSelectorApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateResolutionSelectorApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiResolutionSelectorApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionSelectorApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let allowedResolutionModeArg = args[1] as! ResolutionModeApi
        let aspectRatioStrategyArg = args[2] as! AspectRatioStrategyApi
        let resolutionFilterArg: ResolutionFilterApi? = nilOrValue(args[3])
        let resolutionStrategyArg: ResolutionStrategyApi? = nilOrValue(args[4])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, allowedResolutionMode: allowedResolutionModeArg, aspectRatioStrategy: aspectRatioStrategyArg, resolutionFilter: resolutionFilterArg, resolutionStrategy: resolutionStrategyArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ResolutionSelectorApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ResolutionSelectorApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let allowedResolutionModeArg = try! pigeonDelegate.allowedResolutionMode(pigeonApi: self, pigeonInstance: pigeonInstance)
      let aspectRatioStrategyArg = try! pigeonDelegate.aspectRatioStrategy(pigeonApi: self, pigeonInstance: pigeonInstance)
      let resolutionFilterArg = try! pigeonDelegate.resolutionFilter(pigeonApi: self, pigeonInstance: pigeonInstance)
      let resolutionStrategyArg = try! pigeonDelegate.resolutionStrategy(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ResolutionSelectorApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, allowedResolutionModeArg, aspectRatioStrategyArg, resolutionFilterArg, resolutionStrategyArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageInfoApi {
  func timestamp(pigeonApi: PigeonApiImageInfoApi, pigeonInstance: ImageInfoApi) throws -> Int64
  func rotationDegrees(pigeonApi: PigeonApiImageInfoApi, pigeonInstance: ImageInfoApi) throws -> Int64
}

protocol PigeonApiProtocolImageInfoApi {
}

final class PigeonApiImageInfoApi: PigeonApiProtocolImageInfoApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageInfoApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageInfoApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ImageInfoApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageInfoApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let timestampArg = try! pigeonDelegate.timestamp(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rotationDegreesArg = try! pigeonDelegate.rotationDegrees(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageInfoApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, timestampArg, rotationDegreesArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePlaneProxyApi {
  func buffer(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: PlaneProxyApi) throws -> FlutterStandardTypedData
  func pixelStride(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: PlaneProxyApi) throws -> Int64
  func rowStride(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: PlaneProxyApi) throws -> Int64
}

protocol PigeonApiProtocolPlaneProxyApi {
}

final class PigeonApiPlaneProxyApi: PigeonApiProtocolPlaneProxyApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePlaneProxyApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePlaneProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of PlaneProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PlaneProxyApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let bufferArg = try! pigeonDelegate.buffer(pigeonApi: self, pigeonInstance: pigeonInstance)
      let pixelStrideArg = try! pigeonDelegate.pixelStride(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rowStrideArg = try! pigeonDelegate.rowStride(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PlaneProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, bufferArg, pixelStrideArg, rowStrideArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageProxyApi {
  func format(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxyApi) throws -> ImageFormatApi
  func width(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxyApi) throws -> Int64
  func height(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxyApi) throws -> Int64
  func planes(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxyApi) throws -> [PlaneProxyApi]
  func imageInfo(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxyApi) throws -> ImageInfoApi
  func getCropRect(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxyApi) throws -> RectApi
  func setCropRect(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxyApi, rect: RectApi?) throws
}

protocol PigeonApiProtocolImageProxyApi {
}

final class PigeonApiImageProxyApi: PigeonApiProtocolImageProxyApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageProxyApi
  ///An implementation of [AutoCloseableApi] used to access callback methods
  var pigeonApiAutoCloseableApi: PigeonApiAutoCloseableApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiImageProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getCropRectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageProxyApi.getCropRect", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCropRectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ImageProxyApi
        do {
          let result = try api.pigeonDelegate.getCropRect(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCropRectChannel.setMessageHandler(nil)
    }
    let setCropRectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageProxyApi.setCropRect", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCropRectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ImageProxyApi
        let rectArg: RectApi? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setCropRect(pigeonApi: api, pigeonInstance: pigeonInstanceArg, rect: rectArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCropRectChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ImageProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageProxyApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let formatArg = try! pigeonDelegate.format(pigeonApi: self, pigeonInstance: pigeonInstance)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let planesArg = try! pigeonDelegate.planes(pigeonApi: self, pigeonInstance: pigeonInstance)
      let imageInfoArg = try! pigeonDelegate.imageInfo(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, formatArg, widthArg, heightArg, planesArg, imageInfoArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMetadataApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiMetadataApi, isReversedHorizontal: Bool, isReversedVertical: Bool, location: LocationApi?) throws -> MetadataApi
  func isReversedHorizontal(pigeonApi: PigeonApiMetadataApi, pigeonInstance: MetadataApi) throws -> Bool
  func isReversedVertical(pigeonApi: PigeonApiMetadataApi, pigeonInstance: MetadataApi) throws -> Bool
  func location(pigeonApi: PigeonApiMetadataApi, pigeonInstance: MetadataApi) throws -> LocationApi?
}

protocol PigeonApiProtocolMetadataApi {
}

final class PigeonApiMetadataApi: PigeonApiProtocolMetadataApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMetadataApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMetadataApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMetadataApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MetadataApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let isReversedHorizontalArg = args[1] as! Bool
        let isReversedVerticalArg = args[2] as! Bool
        let locationArg: LocationApi? = nilOrValue(args[3])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, isReversedHorizontal: isReversedHorizontalArg, isReversedVertical: isReversedVerticalArg, location: locationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MetadataApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MetadataApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let isReversedHorizontalArg = try! pigeonDelegate.isReversedHorizontal(pigeonApi: self, pigeonInstance: pigeonInstance)
      let isReversedVerticalArg = try! pigeonDelegate.isReversedVertical(pigeonApi: self, pigeonInstance: pigeonInstance)
      let locationArg = try! pigeonDelegate.location(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MetadataApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, isReversedHorizontalArg, isReversedVerticalArg, locationArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputFileOptionsApi {
  func build(pigeonApi: PigeonApiOutputFileOptionsApi, file: String, metadata: MetadataApi?) throws -> OutputFileOptionsApi
}

protocol PigeonApiProtocolOutputFileOptionsApi {
}

final class PigeonApiOutputFileOptionsApi: PigeonApiProtocolOutputFileOptionsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputFileOptionsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputFileOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOutputFileOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OutputFileOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let fileArg = args[1] as! String
        let metadataArg: MetadataApi? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, file: fileArg, metadata: metadataArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OutputFileOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OutputFileOptionsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputFileOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputFileResultsApi {
  func savedUri(pigeonApi: PigeonApiOutputFileResultsApi, pigeonInstance: OutputFileResultsApi) throws -> String?
}

protocol PigeonApiProtocolOutputFileResultsApi {
}

final class PigeonApiOutputFileResultsApi: PigeonApiProtocolOutputFileResultsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputFileResultsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputFileResultsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of OutputFileResultsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OutputFileResultsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let savedUriArg = try! pigeonDelegate.savedUri(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputFileResultsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, savedUriArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOnImageCapturedCallbackApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiOnImageCapturedCallbackApi) throws -> OnImageCapturedCallbackApi
}

protocol PigeonApiProtocolOnImageCapturedCallbackApi {
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureSuccess(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, image imageArg: ImageProxyApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onError(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiOnImageCapturedCallbackApi: PigeonApiProtocolOnImageCapturedCallbackApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOnImageCapturedCallbackApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOnImageCapturedCallbackApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOnImageCapturedCallbackApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OnImageCapturedCallbackApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OnImageCapturedCallbackApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureStarted"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureProcessProgressed"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, progressArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onPostviewBitmapAvailable"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, bitmapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureSuccess(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, image imageArg: ImageProxyApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureSuccess"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, imageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onError(pigeonInstance pigeonInstanceArg: OnImageCapturedCallbackApi, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onError"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, exceptionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateOnImageSavedCallbackApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiOnImageSavedCallbackApi) throws -> OnImageSavedCallbackApi
}

protocol PigeonApiProtocolOnImageSavedCallbackApi {
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onImageSaved(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, outputFileResults outputFileResultsArg: OutputFileResultsApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onError(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiOnImageSavedCallbackApi: PigeonApiProtocolOnImageSavedCallbackApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOnImageSavedCallbackApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOnImageSavedCallbackApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOnImageSavedCallbackApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OnImageSavedCallbackApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OnImageSavedCallbackApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onCaptureStarted"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onCaptureProcessProgressed"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, progressArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onPostviewBitmapAvailable"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, bitmapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onImageSaved(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, outputFileResults outputFileResultsArg: OutputFileResultsApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onImageSaved"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, outputFileResultsArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onError(pigeonInstance pigeonInstanceArg: OnImageSavedCallbackApi, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onError"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, exceptionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
open class PigeonApiDelegateAnalyzerApi {
}

protocol PigeonApiProtocolAnalyzerApi {
}

final class PigeonApiAnalyzerApi: PigeonApiProtocolAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAnalyzerApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AnalyzerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AnalyzerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageAnalyzerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiImageAnalyzerApi) throws -> ImageAnalyzerApi
}

protocol PigeonApiProtocolImageAnalyzerApi {
  func analyze(pigeonInstance pigeonInstanceArg: ImageAnalyzerApi, image imageArg: ImageProxyApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiImageAnalyzerApi: PigeonApiProtocolImageAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageAnalyzerApi
  ///An implementation of [AnalyzerApi] used to access callback methods
  var pigeonApiAnalyzerApi: PigeonApiAnalyzerApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiImageAnalyzerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageAnalyzerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ImageAnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageAnalyzerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ImageAnalyzerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func analyze(pigeonInstance pigeonInstanceArg: ImageAnalyzerApi, image imageArg: ImageProxyApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageAnalyzerApi.analyze"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, imageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateJpegAnalyzerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiJpegAnalyzerApi, targetCoordinateSystem: CoordinateSystemApi) throws -> JpegAnalyzerApi
}

protocol PigeonApiProtocolJpegAnalyzerApi {
  func consumer(pigeonInstance pigeonInstanceArg: JpegAnalyzerApi, value valueArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiJpegAnalyzerApi: PigeonApiProtocolJpegAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateJpegAnalyzerApi
  ///An implementation of [AnalyzerApi] used to access callback methods
  var pigeonApiAnalyzerApi: PigeonApiAnalyzerApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateJpegAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiJpegAnalyzerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.JpegAnalyzerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let targetCoordinateSystemArg = args[1] as! CoordinateSystemApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, targetCoordinateSystem: targetCoordinateSystemArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of JpegAnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: JpegAnalyzerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of JpegAnalyzerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func consumer(pigeonInstance pigeonInstanceArg: JpegAnalyzerApi, value valueArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.JpegAnalyzerApi.consumer"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
open class PigeonApiDelegateDetectorApi {
}

protocol PigeonApiProtocolDetectorApi {
}

final class PigeonApiDetectorApi: PigeonApiProtocolDetectorApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateDetectorApi
  ///An implementation of [CloseableApi] used to access callback methods
  var pigeonApiCloseableApi: PigeonApiCloseableApi {
    return pigeonRegistrar.apiDelegate.pigeonApiCloseableApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateDetectorApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of DetectorApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: DetectorApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.DetectorApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAddressApi {
  func type(pigeonApi: PigeonApiAddressApi, pigeonInstance: AddressApi) throws -> AddressTypeApi
  func addressLines(pigeonApi: PigeonApiAddressApi, pigeonInstance: AddressApi) throws -> [String]
}

protocol PigeonApiProtocolAddressApi {
}

final class PigeonApiAddressApi: PigeonApiProtocolAddressApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAddressApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAddressApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AddressApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AddressApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let addressLinesArg = try! pigeonDelegate.addressLines(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AddressApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, addressLinesArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCalendarDateTimeApi {
  func rawValue(pigeonApi: PigeonApiCalendarDateTimeApi, pigeonInstance: CalendarDateTimeApi) throws -> String?
  func year(pigeonApi: PigeonApiCalendarDateTimeApi, pigeonInstance: CalendarDateTimeApi) throws -> Int64
  func month(pigeonApi: PigeonApiCalendarDateTimeApi, pigeonInstance: CalendarDateTimeApi) throws -> Int64
  func day(pigeonApi: PigeonApiCalendarDateTimeApi, pigeonInstance: CalendarDateTimeApi) throws -> Int64
  func hours(pigeonApi: PigeonApiCalendarDateTimeApi, pigeonInstance: CalendarDateTimeApi) throws -> Int64
  func minutes(pigeonApi: PigeonApiCalendarDateTimeApi, pigeonInstance: CalendarDateTimeApi) throws -> Int64
  func seconds(pigeonApi: PigeonApiCalendarDateTimeApi, pigeonInstance: CalendarDateTimeApi) throws -> Int64
  func isUtc(pigeonApi: PigeonApiCalendarDateTimeApi, pigeonInstance: CalendarDateTimeApi) throws -> Bool
}

protocol PigeonApiProtocolCalendarDateTimeApi {
}

final class PigeonApiCalendarDateTimeApi: PigeonApiProtocolCalendarDateTimeApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCalendarDateTimeApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCalendarDateTimeApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CalendarDateTimeApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CalendarDateTimeApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let rawValueArg = try! pigeonDelegate.rawValue(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yearArg = try! pigeonDelegate.year(pigeonApi: self, pigeonInstance: pigeonInstance)
      let monthArg = try! pigeonDelegate.month(pigeonApi: self, pigeonInstance: pigeonInstance)
      let dayArg = try! pigeonDelegate.day(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hoursArg = try! pigeonDelegate.hours(pigeonApi: self, pigeonInstance: pigeonInstance)
      let minutesArg = try! pigeonDelegate.minutes(pigeonApi: self, pigeonInstance: pigeonInstance)
      let secondsArg = try! pigeonDelegate.seconds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let isUtcArg = try! pigeonDelegate.isUtc(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CalendarDateTimeApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, rawValueArg, yearArg, monthArg, dayArg, hoursArg, minutesArg, secondsArg, isUtcArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCalendarEventApi {
  func start(pigeonApi: PigeonApiCalendarEventApi, pigeonInstance: CalendarEventApi) throws -> CalendarDateTimeApi?
  func end(pigeonApi: PigeonApiCalendarEventApi, pigeonInstance: CalendarEventApi) throws -> CalendarDateTimeApi?
  func location(pigeonApi: PigeonApiCalendarEventApi, pigeonInstance: CalendarEventApi) throws -> String?
  func organizer(pigeonApi: PigeonApiCalendarEventApi, pigeonInstance: CalendarEventApi) throws -> String?
  func summary(pigeonApi: PigeonApiCalendarEventApi, pigeonInstance: CalendarEventApi) throws -> String?
  func description(pigeonApi: PigeonApiCalendarEventApi, pigeonInstance: CalendarEventApi) throws -> String?
  func status(pigeonApi: PigeonApiCalendarEventApi, pigeonInstance: CalendarEventApi) throws -> String?
}

protocol PigeonApiProtocolCalendarEventApi {
}

final class PigeonApiCalendarEventApi: PigeonApiProtocolCalendarEventApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCalendarEventApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCalendarEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CalendarEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CalendarEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let startArg = try! pigeonDelegate.start(pigeonApi: self, pigeonInstance: pigeonInstance)
      let endArg = try! pigeonDelegate.end(pigeonApi: self, pigeonInstance: pigeonInstance)
      let locationArg = try! pigeonDelegate.location(pigeonApi: self, pigeonInstance: pigeonInstance)
      let organizerArg = try! pigeonDelegate.organizer(pigeonApi: self, pigeonInstance: pigeonInstance)
      let summaryArg = try! pigeonDelegate.summary(pigeonApi: self, pigeonInstance: pigeonInstance)
      let descriptionArg = try! pigeonDelegate.description(pigeonApi: self, pigeonInstance: pigeonInstance)
      let statusArg = try! pigeonDelegate.status(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CalendarEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, startArg, endArg, locationArg, organizerArg, summaryArg, descriptionArg, statusArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateContactInfoApi {
  func addresses(pigeonApi: PigeonApiContactInfoApi, pigeonInstance: ContactInfoApi) throws -> [AddressApi]
  func emails(pigeonApi: PigeonApiContactInfoApi, pigeonInstance: ContactInfoApi) throws -> [EmailApi]
  func name(pigeonApi: PigeonApiContactInfoApi, pigeonInstance: ContactInfoApi) throws -> PersonNameApi?
  func organization(pigeonApi: PigeonApiContactInfoApi, pigeonInstance: ContactInfoApi) throws -> String?
  func phones(pigeonApi: PigeonApiContactInfoApi, pigeonInstance: ContactInfoApi) throws -> [PhoneApi]
  func title(pigeonApi: PigeonApiContactInfoApi, pigeonInstance: ContactInfoApi) throws -> String?
  func urls(pigeonApi: PigeonApiContactInfoApi, pigeonInstance: ContactInfoApi) throws -> [String]
}

protocol PigeonApiProtocolContactInfoApi {
}

final class PigeonApiContactInfoApi: PigeonApiProtocolContactInfoApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateContactInfoApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateContactInfoApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ContactInfoApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ContactInfoApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let addressesArg = try! pigeonDelegate.addresses(pigeonApi: self, pigeonInstance: pigeonInstance)
      let emailsArg = try! pigeonDelegate.emails(pigeonApi: self, pigeonInstance: pigeonInstance)
      let nameArg = try! pigeonDelegate.name(pigeonApi: self, pigeonInstance: pigeonInstance)
      let organizationArg = try! pigeonDelegate.organization(pigeonApi: self, pigeonInstance: pigeonInstance)
      let phonesArg = try! pigeonDelegate.phones(pigeonApi: self, pigeonInstance: pigeonInstance)
      let titleArg = try! pigeonDelegate.title(pigeonApi: self, pigeonInstance: pigeonInstance)
      let urlsArg = try! pigeonDelegate.urls(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ContactInfoApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, addressesArg, emailsArg, nameArg, organizationArg, phonesArg, titleArg, urlsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateDriverLicenseApi {
  func licenseNumber(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func documentType(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func expiryDate(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func firstName(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func middleName(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func lastName(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func gender(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func birthDate(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func issueDate(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func issuingCountry(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func addressState(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func addressCity(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func addressStreet(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
  func addressZip(pigeonApi: PigeonApiDriverLicenseApi, pigeonInstance: DriverLicenseApi) throws -> String?
}

protocol PigeonApiProtocolDriverLicenseApi {
}

final class PigeonApiDriverLicenseApi: PigeonApiProtocolDriverLicenseApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateDriverLicenseApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateDriverLicenseApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of DriverLicenseApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: DriverLicenseApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let licenseNumberArg = try! pigeonDelegate.licenseNumber(pigeonApi: self, pigeonInstance: pigeonInstance)
      let documentTypeArg = try! pigeonDelegate.documentType(pigeonApi: self, pigeonInstance: pigeonInstance)
      let expiryDateArg = try! pigeonDelegate.expiryDate(pigeonApi: self, pigeonInstance: pigeonInstance)
      let firstNameArg = try! pigeonDelegate.firstName(pigeonApi: self, pigeonInstance: pigeonInstance)
      let middleNameArg = try! pigeonDelegate.middleName(pigeonApi: self, pigeonInstance: pigeonInstance)
      let lastNameArg = try! pigeonDelegate.lastName(pigeonApi: self, pigeonInstance: pigeonInstance)
      let genderArg = try! pigeonDelegate.gender(pigeonApi: self, pigeonInstance: pigeonInstance)
      let birthDateArg = try! pigeonDelegate.birthDate(pigeonApi: self, pigeonInstance: pigeonInstance)
      let issueDateArg = try! pigeonDelegate.issueDate(pigeonApi: self, pigeonInstance: pigeonInstance)
      let issuingCountryArg = try! pigeonDelegate.issuingCountry(pigeonApi: self, pigeonInstance: pigeonInstance)
      let addressStateArg = try! pigeonDelegate.addressState(pigeonApi: self, pigeonInstance: pigeonInstance)
      let addressCityArg = try! pigeonDelegate.addressCity(pigeonApi: self, pigeonInstance: pigeonInstance)
      let addressStreetArg = try! pigeonDelegate.addressStreet(pigeonApi: self, pigeonInstance: pigeonInstance)
      let addressZipArg = try! pigeonDelegate.addressZip(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.DriverLicenseApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, licenseNumberArg, documentTypeArg, expiryDateArg, firstNameArg, middleNameArg, lastNameArg, genderArg, birthDateArg, issueDateArg, issuingCountryArg, addressStateArg, addressCityArg, addressStreetArg, addressZipArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateEmailApi {
  func type(pigeonApi: PigeonApiEmailApi, pigeonInstance: EmailApi) throws -> EmailTypeApi
  func address(pigeonApi: PigeonApiEmailApi, pigeonInstance: EmailApi) throws -> String?
  func subject(pigeonApi: PigeonApiEmailApi, pigeonInstance: EmailApi) throws -> String?
  func body(pigeonApi: PigeonApiEmailApi, pigeonInstance: EmailApi) throws -> String?
}

protocol PigeonApiProtocolEmailApi {
}

final class PigeonApiEmailApi: PigeonApiProtocolEmailApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateEmailApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateEmailApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of EmailApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: EmailApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let addressArg = try! pigeonDelegate.address(pigeonApi: self, pigeonInstance: pigeonInstance)
      let subjectArg = try! pigeonDelegate.subject(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyArg = try! pigeonDelegate.body(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.EmailApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, addressArg, subjectArg, bodyArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateGeoPointApi {
  func lat(pigeonApi: PigeonApiGeoPointApi, pigeonInstance: GeoPointApi) throws -> Double
  func lng(pigeonApi: PigeonApiGeoPointApi, pigeonInstance: GeoPointApi) throws -> Double
}

protocol PigeonApiProtocolGeoPointApi {
}

final class PigeonApiGeoPointApi: PigeonApiProtocolGeoPointApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateGeoPointApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateGeoPointApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of GeoPointApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: GeoPointApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let latArg = try! pigeonDelegate.lat(pigeonApi: self, pigeonInstance: pigeonInstance)
      let lngArg = try! pigeonDelegate.lng(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.GeoPointApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, latArg, lngArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePersonNameApi {
  func formattedName(pigeonApi: PigeonApiPersonNameApi, pigeonInstance: PersonNameApi) throws -> String?
  func pronunciation(pigeonApi: PigeonApiPersonNameApi, pigeonInstance: PersonNameApi) throws -> String?
  func prefix(pigeonApi: PigeonApiPersonNameApi, pigeonInstance: PersonNameApi) throws -> String?
  func first(pigeonApi: PigeonApiPersonNameApi, pigeonInstance: PersonNameApi) throws -> String?
  func middle(pigeonApi: PigeonApiPersonNameApi, pigeonInstance: PersonNameApi) throws -> String?
  func last(pigeonApi: PigeonApiPersonNameApi, pigeonInstance: PersonNameApi) throws -> String?
  func suffix(pigeonApi: PigeonApiPersonNameApi, pigeonInstance: PersonNameApi) throws -> String?
}

protocol PigeonApiProtocolPersonNameApi {
}

final class PigeonApiPersonNameApi: PigeonApiProtocolPersonNameApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePersonNameApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePersonNameApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of PersonNameApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PersonNameApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let formattedNameArg = try! pigeonDelegate.formattedName(pigeonApi: self, pigeonInstance: pigeonInstance)
      let pronunciationArg = try! pigeonDelegate.pronunciation(pigeonApi: self, pigeonInstance: pigeonInstance)
      let prefixArg = try! pigeonDelegate.prefix(pigeonApi: self, pigeonInstance: pigeonInstance)
      let firstArg = try! pigeonDelegate.first(pigeonApi: self, pigeonInstance: pigeonInstance)
      let middleArg = try! pigeonDelegate.middle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let lastArg = try! pigeonDelegate.last(pigeonApi: self, pigeonInstance: pigeonInstance)
      let suffixArg = try! pigeonDelegate.suffix(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PersonNameApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, formattedNameArg, pronunciationArg, prefixArg, firstArg, middleArg, lastArg, suffixArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePhoneApi {
  func type(pigeonApi: PigeonApiPhoneApi, pigeonInstance: PhoneApi) throws -> PhoneTypeApi
  func number(pigeonApi: PigeonApiPhoneApi, pigeonInstance: PhoneApi) throws -> String?
}

protocol PigeonApiProtocolPhoneApi {
}

final class PigeonApiPhoneApi: PigeonApiProtocolPhoneApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePhoneApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePhoneApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of PhoneApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PhoneApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let numberArg = try! pigeonDelegate.number(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PhoneApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, numberArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSmsApi {
  func phoneNumber(pigeonApi: PigeonApiSmsApi, pigeonInstance: SmsApi) throws -> String?
  func message(pigeonApi: PigeonApiSmsApi, pigeonInstance: SmsApi) throws -> String?
}

protocol PigeonApiProtocolSmsApi {
}

final class PigeonApiSmsApi: PigeonApiProtocolSmsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSmsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSmsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of SmsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: SmsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let phoneNumberArg = try! pigeonDelegate.phoneNumber(pigeonApi: self, pigeonInstance: pigeonInstance)
      let messageArg = try! pigeonDelegate.message(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SmsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, phoneNumberArg, messageArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateUrlBookmarkApi {
  func title(pigeonApi: PigeonApiUrlBookmarkApi, pigeonInstance: UrlBookmarkApi) throws -> String?
  func url(pigeonApi: PigeonApiUrlBookmarkApi, pigeonInstance: UrlBookmarkApi) throws -> String?
}

protocol PigeonApiProtocolUrlBookmarkApi {
}

final class PigeonApiUrlBookmarkApi: PigeonApiProtocolUrlBookmarkApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateUrlBookmarkApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateUrlBookmarkApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of UrlBookmarkApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: UrlBookmarkApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let titleArg = try! pigeonDelegate.title(pigeonApi: self, pigeonInstance: pigeonInstance)
      let urlArg = try! pigeonDelegate.url(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.UrlBookmarkApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, titleArg, urlArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateWiFiApi {
  func encryptionType(pigeonApi: PigeonApiWiFiApi, pigeonInstance: WiFiApi) throws -> WiFiEncryptionTypeApi
  func ssid(pigeonApi: PigeonApiWiFiApi, pigeonInstance: WiFiApi) throws -> String?
  func password(pigeonApi: PigeonApiWiFiApi, pigeonInstance: WiFiApi) throws -> String?
}

protocol PigeonApiProtocolWiFiApi {
}

final class PigeonApiWiFiApi: PigeonApiProtocolWiFiApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWiFiApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWiFiApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WiFiApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WiFiApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let encryptionTypeArg = try! pigeonDelegate.encryptionType(pigeonApi: self, pigeonInstance: pigeonInstance)
      let ssidArg = try! pigeonDelegate.ssid(pigeonApi: self, pigeonInstance: pigeonInstance)
      let passwordArg = try! pigeonDelegate.password(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.WiFiApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, encryptionTypeArg, ssidArg, passwordArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateBarcodeApi {
  func boundingBox(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> RectApi?
  func cornerPoints(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> [PointApi]?
  func format(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> BarcodeFormatApi
  func valueType(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> BarcodeValueTypeApi
  func rawBytes(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> FlutterStandardTypedData?
  func rawValue(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> String?
  func displayValue(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> String?
  func calendarEvent(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> CalendarEventApi?
  func contactInfo(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> ContactInfoApi?
  func driverLicense(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> DriverLicenseApi?
  func email(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> EmailApi?
  func geoPoint(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> GeoPointApi?
  func phone(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> PhoneApi?
  func sms(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> SmsApi?
  func url(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> UrlBookmarkApi?
  func wifi(pigeonApi: PigeonApiBarcodeApi, pigeonInstance: BarcodeApi) throws -> WiFiApi?
}

protocol PigeonApiProtocolBarcodeApi {
}

final class PigeonApiBarcodeApi: PigeonApiProtocolBarcodeApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateBarcodeApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateBarcodeApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of BarcodeApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: BarcodeApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let boundingBoxArg = try! pigeonDelegate.boundingBox(pigeonApi: self, pigeonInstance: pigeonInstance)
      let cornerPointsArg = try! pigeonDelegate.cornerPoints(pigeonApi: self, pigeonInstance: pigeonInstance)
      let formatArg = try! pigeonDelegate.format(pigeonApi: self, pigeonInstance: pigeonInstance)
      let valueTypeArg = try! pigeonDelegate.valueType(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rawBytesArg = try! pigeonDelegate.rawBytes(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rawValueArg = try! pigeonDelegate.rawValue(pigeonApi: self, pigeonInstance: pigeonInstance)
      let displayValueArg = try! pigeonDelegate.displayValue(pigeonApi: self, pigeonInstance: pigeonInstance)
      let calendarEventArg = try! pigeonDelegate.calendarEvent(pigeonApi: self, pigeonInstance: pigeonInstance)
      let contactInfoArg = try! pigeonDelegate.contactInfo(pigeonApi: self, pigeonInstance: pigeonInstance)
      let driverLicenseArg = try! pigeonDelegate.driverLicense(pigeonApi: self, pigeonInstance: pigeonInstance)
      let emailArg = try! pigeonDelegate.email(pigeonApi: self, pigeonInstance: pigeonInstance)
      let geoPointArg = try! pigeonDelegate.geoPoint(pigeonApi: self, pigeonInstance: pigeonInstance)
      let phoneArg = try! pigeonDelegate.phone(pigeonApi: self, pigeonInstance: pigeonInstance)
      let smsArg = try! pigeonDelegate.sms(pigeonApi: self, pigeonInstance: pigeonInstance)
      let urlArg = try! pigeonDelegate.url(pigeonApi: self, pigeonInstance: pigeonInstance)
      let wifiArg = try! pigeonDelegate.wifi(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.BarcodeApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, boundingBoxArg, cornerPointsArg, formatArg, valueTypeArg, rawBytesArg, rawValueArg, displayValueArg, calendarEventArg, contactInfoArg, driverLicenseArg, emailArg, geoPointArg, phoneArg, smsArg, urlArg, wifiArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateZoomCallbackApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiZoomCallbackApi) throws -> ZoomCallbackApi
}

protocol PigeonApiProtocolZoomCallbackApi {
  func setZoom(pigeonInstance pigeonInstanceArg: ZoomCallbackApi, zoomRatio zoomRatioArg: Double, completion: @escaping (Result<Bool, CameraXError>) -> Void)
}

final class PigeonApiZoomCallbackApi: PigeonApiProtocolZoomCallbackApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomCallbackApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomCallbackApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiZoomCallbackApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomCallbackApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ZoomCallbackApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomCallbackApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ZoomCallbackApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func setZoom(pigeonInstance pigeonInstanceArg: ZoomCallbackApi, zoomRatio zoomRatioArg: Double, completion: @escaping (Result<Bool, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomCallbackApi.setZoom"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, zoomRatioArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(CameraXError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! Bool
        completion(.success(result))
      }
    }
  }

}
protocol PigeonApiDelegateZoomSuggestionOptionsApi {
  func build(pigeonApi: PigeonApiZoomSuggestionOptionsApi, zoomCallback: ZoomCallbackApi, maxSupportedZoomRatio: Double?) throws -> ZoomSuggestionOptionsApi
}

protocol PigeonApiProtocolZoomSuggestionOptionsApi {
}

final class PigeonApiZoomSuggestionOptionsApi: PigeonApiProtocolZoomSuggestionOptionsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomSuggestionOptionsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomSuggestionOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiZoomSuggestionOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomSuggestionOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let zoomCallbackArg = args[1] as! ZoomCallbackApi
        let maxSupportedZoomRatioArg: Double? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, zoomCallback: zoomCallbackArg, maxSupportedZoomRatio: maxSupportedZoomRatioArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ZoomSuggestionOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomSuggestionOptionsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomSuggestionOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateBarcodeScannerOptionsApi {
  func build(pigeonApi: PigeonApiBarcodeScannerOptionsApi, enableAllPotentialBarcodes: Bool?, formats: [BarcodeFormatApi]?, zoomSuggestionOptions: ZoomSuggestionOptionsApi?) throws -> BarcodeScannerOptionsApi
}

protocol PigeonApiProtocolBarcodeScannerOptionsApi {
}

final class PigeonApiBarcodeScannerOptionsApi: PigeonApiProtocolBarcodeScannerOptionsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateBarcodeScannerOptionsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateBarcodeScannerOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiBarcodeScannerOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.BarcodeScannerOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let enableAllPotentialBarcodesArg: Bool? = nilOrValue(args[1])
        let formatsArg: [BarcodeFormatApi]? = nilOrValue(args[2])
        let zoomSuggestionOptionsArg: ZoomSuggestionOptionsApi? = nilOrValue(args[3])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, enableAllPotentialBarcodes: enableAllPotentialBarcodesArg, formats: formatsArg, zoomSuggestionOptions: zoomSuggestionOptionsArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of BarcodeScannerOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: BarcodeScannerOptionsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.BarcodeScannerOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateMlImageApi {
}

protocol PigeonApiProtocolMlImageApi {
}

final class PigeonApiMlImageApi: PigeonApiProtocolMlImageApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMlImageApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMlImageApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of MlImageApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MlImageApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MlImageApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateInputImageApi {
}

protocol PigeonApiProtocolInputImageApi {
}

final class PigeonApiInputImageApi: PigeonApiProtocolInputImageApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateInputImageApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateInputImageApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of InputImageApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: InputImageApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.InputImageApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateBarcodeScannerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiBarcodeScannerApi, options: BarcodeScannerOptionsApi?) throws -> BarcodeScannerApi
  func process0(pigeonApi: PigeonApiBarcodeScannerApi, pigeonInstance: BarcodeScannerApi, image: MlImageApi, completion: @escaping (Result<[BarcodeApi], Error>) -> Void)
  func process1(pigeonApi: PigeonApiBarcodeScannerApi, pigeonInstance: BarcodeScannerApi, image: InputImageApi, completion: @escaping (Result<[BarcodeApi], Error>) -> Void)
}

protocol PigeonApiProtocolBarcodeScannerApi {
}

final class PigeonApiBarcodeScannerApi: PigeonApiProtocolBarcodeScannerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateBarcodeScannerApi
  ///An implementation of [DetectorApi] used to access callback methods
  var pigeonApiDetectorApi: PigeonApiDetectorApi {
    return pigeonRegistrar.apiDelegate.pigeonApiDetectorApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateBarcodeScannerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiBarcodeScannerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.BarcodeScannerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let optionsArg: BarcodeScannerOptionsApi? = nilOrValue(args[1])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, options: optionsArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let process0Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.BarcodeScannerApi.process0", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      process0Channel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! BarcodeScannerApi
        let imageArg = args[1] as! MlImageApi
        api.pigeonDelegate.process0(pigeonApi: api, pigeonInstance: pigeonInstanceArg, image: imageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      process0Channel.setMessageHandler(nil)
    }
    let process1Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.BarcodeScannerApi.process1", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      process1Channel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! BarcodeScannerApi
        let imageArg = args[1] as! InputImageApi
        api.pigeonDelegate.process1(pigeonApi: api, pigeonInstance: pigeonInstanceArg, image: imageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      process1Channel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of BarcodeScannerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: BarcodeScannerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.BarcodeScannerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFaceDetectorOptionsApi {
  func build(pigeonApi: PigeonApiFaceDetectorOptionsApi, enableTracking: Bool?, classificationMode: FaceClassificationModeApi?, contourMode: FaceContourModeApi?, landmarkMode: FaceLandmarkModeApi?, minFaceSize: Double?, performanceMode: FacePerformanceModeApi?) throws -> FaceDetectorOptionsApi
}

protocol PigeonApiProtocolFaceDetectorOptionsApi {
}

final class PigeonApiFaceDetectorOptionsApi: PigeonApiProtocolFaceDetectorOptionsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFaceDetectorOptionsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFaceDetectorOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFaceDetectorOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FaceDetectorOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let enableTrackingArg: Bool? = nilOrValue(args[1])
        let classificationModeArg: FaceClassificationModeApi? = nilOrValue(args[2])
        let contourModeArg: FaceContourModeApi? = nilOrValue(args[3])
        let landmarkModeArg: FaceLandmarkModeApi? = nilOrValue(args[4])
        let minFaceSizeArg: Double? = nilOrValue(args[5])
        let performanceModeArg: FacePerformanceModeApi? = nilOrValue(args[6])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, enableTracking: enableTrackingArg, classificationMode: classificationModeArg, contourMode: contourModeArg, landmarkMode: landmarkModeArg, minFaceSize: minFaceSizeArg, performanceMode: performanceModeArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FaceDetectorOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FaceDetectorOptionsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FaceDetectorOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFaceContourApi {
  func type(pigeonApi: PigeonApiFaceContourApi, pigeonInstance: FaceContourApi) throws -> FaceContourTypeApi
  func points(pigeonApi: PigeonApiFaceContourApi, pigeonInstance: FaceContourApi) throws -> [PointFApi]
}

protocol PigeonApiProtocolFaceContourApi {
}

final class PigeonApiFaceContourApi: PigeonApiProtocolFaceContourApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFaceContourApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFaceContourApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of FaceContourApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FaceContourApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let pointsArg = try! pigeonDelegate.points(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FaceContourApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, pointsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFaceLandmarkApi {
  func type(pigeonApi: PigeonApiFaceLandmarkApi, pigeonInstance: FaceLandmarkApi) throws -> FaceLandmarkTypeApi
  func position(pigeonApi: PigeonApiFaceLandmarkApi, pigeonInstance: FaceLandmarkApi) throws -> PointFApi
}

protocol PigeonApiProtocolFaceLandmarkApi {
}

final class PigeonApiFaceLandmarkApi: PigeonApiProtocolFaceLandmarkApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFaceLandmarkApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFaceLandmarkApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of FaceLandmarkApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FaceLandmarkApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let positionArg = try! pigeonDelegate.position(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FaceLandmarkApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, positionArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFaceApi {
  func boundingBox(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> RectApi
  func allContours(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> [FaceContourApi]
  func allLandmarks(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> [FaceLandmarkApi]
  func headEulerAngleX(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> Double
  func headEulerAngleY(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> Double
  func headEulerAngleZ(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> Double
  func leftEyeOpenProbability(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> Double?
  func rightEyeOpenProbability(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> Double?
  func smilingProbability(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> Double?
  func trackingId(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi) throws -> Int64?
  func getContour(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi, contourType: FaceContourTypeApi) throws -> FaceContourApi?
  func getLandmark(pigeonApi: PigeonApiFaceApi, pigeonInstance: FaceApi, landmarkType: FaceLandmarkTypeApi) throws -> FaceLandmarkApi?
}

protocol PigeonApiProtocolFaceApi {
}

final class PigeonApiFaceApi: PigeonApiProtocolFaceApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFaceApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFaceApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFaceApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getContourChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FaceApi.getContour", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getContourChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FaceApi
        let contourTypeArg = args[1] as! FaceContourTypeApi
        do {
          let result = try api.pigeonDelegate.getContour(pigeonApi: api, pigeonInstance: pigeonInstanceArg, contourType: contourTypeArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getContourChannel.setMessageHandler(nil)
    }
    let getLandmarkChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FaceApi.getLandmark", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getLandmarkChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FaceApi
        let landmarkTypeArg = args[1] as! FaceLandmarkTypeApi
        do {
          let result = try api.pigeonDelegate.getLandmark(pigeonApi: api, pigeonInstance: pigeonInstanceArg, landmarkType: landmarkTypeArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getLandmarkChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FaceApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FaceApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let boundingBoxArg = try! pigeonDelegate.boundingBox(pigeonApi: self, pigeonInstance: pigeonInstance)
      let allContoursArg = try! pigeonDelegate.allContours(pigeonApi: self, pigeonInstance: pigeonInstance)
      let allLandmarksArg = try! pigeonDelegate.allLandmarks(pigeonApi: self, pigeonInstance: pigeonInstance)
      let headEulerAngleXArg = try! pigeonDelegate.headEulerAngleX(pigeonApi: self, pigeonInstance: pigeonInstance)
      let headEulerAngleYArg = try! pigeonDelegate.headEulerAngleY(pigeonApi: self, pigeonInstance: pigeonInstance)
      let headEulerAngleZArg = try! pigeonDelegate.headEulerAngleZ(pigeonApi: self, pigeonInstance: pigeonInstance)
      let leftEyeOpenProbabilityArg = try! pigeonDelegate.leftEyeOpenProbability(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rightEyeOpenProbabilityArg = try! pigeonDelegate.rightEyeOpenProbability(pigeonApi: self, pigeonInstance: pigeonInstance)
      let smilingProbabilityArg = try! pigeonDelegate.smilingProbability(pigeonApi: self, pigeonInstance: pigeonInstance)
      let trackingIdArg = try! pigeonDelegate.trackingId(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FaceApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, boundingBoxArg, allContoursArg, allLandmarksArg, headEulerAngleXArg, headEulerAngleYArg, headEulerAngleZArg, leftEyeOpenProbabilityArg, rightEyeOpenProbabilityArg, smilingProbabilityArg, trackingIdArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFaceDetectorApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiFaceDetectorApi, options: FaceDetectorOptionsApi?) throws -> FaceDetectorApi
  func process0(pigeonApi: PigeonApiFaceDetectorApi, pigeonInstance: FaceDetectorApi, image: MlImageApi, completion: @escaping (Result<[FaceApi], Error>) -> Void)
  func process1(pigeonApi: PigeonApiFaceDetectorApi, pigeonInstance: FaceDetectorApi, image: InputImageApi, completion: @escaping (Result<[FaceApi], Error>) -> Void)
}

protocol PigeonApiProtocolFaceDetectorApi {
}

final class PigeonApiFaceDetectorApi: PigeonApiProtocolFaceDetectorApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFaceDetectorApi
  ///An implementation of [DetectorApi] used to access callback methods
  var pigeonApiDetectorApi: PigeonApiDetectorApi {
    return pigeonRegistrar.apiDelegate.pigeonApiDetectorApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFaceDetectorApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFaceDetectorApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FaceDetectorApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let optionsArg: FaceDetectorOptionsApi? = nilOrValue(args[1])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, options: optionsArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let process0Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FaceDetectorApi.process0", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      process0Channel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FaceDetectorApi
        let imageArg = args[1] as! MlImageApi
        api.pigeonDelegate.process0(pigeonApi: api, pigeonInstance: pigeonInstanceArg, image: imageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      process0Channel.setMessageHandler(nil)
    }
    let process1Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FaceDetectorApi.process1", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      process1Channel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FaceDetectorApi
        let imageArg = args[1] as! InputImageApi
        api.pigeonDelegate.process1(pigeonApi: api, pigeonInstance: pigeonInstanceArg, image: imageArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      process1Channel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FaceDetectorApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FaceDetectorApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FaceDetectorApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMlKitAnalyzerResultApi {
  func timestamp(pigeonApi: PigeonApiMlKitAnalyzerResultApi, pigeonInstance: MlKitAnalyzerResultApi) throws -> Int64
  func getThrowable(pigeonApi: PigeonApiMlKitAnalyzerResultApi, pigeonInstance: MlKitAnalyzerResultApi, detector: DetectorApi) throws -> [Any?]?
  func getBarcodes(pigeonApi: PigeonApiMlKitAnalyzerResultApi, pigeonInstance: MlKitAnalyzerResultApi, detector: BarcodeScannerApi) throws -> [BarcodeApi]?
  func getFaces(pigeonApi: PigeonApiMlKitAnalyzerResultApi, pigeonInstance: MlKitAnalyzerResultApi, detector: FaceDetectorApi) throws -> [FaceApi]?
}

protocol PigeonApiProtocolMlKitAnalyzerResultApi {
}

final class PigeonApiMlKitAnalyzerResultApi: PigeonApiProtocolMlKitAnalyzerResultApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMlKitAnalyzerResultApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMlKitAnalyzerResultApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMlKitAnalyzerResultApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getThrowableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MlKitAnalyzerResultApi.getThrowable", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getThrowableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! MlKitAnalyzerResultApi
        let detectorArg = args[1] as! DetectorApi
        do {
          let result = try api.pigeonDelegate.getThrowable(pigeonApi: api, pigeonInstance: pigeonInstanceArg, detector: detectorArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getThrowableChannel.setMessageHandler(nil)
    }
    let getBarcodesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MlKitAnalyzerResultApi.getBarcodes", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getBarcodesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! MlKitAnalyzerResultApi
        let detectorArg = args[1] as! BarcodeScannerApi
        do {
          let result = try api.pigeonDelegate.getBarcodes(pigeonApi: api, pigeonInstance: pigeonInstanceArg, detector: detectorArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getBarcodesChannel.setMessageHandler(nil)
    }
    let getFacesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MlKitAnalyzerResultApi.getFaces", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFacesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! MlKitAnalyzerResultApi
        let detectorArg = args[1] as! FaceDetectorApi
        do {
          let result = try api.pigeonDelegate.getFaces(pigeonApi: api, pigeonInstance: pigeonInstanceArg, detector: detectorArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFacesChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MlKitAnalyzerResultApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MlKitAnalyzerResultApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let timestampArg = try! pigeonDelegate.timestamp(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MlKitAnalyzerResultApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, timestampArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMlKitAnalyzerResultConsumerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiMlKitAnalyzerResultConsumerApi) throws -> MlKitAnalyzerResultConsumerApi
}

protocol PigeonApiProtocolMlKitAnalyzerResultConsumerApi {
  func accept(pigeonInstance pigeonInstanceArg: MlKitAnalyzerResultConsumerApi, value valueArg: MlKitAnalyzerResultApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiMlKitAnalyzerResultConsumerApi: PigeonApiProtocolMlKitAnalyzerResultConsumerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMlKitAnalyzerResultConsumerApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMlKitAnalyzerResultConsumerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMlKitAnalyzerResultConsumerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MlKitAnalyzerResultConsumerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MlKitAnalyzerResultConsumerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MlKitAnalyzerResultConsumerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of MlKitAnalyzerResultConsumerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func accept(pigeonInstance pigeonInstanceArg: MlKitAnalyzerResultConsumerApi, value valueArg: MlKitAnalyzerResultApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.MlKitAnalyzerResultConsumerApi.accept"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateMlKitAnalyzerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiMlKitAnalyzerApi, detectors: [DetectorApi], targetCoordinateSystem: CoordinateSystemApi, consumer: MlKitAnalyzerResultConsumerApi) throws -> MlKitAnalyzerApi
}

protocol PigeonApiProtocolMlKitAnalyzerApi {
}

final class PigeonApiMlKitAnalyzerApi: PigeonApiProtocolMlKitAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMlKitAnalyzerApi
  ///An implementation of [AnalyzerApi] used to access callback methods
  var pigeonApiAnalyzerApi: PigeonApiAnalyzerApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMlKitAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMlKitAnalyzerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MlKitAnalyzerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let detectorsArg = args[1] as! [DetectorApi]
        let targetCoordinateSystemArg = args[2] as! CoordinateSystemApi
        let consumerArg = args[3] as! MlKitAnalyzerResultConsumerApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, detectors: detectorsArg, targetCoordinateSystem: targetCoordinateSystemArg, consumer: consumerArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MlKitAnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MlKitAnalyzerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MlKitAnalyzerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateQualityApi {
  func fhd(pigeonApi: PigeonApiQualityApi) throws -> QualityApi
  func hd(pigeonApi: PigeonApiQualityApi) throws -> QualityApi
  func highest(pigeonApi: PigeonApiQualityApi) throws -> QualityApi
  func lowest(pigeonApi: PigeonApiQualityApi) throws -> QualityApi
  func sd(pigeonApi: PigeonApiQualityApi) throws -> QualityApi
  func uhd(pigeonApi: PigeonApiQualityApi) throws -> QualityApi
}

protocol PigeonApiProtocolQualityApi {
}

final class PigeonApiQualityApi: PigeonApiProtocolQualityApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateQualityApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateQualityApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiQualityApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let fhdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualityApi.fhd", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fhdChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.fhd(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      fhdChannel.setMessageHandler(nil)
    }
    let hdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualityApi.hd", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hdChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.hd(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hdChannel.setMessageHandler(nil)
    }
    let highestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualityApi.highest", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      highestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.highest(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      highestChannel.setMessageHandler(nil)
    }
    let lowestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualityApi.lowest", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      lowestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.lowest(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      lowestChannel.setMessageHandler(nil)
    }
    let sdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualityApi.sd", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      sdChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.sd(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      sdChannel.setMessageHandler(nil)
    }
    let uhdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualityApi.uhd", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      uhdChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.uhd(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      uhdChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of QualityApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: QualityApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.QualityApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFallbackStrategyApi {
  func higherQualityOrLowerThan(pigeonApi: PigeonApiFallbackStrategyApi, quality: QualityApi) throws -> FallbackStrategyApi
  func higherQualityThan(pigeonApi: PigeonApiFallbackStrategyApi, quality: QualityApi) throws -> FallbackStrategyApi
  func lowerQualityOrHigherThan(pigeonApi: PigeonApiFallbackStrategyApi, quality: QualityApi) throws -> FallbackStrategyApi
  func lowerQualityThan(pigeonApi: PigeonApiFallbackStrategyApi, quality: QualityApi) throws -> FallbackStrategyApi
}

protocol PigeonApiProtocolFallbackStrategyApi {
}

final class PigeonApiFallbackStrategyApi: PigeonApiProtocolFallbackStrategyApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFallbackStrategyApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFallbackStrategyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFallbackStrategyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let higherQualityOrLowerThanChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FallbackStrategyApi.higherQualityOrLowerThan", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      higherQualityOrLowerThanChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let qualityArg = args[1] as! QualityApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.higherQualityOrLowerThan(pigeonApi: api, quality: qualityArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      higherQualityOrLowerThanChannel.setMessageHandler(nil)
    }
    let higherQualityThanChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FallbackStrategyApi.higherQualityThan", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      higherQualityThanChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let qualityArg = args[1] as! QualityApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.higherQualityThan(pigeonApi: api, quality: qualityArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      higherQualityThanChannel.setMessageHandler(nil)
    }
    let lowerQualityOrHigherThanChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FallbackStrategyApi.lowerQualityOrHigherThan", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      lowerQualityOrHigherThanChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let qualityArg = args[1] as! QualityApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.lowerQualityOrHigherThan(pigeonApi: api, quality: qualityArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      lowerQualityOrHigherThanChannel.setMessageHandler(nil)
    }
    let lowerQualityThanChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FallbackStrategyApi.lowerQualityThan", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      lowerQualityThanChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let qualityArg = args[1] as! QualityApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.lowerQualityThan(pigeonApi: api, quality: qualityArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      lowerQualityThanChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FallbackStrategyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FallbackStrategyApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FallbackStrategyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateQualitySelectorApi {
  func from(pigeonApi: PigeonApiQualitySelectorApi, quality: QualityApi, fallbackStrategy: FallbackStrategyApi?) throws -> QualitySelectorApi
  func fromOrderedList(pigeonApi: PigeonApiQualitySelectorApi, qualities: [QualityApi], fallbackStrategy: FallbackStrategyApi?) throws -> QualitySelectorApi
  func getResolution(pigeonApi: PigeonApiQualitySelectorApi, cameraInfo: CameraInfoApi, quality: QualityApi) throws -> SizeApi?
}

protocol PigeonApiProtocolQualitySelectorApi {
}

final class PigeonApiQualitySelectorApi: PigeonApiProtocolQualitySelectorApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateQualitySelectorApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateQualitySelectorApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiQualitySelectorApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let fromChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualitySelectorApi.from", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fromChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let qualityArg = args[1] as! QualityApi
        let fallbackStrategyArg: FallbackStrategyApi? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.from(pigeonApi: api, quality: qualityArg, fallbackStrategy: fallbackStrategyArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      fromChannel.setMessageHandler(nil)
    }
    let fromOrderedListChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualitySelectorApi.fromOrderedList", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fromOrderedListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let qualitiesArg = args[1] as! [QualityApi]
        let fallbackStrategyArg: FallbackStrategyApi? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.fromOrderedList(pigeonApi: api, qualities: qualitiesArg, fallbackStrategy: fallbackStrategyArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      fromOrderedListChannel.setMessageHandler(nil)
    }
    let getResolutionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.QualitySelectorApi.getResolution", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getResolutionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraInfoArg = args[0] as! CameraInfoApi
        let qualityArg = args[1] as! QualityApi
        do {
          let result = try api.pigeonDelegate.getResolution(pigeonApi: api, cameraInfo: cameraInfoArg, quality: qualityArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getResolutionChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of QualitySelectorApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: QualitySelectorApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.QualitySelectorApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFileOutputOptionsApi {
  func build(pigeonApi: PigeonApiFileOutputOptionsApi, file: String, durationLimitMillis: Int64?, fileSizeLimitBytes: Int64?, location: LocationApi?) throws -> FileOutputOptionsApi
  func file(pigeonApi: PigeonApiFileOutputOptionsApi, pigeonInstance: FileOutputOptionsApi) throws -> String
}

protocol PigeonApiProtocolFileOutputOptionsApi {
}

final class PigeonApiFileOutputOptionsApi: PigeonApiProtocolFileOutputOptionsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFileOutputOptionsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFileOutputOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFileOutputOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FileOutputOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let fileArg = args[1] as! String
        let durationLimitMillisArg: Int64? = nilOrValue(args[2])
        let fileSizeLimitBytesArg: Int64? = nilOrValue(args[3])
        let locationArg: LocationApi? = nilOrValue(args[4])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, file: fileArg, durationLimitMillis: durationLimitMillisArg, fileSizeLimitBytes: fileSizeLimitBytesArg, location: locationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FileOutputOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FileOutputOptionsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let fileArg = try! pigeonDelegate.file(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FileOutputOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, fileArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAudioConfigApi {
  func create(pigeonApi: PigeonApiAudioConfigApi, enableAudio: Bool) throws -> AudioConfigApi
  func audioDisabled(pigeonApi: PigeonApiAudioConfigApi) throws -> AudioConfigApi
  func getAudioEnabled(pigeonApi: PigeonApiAudioConfigApi, pigeonInstance: AudioConfigApi) throws -> Bool
}

protocol PigeonApiProtocolAudioConfigApi {
}

final class PigeonApiAudioConfigApi: PigeonApiProtocolAudioConfigApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAudioConfigApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAudioConfigApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAudioConfigApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let enableAudioArg = args[1] as! Bool
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.create(pigeonApi: api, enableAudio: enableAudioArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let audioDisabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.audioDisabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      audioDisabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.audioDisabled(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      audioDisabledChannel.setMessageHandler(nil)
    }
    let getAudioEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.getAudioEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAudioEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! AudioConfigApi
        do {
          let result = try api.pigeonDelegate.getAudioEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAudioEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AudioConfigApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AudioConfigApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AudioConfigApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAudioStatsApi {
  func audioAmplitude(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStatsApi) throws -> Double
  func audioState(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStatsApi) throws -> AudioStateApi
  func errorCause(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStatsApi) throws -> [Any?]?
  func hasAudio(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStatsApi) throws -> Bool
  func hasError(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStatsApi) throws -> Bool
}

protocol PigeonApiProtocolAudioStatsApi {
}

final class PigeonApiAudioStatsApi: PigeonApiProtocolAudioStatsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAudioStatsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAudioStatsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AudioStatsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AudioStatsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let audioAmplitudeArg = try! pigeonDelegate.audioAmplitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let audioStateArg = try! pigeonDelegate.audioState(pigeonApi: self, pigeonInstance: pigeonInstance)
      let errorCauseArg = try! pigeonDelegate.errorCause(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasAudioArg = try! pigeonDelegate.hasAudio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasErrorArg = try! pigeonDelegate.hasError(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AudioStatsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, audioAmplitudeArg, audioStateArg, errorCauseArg, hasAudioArg, hasErrorArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRecordingStatsApi {
  func audioStats(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStatsApi) throws -> AudioStatsApi
  func numBytesRecorded(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStatsApi) throws -> Int64
  func recordedDurationNanos(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStatsApi) throws -> Int64
}

protocol PigeonApiProtocolRecordingStatsApi {
}

final class PigeonApiRecordingStatsApi: PigeonApiProtocolRecordingStatsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRecordingStatsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRecordingStatsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of RecordingStatsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RecordingStatsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let audioStatsArg = try! pigeonDelegate.audioStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let numBytesRecordedArg = try! pigeonDelegate.numBytesRecorded(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordedDurationNanosArg = try! pigeonDelegate.recordedDurationNanos(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RecordingStatsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, audioStatsArg, numBytesRecordedArg, recordedDurationNanosArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateVideoRecordEventApi {
}

protocol PigeonApiProtocolVideoRecordEventApi {
}

final class PigeonApiVideoRecordEventApi: PigeonApiProtocolVideoRecordEventApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordEventApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordStatusEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordStatusEventApi, pigeonInstance: VideoRecordStatusEventApi) throws -> RecordingStatsApi
}

protocol PigeonApiProtocolVideoRecordStatusEventApi {
}

final class PigeonApiVideoRecordStatusEventApi: PigeonApiProtocolVideoRecordStatusEventApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordStatusEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordStatusEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordStatusEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordStatusEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordStatusEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordStartEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordStartEventApi, pigeonInstance: VideoRecordStartEventApi) throws -> RecordingStatsApi
}

protocol PigeonApiProtocolVideoRecordStartEventApi {
}

final class PigeonApiVideoRecordStartEventApi: PigeonApiProtocolVideoRecordStartEventApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordStartEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordStartEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordStartEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordStartEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordStartEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordPauseEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordPauseEventApi, pigeonInstance: VideoRecordPauseEventApi) throws -> RecordingStatsApi
}

protocol PigeonApiProtocolVideoRecordPauseEventApi {
}

final class PigeonApiVideoRecordPauseEventApi: PigeonApiProtocolVideoRecordPauseEventApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordPauseEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordPauseEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordPauseEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordPauseEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordPauseEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordResumeEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordResumeEventApi, pigeonInstance: VideoRecordResumeEventApi) throws -> RecordingStatsApi
}

protocol PigeonApiProtocolVideoRecordResumeEventApi {
}

final class PigeonApiVideoRecordResumeEventApi: PigeonApiProtocolVideoRecordResumeEventApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordResumeEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordResumeEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordResumeEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordResumeEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordResumeEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputResultsApi {
  func outputUri(pigeonApi: PigeonApiOutputResultsApi, pigeonInstance: OutputResultsApi) throws -> String?
}

protocol PigeonApiProtocolOutputResultsApi {
}

final class PigeonApiOutputResultsApi: PigeonApiProtocolOutputResultsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputResultsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputResultsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of OutputResultsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OutputResultsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputUriArg = try! pigeonDelegate.outputUri(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputResultsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputUriArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordFinalizeEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordFinalizeEventApi) throws -> RecordingStatsApi
  func cause(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordFinalizeEventApi) throws -> [Any?]?
  func error(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordFinalizeEventApi) throws -> VideoRecordFinalizeEventErrorApi
  func outputResults(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordFinalizeEventApi) throws -> OutputResultsApi
}

protocol PigeonApiProtocolVideoRecordFinalizeEventApi {
}

final class PigeonApiVideoRecordFinalizeEventApi: PigeonApiProtocolVideoRecordFinalizeEventApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordFinalizeEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordFinalizeEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordFinalizeEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordFinalizeEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let causeArg = try! pigeonDelegate.cause(pigeonApi: self, pigeonInstance: pigeonInstance)
      let errorArg = try! pigeonDelegate.error(pigeonApi: self, pigeonInstance: pigeonInstance)
      let outputResultsArg = try! pigeonDelegate.outputResults(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordFinalizeEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg, causeArg, errorArg, outputResultsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordEventConsumerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiVideoRecordEventConsumerApi) throws -> VideoRecordEventConsumerApi
}

protocol PigeonApiProtocolVideoRecordEventConsumerApi {
  func accept(pigeonInstance pigeonInstanceArg: VideoRecordEventConsumerApi, value valueArg: VideoRecordEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiVideoRecordEventConsumerApi: PigeonApiProtocolVideoRecordEventConsumerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordEventConsumerApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordEventConsumerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiVideoRecordEventConsumerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.VideoRecordEventConsumerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of VideoRecordEventConsumerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEventConsumerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of VideoRecordEventConsumerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func accept(pigeonInstance pigeonInstanceArg: VideoRecordEventConsumerApi, value valueArg: VideoRecordEventApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordEventConsumerApi.accept"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateRecordingApi {
  func isPersistene(pigeonApi: PigeonApiRecordingApi, pigeonInstance: RecordingApi) throws -> Bool
  func mute(pigeonApi: PigeonApiRecordingApi, pigeonInstance: RecordingApi, muted: Bool) throws
  func pause(pigeonApi: PigeonApiRecordingApi, pigeonInstance: RecordingApi) throws
  func resume(pigeonApi: PigeonApiRecordingApi, pigeonInstance: RecordingApi) throws
  func stop(pigeonApi: PigeonApiRecordingApi, pigeonInstance: RecordingApi) throws
  func close(pigeonApi: PigeonApiRecordingApi, pigeonInstance: RecordingApi) throws
}

protocol PigeonApiProtocolRecordingApi {
}

final class PigeonApiRecordingApi: PigeonApiProtocolRecordingApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRecordingApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRecordingApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRecordingApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let isPersisteneChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.isPersistene", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPersisteneChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! RecordingApi
        do {
          let result = try api.pigeonDelegate.isPersistene(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPersisteneChannel.setMessageHandler(nil)
    }
    let muteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.mute", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      muteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! RecordingApi
        let mutedArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.mute(pigeonApi: api, pigeonInstance: pigeonInstanceArg, muted: mutedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      muteChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! RecordingApi
        do {
          try api.pigeonDelegate.pause(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let resumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.resume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! RecordingApi
        do {
          try api.pigeonDelegate.resume(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resumeChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.stop", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! RecordingApi
        do {
          try api.pigeonDelegate.stop(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    let closeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.close", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! RecordingApi
        do {
          try api.pigeonDelegate.close(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      closeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RecordingApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RecordingApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RecordingApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraControllerApi {
  func initialize(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Void, Error>) -> Void)
  func hasCamera(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, cameraSelector: CameraSelectorApi, completion: @escaping (Result<Bool, Error>) -> Void)
  func getCameraSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<CameraSelectorApi, Error>) -> Void)
  func setCameraSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, cameraSelector: CameraSelectorApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getCameraInfo(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<CameraInfoApi?, Error>) -> Void)
  func getCameraControl(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<CameraControlApi?, Error>) -> Void)
  func getTorchState(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<TorchStateLiveDataApi, Error>) -> Void)
  func enableTorch(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, torchEnabled: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getZoomState(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<ZoomStateLiveDataApi, Error>) -> Void)
  func setZoomRatio(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, zoomRatio: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func setLinearZoom(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, linearZoom: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func isPinchToZoomEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Bool, Error>) -> Void)
  func setPinchToZoomEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, enabled: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func isTapToFocusEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Bool, Error>) -> Void)
  func setTapToFocusEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, enabled: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func isImageCaptureEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Bool, Error>) -> Void)
  func isImageAnalysisEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Bool, Error>) -> Void)
  func isVideoCaptureEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Bool, Error>) -> Void)
  func setEnabledUseCases(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, enabledUseCases: [UseCaseApi], completion: @escaping (Result<Void, Error>) -> Void)
  func getPreviewResolutionSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<ResolutionSelectorApi?, Error>) -> Void)
  func setPreviewResolutionSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, resolutionSelector: ResolutionSelectorApi?, completion: @escaping (Result<Void, Error>) -> Void)
  func getImageCaptureResolutionSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<ResolutionSelectorApi?, Error>) -> Void)
  func setImageCaptureResolutionSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, resolutionSelector: ResolutionSelectorApi?, completion: @escaping (Result<Void, Error>) -> Void)
  func getImageCaptureMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<CaptureModeApi, Error>) -> Void)
  func setImageCaptureMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, captureMode: CaptureModeApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getImageCaptureFlashMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<FlashModeApi, Error>) -> Void)
  func setImageCaptureFlashMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, flashMode: FlashModeApi, completion: @escaping (Result<Void, Error>) -> Void)
  func takePictureToMemory(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, capturedCallback: OnImageCapturedCallbackApi, completion: @escaping (Result<Void, Error>) -> Void)
  func takePictureToFile(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, outputFileOptions: OutputFileOptionsApi, savedCallback: OnImageSavedCallbackApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getImageAnalysisResolutionSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<ResolutionSelectorApi?, Error>) -> Void)
  func setImageAnalysisResolutionSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, resolutionSelector: ResolutionSelectorApi?, completion: @escaping (Result<Void, Error>) -> Void)
  func getImageAnalysisBackpressureStrategy(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<BackpressureStrategyApi, Error>) -> Void)
  func setImageAnalysisBackpressureStrategy(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, strategy: BackpressureStrategyApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getImageAnalysisImageQueueDepth(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Int64, Error>) -> Void)
  func setImageAnalysisImageQueueDepth(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, depth: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func getImageAnalysisOutputImageFormat(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<ImageFormatApi, Error>) -> Void)
  func setImageAnalysisOutputImageFormat(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, imageAnalysisOutputImageFormat: ImageFormatApi, completion: @escaping (Result<Void, Error>) -> Void)
  func setImageAnalysisAnalyzer(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, analyzer: AnalyzerApi, completion: @escaping (Result<Void, Error>) -> Void)
  func clearImageAnalysisAnalyzer(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getVideoCaptureDynamicRange(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<DynamicRangeApi, Error>) -> Void)
  func setVideoCaptureDynamicRange(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, dynamicRange: DynamicRangeApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getVideoCaptureMirrorMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<MirrorModeApi, Error>) -> Void)
  func setVideoCaptureMirrorMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, mirrorMode: MirrorModeApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getVideoCaptureQualitySelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<QualitySelectorApi, Error>) -> Void)
  func setVideoCaptureQualitySelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, qualitySelector: QualitySelectorApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getVideoCaptureTargetFrameRate(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<IntRangeApi, Error>) -> Void)
  func setVideoCaptureTargetFrameRate(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, targetFrameRate: IntRangeApi, completion: @escaping (Result<Void, Error>) -> Void)
  func isRecording(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, completion: @escaping (Result<Bool, Error>) -> Void)
  func startRecording(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraControllerApi, outputOptions: FileOutputOptionsApi, audioConfig: AudioConfigApi, listener: VideoRecordEventConsumerApi, completion: @escaping (Result<RecordingApi, Error>) -> Void)
}

protocol PigeonApiProtocolCameraControllerApi {
}

final class PigeonApiCameraControllerApi: PigeonApiProtocolCameraControllerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraControllerApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraControllerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraControllerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.initialize", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.initialize(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    let hasCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.hasCamera", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let cameraSelectorArg = args[1] as! CameraSelectorApi
        api.pigeonDelegate.hasCamera(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cameraSelector: cameraSelectorArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      hasCameraChannel.setMessageHandler(nil)
    }
    let getCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCameraSelectorChannel.setMessageHandler(nil)
    }
    let setCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let cameraSelectorArg = args[1] as! CameraSelectorApi
        api.pigeonDelegate.setCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cameraSelector: cameraSelectorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCameraSelectorChannel.setMessageHandler(nil)
    }
    let getCameraInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getCameraInfo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getCameraInfo(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCameraInfoChannel.setMessageHandler(nil)
    }
    let getCameraControlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getCameraControl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraControlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getCameraControl(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCameraControlChannel.setMessageHandler(nil)
    }
    let getTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTorchStateChannel.setMessageHandler(nil)
    }
    let enableTorchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.enableTorch", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableTorchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let torchEnabledArg = args[1] as! Bool
        api.pigeonDelegate.enableTorch(pigeonApi: api, pigeonInstance: pigeonInstanceArg, torchEnabled: torchEnabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      enableTorchChannel.setMessageHandler(nil)
    }
    let getZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getZoomStateChannel.setMessageHandler(nil)
    }
    let setZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let zoomRatioArg = args[1] as! Double
        api.pigeonDelegate.setZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg, zoomRatio: zoomRatioArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setZoomRatioChannel.setMessageHandler(nil)
    }
    let setLinearZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setLinearZoom", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLinearZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let linearZoomArg = args[1] as! Double
        api.pigeonDelegate.setLinearZoom(pigeonApi: api, pigeonInstance: pigeonInstanceArg, linearZoom: linearZoomArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLinearZoomChannel.setMessageHandler(nil)
    }
    let isPinchToZoomEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isPinchToZoomEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPinchToZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.isPinchToZoomEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isPinchToZoomEnabledChannel.setMessageHandler(nil)
    }
    let setPinchToZoomEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setPinchToZoomEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPinchToZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let enabledArg = args[1] as! Bool
        api.pigeonDelegate.setPinchToZoomEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setPinchToZoomEnabledChannel.setMessageHandler(nil)
    }
    let isTapToFocusEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isTapToFocusEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isTapToFocusEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.isTapToFocusEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isTapToFocusEnabledChannel.setMessageHandler(nil)
    }
    let setTapToFocusEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setTapToFocusEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTapToFocusEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let enabledArg = args[1] as! Bool
        api.pigeonDelegate.setTapToFocusEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTapToFocusEnabledChannel.setMessageHandler(nil)
    }
    let isImageCaptureEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isImageCaptureEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isImageCaptureEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.isImageCaptureEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isImageCaptureEnabledChannel.setMessageHandler(nil)
    }
    let isImageAnalysisEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isImageAnalysisEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isImageAnalysisEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.isImageAnalysisEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isImageAnalysisEnabledChannel.setMessageHandler(nil)
    }
    let isVideoCaptureEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isVideoCaptureEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isVideoCaptureEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.isVideoCaptureEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isVideoCaptureEnabledChannel.setMessageHandler(nil)
    }
    let setEnabledUseCasesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setEnabledUseCases", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setEnabledUseCasesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let enabledUseCasesArg = args[1] as! [UseCaseApi]
        api.pigeonDelegate.setEnabledUseCases(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabledUseCases: enabledUseCasesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setEnabledUseCasesChannel.setMessageHandler(nil)
    }
    let getPreviewResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getPreviewResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPreviewResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getPreviewResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getPreviewResolutionSelectorChannel.setMessageHandler(nil)
    }
    let setPreviewResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setPreviewResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPreviewResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let resolutionSelectorArg: ResolutionSelectorApi? = nilOrValue(args[1])
        api.pigeonDelegate.setPreviewResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, resolutionSelector: resolutionSelectorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setPreviewResolutionSelectorChannel.setMessageHandler(nil)
    }
    let getImageCaptureResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageCaptureResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getImageCaptureResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getImageCaptureResolutionSelectorChannel.setMessageHandler(nil)
    }
    let setImageCaptureResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageCaptureResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let resolutionSelectorArg: ResolutionSelectorApi? = nilOrValue(args[1])
        api.pigeonDelegate.setImageCaptureResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, resolutionSelector: resolutionSelectorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageCaptureResolutionSelectorChannel.setMessageHandler(nil)
    }
    let getImageCaptureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageCaptureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getImageCaptureMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getImageCaptureModeChannel.setMessageHandler(nil)
    }
    let setImageCaptureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageCaptureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let captureModeArg = args[1] as! CaptureModeApi
        api.pigeonDelegate.setImageCaptureMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, captureMode: captureModeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageCaptureModeChannel.setMessageHandler(nil)
    }
    let getImageCaptureFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageCaptureFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getImageCaptureFlashMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getImageCaptureFlashModeChannel.setMessageHandler(nil)
    }
    let setImageCaptureFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageCaptureFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let flashModeArg = args[1] as! FlashModeApi
        api.pigeonDelegate.setImageCaptureFlashMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, flashMode: flashModeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageCaptureFlashModeChannel.setMessageHandler(nil)
    }
    let takePictureToMemoryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.takePictureToMemory", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takePictureToMemoryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let capturedCallbackArg = args[1] as! OnImageCapturedCallbackApi
        api.pigeonDelegate.takePictureToMemory(pigeonApi: api, pigeonInstance: pigeonInstanceArg, capturedCallback: capturedCallbackArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      takePictureToMemoryChannel.setMessageHandler(nil)
    }
    let takePictureToFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.takePictureToFile", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takePictureToFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let outputFileOptionsArg = args[1] as! OutputFileOptionsApi
        let savedCallbackArg = args[2] as! OnImageSavedCallbackApi
        api.pigeonDelegate.takePictureToFile(pigeonApi: api, pigeonInstance: pigeonInstanceArg, outputFileOptions: outputFileOptionsArg, savedCallback: savedCallbackArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      takePictureToFileChannel.setMessageHandler(nil)
    }
    let getImageAnalysisResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getImageAnalysisResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getImageAnalysisResolutionSelectorChannel.setMessageHandler(nil)
    }
    let setImageAnalysisResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let resolutionSelectorArg: ResolutionSelectorApi? = nilOrValue(args[1])
        api.pigeonDelegate.setImageAnalysisResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, resolutionSelector: resolutionSelectorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageAnalysisResolutionSelectorChannel.setMessageHandler(nil)
    }
    let getImageAnalysisBackpressureStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisBackpressureStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisBackpressureStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getImageAnalysisBackpressureStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getImageAnalysisBackpressureStrategyChannel.setMessageHandler(nil)
    }
    let setImageAnalysisBackpressureStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisBackpressureStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisBackpressureStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let strategyArg = args[1] as! BackpressureStrategyApi
        api.pigeonDelegate.setImageAnalysisBackpressureStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg, strategy: strategyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageAnalysisBackpressureStrategyChannel.setMessageHandler(nil)
    }
    let getImageAnalysisImageQueueDepthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisImageQueueDepth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisImageQueueDepthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getImageAnalysisImageQueueDepth(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getImageAnalysisImageQueueDepthChannel.setMessageHandler(nil)
    }
    let setImageAnalysisImageQueueDepthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisImageQueueDepth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisImageQueueDepthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let depthArg = args[1] as! Int64
        api.pigeonDelegate.setImageAnalysisImageQueueDepth(pigeonApi: api, pigeonInstance: pigeonInstanceArg, depth: depthArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageAnalysisImageQueueDepthChannel.setMessageHandler(nil)
    }
    let getImageAnalysisOutputImageFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisOutputImageFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisOutputImageFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getImageAnalysisOutputImageFormat(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getImageAnalysisOutputImageFormatChannel.setMessageHandler(nil)
    }
    let setImageAnalysisOutputImageFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisOutputImageFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisOutputImageFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let imageAnalysisOutputImageFormatArg = args[1] as! ImageFormatApi
        api.pigeonDelegate.setImageAnalysisOutputImageFormat(pigeonApi: api, pigeonInstance: pigeonInstanceArg, imageAnalysisOutputImageFormat: imageAnalysisOutputImageFormatArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageAnalysisOutputImageFormatChannel.setMessageHandler(nil)
    }
    let setImageAnalysisAnalyzerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisAnalyzer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisAnalyzerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let analyzerArg = args[1] as! AnalyzerApi
        api.pigeonDelegate.setImageAnalysisAnalyzer(pigeonApi: api, pigeonInstance: pigeonInstanceArg, analyzer: analyzerArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageAnalysisAnalyzerChannel.setMessageHandler(nil)
    }
    let clearImageAnalysisAnalyzerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.clearImageAnalysisAnalyzer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearImageAnalysisAnalyzerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.clearImageAnalysisAnalyzer(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      clearImageAnalysisAnalyzerChannel.setMessageHandler(nil)
    }
    let getVideoCaptureDynamicRangeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getVideoCaptureDynamicRange", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoCaptureDynamicRangeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getVideoCaptureDynamicRange(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVideoCaptureDynamicRangeChannel.setMessageHandler(nil)
    }
    let setVideoCaptureDynamicRangeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setVideoCaptureDynamicRange", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoCaptureDynamicRangeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let dynamicRangeArg = args[1] as! DynamicRangeApi
        api.pigeonDelegate.setVideoCaptureDynamicRange(pigeonApi: api, pigeonInstance: pigeonInstanceArg, dynamicRange: dynamicRangeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVideoCaptureDynamicRangeChannel.setMessageHandler(nil)
    }
    let getVideoCaptureMirrorModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getVideoCaptureMirrorMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoCaptureMirrorModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getVideoCaptureMirrorMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVideoCaptureMirrorModeChannel.setMessageHandler(nil)
    }
    let setVideoCaptureMirrorModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setVideoCaptureMirrorMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoCaptureMirrorModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let mirrorModeArg = args[1] as! MirrorModeApi
        api.pigeonDelegate.setVideoCaptureMirrorMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, mirrorMode: mirrorModeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVideoCaptureMirrorModeChannel.setMessageHandler(nil)
    }
    let getVideoCaptureQualitySelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getVideoCaptureQualitySelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoCaptureQualitySelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getVideoCaptureQualitySelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVideoCaptureQualitySelectorChannel.setMessageHandler(nil)
    }
    let setVideoCaptureQualitySelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setVideoCaptureQualitySelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoCaptureQualitySelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let qualitySelectorArg = args[1] as! QualitySelectorApi
        api.pigeonDelegate.setVideoCaptureQualitySelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, qualitySelector: qualitySelectorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVideoCaptureQualitySelectorChannel.setMessageHandler(nil)
    }
    let getVideoCaptureTargetFrameRateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getVideoCaptureTargetFrameRate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoCaptureTargetFrameRateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.getVideoCaptureTargetFrameRate(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVideoCaptureTargetFrameRateChannel.setMessageHandler(nil)
    }
    let setVideoCaptureTargetFrameRateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setVideoCaptureTargetFrameRate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoCaptureTargetFrameRateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let targetFrameRateArg = args[1] as! IntRangeApi
        api.pigeonDelegate.setVideoCaptureTargetFrameRate(pigeonApi: api, pigeonInstance: pigeonInstanceArg, targetFrameRate: targetFrameRateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVideoCaptureTargetFrameRateChannel.setMessageHandler(nil)
    }
    let isRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        api.pigeonDelegate.isRecording(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isRecordingChannel.setMessageHandler(nil)
    }
    let startRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.startRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControllerApi
        let outputOptionsArg = args[1] as! FileOutputOptionsApi
        let audioConfigArg = args[2] as! AudioConfigApi
        let listenerArg = args[3] as! VideoRecordEventConsumerApi
        api.pigeonDelegate.startRecording(pigeonApi: api, pigeonInstance: pigeonInstanceArg, outputOptions: outputOptionsArg, audioConfig: audioConfigArg, listener: listenerArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startRecordingChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraControllerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraControllerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraControllerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateLifecycleCameraControllerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiLifecycleCameraControllerApi) throws -> LifecycleCameraControllerApi
  func bindToLifecycle(pigeonApi: PigeonApiLifecycleCameraControllerApi, pigeonInstance: LifecycleCameraControllerApi, completion: @escaping (Result<Void, Error>) -> Void)
  func unbind(pigeonApi: PigeonApiLifecycleCameraControllerApi, pigeonInstance: LifecycleCameraControllerApi, completion: @escaping (Result<Void, Error>) -> Void)
}

protocol PigeonApiProtocolLifecycleCameraControllerApi {
}

final class PigeonApiLifecycleCameraControllerApi: PigeonApiProtocolLifecycleCameraControllerApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateLifecycleCameraControllerApi
  ///An implementation of [CameraControllerApi] used to access callback methods
  var pigeonApiCameraControllerApi: PigeonApiCameraControllerApi {
    return pigeonRegistrar.apiDelegate.pigeonApiCameraControllerApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateLifecycleCameraControllerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiLifecycleCameraControllerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.LifecycleCameraControllerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let bindToLifecycleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.LifecycleCameraControllerApi.bindToLifecycle", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      bindToLifecycleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! LifecycleCameraControllerApi
        api.pigeonDelegate.bindToLifecycle(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      bindToLifecycleChannel.setMessageHandler(nil)
    }
    let unbindChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.LifecycleCameraControllerApi.unbind", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unbindChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! LifecycleCameraControllerApi
        api.pigeonDelegate.unbind(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      unbindChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of LifecycleCameraControllerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: LifecycleCameraControllerApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.LifecycleCameraControllerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePreviewViewApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPreviewViewApi) throws -> PreviewViewApi
  func getController(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewViewApi, completion: @escaping (Result<CameraControllerApi?, Error>) -> Void)
  func setController(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewViewApi, controller: CameraControllerApi?, completion: @escaping (Result<Void, Error>) -> Void)
  func getScaleType(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewViewApi, completion: @escaping (Result<ScaleTypeApi, Error>) -> Void)
  func setScaleType(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewViewApi, scaleType: ScaleTypeApi, completion: @escaping (Result<Void, Error>) -> Void)
}

protocol PigeonApiProtocolPreviewViewApi {
}

final class PigeonApiPreviewViewApi: PigeonApiProtocolPreviewViewApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePreviewViewApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePreviewViewApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPreviewViewApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let getControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.getController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewViewApi
        api.pigeonDelegate.getController(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getControllerChannel.setMessageHandler(nil)
    }
    let setControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.setController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewViewApi
        let controllerArg: CameraControllerApi? = nilOrValue(args[1])
        api.pigeonDelegate.setController(pigeonApi: api, pigeonInstance: pigeonInstanceArg, controller: controllerArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setControllerChannel.setMessageHandler(nil)
    }
    let getScaleTypeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.getScaleType", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getScaleTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewViewApi
        api.pigeonDelegate.getScaleType(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getScaleTypeChannel.setMessageHandler(nil)
    }
    let setScaleTypeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.setScaleType", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setScaleTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewViewApi
        let scaleTypeArg = args[1] as! ScaleTypeApi
        api.pigeonDelegate.setScaleType(pigeonApi: api, pigeonInstance: pigeonInstanceArg, scaleType: scaleTypeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setScaleTypeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PreviewViewApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PreviewViewApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PreviewViewApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCamera2CameraControlApi {
  func from(pigeonApi: PigeonApiCamera2CameraControlApi, cameraControl: CameraControlApi) throws -> Camera2CameraControlApi
  func addCaptureRequestOptions(pigeonApi: PigeonApiCamera2CameraControlApi, pigeonInstance: Camera2CameraControlApi, bundle: CaptureRequestOptionsApi, completion: @escaping (Result<Void, Error>) -> Void)
  func clearCaptureRequestOptions(pigeonApi: PigeonApiCamera2CameraControlApi, pigeonInstance: Camera2CameraControlApi, completion: @escaping (Result<Void, Error>) -> Void)
  func getCaptureRequestOptions(pigeonApi: PigeonApiCamera2CameraControlApi, pigeonInstance: Camera2CameraControlApi) throws -> CaptureRequestOptionsApi
  func setCaptureRequestOptions(pigeonApi: PigeonApiCamera2CameraControlApi, pigeonInstance: Camera2CameraControlApi, bundle: CaptureRequestOptionsApi, completion: @escaping (Result<Void, Error>) -> Void)
}

protocol PigeonApiProtocolCamera2CameraControlApi {
}

final class PigeonApiCamera2CameraControlApi: PigeonApiProtocolCamera2CameraControlApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCamera2CameraControlApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCamera2CameraControlApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCamera2CameraControlApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let fromChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.Camera2CameraControlApi.from", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fromChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let cameraControlArg = args[1] as! CameraControlApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.from(pigeonApi: api, cameraControl: cameraControlArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      fromChannel.setMessageHandler(nil)
    }
    let addCaptureRequestOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.Camera2CameraControlApi.addCaptureRequestOptions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addCaptureRequestOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Camera2CameraControlApi
        let bundleArg = args[1] as! CaptureRequestOptionsApi
        api.pigeonDelegate.addCaptureRequestOptions(pigeonApi: api, pigeonInstance: pigeonInstanceArg, bundle: bundleArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addCaptureRequestOptionsChannel.setMessageHandler(nil)
    }
    let clearCaptureRequestOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.Camera2CameraControlApi.clearCaptureRequestOptions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearCaptureRequestOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Camera2CameraControlApi
        api.pigeonDelegate.clearCaptureRequestOptions(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      clearCaptureRequestOptionsChannel.setMessageHandler(nil)
    }
    let getCaptureRequestOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.Camera2CameraControlApi.getCaptureRequestOptions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCaptureRequestOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Camera2CameraControlApi
        do {
          let result = try api.pigeonDelegate.getCaptureRequestOptions(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCaptureRequestOptionsChannel.setMessageHandler(nil)
    }
    let setCaptureRequestOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.Camera2CameraControlApi.setCaptureRequestOptions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCaptureRequestOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Camera2CameraControlApi
        let bundleArg = args[1] as! CaptureRequestOptionsApi
        api.pigeonDelegate.setCaptureRequestOptions(pigeonApi: api, pigeonInstance: pigeonInstanceArg, bundle: bundleArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCaptureRequestOptionsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of Camera2CameraControlApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Camera2CameraControlApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.Camera2CameraControlApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCamera2CameraInfoApi {
  func from(pigeonApi: PigeonApiCamera2CameraInfoApi, cameraInfo: CameraInfoApi) throws -> Camera2CameraInfoApi
  func getSensorInfoExposureTimeRange(pigeonApi: PigeonApiCamera2CameraInfoApi, pigeonInstance: Camera2CameraInfoApi) throws -> LongRangeApi?
  func getCameraId(pigeonApi: PigeonApiCamera2CameraInfoApi, pigeonInstance: Camera2CameraInfoApi) throws -> String
}

protocol PigeonApiProtocolCamera2CameraInfoApi {
}

final class PigeonApiCamera2CameraInfoApi: PigeonApiProtocolCamera2CameraInfoApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCamera2CameraInfoApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCamera2CameraInfoApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCamera2CameraInfoApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let fromChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.Camera2CameraInfoApi.from", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fromChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let cameraInfoArg = args[1] as! CameraInfoApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.from(pigeonApi: api, cameraInfo: cameraInfoArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      fromChannel.setMessageHandler(nil)
    }
    let getSensorInfoExposureTimeRangeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.Camera2CameraInfoApi.getSensorInfoExposureTimeRange", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSensorInfoExposureTimeRangeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Camera2CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getSensorInfoExposureTimeRange(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSensorInfoExposureTimeRangeChannel.setMessageHandler(nil)
    }
    let getCameraIdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.Camera2CameraInfoApi.getCameraId", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraIdChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Camera2CameraInfoApi
        do {
          let result = try api.pigeonDelegate.getCameraId(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraIdChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of Camera2CameraInfoApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Camera2CameraInfoApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.Camera2CameraInfoApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCaptureRequestOptionsApi {
  func build(pigeonApi: PigeonApiCaptureRequestOptionsApi, mode: ControlModeApi?, aeMode: ControlAeModeApi?, afMode: ControlAfModeApi?, awbMode: ControlAwbModeApi?, sensorExposureTime: Int64?) throws -> CaptureRequestOptionsApi
}

protocol PigeonApiProtocolCaptureRequestOptionsApi {
}

final class PigeonApiCaptureRequestOptionsApi: PigeonApiProtocolCaptureRequestOptionsApi  {
  unowned let pigeonRegistrar: CameraXPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCaptureRequestOptionsApi
  init(pigeonRegistrar: CameraXPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCaptureRequestOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCaptureRequestOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CaptureRequestOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let modeArg: ControlModeApi? = nilOrValue(args[1])
        let aeModeArg: ControlAeModeApi? = nilOrValue(args[2])
        let afModeArg: ControlAfModeApi? = nilOrValue(args[3])
        let awbModeArg: ControlAwbModeApi? = nilOrValue(args[4])
        let sensorExposureTimeArg: Int64? = nilOrValue(args[5])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, mode: modeArg, aeMode: aeModeArg, afMode: afModeArg, awbMode: awbModeArg, sensorExposureTime: sensorExposureTimeArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CaptureRequestOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CaptureRequestOptionsApi, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CaptureRequestOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
