// Autogenerated from Pigeon (v25.5.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
import CoreLocation
import AVFoundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class CameraXError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "CameraXError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? CameraXError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> CameraXError {
  return CameraXError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Handles the callback when an object is deallocated.
protocol CameraXApiPigeonInternalFinalizerDelegate: AnyObject {
  /// Invoked when the strong reference of an object is deallocated in an `InstanceManager`.
  func onDeinit(identifier: Int64)
}


// Attaches to an object to receive a callback when the object is deallocated.
internal final class CameraXApiPigeonInternalFinalizer {
  internal static let associatedObjectKey = malloc(1)!

  private let identifier: Int64
  // Reference to the delegate is weak because the callback should be ignored if the
  // `InstanceManager` is deallocated.
  internal weak var delegate: CameraXApiPigeonInternalFinalizerDelegate?

  private init(identifier: Int64, delegate: CameraXApiPigeonInternalFinalizerDelegate) {
    self.identifier = identifier
    self.delegate = delegate
  }

  internal static func attach(
    to instance: AnyObject, identifier: Int64, delegate: CameraXApiPigeonInternalFinalizerDelegate
  ) {
    let finalizer = CameraXApiPigeonInternalFinalizer(identifier: identifier, delegate: delegate)
    objc_setAssociatedObject(instance, associatedObjectKey, finalizer, .OBJC_ASSOCIATION_RETAIN)
  }

  static func detach(from instance: AnyObject) {
    let finalizer = objc_getAssociatedObject(instance, associatedObjectKey) as? CameraXApiPigeonInternalFinalizer
    if let finalizer = finalizer {
      finalizer.delegate = nil
      objc_setAssociatedObject(instance, associatedObjectKey, nil, .OBJC_ASSOCIATION_ASSIGN)
    }
  }

  deinit {
    delegate?.onDeinit(identifier: identifier)
  }
}


/// Maintains instances used to communicate with the corresponding objects in Dart.
///
/// Objects stored in this container are represented by an object in Dart that is also stored in
/// an InstanceManager with the same identifier.
///
/// When an instance is added with an identifier, either can be used to retrieve the other.
///
/// Added instances are added as a weak reference and a strong reference. When the strong
/// reference is removed and the weak reference is deallocated,`CameraXApiPigeonInternalFinalizerDelegate.onDeinit`
/// is called with the instance's identifier. However, if the strong reference is removed and then the identifier is
/// retrieved with the intention to pass the identifier to Dart (e.g. by calling `identifierWithStrongReference`),
/// the strong reference to the instance is re-added. The strong reference will then need to be removed manually
/// again.
///
/// Accessing and inserting to an InstanceManager is thread safe.
final class CameraXApiPigeonInstanceManager {
  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously from Dart.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  private static let minHostCreatedIdentifier: Int64 = 65536

  private let lockQueue = DispatchQueue(label: "CameraXApiPigeonInstanceManager")
  private let identifiers: NSMapTable<AnyObject, NSNumber> = NSMapTable(
    keyOptions: [.weakMemory, .objectPointerPersonality], valueOptions: .strongMemory)
  private let weakInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.weakMemory, .objectPointerPersonality])
  private let strongInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.strongMemory, .objectPointerPersonality])
  private let finalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate
  private var nextIdentifier: Int64 = minHostCreatedIdentifier

  public init(finalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate) {
    self.finalizerDelegate = finalizerDelegate
  }

  /// Adds a new instance that was instantiated from Dart.
  ///
  /// The same instance can be added multiple times, but each identifier must be unique. This allows
  /// two objects that are equivalent (e.g. conforms to `Equatable`)  to both be added.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored
  ///   - identifier: the identifier to be paired with instance. This value must be >= 0 and unique
  func addDartCreatedInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    lockQueue.async {
      self.addInstance(instance, withIdentifier: identifier)
    }
  }

  /// Adds a new instance that was instantiated from the host platform.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored. This must be unique to all other added instances.
  /// - Returns: the unique identifier (>= 0) stored with instance
  func addHostCreatedInstance(_ instance: AnyObject) -> Int64 {
    assert(!containsInstance(instance), "Instance of \(instance) has already been added.")
    var identifier: Int64 = -1
    lockQueue.sync {
      identifier = nextIdentifier
      nextIdentifier += 1
      self.addInstance(instance, withIdentifier: identifier)
    }
    return identifier
  }

  /// Removes `instanceIdentifier` and its associated strongly referenced instance, if present, from the manager.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier paired to an instance.
  /// - Returns: removed instance if the manager contains the given identifier, otherwise `nil` if
  ///   the manager doesn't contain the value
  func removeInstance<T: AnyObject>(withIdentifier instanceIdentifier: Int64) throws -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = strongInstances.object(forKey: NSNumber(value: instanceIdentifier))
      strongInstances.removeObject(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier associated with an instance
  /// - Returns: the instance associated with `instanceIdentifier` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func instance<T: AnyObject>(forIdentifier instanceIdentifier: Int64) -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = weakInstances.object(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  private func addInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    assert(identifier >= 0)
    assert(
      weakInstances.object(forKey: identifier as NSNumber) == nil,
      "Identifier has already been added: \(identifier)")
    identifiers.setObject(NSNumber(value: identifier), forKey: instance)
    weakInstances.setObject(instance, forKey: NSNumber(value: identifier))
    strongInstances.setObject(instance, forKey: NSNumber(value: identifier))
    CameraXApiPigeonInternalFinalizer.attach(to: instance, identifier: identifier, delegate: finalizerDelegate)
  }

  /// Retrieves the identifier paired with an instance.
  ///
  /// If the manager contains a strong reference to `instance`, it will return the identifier
  /// associated with `instance`. If the manager contains only a weak reference to `instance`, a new
  /// strong reference to `instance` will be added and will need to be removed again with `removeInstance`.
  ///
  /// If this method returns a nonnull identifier, this method also expects the Dart
  /// `CameraXApiPigeonInstanceManager` to have, or recreate, a weak reference to the Dart instance the
  /// identifier is associated with.
  ///
  /// - Parameters:
  ///   - instance: an instance that may be stored in the manager
  /// - Returns: the identifier associated with `instance` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func identifierWithStrongReference(forInstance instance: AnyObject) -> Int64? {
    var identifier: Int64? = nil
    lockQueue.sync {
      if let existingIdentifier = identifiers.object(forKey: instance)?.int64Value {
        strongInstances.setObject(instance, forKey: NSNumber(value: existingIdentifier))
        identifier = existingIdentifier
      }
    }
    return identifier
  }

  /// Whether this manager contains the given `instance`.
  ///
  /// - Parameters:
  ///   - instance: the instance whose presence in this manager is to be tested
  /// - Returns: whether this manager contains the given `instance`
  func containsInstance(_ instance: AnyObject) -> Bool {
    var containsInstance = false
    lockQueue.sync {
      containsInstance = identifiers.object(forKey: instance) != nil
    }
    return containsInstance
  }

  /// Removes all of the instances from this manager.
  ///
  /// The manager will be empty after this call returns.
  func removeAllObjects() throws {
    lockQueue.sync {
      let weakInstancesEnumerator = weakInstances.objectEnumerator()!
      while let instance = weakInstancesEnumerator.nextObject() {
        CameraXApiPigeonInternalFinalizer.detach(from: instance as AnyObject)
      }
      identifiers.removeAllObjects()
      weakInstances.removeAllObjects()
      strongInstances.removeAllObjects()
      nextIdentifier = CameraXApiPigeonInstanceManager.minHostCreatedIdentifier
    }
  }

  /// The number of instances stored as a strong reference.
  ///
  /// For debugging and testing purposes.
  internal var strongInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = strongInstances.count
    }
    return count
  }

  /// The number of instances stored as a weak reference.
  ///
  /// For debugging and testing purposes. NSMapTables that store keys or objects as weak
  /// reference will be reclaimed non-deterministically.
  internal var weakInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = weakInstances.count
    }
    return count
  }
}


private class CameraXApiPigeonInstanceManagerApi {
  /// The codec used for serializing messages.
  var codec: FlutterStandardMessageCodec { CameraXApiPigeonCodec.shared }

  /// Handles sending and receiving messages with Dart.
  unowned let binaryMessenger: FlutterBinaryMessenger

  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  /// Sets up an instance of `CameraXApiPigeonInstanceManagerApi` to handle messages through the `binaryMessenger`.
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, instanceManager: CameraXApiPigeonInstanceManager?) {
    let codec = CameraXApiPigeonCodec.shared
    let removeStrongReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.removeStrongReference", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      removeStrongReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! Int64
        do {
          let _: AnyObject? = try instanceManager.removeInstance(withIdentifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStrongReferenceChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.clear", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      clearChannel.setMessageHandler { _, reply in
        do {
          try instanceManager.removeAllObjects()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
  }

  /// Sends a message to the Dart `InstanceManager` to remove the strong reference of the instance associated with `identifier`.
  func removeStrongReference(identifier identifierArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.removeStrongReference"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
protocol CameraXApiPigeonProxyApiDelegate {
  /// An implementation of [PigeonApiPermissionManagerApi] used to add a new Dart instance of
  /// `PermissionManagerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPermissionManagerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPermissionManagerApi
  /// An implementation of [PigeonApiAutoCloseableApi] used to add a new Dart instance of
  /// `AutoCloseableApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAutoCloseableApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAutoCloseableApi
  /// An implementation of [PigeonApiCloseableApi] used to add a new Dart instance of
  /// `CloseableApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCloseableApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCloseableApi
  /// An implementation of [PigeonApiCLLocationApi] used to add a new Dart instance of
  /// `CLLocationApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCLLocationApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCLLocationApi
  /// An implementation of [PigeonApiSizeApi] used to add a new Dart instance of
  /// `SizeApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSizeApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiSizeApi
  /// An implementation of [PigeonApiSizeFApi] used to add a new Dart instance of
  /// `SizeFApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSizeFApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiSizeFApi
  /// An implementation of [PigeonApiPointApi] used to add a new Dart instance of
  /// `PointApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPointApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPointApi
  /// An implementation of [PigeonApiPointFApi] used to add a new Dart instance of
  /// `PointFApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPointFApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPointFApi
  /// An implementation of [PigeonApiRectApi] used to add a new Dart instance of
  /// `RectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRectApi
  /// An implementation of [PigeonApiRectFApi] used to add a new Dart instance of
  /// `RectFApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRectFApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRectFApi
  /// An implementation of [PigeonApiCameraSelectorApi] used to add a new Dart instance of
  /// `CameraSelectorApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraSelectorApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraSelectorApi
  /// An implementation of [PigeonApiCameraStateLiveDataApi] used to add a new Dart instance of
  /// `CameraStateLiveDataApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraStateLiveDataApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraStateLiveDataApi
  /// An implementation of [PigeonApiCameraStateObserverApi] used to add a new Dart instance of
  /// `CameraStateObserverApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraStateObserverApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraStateObserverApi
  /// An implementation of [PigeonApiTorchStateLiveDataApi] used to add a new Dart instance of
  /// `TorchStateLiveDataApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiTorchStateLiveDataApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiTorchStateLiveDataApi
  /// An implementation of [PigeonApiTorchStateObserverApi] used to add a new Dart instance of
  /// `TorchStateObserverApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiTorchStateObserverApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiTorchStateObserverApi
  /// An implementation of [PigeonApiZoomStateApi] used to add a new Dart instance of
  /// `ZoomStateApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiZoomStateApi
  /// An implementation of [PigeonApiZoomStateLiveDataApi] used to add a new Dart instance of
  /// `ZoomStateLiveDataApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateLiveDataApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiZoomStateLiveDataApi
  /// An implementation of [PigeonApiZoomStateObserverApi] used to add a new Dart instance of
  /// `ZoomStateObserverApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateObserverApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiZoomStateObserverApi
  /// An implementation of [PigeonApiMeteringPointApi] used to add a new Dart instance of
  /// `MeteringPointApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiMeteringPointApi
  /// An implementation of [PigeonApiMeteringPointFactoryApi] used to add a new Dart instance of
  /// `MeteringPointFactoryApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointFactoryApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiMeteringPointFactoryApi
  /// An implementation of [PigeonApiSurfaceOrientedMeteringPointFactoryApi] used to add a new Dart instance of
  /// `SurfaceOrientedMeteringPointFactoryApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSurfaceOrientedMeteringPointFactoryApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiSurfaceOrientedMeteringPointFactoryApi
  /// An implementation of [PigeonApiMeteringPointTupleApi] used to add a new Dart instance of
  /// `MeteringPointTupleApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointTupleApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiMeteringPointTupleApi
  /// An implementation of [PigeonApiDurationTupleApi] used to add a new Dart instance of
  /// `DurationTupleApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiDurationTupleApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiDurationTupleApi
  /// An implementation of [PigeonApiFocusMeteringActionApi] used to add a new Dart instance of
  /// `FocusMeteringActionApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFocusMeteringActionApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiFocusMeteringActionApi
  /// An implementation of [PigeonApiFocusMeteringResultApi] used to add a new Dart instance of
  /// `FocusMeteringResultApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFocusMeteringResultApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiFocusMeteringResultApi
  /// An implementation of [PigeonApiCameraInfoApi] used to add a new Dart instance of
  /// `CameraInfoApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraInfoApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraInfoApi
  /// An implementation of [PigeonApiCameraControlApi] used to add a new Dart instance of
  /// `CameraControlApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraControlApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraControlApi
  /// An implementation of [PigeonApiResolutionStrategyApi] used to add a new Dart instance of
  /// `ResolutionStrategyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiResolutionStrategyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiResolutionStrategyApi
  /// An implementation of [PigeonApiResolutionSelectorApi] used to add a new Dart instance of
  /// `ResolutionSelectorApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiResolutionSelectorApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiResolutionSelectorApi
  /// An implementation of [PigeonApiImageInfoApi] used to add a new Dart instance of
  /// `ImageInfoApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageInfoApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageInfoApi
  /// An implementation of [PigeonApiPlaneProxyApi] used to add a new Dart instance of
  /// `PlaneProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPlaneProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPlaneProxyApi
  /// An implementation of [PigeonApiImageProxyApi] used to add a new Dart instance of
  /// `ImageProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageProxyApi
  /// An implementation of [PigeonApiOnImageCapturedCallbackApi] used to add a new Dart instance of
  /// `OnImageCapturedCallbackApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOnImageCapturedCallbackApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOnImageCapturedCallbackApi
  /// An implementation of [PigeonApiAnalyzerApi] used to add a new Dart instance of
  /// `AnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAnalyzerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAnalyzerApi
  /// An implementation of [PigeonApiImageAnalyzerApi] used to add a new Dart instance of
  /// `ImageAnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageAnalyzerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageAnalyzerApi
  /// An implementation of [PigeonApiAVMetadataObjectApi] used to add a new Dart instance of
  /// `AVMetadataObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataObjectApi
  /// An implementation of [PigeonApiAVMetadataBodyObjectApi] used to add a new Dart instance of
  /// `AVMetadataBodyObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataBodyObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataBodyObjectApi
  /// An implementation of [PigeonApiAVMetadataCatBodyObjectApi] used to add a new Dart instance of
  /// `AVMetadataCatBodyObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataCatBodyObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataCatBodyObjectApi
  /// An implementation of [PigeonApiAVMetadataDogBodyObjectApi] used to add a new Dart instance of
  /// `AVMetadataDogBodyObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataDogBodyObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataDogBodyObjectApi
  /// An implementation of [PigeonApiAVMetadataHumanBodyObjectApi] used to add a new Dart instance of
  /// `AVMetadataHumanBodyObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataHumanBodyObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataHumanBodyObjectApi
  /// An implementation of [PigeonApiAVMetadataHumanFullBodyObjectApi] used to add a new Dart instance of
  /// `AVMetadataHumanFullBodyObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataHumanFullBodyObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataHumanFullBodyObjectApi
  /// An implementation of [PigeonApiAVMetadataFaceObjectApi] used to add a new Dart instance of
  /// `AVMetadataFaceObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataFaceObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataFaceObjectApi
  /// An implementation of [PigeonApiAVMetadataMachineReadableCodeObjectApi] used to add a new Dart instance of
  /// `AVMetadataMachineReadableCodeObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataMachineReadableCodeObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataMachineReadableCodeObjectApi
  /// An implementation of [PigeonApiAVMetadataSalientObjectApi] used to add a new Dart instance of
  /// `AVMetadataSalientObjectApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataSalientObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataSalientObjectApi
  /// An implementation of [PigeonApiAVAnalyzerResultApi] used to add a new Dart instance of
  /// `AVAnalyzerResultApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVAnalyzerResultApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVAnalyzerResultApi
  /// An implementation of [PigeonApiAVAnalyzerResultConsumerApi] used to add a new Dart instance of
  /// `AVAnalyzerResultConsumerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVAnalyzerResultConsumerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVAnalyzerResultConsumerApi
  /// An implementation of [PigeonApiAVAnalyzerApi] used to add a new Dart instance of
  /// `AVAnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVAnalyzerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVAnalyzerApi
  /// An implementation of [PigeonApiOutputOptionsApi] used to add a new Dart instance of
  /// `OutputOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputOptionsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOutputOptionsApi
  /// An implementation of [PigeonApiFileOutputOptionsApi] used to add a new Dart instance of
  /// `FileOutputOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFileOutputOptionsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiFileOutputOptionsApi
  /// An implementation of [PigeonApiAudioConfigApi] used to add a new Dart instance of
  /// `AudioConfigApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAudioConfigApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAudioConfigApi
  /// An implementation of [PigeonApiAudioStatsApi] used to add a new Dart instance of
  /// `AudioStatsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAudioStatsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAudioStatsApi
  /// An implementation of [PigeonApiRecordingStatsApi] used to add a new Dart instance of
  /// `RecordingStatsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRecordingStatsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRecordingStatsApi
  /// An implementation of [PigeonApiVideoRecordEventApi] used to add a new Dart instance of
  /// `VideoRecordEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventApi
  /// An implementation of [PigeonApiVideoRecordStatusEventApi] used to add a new Dart instance of
  /// `VideoRecordStatusEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordStatusEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordStatusEventApi
  /// An implementation of [PigeonApiVideoRecordStartEventApi] used to add a new Dart instance of
  /// `VideoRecordStartEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordStartEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordStartEventApi
  /// An implementation of [PigeonApiVideoRecordPauseEventApi] used to add a new Dart instance of
  /// `VideoRecordPauseEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordPauseEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordPauseEventApi
  /// An implementation of [PigeonApiVideoRecordResumeEventApi] used to add a new Dart instance of
  /// `VideoRecordResumeEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordResumeEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordResumeEventApi
  /// An implementation of [PigeonApiOutputResultsApi] used to add a new Dart instance of
  /// `OutputResultsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputResultsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOutputResultsApi
  /// An implementation of [PigeonApiVideoRecordFinalizeEventApi] used to add a new Dart instance of
  /// `VideoRecordFinalizeEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordFinalizeEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordFinalizeEventApi
  /// An implementation of [PigeonApiVideoRecordEventConsumerApi] used to add a new Dart instance of
  /// `VideoRecordEventConsumerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordEventConsumerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventConsumerApi
  /// An implementation of [PigeonApiRecordingApi] used to add a new Dart instance of
  /// `RecordingApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRecordingApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRecordingApi
  /// An implementation of [PigeonApiCameraControllerApi] used to add a new Dart instance of
  /// `CameraControllerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraControllerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraControllerApi
  /// An implementation of [PigeonApiPreviewViewApi] used to add a new Dart instance of
  /// `PreviewViewApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPreviewViewApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPreviewViewApi
}

extension CameraXApiPigeonProxyApiDelegate {
  func pigeonApiCloseableApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCloseableApi {
    return PigeonApiCloseableApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateCloseableApi())
  }
  func pigeonApiAnalyzerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAnalyzerApi {
    return PigeonApiAnalyzerApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateAnalyzerApi())
  }
  func pigeonApiAVMetadataObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataObjectApi {
    return PigeonApiAVMetadataObjectApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateAVMetadataObjectApi())
  }
  func pigeonApiAVMetadataBodyObjectApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataBodyObjectApi {
    return PigeonApiAVMetadataBodyObjectApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateAVMetadataBodyObjectApi())
  }
  func pigeonApiVideoRecordEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventApi {
    return PigeonApiVideoRecordEventApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateVideoRecordEventApi())
  }
}

open class CameraXApiPigeonProxyApiRegistrar {
  let binaryMessenger: FlutterBinaryMessenger
  let apiDelegate: CameraXApiPigeonProxyApiDelegate
  let instanceManager: CameraXApiPigeonInstanceManager
  /// Whether APIs should ignore calling to Dart.
  public var ignoreCallsToDart = false
  private var _codec: FlutterStandardMessageCodec?
  var codec: FlutterStandardMessageCodec {
    if _codec == nil {
      _codec = FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: self))
    }
    return _codec!
  }

  private class InstanceManagerApiFinalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate {
    let api: CameraXApiPigeonInstanceManagerApi

    init(_ api: CameraXApiPigeonInstanceManagerApi) {
      self.api = api
    }

    public func onDeinit(identifier: Int64) {
      api.removeStrongReference(identifier: identifier) {
        _ in
      }
    }
  }

  init(binaryMessenger: FlutterBinaryMessenger, apiDelegate: CameraXApiPigeonProxyApiDelegate) {
    self.binaryMessenger = binaryMessenger
    self.apiDelegate = apiDelegate
    self.instanceManager = CameraXApiPigeonInstanceManager(
      finalizerDelegate: InstanceManagerApiFinalizerDelegate(
        CameraXApiPigeonInstanceManagerApi(binaryMessenger: binaryMessenger)))
  }

  func setUp() {
    CameraXApiPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: instanceManager)
    PigeonApiPermissionManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPermissionManagerApi(self))
    PigeonApiAutoCloseableApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAutoCloseableApi(self))
    PigeonApiCLLocationApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCLLocationApi(self))
    PigeonApiSizeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiSizeApi(self))
    PigeonApiSizeFApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiSizeFApi(self))
    PigeonApiPointApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPointApi(self))
    PigeonApiPointFApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPointFApi(self))
    PigeonApiRectApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRectApi(self))
    PigeonApiRectFApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRectFApi(self))
    PigeonApiCameraSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraSelectorApi(self))
    PigeonApiCameraStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraStateLiveDataApi(self))
    PigeonApiCameraStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraStateObserverApi(self))
    PigeonApiTorchStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiTorchStateLiveDataApi(self))
    PigeonApiTorchStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiTorchStateObserverApi(self))
    PigeonApiZoomStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiZoomStateLiveDataApi(self))
    PigeonApiZoomStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiZoomStateObserverApi(self))
    PigeonApiMeteringPointFactoryApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMeteringPointFactoryApi(self))
    PigeonApiSurfaceOrientedMeteringPointFactoryApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiSurfaceOrientedMeteringPointFactoryApi(self))
    PigeonApiMeteringPointTupleApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMeteringPointTupleApi(self))
    PigeonApiDurationTupleApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiDurationTupleApi(self))
    PigeonApiFocusMeteringActionApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFocusMeteringActionApi(self))
    PigeonApiCameraInfoApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraInfoApi(self))
    PigeonApiCameraControlApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraControlApi(self))
    PigeonApiResolutionStrategyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiResolutionStrategyApi(self))
    PigeonApiResolutionSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiResolutionSelectorApi(self))
    PigeonApiOnImageCapturedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOnImageCapturedCallbackApi(self))
    PigeonApiImageAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiImageAnalyzerApi(self))
    PigeonApiAVAnalyzerResultConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAVAnalyzerResultConsumerApi(self))
    PigeonApiAVAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAVAnalyzerApi(self))
    PigeonApiOutputOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOutputOptionsApi(self))
    PigeonApiFileOutputOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFileOutputOptionsApi(self))
    PigeonApiAudioConfigApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAudioConfigApi(self))
    PigeonApiVideoRecordEventConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiVideoRecordEventConsumerApi(self))
    PigeonApiRecordingApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRecordingApi(self))
    PigeonApiCameraControllerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraControllerApi(self))
    PigeonApiPreviewViewApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPreviewViewApi(self))
  }
  func tearDown() {
    CameraXApiPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: nil)
    PigeonApiPermissionManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAutoCloseableApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCLLocationApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiSizeApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiSizeFApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPointApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPointFApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRectApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRectFApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiTorchStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiTorchStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiZoomStateLiveDataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiZoomStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMeteringPointFactoryApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiSurfaceOrientedMeteringPointFactoryApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMeteringPointTupleApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiDurationTupleApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFocusMeteringActionApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraInfoApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraControlApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiResolutionStrategyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiResolutionSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOnImageCapturedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiImageAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAVAnalyzerResultConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAVAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOutputOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFileOutputOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAudioConfigApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiVideoRecordEventConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRecordingApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraControllerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPreviewViewApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
  }
}
private class CameraXApiPigeonInternalProxyApiCodecReaderWriter: FlutterStandardReaderWriter {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

  private class CameraXApiPigeonInternalProxyApiCodecReader: CameraXApiPigeonCodecReader {
    unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

    init(data: Data, pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func readValue(ofType type: UInt8) -> Any? {
      switch type {
      case 128:
        let identifier = self.readValue()
        let instance: AnyObject? = pigeonRegistrar.instanceManager.instance(
          forIdentifier: identifier is Int64 ? identifier as! Int64 : Int64(identifier as! Int32))
        if instance == nil {
          print("Failed to find instance with identifier: \(identifier!)")
        }
        return instance
      default:
        return super.readValue(ofType: type)
      }
    }
  }

  private class CameraXApiPigeonInternalProxyApiCodecWriter: CameraXApiPigeonCodecWriter {
    unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

    init(data: NSMutableData, pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func writeValue(_ value: Any) {
      if value is [Any] || value is Bool || value is Data || value is [AnyHashable: Any] || value is Double || value is FlutterStandardTypedData || value is Int64 || value is String || value is PermissionApi || value is LensFacingApi || value is CameraStateApi || value is TorchStateApi || value is MeteringModeApi || value is TimeUnitApi || value is AspectRatioApi || value is BitDepthApi || value is EncodingApi || value is ScaleTypeApi || value is UseCaseApi || value is ResolutionModeApi || value is AspectRatioFallbackRuleApi || value is ResolutionFallbackRuleApi || value is CaptureModeApi || value is FlashModeApi || value is BackpressureStrategyApi || value is CoordinateSystemApi || value is ImageFormatApi || value is MirrorModeApi || value is AudioStateApi || value is VideoRecordFinalizeEventErrorApi || value is AVMetadataObjectTypeApi || value is VNBarcodeSymbologyApi || value is VNBarcodeCompositeTypeApi || value is ControlModeApi || value is ControlAeModeApi || value is ControlAfModeApi || value is ControlAwbModeApi {
        super.writeValue(value)
        return
      }


      if let instance = value as? PermissionManager {
        pigeonRegistrar.apiDelegate.pigeonApiPermissionManagerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Closeable {
        pigeonRegistrar.apiDelegate.pigeonApiCloseableApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CLLocation {
        pigeonRegistrar.apiDelegate.pigeonApiCLLocationApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Size {
        pigeonRegistrar.apiDelegate.pigeonApiSizeApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? SizeF {
        pigeonRegistrar.apiDelegate.pigeonApiSizeFApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Point {
        pigeonRegistrar.apiDelegate.pigeonApiPointApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PointF {
        pigeonRegistrar.apiDelegate.pigeonApiPointFApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Rect {
        pigeonRegistrar.apiDelegate.pigeonApiRectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RectF {
        pigeonRegistrar.apiDelegate.pigeonApiRectFApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraSelector {
        pigeonRegistrar.apiDelegate.pigeonApiCameraSelectorApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraStateLiveData {
        pigeonRegistrar.apiDelegate.pigeonApiCameraStateLiveDataApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraStateObserver {
        pigeonRegistrar.apiDelegate.pigeonApiCameraStateObserverApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? TorchStateLiveData {
        pigeonRegistrar.apiDelegate.pigeonApiTorchStateLiveDataApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? TorchStateObserver {
        pigeonRegistrar.apiDelegate.pigeonApiTorchStateObserverApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomState {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomStateLiveData {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateLiveDataApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomStateObserver {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateObserverApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPoint {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? SurfaceOrientedMeteringPointFactory {
        pigeonRegistrar.apiDelegate.pigeonApiSurfaceOrientedMeteringPointFactoryApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPointFactory {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointFactoryApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPointTuple {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointTupleApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? DurationTuple {
        pigeonRegistrar.apiDelegate.pigeonApiDurationTupleApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FocusMeteringAction {
        pigeonRegistrar.apiDelegate.pigeonApiFocusMeteringActionApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FocusMeteringResult {
        pigeonRegistrar.apiDelegate.pigeonApiFocusMeteringResultApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraInfo {
        pigeonRegistrar.apiDelegate.pigeonApiCameraInfoApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraControl {
        pigeonRegistrar.apiDelegate.pigeonApiCameraControlApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ResolutionStrategy {
        pigeonRegistrar.apiDelegate.pigeonApiResolutionStrategyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ResolutionSelector {
        pigeonRegistrar.apiDelegate.pigeonApiResolutionSelectorApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageInfo {
        pigeonRegistrar.apiDelegate.pigeonApiImageInfoApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageProxy.PlaneProxy {
        pigeonRegistrar.apiDelegate.pigeonApiPlaneProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageProxy {
        pigeonRegistrar.apiDelegate.pigeonApiImageProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageCapture.OnImageCapturedCallback {
        pigeonRegistrar.apiDelegate.pigeonApiOnImageCapturedCallbackApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageAnalyzer {
        pigeonRegistrar.apiDelegate.pigeonApiImageAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataCatBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataCatBodyObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataDogBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataDogBodyObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataHumanBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataHumanBodyObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 17.0.0, *), let instance = value as? AVMetadataHumanFullBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataHumanFullBodyObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVMetadataFaceObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataFaceObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVMetadataMachineReadableCodeObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataMachineReadableCodeObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataSalientObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataSalientObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVMetadataObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVAnalyzer.Result {
        pigeonRegistrar.apiDelegate.pigeonApiAVAnalyzerResultApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVAnalyzerResultConsumer {
        pigeonRegistrar.apiDelegate.pigeonApiAVAnalyzerResultConsumerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVAnalyzer {
        pigeonRegistrar.apiDelegate.pigeonApiAVAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageAnalysis.Analyzer {
        pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FileOutputOptions {
        pigeonRegistrar.apiDelegate.pigeonApiFileOutputOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OutputOptions {
        pigeonRegistrar.apiDelegate.pigeonApiOutputOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AudioConfig {
        pigeonRegistrar.apiDelegate.pigeonApiAudioConfigApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AudioStats {
        pigeonRegistrar.apiDelegate.pigeonApiAudioStatsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RecordingStats {
        pigeonRegistrar.apiDelegate.pigeonApiRecordingStatsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Status {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordStatusEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Start {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordStartEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Pause {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordPauseEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Resume {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordResumeEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OutputResults {
        pigeonRegistrar.apiDelegate.pigeonApiOutputResultsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Finalize {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordFinalizeEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEventConsumer {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventConsumerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Recording {
        pigeonRegistrar.apiDelegate.pigeonApiRecordingApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AutoCloseable {
        pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraController {
        pigeonRegistrar.apiDelegate.pigeonApiCameraControllerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PreviewView {
        pigeonRegistrar.apiDelegate.pigeonApiPreviewViewApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as AnyObject?, pigeonRegistrar.instanceManager.containsInstance(instance)
      {
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance)!)
      } else {
        print("Unsupported value: \(value) of \(type(of: value))")
        assert(false, "Unsupported value for CameraXApiPigeonInternalProxyApiCodecWriter")
      }

    }
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
    self.pigeonRegistrar = pigeonRegistrar
  }

  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraXApiPigeonInternalProxyApiCodecReader(data: data, pigeonRegistrar: pigeonRegistrar)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraXApiPigeonInternalProxyApiCodecWriter(data: data, pigeonRegistrar: pigeonRegistrar)
  }
}

enum PermissionApi: Int {
  case video = 0
  case audio = 1
}

enum LensFacingApi: Int {
  case unknown = 0
  case front = 1
  case back = 2
  case external = 3
}

enum CameraStateApi: Int {
  case pendingOpen = 0
  case opening = 1
  case open = 2
  case closing = 3
  case closed = 4
}

enum TorchStateApi: Int {
  case off = 0
  case on = 1
}

enum MeteringModeApi: Int {
  case af = 0
  case ae = 1
  case awb = 2
}

enum TimeUnitApi: Int {
  case nanoseconds = 0
  case microseconds = 1
  case milliseconds = 2
  case seconds = 3
  case minutes = 4
  case hours = 5
  case days = 6
}

enum AspectRatioApi: Int {
  case ratioDefault = 0
  case ratio43 = 1
  case ratio169 = 2
}

enum BitDepthApi: Int {
  case bitDepthUnspecified = 0
  case bitDepth8Bit = 1
  case bitDepth10Bit = 2
}

enum EncodingApi: Int {
  case unspecified = 0
  case sdr = 1
  case hdrUnspecified = 2
  case hlg = 3
  case hdr10 = 4
  case hdr10Plus = 5
  case dolbyVision = 6
}

enum ScaleTypeApi: Int {
  case fillStart = 0
  case fillCenter = 1
  case fillEnd = 2
  case fitStart = 3
  case fitCenter = 4
  case fitEnd = 5
}

enum UseCaseApi: Int {
  case imageCapture = 0
  case imageAnalysis = 1
  case videoCapture = 2
}

enum ResolutionModeApi: Int {
  case preferCaptureRateOverHigherResolution = 0
  case preferHigherResolutionOverCaptureRate = 1
}

enum AspectRatioFallbackRuleApi: Int {
  case none = 0
  case auto = 1
}

enum ResolutionFallbackRuleApi: Int {
  case none = 0
  case closestHigherThenLower = 1
  case closestHigher = 2
  case closestLowerThenHigher = 3
  case closestLower = 4
}

enum CaptureModeApi: Int {
  case maximizeQuality = 0
  case minimizeLatency = 1
  case zeroShutterLag = 2
}

enum FlashModeApi: Int {
  case auto = 0
  case on = 1
  case off = 2
  case screen = 3
}

enum BackpressureStrategyApi: Int {
  case keepOnlyLatest = 0
  case blockProducer = 1
}

enum CoordinateSystemApi: Int {
  case original = 0
  case sensor = 1
  case viewReferenced = 2
}

enum ImageFormatApi: Int {
  case yuv420888 = 0
  case rgba8888 = 1
  case jpeg = 2
}

enum MirrorModeApi: Int {
  case off = 0
  case on = 1
  case onFrontOnly = 2
}

enum AudioStateApi: Int {
  case active = 0
  case disabled = 1
  case sourceSilenced = 2
  case encoderError = 3
  case sourceError = 4
  case muted = 5
}

enum VideoRecordFinalizeEventErrorApi: Int {
  case none = 0
  case unknown = 1
  case fileSizeLimitReached = 2
  case insufficientStorage = 3
  case sourceInactive = 4
  case invalidOuputOptions = 5
  case encodingFailed = 6
  case recorderError = 7
  case noValidData = 8
  case durationLimitReached = 9
  case recordingGarbageCollected = 10
}

enum AVMetadataObjectTypeApi: Int {
  case codabar = 0
  case code39 = 1
  case code39Mod43 = 2
  case code93 = 3
  case code128 = 4
  case ean8 = 5
  case ean13 = 6
  case gs1DataBar = 7
  case gs1DataBarExpanded = 8
  case gs1DataBarLimited = 9
  case interleaved2of5 = 10
  case itf14 = 11
  case upce = 12
  case aztec = 13
  case dataMatrix = 14
  case microPDF417 = 15
  case microQR = 16
  case pdf417 = 17
  case qr = 18
  case humanBody = 19
  case humanFullBody = 20
  case dogBody = 21
  case catBody = 22
  case face = 23
  case salientObject = 24
}

enum VNBarcodeSymbologyApi: Int {
  case aztec = 0
  case codabar = 1
  case code39 = 2
  case code39Checksum = 3
  case code39FullASCII = 4
  case code39FullASCIIChecksum = 5
  case code93 = 6
  case code93i = 7
  case code128 = 8
  case dataMatrix = 9
  case ean8 = 10
  case ean13 = 11
  case gs1DataBar = 12
  case gs1DataBarExpanded = 13
  case gs1DataBarLimited = 14
  case i2of5 = 15
  case i2of5Checksum = 16
  case itf14 = 17
  case microPDF417 = 18
  case microQR = 19
  case msiPlessey = 20
  case pdf417 = 21
  case qr = 22
  case upce = 23
}

enum VNBarcodeCompositeTypeApi: Int {
  case none = 0
  case linked = 1
  case gs1TypeA = 2
  case gs1TypeB = 3
  case gs1TypeC = 4
}

enum ControlModeApi: Int {
  case auto = 0
  case off = 1
  case offKeepState = 2
  case useExtendedSceneMode = 3
  case useSceneMode = 4
}

enum ControlAeModeApi: Int {
  case off = 0
  case on = 1
  case onAlwaysFlash = 2
  case onAutoFlash = 3
  case onAutoFlashRedeye = 4
  case onExternalFlash = 5
  case onLowLightBoostBrightnessPriority = 6
}

enum ControlAfModeApi: Int {
  case auto = 0
  case continuousPicture = 1
  case edof = 2
  case macro = 3
  case off = 4
}

enum ControlAwbModeApi: Int {
  case auto = 0
  case cloudyDaylight = 1
  case daylight = 2
  case fluorescent = 3
  case incandesecent = 4
  case off = 5
  case shade = 6
  case twilight = 7
  case warmFluorescent = 8
}

private class CameraXApiPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PermissionApi(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return LensFacingApi(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CameraStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TorchStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MeteringModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TimeUnitApi(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AspectRatioApi(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BitDepthApi(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return EncodingApi(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ScaleTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UseCaseApi(rawValue: enumResultAsInt)
      }
      return nil
    case 140:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResolutionModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 141:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AspectRatioFallbackRuleApi(rawValue: enumResultAsInt)
      }
      return nil
    case 142:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResolutionFallbackRuleApi(rawValue: enumResultAsInt)
      }
      return nil
    case 143:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CaptureModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 144:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FlashModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 145:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BackpressureStrategyApi(rawValue: enumResultAsInt)
      }
      return nil
    case 146:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CoordinateSystemApi(rawValue: enumResultAsInt)
      }
      return nil
    case 147:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageFormatApi(rawValue: enumResultAsInt)
      }
      return nil
    case 148:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MirrorModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 149:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AudioStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 150:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VideoRecordFinalizeEventErrorApi(rawValue: enumResultAsInt)
      }
      return nil
    case 151:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AVMetadataObjectTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 152:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VNBarcodeSymbologyApi(rawValue: enumResultAsInt)
      }
      return nil
    case 153:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VNBarcodeCompositeTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 154:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 155:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAeModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 156:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAfModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 157:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAwbModeApi(rawValue: enumResultAsInt)
      }
      return nil
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class CameraXApiPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PermissionApi {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? LensFacingApi {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? CameraStateApi {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? TorchStateApi {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? MeteringModeApi {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? TimeUnitApi {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? AspectRatioApi {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? BitDepthApi {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? EncodingApi {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? ScaleTypeApi {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? UseCaseApi {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResolutionModeApi {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? AspectRatioFallbackRuleApi {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResolutionFallbackRuleApi {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else if let value = value as? CaptureModeApi {
      super.writeByte(143)
      super.writeValue(value.rawValue)
    } else if let value = value as? FlashModeApi {
      super.writeByte(144)
      super.writeValue(value.rawValue)
    } else if let value = value as? BackpressureStrategyApi {
      super.writeByte(145)
      super.writeValue(value.rawValue)
    } else if let value = value as? CoordinateSystemApi {
      super.writeByte(146)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageFormatApi {
      super.writeByte(147)
      super.writeValue(value.rawValue)
    } else if let value = value as? MirrorModeApi {
      super.writeByte(148)
      super.writeValue(value.rawValue)
    } else if let value = value as? AudioStateApi {
      super.writeByte(149)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoRecordFinalizeEventErrorApi {
      super.writeByte(150)
      super.writeValue(value.rawValue)
    } else if let value = value as? AVMetadataObjectTypeApi {
      super.writeByte(151)
      super.writeValue(value.rawValue)
    } else if let value = value as? VNBarcodeSymbologyApi {
      super.writeByte(152)
      super.writeValue(value.rawValue)
    } else if let value = value as? VNBarcodeCompositeTypeApi {
      super.writeByte(153)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlModeApi {
      super.writeByte(154)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAeModeApi {
      super.writeByte(155)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAfModeApi {
      super.writeByte(156)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAwbModeApi {
      super.writeByte(157)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class CameraXApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraXApiPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraXApiPigeonCodecWriter(data: data)
  }
}

class CameraXApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = CameraXApiPigeonCodec(readerWriter: CameraXApiPigeonCodecReaderWriter())
}

protocol PigeonApiDelegatePermissionManagerApi {
  func instance(pigeonApi: PigeonApiPermissionManagerApi) throws -> PermissionManager
  func checkPermissioin(pigeonApi: PigeonApiPermissionManagerApi, pigeonInstance: PermissionManager, permission: PermissionApi) throws -> Bool
  func requestPermissions(pigeonApi: PigeonApiPermissionManagerApi, pigeonInstance: PermissionManager, permissions: [PermissionApi], completion: @escaping (Result<Bool, Error>) -> Void)
}

protocol PigeonApiProtocolPermissionManagerApi {
}

final class PigeonApiPermissionManagerApi: PigeonApiProtocolPermissionManagerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePermissionManagerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePermissionManagerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPermissionManagerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let instanceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.instance", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      instanceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.instance(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      instanceChannel.setMessageHandler(nil)
    }
    let checkPermissioinChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.checkPermissioin", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      checkPermissioinChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PermissionManager
        let permissionArg = args[1] as! PermissionApi
        do {
          let result = try api.pigeonDelegate.checkPermissioin(pigeonApi: api, pigeonInstance: pigeonInstanceArg, permission: permissionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      checkPermissioinChannel.setMessageHandler(nil)
    }
    let requestPermissionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.requestPermissions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestPermissionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PermissionManager
        let permissionsArg = args[1] as! [PermissionApi]
        api.pigeonDelegate.requestPermissions(pigeonApi: api, pigeonInstance: pigeonInstanceArg, permissions: permissionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      requestPermissionsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PermissionManagerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PermissionManager, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAutoCloseableApi {
  func close(pigeonApi: PigeonApiAutoCloseableApi, pigeonInstance: AutoCloseable) throws
}

protocol PigeonApiProtocolAutoCloseableApi {
}

final class PigeonApiAutoCloseableApi: PigeonApiProtocolAutoCloseableApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAutoCloseableApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAutoCloseableApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAutoCloseableApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let closeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AutoCloseableApi.close", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! AutoCloseable
        do {
          try api.pigeonDelegate.close(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      closeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AutoCloseableApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AutoCloseable, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AutoCloseableApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateCloseableApi {
}

protocol PigeonApiProtocolCloseableApi {
}

final class PigeonApiCloseableApi: PigeonApiProtocolCloseableApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCloseableApi
  ///An implementation of [AutoCloseableApi] used to access callback methods
  var pigeonApiAutoCloseableApi: PigeonApiAutoCloseableApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCloseableApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CloseableApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Closeable, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CloseableApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCLLocationApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCLLocationApi, latitude: Double, longitude: Double) throws -> CLLocation
  func latitude(pigeonApi: PigeonApiCLLocationApi, pigeonInstance: CLLocation) throws -> Double
  func longitude(pigeonApi: PigeonApiCLLocationApi, pigeonInstance: CLLocation) throws -> Double
}

protocol PigeonApiProtocolCLLocationApi {
}

final class PigeonApiCLLocationApi: PigeonApiProtocolCLLocationApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCLLocationApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCLLocationApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCLLocationApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CLLocationApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let latitudeArg = args[1] as! Double
        let longitudeArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, latitude: latitudeArg, longitude: longitudeArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CLLocationApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CLLocation, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let latitudeArg = try! pigeonDelegate.latitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let longitudeArg = try! pigeonDelegate.longitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CLLocationApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, latitudeArg, longitudeArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSizeApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiSizeApi, width: Int64, height: Int64) throws -> Size
  func width(pigeonApi: PigeonApiSizeApi, pigeonInstance: Size) throws -> Int64
  func height(pigeonApi: PigeonApiSizeApi, pigeonInstance: Size) throws -> Int64
}

protocol PigeonApiProtocolSizeApi {
}

final class PigeonApiSizeApi: PigeonApiProtocolSizeApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSizeApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSizeApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiSizeApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.SizeApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let widthArg = args[1] as! Int64
        let heightArg = args[2] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, width: widthArg, height: heightArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of SizeApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Size, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SizeApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, widthArg, heightArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSizeFApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiSizeFApi, width: Double, height: Double) throws -> SizeF
  func width(pigeonApi: PigeonApiSizeFApi, pigeonInstance: SizeF) throws -> Double
  func height(pigeonApi: PigeonApiSizeFApi, pigeonInstance: SizeF) throws -> Double
}

protocol PigeonApiProtocolSizeFApi {
}

final class PigeonApiSizeFApi: PigeonApiProtocolSizeFApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSizeFApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSizeFApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiSizeFApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.SizeFApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let widthArg = args[1] as! Double
        let heightArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, width: widthArg, height: heightArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of SizeFApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: SizeF, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SizeFApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, widthArg, heightArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePointApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPointApi, x: Int64, y: Int64) throws -> Point
  func x(pigeonApi: PigeonApiPointApi, pigeonInstance: Point) throws -> Int64
  func y(pigeonApi: PigeonApiPointApi, pigeonInstance: Point) throws -> Int64
}

protocol PigeonApiProtocolPointApi {
}

final class PigeonApiPointApi: PigeonApiProtocolPointApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePointApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePointApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPointApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PointApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let xArg = args[1] as! Int64
        let yArg = args[2] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, x: xArg, y: yArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PointApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Point, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let xArg = try! pigeonDelegate.x(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yArg = try! pigeonDelegate.y(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PointApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, xArg, yArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePointFApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPointFApi, x: Double, y: Double) throws -> PointF
  func x(pigeonApi: PigeonApiPointFApi, pigeonInstance: PointF) throws -> Double
  func y(pigeonApi: PigeonApiPointFApi, pigeonInstance: PointF) throws -> Double
}

protocol PigeonApiProtocolPointFApi {
}

final class PigeonApiPointFApi: PigeonApiProtocolPointFApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePointFApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePointFApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPointFApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PointFApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, x: xArg, y: yArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PointFApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PointF, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let xArg = try! pigeonDelegate.x(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yArg = try! pigeonDelegate.y(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PointFApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, xArg, yArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRectApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiRectApi, left: Int64, top: Int64, right: Int64, bottom: Int64) throws -> Rect
  func left(pigeonApi: PigeonApiRectApi, pigeonInstance: Rect) throws -> Int64
  func top(pigeonApi: PigeonApiRectApi, pigeonInstance: Rect) throws -> Int64
  func right(pigeonApi: PigeonApiRectApi, pigeonInstance: Rect) throws -> Int64
  func bottom(pigeonApi: PigeonApiRectApi, pigeonInstance: Rect) throws -> Int64
}

protocol PigeonApiProtocolRectApi {
}

final class PigeonApiRectApi: PigeonApiProtocolRectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRectApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRectApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RectApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let leftArg = args[1] as! Int64
        let topArg = args[2] as! Int64
        let rightArg = args[3] as! Int64
        let bottomArg = args[4] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, left: leftArg, top: topArg, right: rightArg, bottom: bottomArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RectApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Rect, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let leftArg = try! pigeonDelegate.left(pigeonApi: self, pigeonInstance: pigeonInstance)
      let topArg = try! pigeonDelegate.top(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rightArg = try! pigeonDelegate.right(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bottomArg = try! pigeonDelegate.bottom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, leftArg, topArg, rightArg, bottomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRectFApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiRectFApi, left: Double, top: Double, right: Double, bottom: Double) throws -> RectF
  func left(pigeonApi: PigeonApiRectFApi, pigeonInstance: RectF) throws -> Double
  func top(pigeonApi: PigeonApiRectFApi, pigeonInstance: RectF) throws -> Double
  func right(pigeonApi: PigeonApiRectFApi, pigeonInstance: RectF) throws -> Double
  func bottom(pigeonApi: PigeonApiRectFApi, pigeonInstance: RectF) throws -> Double
}

protocol PigeonApiProtocolRectFApi {
}

final class PigeonApiRectFApi: PigeonApiProtocolRectFApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRectFApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRectFApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRectFApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RectFApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let leftArg = args[1] as! Double
        let topArg = args[2] as! Double
        let rightArg = args[3] as! Double
        let bottomArg = args[4] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, left: leftArg, top: topArg, right: rightArg, bottom: bottomArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RectFApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RectF, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let leftArg = try! pigeonDelegate.left(pigeonApi: self, pigeonInstance: pigeonInstance)
      let topArg = try! pigeonDelegate.top(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rightArg = try! pigeonDelegate.right(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bottomArg = try! pigeonDelegate.bottom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RectFApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, leftArg, topArg, rightArg, bottomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraSelectorApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraSelectorApi, lensFacing: LensFacingApi?) throws -> CameraSelector
  func front(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelector
  func back(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelector
  func external(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelector
}

protocol PigeonApiProtocolCameraSelectorApi {
}

final class PigeonApiCameraSelectorApi: PigeonApiProtocolCameraSelectorApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraSelectorApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraSelectorApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraSelectorApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let lensFacingArg: LensFacingApi? = nilOrValue(args[1])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, lensFacing: lensFacingArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let frontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.front", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      frontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.front(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      frontChannel.setMessageHandler(nil)
    }
    let backChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.back", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      backChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.back(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      backChannel.setMessageHandler(nil)
    }
    let externalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.external", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      externalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.external(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      externalChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraSelectorApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraSelector, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraStateLiveDataApi {
  func getValue(pigeonApi: PigeonApiCameraStateLiveDataApi, pigeonInstance: CameraStateLiveData) throws -> CameraStateApi?
  func observe(pigeonApi: PigeonApiCameraStateLiveDataApi, pigeonInstance: CameraStateLiveData, observer: CameraStateObserver) throws
  func removeObserver(pigeonApi: PigeonApiCameraStateLiveDataApi, pigeonInstance: CameraStateLiveData, observer: CameraStateObserver) throws
}

protocol PigeonApiProtocolCameraStateLiveDataApi {
}

final class PigeonApiCameraStateLiveDataApi: PigeonApiProtocolCameraStateLiveDataApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraStateLiveDataApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraStateLiveDataApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraStateLiveDataApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateLiveDataApi.getValue", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraStateLiveData
        do {
          let result = try api.pigeonDelegate.getValue(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getValueChannel.setMessageHandler(nil)
    }
    let observeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateLiveDataApi.observe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraStateLiveData
        let observerArg = args[1] as! CameraStateObserver
        do {
          try api.pigeonDelegate.observe(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateLiveDataApi.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraStateLiveData
        let observerArg = args[1] as! CameraStateObserver
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraStateLiveDataApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraStateLiveData, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraStateLiveDataApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraStateObserverApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraStateObserverApi) throws -> CameraStateObserver
}

protocol PigeonApiProtocolCameraStateObserverApi {
  func onChanged(pigeonInstance pigeonInstanceArg: CameraStateObserver, value valueArg: CameraStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiCameraStateObserverApi: PigeonApiProtocolCameraStateObserverApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraStateObserverApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraStateObserverApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraStateObserverApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateObserverApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraStateObserverApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraStateObserver, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of CameraStateObserverApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: CameraStateObserver, value valueArg: CameraStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraStateObserverApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateTorchStateLiveDataApi {
  func getValue(pigeonApi: PigeonApiTorchStateLiveDataApi, pigeonInstance: TorchStateLiveData) throws -> TorchStateApi?
  func observe(pigeonApi: PigeonApiTorchStateLiveDataApi, pigeonInstance: TorchStateLiveData, observer: TorchStateObserver) throws
  func removeObserver(pigeonApi: PigeonApiTorchStateLiveDataApi, pigeonInstance: TorchStateLiveData, observer: TorchStateObserver) throws
}

protocol PigeonApiProtocolTorchStateLiveDataApi {
}

final class PigeonApiTorchStateLiveDataApi: PigeonApiProtocolTorchStateLiveDataApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateTorchStateLiveDataApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateTorchStateLiveDataApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiTorchStateLiveDataApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateLiveDataApi.getValue", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! TorchStateLiveData
        do {
          let result = try api.pigeonDelegate.getValue(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getValueChannel.setMessageHandler(nil)
    }
    let observeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateLiveDataApi.observe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! TorchStateLiveData
        let observerArg = args[1] as! TorchStateObserver
        do {
          try api.pigeonDelegate.observe(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateLiveDataApi.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! TorchStateLiveData
        let observerArg = args[1] as! TorchStateObserver
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of TorchStateLiveDataApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: TorchStateLiveData, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.TorchStateLiveDataApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateTorchStateObserverApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiTorchStateObserverApi) throws -> TorchStateObserver
}

protocol PigeonApiProtocolTorchStateObserverApi {
  func onChanged(pigeonInstance pigeonInstanceArg: TorchStateObserver, value valueArg: TorchStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiTorchStateObserverApi: PigeonApiProtocolTorchStateObserverApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateTorchStateObserverApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateTorchStateObserverApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiTorchStateObserverApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateObserverApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of TorchStateObserverApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: TorchStateObserver, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of TorchStateObserverApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: TorchStateObserver, value valueArg: TorchStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.TorchStateObserverApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateZoomStateApi {
  func minZoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomState) throws -> Double
  func maxZoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomState) throws -> Double
  func zoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomState) throws -> Double
  func linearZoom(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomState) throws -> Double
}

protocol PigeonApiProtocolZoomStateApi {
}

final class PigeonApiZoomStateApi: PigeonApiProtocolZoomStateApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ZoomStateApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let minZoomRatioArg = try! pigeonDelegate.minZoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let maxZoomRatioArg = try! pigeonDelegate.maxZoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let zoomRatioArg = try! pigeonDelegate.zoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let linearZoomArg = try! pigeonDelegate.linearZoom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, minZoomRatioArg, maxZoomRatioArg, zoomRatioArg, linearZoomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateZoomStateLiveDataApi {
  func getValue(pigeonApi: PigeonApiZoomStateLiveDataApi, pigeonInstance: ZoomStateLiveData) throws -> ZoomState?
  func observe(pigeonApi: PigeonApiZoomStateLiveDataApi, pigeonInstance: ZoomStateLiveData, observer: ZoomStateObserver) throws
  func removeObserver(pigeonApi: PigeonApiZoomStateLiveDataApi, pigeonInstance: ZoomStateLiveData, observer: ZoomStateObserver) throws
}

protocol PigeonApiProtocolZoomStateLiveDataApi {
}

final class PigeonApiZoomStateLiveDataApi: PigeonApiProtocolZoomStateLiveDataApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateLiveDataApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateLiveDataApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiZoomStateLiveDataApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getValueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateLiveDataApi.getValue", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getValueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ZoomStateLiveData
        do {
          let result = try api.pigeonDelegate.getValue(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getValueChannel.setMessageHandler(nil)
    }
    let observeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateLiveDataApi.observe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ZoomStateLiveData
        let observerArg = args[1] as! ZoomStateObserver
        do {
          try api.pigeonDelegate.observe(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateLiveDataApi.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ZoomStateLiveData
        let observerArg = args[1] as! ZoomStateObserver
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ZoomStateLiveDataApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomStateLiveData, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateLiveDataApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateZoomStateObserverApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiZoomStateObserverApi) throws -> ZoomStateObserver
}

protocol PigeonApiProtocolZoomStateObserverApi {
  func onChanged(pigeonInstance pigeonInstanceArg: ZoomStateObserver, value valueArg: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiZoomStateObserverApi: PigeonApiProtocolZoomStateObserverApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateObserverApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateObserverApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiZoomStateObserverApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateObserverApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ZoomStateObserverApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomStateObserver, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ZoomStateObserverApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: ZoomStateObserver, value valueArg: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateObserverApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateMeteringPointApi {
  func size(pigeonApi: PigeonApiMeteringPointApi, pigeonInstance: MeteringPoint) throws -> Double
}

protocol PigeonApiProtocolMeteringPointApi {
}

final class PigeonApiMeteringPointApi: PigeonApiProtocolMeteringPointApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of MeteringPointApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPoint, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let sizeArg = try! pigeonDelegate.size(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, sizeArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMeteringPointFactoryApi {
  func createPoint(pigeonApi: PigeonApiMeteringPointFactoryApi, pigeonInstance: MeteringPointFactory, x: Double, y: Double, size: Double?) throws -> MeteringPoint
}

protocol PigeonApiProtocolMeteringPointFactoryApi {
}

final class PigeonApiMeteringPointFactoryApi: PigeonApiProtocolMeteringPointFactoryApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointFactoryApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointFactoryApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMeteringPointFactoryApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let createPointChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MeteringPointFactoryApi.createPoint", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createPointChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! MeteringPointFactory
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        let sizeArg: Double? = nilOrValue(args[3])
        do {
          let result = try api.pigeonDelegate.createPoint(pigeonApi: api, pigeonInstance: pigeonInstanceArg, x: xArg, y: yArg, size: sizeArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createPointChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MeteringPointFactoryApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPointFactory, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointFactoryApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSurfaceOrientedMeteringPointFactoryApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiSurfaceOrientedMeteringPointFactoryApi, width: Double, height: Double) throws -> SurfaceOrientedMeteringPointFactory
}

protocol PigeonApiProtocolSurfaceOrientedMeteringPointFactoryApi {
}

final class PigeonApiSurfaceOrientedMeteringPointFactoryApi: PigeonApiProtocolSurfaceOrientedMeteringPointFactoryApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSurfaceOrientedMeteringPointFactoryApi
  ///An implementation of [MeteringPointFactoryApi] used to access callback methods
  var pigeonApiMeteringPointFactoryApi: PigeonApiMeteringPointFactoryApi {
    return pigeonRegistrar.apiDelegate.pigeonApiMeteringPointFactoryApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSurfaceOrientedMeteringPointFactoryApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiSurfaceOrientedMeteringPointFactoryApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.SurfaceOrientedMeteringPointFactoryApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let widthArg = args[1] as! Double
        let heightArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, width: widthArg, height: heightArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of SurfaceOrientedMeteringPointFactoryApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: SurfaceOrientedMeteringPointFactory, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SurfaceOrientedMeteringPointFactoryApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMeteringPointTupleApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiMeteringPointTupleApi, point: MeteringPoint, modes: [MeteringModeApi]?) throws -> MeteringPointTuple
}

protocol PigeonApiProtocolMeteringPointTupleApi {
}

final class PigeonApiMeteringPointTupleApi: PigeonApiProtocolMeteringPointTupleApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointTupleApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointTupleApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMeteringPointTupleApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MeteringPointTupleApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let pointArg = args[1] as! MeteringPoint
        let modesArg: [MeteringModeApi]? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, point: pointArg, modes: modesArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MeteringPointTupleApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPointTuple, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointTupleApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateDurationTupleApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiDurationTupleApi, duration: Int64, timeUnit: TimeUnitApi) throws -> DurationTuple
}

protocol PigeonApiProtocolDurationTupleApi {
}

final class PigeonApiDurationTupleApi: PigeonApiProtocolDurationTupleApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateDurationTupleApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateDurationTupleApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiDurationTupleApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.DurationTupleApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let durationArg = args[1] as! Int64
        let timeUnitArg = args[2] as! TimeUnitApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, duration: durationArg, timeUnit: timeUnitArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of DurationTupleApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: DurationTuple, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.DurationTupleApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFocusMeteringActionApi {
  func build(pigeonApi: PigeonApiFocusMeteringActionApi, first: MeteringPointTuple, others: [MeteringPointTuple]?, disableAutoCancel: Bool?, autoCancelDuration: DurationTuple?) throws -> FocusMeteringAction
  func getAutoCancelDurationInMillis(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringAction) throws -> Int64
  func getMeteringPointsAe(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringAction) throws -> [MeteringPoint]
  func getMeteringPointsAf(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringAction) throws -> [MeteringPoint]
  func getMeteringPointsAwb(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringAction) throws -> [MeteringPoint]
  func isAutoCancelEnabled(pigeonApi: PigeonApiFocusMeteringActionApi, pigeonInstance: FocusMeteringAction) throws -> Bool
}

protocol PigeonApiProtocolFocusMeteringActionApi {
}

final class PigeonApiFocusMeteringActionApi: PigeonApiProtocolFocusMeteringActionApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFocusMeteringActionApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFocusMeteringActionApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFocusMeteringActionApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let firstArg = args[1] as! MeteringPointTuple
        let othersArg: [MeteringPointTuple]? = nilOrValue(args[2])
        let disableAutoCancelArg: Bool? = nilOrValue(args[3])
        let autoCancelDurationArg: DurationTuple? = nilOrValue(args[4])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, first: firstArg, others: othersArg, disableAutoCancel: disableAutoCancelArg, autoCancelDuration: autoCancelDurationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
    let getAutoCancelDurationInMillisChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.getAutoCancelDurationInMillis", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAutoCancelDurationInMillisChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.getAutoCancelDurationInMillis(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAutoCancelDurationInMillisChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.getMeteringPointsAe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAe(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAeChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.getMeteringPointsAf", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAf(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAfChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAwbChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.getMeteringPointsAwb", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAwbChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAwb(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAwbChannel.setMessageHandler(nil)
    }
    let isAutoCancelEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.isAutoCancelEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isAutoCancelEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.isAutoCancelEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isAutoCancelEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FocusMeteringActionApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FocusMeteringAction, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FocusMeteringActionApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFocusMeteringResultApi {
  func isFocusSuccessful(pigeonApi: PigeonApiFocusMeteringResultApi, pigeonInstance: FocusMeteringResult) throws -> Bool
}

protocol PigeonApiProtocolFocusMeteringResultApi {
}

final class PigeonApiFocusMeteringResultApi: PigeonApiProtocolFocusMeteringResultApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFocusMeteringResultApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFocusMeteringResultApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of FocusMeteringResultApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FocusMeteringResult, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let isFocusSuccessfulArg = try! pigeonDelegate.isFocusSuccessful(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FocusMeteringResultApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, isFocusSuccessfulArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraInfoApi {
  func mustPlayShutterSound(pigeonApi: PigeonApiCameraInfoApi) throws -> Bool
  func getCameraSelector(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> CameraSelector
  func getCameraState(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> CameraStateLiveData
  func getTorchState(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> TorchStateLiveData
  func getZoomState(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> ZoomStateLiveData
  func getIntrinsticZoomRatio(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> Double
  func getLensFacing(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> LensFacingApi
  func getPhysicalCameraInfos(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> [CameraInfo]
  func getSensorRotationDegrees(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> Int64
  func isLogicalMultiCameraSupported(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> Bool
  func isZslSupported(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> Bool
  func hasFlashUnit(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo) throws -> Bool
  func isFocusMeteringSupported(pigeonApi: PigeonApiCameraInfoApi, pigeonInstance: CameraInfo, action: FocusMeteringAction) throws -> Bool
}

protocol PigeonApiProtocolCameraInfoApi {
}

final class PigeonApiCameraInfoApi: PigeonApiProtocolCameraInfoApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraInfoApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraInfoApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraInfoApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let mustPlayShutterSoundChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.mustPlayShutterSound", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      mustPlayShutterSoundChannel.setMessageHandler { _, reply in
        do {
          let result = try api.pigeonDelegate.mustPlayShutterSound(pigeonApi: api)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      mustPlayShutterSoundChannel.setMessageHandler(nil)
    }
    let getCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraSelectorChannel.setMessageHandler(nil)
    }
    let getCameraStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getCameraState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getCameraState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraStateChannel.setMessageHandler(nil)
    }
    let getTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTorchStateChannel.setMessageHandler(nil)
    }
    let getZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getZoomStateChannel.setMessageHandler(nil)
    }
    let getIntrinsticZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getIntrinsticZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIntrinsticZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getIntrinsticZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getIntrinsticZoomRatioChannel.setMessageHandler(nil)
    }
    let getLensFacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getLensFacing", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getLensFacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getLensFacing(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getLensFacingChannel.setMessageHandler(nil)
    }
    let getPhysicalCameraInfosChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getPhysicalCameraInfos", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPhysicalCameraInfosChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getPhysicalCameraInfos(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPhysicalCameraInfosChannel.setMessageHandler(nil)
    }
    let getSensorRotationDegreesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.getSensorRotationDegrees", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSensorRotationDegreesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getSensorRotationDegrees(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSensorRotationDegreesChannel.setMessageHandler(nil)
    }
    let isLogicalMultiCameraSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.isLogicalMultiCameraSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isLogicalMultiCameraSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.isLogicalMultiCameraSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isLogicalMultiCameraSupportedChannel.setMessageHandler(nil)
    }
    let isZslSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.isZslSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isZslSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.isZslSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isZslSupportedChannel.setMessageHandler(nil)
    }
    let hasFlashUnitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.hasFlashUnit", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasFlashUnitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.hasFlashUnit(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasFlashUnitChannel.setMessageHandler(nil)
    }
    let isFocusMeteringSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoApi.isFocusMeteringSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isFocusMeteringSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        let actionArg = args[1] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.isFocusMeteringSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg, action: actionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isFocusMeteringSupportedChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraInfoApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraInfo, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraInfoApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraControlApi {
  func enableTorch(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControl, torch: Bool) throws
  func setZoomRatio(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControl, ratio: Double) throws
  func setLinearZoom(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControl, linearZoom: Double) throws
  func startFocusAndMetering(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControl, action: FocusMeteringAction) throws -> FocusMeteringResult
  func cancelFocusAndMetering(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControl) throws
  func setExposureCompensationIndex(pigeonApi: PigeonApiCameraControlApi, pigeonInstance: CameraControl, value: Int64) throws -> Int64
}

protocol PigeonApiProtocolCameraControlApi {
}

final class PigeonApiCameraControlApi: PigeonApiProtocolCameraControlApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraControlApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraControlApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraControlApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let enableTorchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.enableTorch", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableTorchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let torchArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.enableTorch(pigeonApi: api, pigeonInstance: pigeonInstanceArg, torch: torchArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableTorchChannel.setMessageHandler(nil)
    }
    let setZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.setZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let ratioArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg, ratio: ratioArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setZoomRatioChannel.setMessageHandler(nil)
    }
    let setLinearZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.setLinearZoom", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLinearZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let linearZoomArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setLinearZoom(pigeonApi: api, pigeonInstance: pigeonInstanceArg, linearZoom: linearZoomArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLinearZoomChannel.setMessageHandler(nil)
    }
    let startFocusAndMeteringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.startFocusAndMetering", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startFocusAndMeteringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let actionArg = args[1] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.startFocusAndMetering(pigeonApi: api, pigeonInstance: pigeonInstanceArg, action: actionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startFocusAndMeteringChannel.setMessageHandler(nil)
    }
    let cancelFocusAndMeteringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.cancelFocusAndMetering", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelFocusAndMeteringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        do {
          try api.pigeonDelegate.cancelFocusAndMetering(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cancelFocusAndMeteringChannel.setMessageHandler(nil)
    }
    let setExposureCompensationIndexChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlApi.setExposureCompensationIndex", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposureCompensationIndexChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let valueArg = args[1] as! Int64
        do {
          let result = try api.pigeonDelegate.setExposureCompensationIndex(pigeonApi: api, pigeonInstance: pigeonInstanceArg, value: valueArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setExposureCompensationIndexChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraControlApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraControl, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraControlApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateResolutionStrategyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiResolutionStrategyApi, boundSize: Size?, fallbackRule: ResolutionFallbackRuleApi) throws -> ResolutionStrategy
  func boundSize(pigeonApi: PigeonApiResolutionStrategyApi, pigeonInstance: ResolutionStrategy) throws -> Size?
  func fallbackRule(pigeonApi: PigeonApiResolutionStrategyApi, pigeonInstance: ResolutionStrategy) throws -> ResolutionFallbackRuleApi
}

protocol PigeonApiProtocolResolutionStrategyApi {
}

final class PigeonApiResolutionStrategyApi: PigeonApiProtocolResolutionStrategyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateResolutionStrategyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateResolutionStrategyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiResolutionStrategyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionStrategyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let boundSizeArg: Size? = nilOrValue(args[1])
        let fallbackRuleArg = args[2] as! ResolutionFallbackRuleApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, boundSize: boundSizeArg, fallbackRule: fallbackRuleArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ResolutionStrategyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ResolutionStrategy, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let boundSizeArg = try! pigeonDelegate.boundSize(pigeonApi: self, pigeonInstance: pigeonInstance)
      let fallbackRuleArg = try! pigeonDelegate.fallbackRule(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ResolutionStrategyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, boundSizeArg, fallbackRuleArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateResolutionSelectorApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiResolutionSelectorApi, resolutionStrategy: ResolutionStrategy?) throws -> ResolutionSelector
  func resolutionStrategy(pigeonApi: PigeonApiResolutionSelectorApi, pigeonInstance: ResolutionSelector) throws -> ResolutionStrategy?
}

protocol PigeonApiProtocolResolutionSelectorApi {
}

final class PigeonApiResolutionSelectorApi: PigeonApiProtocolResolutionSelectorApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateResolutionSelectorApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateResolutionSelectorApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiResolutionSelectorApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionSelectorApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let resolutionStrategyArg: ResolutionStrategy? = nilOrValue(args[1])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, resolutionStrategy: resolutionStrategyArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ResolutionSelectorApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ResolutionSelector, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let resolutionStrategyArg = try! pigeonDelegate.resolutionStrategy(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ResolutionSelectorApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, resolutionStrategyArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageInfoApi {
  func timestamp(pigeonApi: PigeonApiImageInfoApi, pigeonInstance: ImageInfo) throws -> Int64
  func rotationDegrees(pigeonApi: PigeonApiImageInfoApi, pigeonInstance: ImageInfo) throws -> Int64
}

protocol PigeonApiProtocolImageInfoApi {
}

final class PigeonApiImageInfoApi: PigeonApiProtocolImageInfoApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageInfoApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageInfoApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ImageInfoApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageInfo, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let timestampArg = try! pigeonDelegate.timestamp(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rotationDegreesArg = try! pigeonDelegate.rotationDegrees(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageInfoApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, timestampArg, rotationDegreesArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePlaneProxyApi {
  func value(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> FlutterStandardTypedData
  func pixelStride(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> Int64
  func rowStride(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> Int64
}

protocol PigeonApiProtocolPlaneProxyApi {
}

final class PigeonApiPlaneProxyApi: PigeonApiProtocolPlaneProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePlaneProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePlaneProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of PlaneProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageProxy.PlaneProxy, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let valueArg = try! pigeonDelegate.value(pigeonApi: self, pigeonInstance: pigeonInstance)
      let pixelStrideArg = try! pigeonDelegate.pixelStride(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rowStrideArg = try! pigeonDelegate.rowStride(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PlaneProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, valueArg, pixelStrideArg, rowStrideArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageProxyApi {
  func format(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> ImageFormatApi
  func width(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> Int64
  func height(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> Int64
  func planes(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> [ImageProxy.PlaneProxy]
  func imageInfo(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> ImageInfo
}

protocol PigeonApiProtocolImageProxyApi {
}

final class PigeonApiImageProxyApi: PigeonApiProtocolImageProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageProxyApi
  ///An implementation of [AutoCloseableApi] used to access callback methods
  var pigeonApiAutoCloseableApi: PigeonApiAutoCloseableApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ImageProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let formatArg = try! pigeonDelegate.format(pigeonApi: self, pigeonInstance: pigeonInstance)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let planesArg = try! pigeonDelegate.planes(pigeonApi: self, pigeonInstance: pigeonInstance)
      let imageInfoArg = try! pigeonDelegate.imageInfo(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, formatArg, widthArg, heightArg, planesArg, imageInfoArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOnImageCapturedCallbackApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiOnImageCapturedCallbackApi) throws -> ImageCapture.OnImageCapturedCallback
}

protocol PigeonApiProtocolOnImageCapturedCallbackApi {
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureSuccess(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onError(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiOnImageCapturedCallbackApi: PigeonApiProtocolOnImageCapturedCallbackApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOnImageCapturedCallbackApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOnImageCapturedCallbackApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOnImageCapturedCallbackApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OnImageCapturedCallbackApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureStarted"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureProcessProgressed"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, progressArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onPostviewBitmapAvailable"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, bitmapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureSuccess(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureSuccess"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, imageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onError(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onError"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, exceptionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
open class PigeonApiDelegateAnalyzerApi {
}

protocol PigeonApiProtocolAnalyzerApi {
}

final class PigeonApiAnalyzerApi: PigeonApiProtocolAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAnalyzerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageAnalysis.Analyzer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AnalyzerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageAnalyzerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiImageAnalyzerApi) throws -> ImageAnalyzer
}

protocol PigeonApiProtocolImageAnalyzerApi {
  func analyze(pigeonInstance pigeonInstanceArg: ImageAnalyzer, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiImageAnalyzerApi: PigeonApiProtocolImageAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageAnalyzerApi
  ///An implementation of [AnalyzerApi] used to access callback methods
  var pigeonApiAnalyzerApi: PigeonApiAnalyzerApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiImageAnalyzerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageAnalyzerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ImageAnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageAnalyzer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ImageAnalyzerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func analyze(pigeonInstance pigeonInstanceArg: ImageAnalyzer, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageAnalyzerApi.analyze"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, imageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
open class PigeonApiDelegateAVMetadataObjectApi {
}

protocol PigeonApiProtocolAVMetadataObjectApi {
}

final class PigeonApiAVMetadataObjectApi: PigeonApiProtocolAVMetadataObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataObjectApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataObjectApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVMetadataObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateAVMetadataBodyObjectApi {
}

protocol PigeonApiProtocolAVMetadataBodyObjectApi {
}

final class PigeonApiAVMetadataBodyObjectApi: PigeonApiProtocolAVMetadataBodyObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataBodyObjectApi
  ///An implementation of [AVMetadataObjectApi] used to access callback methods
  var pigeonApiAVMetadataObjectApi: PigeonApiAVMetadataObjectApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataBodyObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataBodyObjectApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataBodyObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataCatBodyObjectApi {
  @available(iOS 13.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataCatBodyObjectApi, pigeonInstance: AVMetadataCatBodyObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 13.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataCatBodyObjectApi, pigeonInstance: AVMetadataCatBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataCatBodyObjectApi, pigeonInstance: AVMetadataCatBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataCatBodyObjectApi, pigeonInstance: AVMetadataCatBodyObject) throws -> RectF
  @available(iOS 13.0.0, *)
  func bodyID(pigeonApi: PigeonApiAVMetadataCatBodyObjectApi, pigeonInstance: AVMetadataCatBodyObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataCatBodyObjectApi {
}

final class PigeonApiAVMetadataCatBodyObjectApi: PigeonApiProtocolAVMetadataCatBodyObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataCatBodyObjectApi
  ///An implementation of [AVMetadataBodyObjectApi] used to access callback methods
  var pigeonApiAVMetadataBodyObjectApi: PigeonApiAVMetadataBodyObjectApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataCatBodyObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataCatBodyObjectApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataCatBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyIDArg = try! pigeonDelegate.bodyID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataCatBodyObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, bodyIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataDogBodyObjectApi {
  @available(iOS 13.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataDogBodyObjectApi, pigeonInstance: AVMetadataDogBodyObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 13.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataDogBodyObjectApi, pigeonInstance: AVMetadataDogBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataDogBodyObjectApi, pigeonInstance: AVMetadataDogBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataDogBodyObjectApi, pigeonInstance: AVMetadataDogBodyObject) throws -> RectF
  @available(iOS 13.0.0, *)
  func bodyID(pigeonApi: PigeonApiAVMetadataDogBodyObjectApi, pigeonInstance: AVMetadataDogBodyObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataDogBodyObjectApi {
}

final class PigeonApiAVMetadataDogBodyObjectApi: PigeonApiProtocolAVMetadataDogBodyObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataDogBodyObjectApi
  ///An implementation of [AVMetadataBodyObjectApi] used to access callback methods
  var pigeonApiAVMetadataBodyObjectApi: PigeonApiAVMetadataBodyObjectApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataDogBodyObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataDogBodyObjectApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataDogBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyIDArg = try! pigeonDelegate.bodyID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataDogBodyObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, bodyIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataHumanBodyObjectApi {
  @available(iOS 13.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataHumanBodyObjectApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 13.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataHumanBodyObjectApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataHumanBodyObjectApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataHumanBodyObjectApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> RectF
  @available(iOS 13.0.0, *)
  func bodyID(pigeonApi: PigeonApiAVMetadataHumanBodyObjectApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataHumanBodyObjectApi {
}

final class PigeonApiAVMetadataHumanBodyObjectApi: PigeonApiProtocolAVMetadataHumanBodyObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataHumanBodyObjectApi
  ///An implementation of [AVMetadataBodyObjectApi] used to access callback methods
  var pigeonApiAVMetadataBodyObjectApi: PigeonApiAVMetadataBodyObjectApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataHumanBodyObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataHumanBodyObjectApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataHumanBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyIDArg = try! pigeonDelegate.bodyID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataHumanBodyObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, bodyIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataHumanFullBodyObjectApi {
  @available(iOS 17.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 17.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> Int64
  @available(iOS 17.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> Int64
  @available(iOS 17.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> RectF
  @available(iOS 17.0.0, *)
  func bodyID(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataHumanFullBodyObjectApi {
}

final class PigeonApiAVMetadataHumanFullBodyObjectApi: PigeonApiProtocolAVMetadataHumanFullBodyObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataHumanFullBodyObjectApi
  ///An implementation of [AVMetadataBodyObjectApi] used to access callback methods
  var pigeonApiAVMetadataBodyObjectApi: PigeonApiAVMetadataBodyObjectApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataHumanFullBodyObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataHumanFullBodyObjectApi and attaches it to [pigeonInstance].
  @available(iOS 17.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataHumanFullBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyIDArg = try! pigeonDelegate.bodyID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataHumanFullBodyObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, bodyIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataFaceObjectApi {
  func type(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> AVMetadataObjectTypeApi
  func time(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> Int64
  func duration(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> Int64
  func bounds(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> RectF
  func faceID(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> Int64
  func hasRollAngle(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> Bool
  func rollAngle(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> Double
  func hasYawAngle(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> Bool
  func yawAngle(pigeonApi: PigeonApiAVMetadataFaceObjectApi, pigeonInstance: AVMetadataFaceObject) throws -> Double
}

protocol PigeonApiProtocolAVMetadataFaceObjectApi {
}

final class PigeonApiAVMetadataFaceObjectApi: PigeonApiProtocolAVMetadataFaceObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataFaceObjectApi
  ///An implementation of [AVMetadataObjectApi] used to access callback methods
  var pigeonApiAVMetadataObjectApi: PigeonApiAVMetadataObjectApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataFaceObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataFaceObjectApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVMetadataFaceObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let faceIDArg = try! pigeonDelegate.faceID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasRollAngleArg = try! pigeonDelegate.hasRollAngle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rollAngleArg = try! pigeonDelegate.rollAngle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasYawAngleArg = try! pigeonDelegate.hasYawAngle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yawAngleArg = try! pigeonDelegate.yawAngle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataFaceObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, faceIDArg, hasRollAngleArg, rollAngleArg, hasYawAngleArg, yawAngleArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataMachineReadableCodeObjectApi {
  func type(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> AVMetadataObjectTypeApi
  func time(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> Int64
  func duration(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> Int64
  func bounds(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> RectF
  func corners(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> [PointF]
  func stringValue(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> String?
}

protocol PigeonApiProtocolAVMetadataMachineReadableCodeObjectApi {
}

final class PigeonApiAVMetadataMachineReadableCodeObjectApi: PigeonApiProtocolAVMetadataMachineReadableCodeObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataMachineReadableCodeObjectApi
  ///An implementation of [AVMetadataObjectApi] used to access callback methods
  var pigeonApiAVMetadataObjectApi: PigeonApiAVMetadataObjectApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataMachineReadableCodeObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataMachineReadableCodeObjectApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVMetadataMachineReadableCodeObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let cornersArg = try! pigeonDelegate.corners(pigeonApi: self, pigeonInstance: pigeonInstance)
      let stringValueArg = try! pigeonDelegate.stringValue(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataMachineReadableCodeObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, cornersArg, stringValueArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataSalientObjectApi {
  @available(iOS 13.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataSalientObjectApi, pigeonInstance: AVMetadataSalientObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 13.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataSalientObjectApi, pigeonInstance: AVMetadataSalientObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataSalientObjectApi, pigeonInstance: AVMetadataSalientObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataSalientObjectApi, pigeonInstance: AVMetadataSalientObject) throws -> RectF
  @available(iOS 13.0.0, *)
  func objectID(pigeonApi: PigeonApiAVMetadataSalientObjectApi, pigeonInstance: AVMetadataSalientObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataSalientObjectApi {
}

final class PigeonApiAVMetadataSalientObjectApi: PigeonApiProtocolAVMetadataSalientObjectApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataSalientObjectApi
  ///An implementation of [AVMetadataObjectApi] used to access callback methods
  var pigeonApiAVMetadataObjectApi: PigeonApiAVMetadataObjectApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataSalientObjectApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataSalientObjectApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataSalientObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let objectIDArg = try! pigeonDelegate.objectID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataSalientObjectApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, objectIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVAnalyzerResultApi {
  func size(pigeonApi: PigeonApiAVAnalyzerResultApi, pigeonInstance: AVAnalyzer.Result) throws -> Size
  func objects(pigeonApi: PigeonApiAVAnalyzerResultApi, pigeonInstance: AVAnalyzer.Result) throws -> [AVMetadataObject]
}

protocol PigeonApiProtocolAVAnalyzerResultApi {
}

final class PigeonApiAVAnalyzerResultApi: PigeonApiProtocolAVAnalyzerResultApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVAnalyzerResultApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVAnalyzerResultApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVAnalyzerResultApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVAnalyzer.Result, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let sizeArg = try! pigeonDelegate.size(pigeonApi: self, pigeonInstance: pigeonInstance)
      let objectsArg = try! pigeonDelegate.objects(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVAnalyzerResultApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, sizeArg, objectsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVAnalyzerResultConsumerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiAVAnalyzerResultConsumerApi) throws -> AVAnalyzerResultConsumer
}

protocol PigeonApiProtocolAVAnalyzerResultConsumerApi {
  func accept(pigeonInstance pigeonInstanceArg: AVAnalyzerResultConsumer, value valueArg: AVAnalyzer.Result, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiAVAnalyzerResultConsumerApi: PigeonApiProtocolAVAnalyzerResultConsumerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVAnalyzerResultConsumerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVAnalyzerResultConsumerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAVAnalyzerResultConsumerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AVAnalyzerResultConsumerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AVAnalyzerResultConsumerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVAnalyzerResultConsumer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of AVAnalyzerResultConsumerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func accept(pigeonInstance pigeonInstanceArg: AVAnalyzerResultConsumer, value valueArg: AVAnalyzer.Result, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.AVAnalyzerResultConsumerApi.accept"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateAVAnalyzerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiAVAnalyzerApi, types: [AVMetadataObjectTypeApi]?, consumer: AVAnalyzerResultConsumer) throws -> AVAnalyzer
}

protocol PigeonApiProtocolAVAnalyzerApi {
}

final class PigeonApiAVAnalyzerApi: PigeonApiProtocolAVAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVAnalyzerApi
  ///An implementation of [AnalyzerApi] used to access callback methods
  var pigeonApiAnalyzerApi: PigeonApiAnalyzerApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAVAnalyzerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AVAnalyzerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let typesArg: [AVMetadataObjectTypeApi]? = nilOrValue(args[1])
        let consumerArg = args[2] as! AVAnalyzerResultConsumer
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, types: typesArg, consumer: consumerArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AVAnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVAnalyzer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVAnalyzerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputOptionsApi {
  func getDurationLimitMillis(pigeonApi: PigeonApiOutputOptionsApi, pigeonInstance: OutputOptions) throws -> Int64
  func getFileSizeLimit(pigeonApi: PigeonApiOutputOptionsApi, pigeonInstance: OutputOptions) throws -> Int64
  func getLocation(pigeonApi: PigeonApiOutputOptionsApi, pigeonInstance: OutputOptions) throws -> CLLocation?
}

protocol PigeonApiProtocolOutputOptionsApi {
}

final class PigeonApiOutputOptionsApi: PigeonApiProtocolOutputOptionsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputOptionsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOutputOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getDurationLimitMillisChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OutputOptionsApi.getDurationLimitMillis", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDurationLimitMillisChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! OutputOptions
        do {
          let result = try api.pigeonDelegate.getDurationLimitMillis(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDurationLimitMillisChannel.setMessageHandler(nil)
    }
    let getFileSizeLimitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OutputOptionsApi.getFileSizeLimit", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFileSizeLimitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! OutputOptions
        do {
          let result = try api.pigeonDelegate.getFileSizeLimit(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFileSizeLimitChannel.setMessageHandler(nil)
    }
    let getLocationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OutputOptionsApi.getLocation", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getLocationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! OutputOptions
        do {
          let result = try api.pigeonDelegate.getLocation(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getLocationChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OutputOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OutputOptions, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFileOutputOptionsApi {
  func build(pigeonApi: PigeonApiFileOutputOptionsApi, file: String, durationLimitMillis: Int64?, fileSizeLimitBytes: Int64?, location: CLLocation?) throws -> FileOutputOptions
  func getFile(pigeonApi: PigeonApiFileOutputOptionsApi, pigeonInstance: FileOutputOptions) throws -> String
}

protocol PigeonApiProtocolFileOutputOptionsApi {
}

final class PigeonApiFileOutputOptionsApi: PigeonApiProtocolFileOutputOptionsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFileOutputOptionsApi
  ///An implementation of [OutputOptionsApi] used to access callback methods
  var pigeonApiOutputOptionsApi: PigeonApiOutputOptionsApi {
    return pigeonRegistrar.apiDelegate.pigeonApiOutputOptionsApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFileOutputOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFileOutputOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FileOutputOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let fileArg = args[1] as! String
        let durationLimitMillisArg: Int64? = nilOrValue(args[2])
        let fileSizeLimitBytesArg: Int64? = nilOrValue(args[3])
        let locationArg: CLLocation? = nilOrValue(args[4])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, file: fileArg, durationLimitMillis: durationLimitMillisArg, fileSizeLimitBytes: fileSizeLimitBytesArg, location: locationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
    let getFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FileOutputOptionsApi.getFile", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FileOutputOptions
        do {
          let result = try api.pigeonDelegate.getFile(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFileChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FileOutputOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FileOutputOptions, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FileOutputOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAudioConfigApi {
  func create(pigeonApi: PigeonApiAudioConfigApi, enableAudio: Bool) throws -> AudioConfig
  func audioDisabled(pigeonApi: PigeonApiAudioConfigApi) throws -> AudioConfig
  func getAudioEnabled(pigeonApi: PigeonApiAudioConfigApi, pigeonInstance: AudioConfig) throws -> Bool
}

protocol PigeonApiProtocolAudioConfigApi {
}

final class PigeonApiAudioConfigApi: PigeonApiProtocolAudioConfigApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAudioConfigApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAudioConfigApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAudioConfigApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let enableAudioArg = args[1] as! Bool
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.create(pigeonApi: api, enableAudio: enableAudioArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let audioDisabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.audioDisabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      audioDisabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.audioDisabled(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      audioDisabledChannel.setMessageHandler(nil)
    }
    let getAudioEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.getAudioEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAudioEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! AudioConfig
        do {
          let result = try api.pigeonDelegate.getAudioEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAudioEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AudioConfigApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AudioConfig, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AudioConfigApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAudioStatsApi {
  func audioAmplitude(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> Double
  func audioState(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> AudioStateApi
  func errorCause(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> [Any?]?
  func hasAudio(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> Bool
  func hasError(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> Bool
}

protocol PigeonApiProtocolAudioStatsApi {
}

final class PigeonApiAudioStatsApi: PigeonApiProtocolAudioStatsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAudioStatsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAudioStatsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AudioStatsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AudioStats, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let audioAmplitudeArg = try! pigeonDelegate.audioAmplitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let audioStateArg = try! pigeonDelegate.audioState(pigeonApi: self, pigeonInstance: pigeonInstance)
      let errorCauseArg = try! pigeonDelegate.errorCause(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasAudioArg = try! pigeonDelegate.hasAudio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasErrorArg = try! pigeonDelegate.hasError(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AudioStatsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, audioAmplitudeArg, audioStateArg, errorCauseArg, hasAudioArg, hasErrorArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRecordingStatsApi {
  func audioStats(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStats) throws -> AudioStats
  func numBytesRecorded(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStats) throws -> Int64
  func recordedDurationNanos(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStats) throws -> Int64
}

protocol PigeonApiProtocolRecordingStatsApi {
}

final class PigeonApiRecordingStatsApi: PigeonApiProtocolRecordingStatsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRecordingStatsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRecordingStatsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of RecordingStatsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RecordingStats, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let audioStatsArg = try! pigeonDelegate.audioStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let numBytesRecordedArg = try! pigeonDelegate.numBytesRecorded(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordedDurationNanosArg = try! pigeonDelegate.recordedDurationNanos(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RecordingStatsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, audioStatsArg, numBytesRecordedArg, recordedDurationNanosArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateVideoRecordEventApi {
}

protocol PigeonApiProtocolVideoRecordEventApi {
}

final class PigeonApiVideoRecordEventApi: PigeonApiProtocolVideoRecordEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordEventApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordStatusEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordStatusEventApi, pigeonInstance: VideoRecordEvent.Status) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordStatusEventApi {
}

final class PigeonApiVideoRecordStatusEventApi: PigeonApiProtocolVideoRecordStatusEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordStatusEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordStatusEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordStatusEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Status, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordStatusEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordStartEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordStartEventApi, pigeonInstance: VideoRecordEvent.Start) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordStartEventApi {
}

final class PigeonApiVideoRecordStartEventApi: PigeonApiProtocolVideoRecordStartEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordStartEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordStartEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordStartEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Start, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordStartEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordPauseEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordPauseEventApi, pigeonInstance: VideoRecordEvent.Pause) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordPauseEventApi {
}

final class PigeonApiVideoRecordPauseEventApi: PigeonApiProtocolVideoRecordPauseEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordPauseEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordPauseEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordPauseEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Pause, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordPauseEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordResumeEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordResumeEventApi, pigeonInstance: VideoRecordEvent.Resume) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordResumeEventApi {
}

final class PigeonApiVideoRecordResumeEventApi: PigeonApiProtocolVideoRecordResumeEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordResumeEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordResumeEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordResumeEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Resume, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordResumeEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputResultsApi {
  func outputUri(pigeonApi: PigeonApiOutputResultsApi, pigeonInstance: OutputResults) throws -> String?
}

protocol PigeonApiProtocolOutputResultsApi {
}

final class PigeonApiOutputResultsApi: PigeonApiProtocolOutputResultsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputResultsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputResultsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of OutputResultsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OutputResults, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputUriArg = try! pigeonDelegate.outputUri(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputResultsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputUriArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordFinalizeEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> RecordingStats
  func cause(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> [Any?]?
  func error(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> VideoRecordFinalizeEventErrorApi
  func outputResults(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> OutputResults
}

protocol PigeonApiProtocolVideoRecordFinalizeEventApi {
}

final class PigeonApiVideoRecordFinalizeEventApi: PigeonApiProtocolVideoRecordFinalizeEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordFinalizeEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordFinalizeEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordFinalizeEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Finalize, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let causeArg = try! pigeonDelegate.cause(pigeonApi: self, pigeonInstance: pigeonInstance)
      let errorArg = try! pigeonDelegate.error(pigeonApi: self, pigeonInstance: pigeonInstance)
      let outputResultsArg = try! pigeonDelegate.outputResults(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordFinalizeEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg, causeArg, errorArg, outputResultsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordEventConsumerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiVideoRecordEventConsumerApi) throws -> VideoRecordEventConsumer
}

protocol PigeonApiProtocolVideoRecordEventConsumerApi {
  func accept(pigeonInstance pigeonInstanceArg: VideoRecordEventConsumer, value valueArg: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiVideoRecordEventConsumerApi: PigeonApiProtocolVideoRecordEventConsumerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordEventConsumerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordEventConsumerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiVideoRecordEventConsumerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.VideoRecordEventConsumerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of VideoRecordEventConsumerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEventConsumer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of VideoRecordEventConsumerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func accept(pigeonInstance pigeonInstanceArg: VideoRecordEventConsumer, value valueArg: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordEventConsumerApi.accept"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateRecordingApi {
  func isPersistent(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws -> Bool
  func mute(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording, muted: Bool) throws
  func pause(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws
  func resume(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws
  func stop(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws
}

protocol PigeonApiProtocolRecordingApi {
}

final class PigeonApiRecordingApi: PigeonApiProtocolRecordingApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRecordingApi
  ///An implementation of [AutoCloseableApi] used to access callback methods
  var pigeonApiAutoCloseableApi: PigeonApiAutoCloseableApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRecordingApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRecordingApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let isPersistentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.isPersistent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPersistentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          let result = try api.pigeonDelegate.isPersistent(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPersistentChannel.setMessageHandler(nil)
    }
    let muteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.mute", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      muteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        let mutedArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.mute(pigeonApi: api, pigeonInstance: pigeonInstanceArg, muted: mutedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      muteChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.pause(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let resumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.resume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.resume(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resumeChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.stop", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.stop(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RecordingApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Recording, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RecordingApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraControllerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraControllerApi) throws -> CameraController
  func initialize(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws
  func bind(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws
  func unbind(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws
  func hasCamera(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, cameraSelector: CameraSelector) throws -> Bool
  func getCameraSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> CameraSelector
  func setCameraSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, cameraSelector: CameraSelector) throws
  func getCameraInfo(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> CameraInfo?
  func getCameraControl(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> CameraControl?
  func getTorchState(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> TorchStateLiveData
  func enableTorch(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, torchEnabled: Bool) throws
  func getZoomState(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> ZoomStateLiveData
  func setZoomRatio(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, zoomRatio: Double) throws
  func setLinearZoom(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, linearZoom: Double) throws
  func isPinchToZoomEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func setPinchToZoomEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, enabled: Bool) throws
  func isTapToFocusEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func setTapToFocusEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, enabled: Bool) throws
  func isImageCaptureEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func isImageAnalysisEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func isVideoCaptureEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func setEnabledUseCases(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, enabledUseCases: [UseCaseApi]) throws
  func getImageCaptureMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> CaptureModeApi
  func setImageCaptureMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, captureMode: CaptureModeApi) throws
  func getImageCaptureFlashMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> FlashModeApi
  func setImageCaptureFlashMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, flashMode: FlashModeApi) throws
  func takePicture(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, capturedCallback: ImageCapture.OnImageCapturedCallback) throws
  func getImageAnalysisResolutionSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> ResolutionSelector?
  func setImageAnalysisResolutionSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, resolutionSelector: ResolutionSelector?) throws
  func getImageAnalysisBackpressureStrategy(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> BackpressureStrategyApi
  func setImageAnalysisBackpressureStrategy(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, strategy: BackpressureStrategyApi) throws
  func getImageAnalysisImageQueueDepth(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Int64
  func setImageAnalysisImageQueueDepth(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, depth: Int64) throws
  func getImageAnalysisOutputImageFormat(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> ImageFormatApi
  func setImageAnalysisOutputImageFormat(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, imageAnalysisOutputImageFormat: ImageFormatApi) throws
  func setImageAnalysisAnalyzer(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, analyzer: ImageAnalysis.Analyzer) throws
  func clearImageAnalysisAnalyzer(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws
  func getVideoCaptureMirrorMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> MirrorModeApi
  func setVideoCaptureMirrorMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, mirrorMode: MirrorModeApi) throws
  func isRecording(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func startRecording(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, outputOptions: FileOutputOptions, audioConfig: AudioConfig, listener: VideoRecordEventConsumer) throws -> Recording
}

protocol PigeonApiProtocolCameraControllerApi {
}

final class PigeonApiCameraControllerApi: PigeonApiProtocolCameraControllerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraControllerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraControllerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraControllerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.initialize", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.initialize(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    let bindChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.bind", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      bindChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.bind(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      bindChannel.setMessageHandler(nil)
    }
    let unbindChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.unbind", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unbindChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.unbind(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unbindChannel.setMessageHandler(nil)
    }
    let hasCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.hasCamera", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let cameraSelectorArg = args[1] as! CameraSelector
        do {
          let result = try api.pigeonDelegate.hasCamera(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cameraSelector: cameraSelectorArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasCameraChannel.setMessageHandler(nil)
    }
    let getCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraSelectorChannel.setMessageHandler(nil)
    }
    let setCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let cameraSelectorArg = args[1] as! CameraSelector
        do {
          try api.pigeonDelegate.setCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cameraSelector: cameraSelectorArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCameraSelectorChannel.setMessageHandler(nil)
    }
    let getCameraInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getCameraInfo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getCameraInfo(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraInfoChannel.setMessageHandler(nil)
    }
    let getCameraControlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getCameraControl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraControlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getCameraControl(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraControlChannel.setMessageHandler(nil)
    }
    let getTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTorchStateChannel.setMessageHandler(nil)
    }
    let enableTorchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.enableTorch", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableTorchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let torchEnabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.enableTorch(pigeonApi: api, pigeonInstance: pigeonInstanceArg, torchEnabled: torchEnabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableTorchChannel.setMessageHandler(nil)
    }
    let getZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getZoomStateChannel.setMessageHandler(nil)
    }
    let setZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let zoomRatioArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg, zoomRatio: zoomRatioArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setZoomRatioChannel.setMessageHandler(nil)
    }
    let setLinearZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setLinearZoom", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLinearZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let linearZoomArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setLinearZoom(pigeonApi: api, pigeonInstance: pigeonInstanceArg, linearZoom: linearZoomArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLinearZoomChannel.setMessageHandler(nil)
    }
    let isPinchToZoomEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isPinchToZoomEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPinchToZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isPinchToZoomEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPinchToZoomEnabledChannel.setMessageHandler(nil)
    }
    let setPinchToZoomEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setPinchToZoomEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPinchToZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setPinchToZoomEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPinchToZoomEnabledChannel.setMessageHandler(nil)
    }
    let isTapToFocusEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isTapToFocusEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isTapToFocusEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isTapToFocusEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isTapToFocusEnabledChannel.setMessageHandler(nil)
    }
    let setTapToFocusEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setTapToFocusEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTapToFocusEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setTapToFocusEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTapToFocusEnabledChannel.setMessageHandler(nil)
    }
    let isImageCaptureEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isImageCaptureEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isImageCaptureEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isImageCaptureEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isImageCaptureEnabledChannel.setMessageHandler(nil)
    }
    let isImageAnalysisEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isImageAnalysisEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isImageAnalysisEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isImageAnalysisEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isImageAnalysisEnabledChannel.setMessageHandler(nil)
    }
    let isVideoCaptureEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isVideoCaptureEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isVideoCaptureEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isVideoCaptureEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isVideoCaptureEnabledChannel.setMessageHandler(nil)
    }
    let setEnabledUseCasesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setEnabledUseCases", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setEnabledUseCasesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledUseCasesArg = args[1] as! [UseCaseApi]
        do {
          try api.pigeonDelegate.setEnabledUseCases(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabledUseCases: enabledUseCasesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setEnabledUseCasesChannel.setMessageHandler(nil)
    }
    let getImageCaptureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageCaptureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageCaptureMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageCaptureModeChannel.setMessageHandler(nil)
    }
    let setImageCaptureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageCaptureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let captureModeArg = args[1] as! CaptureModeApi
        do {
          try api.pigeonDelegate.setImageCaptureMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, captureMode: captureModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageCaptureModeChannel.setMessageHandler(nil)
    }
    let getImageCaptureFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageCaptureFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageCaptureFlashMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageCaptureFlashModeChannel.setMessageHandler(nil)
    }
    let setImageCaptureFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageCaptureFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let flashModeArg = args[1] as! FlashModeApi
        do {
          try api.pigeonDelegate.setImageCaptureFlashMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, flashMode: flashModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageCaptureFlashModeChannel.setMessageHandler(nil)
    }
    let takePictureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.takePicture", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takePictureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let capturedCallbackArg = args[1] as! ImageCapture.OnImageCapturedCallback
        do {
          try api.pigeonDelegate.takePicture(pigeonApi: api, pigeonInstance: pigeonInstanceArg, capturedCallback: capturedCallbackArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      takePictureChannel.setMessageHandler(nil)
    }
    let getImageAnalysisResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisResolutionSelectorChannel.setMessageHandler(nil)
    }
    let setImageAnalysisResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let resolutionSelectorArg: ResolutionSelector? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setImageAnalysisResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, resolutionSelector: resolutionSelectorArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisResolutionSelectorChannel.setMessageHandler(nil)
    }
    let getImageAnalysisBackpressureStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisBackpressureStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisBackpressureStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisBackpressureStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisBackpressureStrategyChannel.setMessageHandler(nil)
    }
    let setImageAnalysisBackpressureStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisBackpressureStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisBackpressureStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let strategyArg = args[1] as! BackpressureStrategyApi
        do {
          try api.pigeonDelegate.setImageAnalysisBackpressureStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg, strategy: strategyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisBackpressureStrategyChannel.setMessageHandler(nil)
    }
    let getImageAnalysisImageQueueDepthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisImageQueueDepth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisImageQueueDepthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisImageQueueDepth(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisImageQueueDepthChannel.setMessageHandler(nil)
    }
    let setImageAnalysisImageQueueDepthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisImageQueueDepth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisImageQueueDepthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let depthArg = args[1] as! Int64
        do {
          try api.pigeonDelegate.setImageAnalysisImageQueueDepth(pigeonApi: api, pigeonInstance: pigeonInstanceArg, depth: depthArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisImageQueueDepthChannel.setMessageHandler(nil)
    }
    let getImageAnalysisOutputImageFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisOutputImageFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisOutputImageFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisOutputImageFormat(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisOutputImageFormatChannel.setMessageHandler(nil)
    }
    let setImageAnalysisOutputImageFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisOutputImageFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisOutputImageFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let imageAnalysisOutputImageFormatArg = args[1] as! ImageFormatApi
        do {
          try api.pigeonDelegate.setImageAnalysisOutputImageFormat(pigeonApi: api, pigeonInstance: pigeonInstanceArg, imageAnalysisOutputImageFormat: imageAnalysisOutputImageFormatArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisOutputImageFormatChannel.setMessageHandler(nil)
    }
    let setImageAnalysisAnalyzerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisAnalyzer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisAnalyzerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let analyzerArg = args[1] as! ImageAnalysis.Analyzer
        do {
          try api.pigeonDelegate.setImageAnalysisAnalyzer(pigeonApi: api, pigeonInstance: pigeonInstanceArg, analyzer: analyzerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisAnalyzerChannel.setMessageHandler(nil)
    }
    let clearImageAnalysisAnalyzerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.clearImageAnalysisAnalyzer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearImageAnalysisAnalyzerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.clearImageAnalysisAnalyzer(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearImageAnalysisAnalyzerChannel.setMessageHandler(nil)
    }
    let getVideoCaptureMirrorModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getVideoCaptureMirrorMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoCaptureMirrorModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getVideoCaptureMirrorMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoCaptureMirrorModeChannel.setMessageHandler(nil)
    }
    let setVideoCaptureMirrorModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setVideoCaptureMirrorMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoCaptureMirrorModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let mirrorModeArg = args[1] as! MirrorModeApi
        do {
          try api.pigeonDelegate.setVideoCaptureMirrorMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, mirrorMode: mirrorModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVideoCaptureMirrorModeChannel.setMessageHandler(nil)
    }
    let isRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isRecording(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isRecordingChannel.setMessageHandler(nil)
    }
    let startRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.startRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let outputOptionsArg = args[1] as! FileOutputOptions
        let audioConfigArg = args[2] as! AudioConfig
        let listenerArg = args[3] as! VideoRecordEventConsumer
        do {
          let result = try api.pigeonDelegate.startRecording(pigeonApi: api, pigeonInstance: pigeonInstanceArg, outputOptions: outputOptionsArg, audioConfig: audioConfigArg, listener: listenerArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startRecordingChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraControllerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraController, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraControllerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePreviewViewApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPreviewViewApi) throws -> PreviewView
  func getController(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewView) throws -> CameraController?
  func setController(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewView, controller: CameraController?) throws
  func getScaleType(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewView) throws -> ScaleTypeApi
  func setScaleType(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewView, scaleType: ScaleTypeApi) throws
}

protocol PigeonApiProtocolPreviewViewApi {
}

final class PigeonApiPreviewViewApi: PigeonApiProtocolPreviewViewApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePreviewViewApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePreviewViewApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPreviewViewApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let getControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.getController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        do {
          let result = try api.pigeonDelegate.getController(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getControllerChannel.setMessageHandler(nil)
    }
    let setControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.setController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        let controllerArg: CameraController? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setController(pigeonApi: api, pigeonInstance: pigeonInstanceArg, controller: controllerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setControllerChannel.setMessageHandler(nil)
    }
    let getScaleTypeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.getScaleType", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getScaleTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        do {
          let result = try api.pigeonDelegate.getScaleType(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getScaleTypeChannel.setMessageHandler(nil)
    }
    let setScaleTypeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.setScaleType", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setScaleTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        let scaleTypeArg = args[1] as! ScaleTypeApi
        do {
          try api.pigeonDelegate.setScaleType(pigeonApi: api, pigeonInstance: pigeonInstanceArg, scaleType: scaleTypeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setScaleTypeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PreviewViewApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PreviewView, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PreviewViewApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
