// Autogenerated from Pigeon (v26.0.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
import AVFoundation
import ImageIO
import CoreLocation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class CameraXError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "CameraXError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? CameraXError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> CameraXError {
  return CameraXError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Handles the callback when an object is deallocated.
protocol CameraXApiPigeonInternalFinalizerDelegate: AnyObject {
  /// Invoked when the strong reference of an object is deallocated in an `InstanceManager`.
  func onDeinit(identifier: Int64)
}


// Attaches to an object to receive a callback when the object is deallocated.
internal final class CameraXApiPigeonInternalFinalizer {
  internal static let associatedObjectKey = malloc(1)!

  private let identifier: Int64
  // Reference to the delegate is weak because the callback should be ignored if the
  // `InstanceManager` is deallocated.
  internal weak var delegate: CameraXApiPigeonInternalFinalizerDelegate?

  private init(identifier: Int64, delegate: CameraXApiPigeonInternalFinalizerDelegate) {
    self.identifier = identifier
    self.delegate = delegate
  }

  internal static func attach(
    to instance: AnyObject, identifier: Int64, delegate: CameraXApiPigeonInternalFinalizerDelegate
  ) {
    let finalizer = CameraXApiPigeonInternalFinalizer(identifier: identifier, delegate: delegate)
    objc_setAssociatedObject(instance, associatedObjectKey, finalizer, .OBJC_ASSOCIATION_RETAIN)
  }

  static func detach(from instance: AnyObject) {
    let finalizer = objc_getAssociatedObject(instance, associatedObjectKey) as? CameraXApiPigeonInternalFinalizer
    if let finalizer = finalizer {
      finalizer.delegate = nil
      objc_setAssociatedObject(instance, associatedObjectKey, nil, .OBJC_ASSOCIATION_ASSIGN)
    }
  }

  deinit {
    delegate?.onDeinit(identifier: identifier)
  }
}


/// Maintains instances used to communicate with the corresponding objects in Dart.
///
/// Objects stored in this container are represented by an object in Dart that is also stored in
/// an InstanceManager with the same identifier.
///
/// When an instance is added with an identifier, either can be used to retrieve the other.
///
/// Added instances are added as a weak reference and a strong reference. When the strong
/// reference is removed and the weak reference is deallocated,`CameraXApiPigeonInternalFinalizerDelegate.onDeinit`
/// is called with the instance's identifier. However, if the strong reference is removed and then the identifier is
/// retrieved with the intention to pass the identifier to Dart (e.g. by calling `identifierWithStrongReference`),
/// the strong reference to the instance is re-added. The strong reference will then need to be removed manually
/// again.
///
/// Accessing and inserting to an InstanceManager is thread safe.
final class CameraXApiPigeonInstanceManager {
  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously from Dart.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  private static let minHostCreatedIdentifier: Int64 = 65536

  private let lockQueue = DispatchQueue(label: "CameraXApiPigeonInstanceManager")
  private let identifiers: NSMapTable<AnyObject, NSNumber> = NSMapTable(
    keyOptions: [.weakMemory, .objectPointerPersonality], valueOptions: .strongMemory)
  private let weakInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.weakMemory, .objectPointerPersonality])
  private let strongInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.strongMemory, .objectPointerPersonality])
  private let finalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate
  private var nextIdentifier: Int64 = minHostCreatedIdentifier

  public init(finalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate) {
    self.finalizerDelegate = finalizerDelegate
  }

  /// Adds a new instance that was instantiated from Dart.
  ///
  /// The same instance can be added multiple times, but each identifier must be unique. This allows
  /// two objects that are equivalent (e.g. conforms to `Equatable`)  to both be added.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored
  ///   - identifier: the identifier to be paired with instance. This value must be >= 0 and unique
  func addDartCreatedInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    lockQueue.async {
      self.addInstance(instance, withIdentifier: identifier)
    }
  }

  /// Adds a new instance that was instantiated from the host platform.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored. This must be unique to all other added instances.
  /// - Returns: the unique identifier (>= 0) stored with instance
  func addHostCreatedInstance(_ instance: AnyObject) -> Int64 {
    assert(!containsInstance(instance), "Instance of \(instance) has already been added.")
    var identifier: Int64 = -1
    lockQueue.sync {
      identifier = nextIdentifier
      nextIdentifier += 1
      self.addInstance(instance, withIdentifier: identifier)
    }
    return identifier
  }

  /// Removes `instanceIdentifier` and its associated strongly referenced instance, if present, from the manager.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier paired to an instance.
  /// - Returns: removed instance if the manager contains the given identifier, otherwise `nil` if
  ///   the manager doesn't contain the value
  func removeInstance<T: AnyObject>(withIdentifier instanceIdentifier: Int64) throws -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = strongInstances.object(forKey: NSNumber(value: instanceIdentifier))
      strongInstances.removeObject(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier associated with an instance
  /// - Returns: the instance associated with `instanceIdentifier` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func instance<T: AnyObject>(forIdentifier instanceIdentifier: Int64) -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = weakInstances.object(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  private func addInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    assert(identifier >= 0)
    assert(
      weakInstances.object(forKey: identifier as NSNumber) == nil,
      "Identifier has already been added: \(identifier)")
    identifiers.setObject(NSNumber(value: identifier), forKey: instance)
    weakInstances.setObject(instance, forKey: NSNumber(value: identifier))
    strongInstances.setObject(instance, forKey: NSNumber(value: identifier))
    CameraXApiPigeonInternalFinalizer.attach(to: instance, identifier: identifier, delegate: finalizerDelegate)
  }

  /// Retrieves the identifier paired with an instance.
  ///
  /// If the manager contains a strong reference to `instance`, it will return the identifier
  /// associated with `instance`. If the manager contains only a weak reference to `instance`, a new
  /// strong reference to `instance` will be added and will need to be removed again with `removeInstance`.
  ///
  /// If this method returns a nonnull identifier, this method also expects the Dart
  /// `CameraXApiPigeonInstanceManager` to have, or recreate, a weak reference to the Dart instance the
  /// identifier is associated with.
  ///
  /// - Parameters:
  ///   - instance: an instance that may be stored in the manager
  /// - Returns: the identifier associated with `instance` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func identifierWithStrongReference(forInstance instance: AnyObject) -> Int64? {
    var identifier: Int64? = nil
    lockQueue.sync {
      if let existingIdentifier = identifiers.object(forKey: instance)?.int64Value {
        strongInstances.setObject(instance, forKey: NSNumber(value: existingIdentifier))
        identifier = existingIdentifier
      }
    }
    return identifier
  }

  /// Whether this manager contains the given `instance`.
  ///
  /// - Parameters:
  ///   - instance: the instance whose presence in this manager is to be tested
  /// - Returns: whether this manager contains the given `instance`
  func containsInstance(_ instance: AnyObject) -> Bool {
    var containsInstance = false
    lockQueue.sync {
      containsInstance = identifiers.object(forKey: instance) != nil
    }
    return containsInstance
  }

  /// Removes all of the instances from this manager.
  ///
  /// The manager will be empty after this call returns.
  func removeAllObjects() throws {
    lockQueue.sync {
      let weakInstancesEnumerator = weakInstances.objectEnumerator()!
      while let instance = weakInstancesEnumerator.nextObject() {
        CameraXApiPigeonInternalFinalizer.detach(from: instance as AnyObject)
      }
      identifiers.removeAllObjects()
      weakInstances.removeAllObjects()
      strongInstances.removeAllObjects()
      nextIdentifier = CameraXApiPigeonInstanceManager.minHostCreatedIdentifier
    }
  }

  /// The number of instances stored as a strong reference.
  ///
  /// For debugging and testing purposes.
  internal var strongInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = strongInstances.count
    }
    return count
  }

  /// The number of instances stored as a weak reference.
  ///
  /// For debugging and testing purposes. NSMapTables that store keys or objects as weak
  /// reference will be reclaimed non-deterministically.
  internal var weakInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = weakInstances.count
    }
    return count
  }
}


private class CameraXApiPigeonInstanceManagerApi {
  /// The codec used for serializing messages.
  var codec: FlutterStandardMessageCodec { CameraXApiPigeonCodec.shared }

  /// Handles sending and receiving messages with Dart.
  unowned let binaryMessenger: FlutterBinaryMessenger

  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  /// Sets up an instance of `CameraXApiPigeonInstanceManagerApi` to handle messages through the `binaryMessenger`.
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, instanceManager: CameraXApiPigeonInstanceManager?) {
    let codec = CameraXApiPigeonCodec.shared
    let removeStrongReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.removeStrongReference", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      removeStrongReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! Int64
        do {
          let _: AnyObject? = try instanceManager.removeInstance(withIdentifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStrongReferenceChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.clear", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      clearChannel.setMessageHandler { _, reply in
        do {
          try instanceManager.removeAllObjects()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
  }

  /// Sends a message to the Dart `InstanceManager` to remove the strong reference of the instance associated with `identifier`.
  func removeStrongReference(identifier identifierArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.removeStrongReference"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
protocol CameraXApiPigeonProxyApiDelegate {
  /// An implementation of [PigeonApiAVMetadataObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataObjectProxyApi
  /// An implementation of [PigeonApiAVMetadataBodyObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataBodyObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataBodyObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataBodyObjectProxyApi
  /// An implementation of [PigeonApiAVMetadataCatBodyObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataCatBodyObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataCatBodyObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataCatBodyObjectProxyApi
  /// An implementation of [PigeonApiAVMetadataDogBodyObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataDogBodyObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataDogBodyObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataDogBodyObjectProxyApi
  /// An implementation of [PigeonApiAVMetadataHumanBodyObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataHumanBodyObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataHumanBodyObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataHumanBodyObjectProxyApi
  /// An implementation of [PigeonApiAVMetadataHumanFullBodyObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataHumanFullBodyObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataHumanFullBodyObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataHumanFullBodyObjectProxyApi
  /// An implementation of [PigeonApiAVMetadataFaceObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataFaceObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataFaceObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataFaceObjectProxyApi
  /// An implementation of [PigeonApiAVMetadataMachineReadableCodeObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataMachineReadableCodeObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataMachineReadableCodeObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataMachineReadableCodeObjectProxyApi
  /// An implementation of [PigeonApiAVMetadataSalientObjectProxyApi] used to add a new Dart instance of
  /// `AVMetadataSalientObjectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVMetadataSalientObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataSalientObjectProxyApi
  /// An implementation of [PigeonApiAVAnalyzerResultProxyApi] used to add a new Dart instance of
  /// `AVAnalyzerResultProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVAnalyzerResultProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVAnalyzerResultProxyApi
  /// An implementation of [PigeonApiAVAnalyzerProxyApi] used to add a new Dart instance of
  /// `AVAnalyzerProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVAnalyzerProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVAnalyzerProxyApi
  /// An implementation of [PigeonApiAutoCloseableProxyApi] used to add a new Dart instance of
  /// `AutoCloseableProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAutoCloseableProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAutoCloseableProxyApi
  /// An implementation of [PigeonApiCloseableProxyApi] used to add a new Dart instance of
  /// `CloseableProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCloseableProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCloseableProxyApi
  /// An implementation of [PigeonApiCGImageProxyApi] used to add a new Dart instance of
  /// `CGImageProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCGImageProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCGImageProxyApi
  /// An implementation of [PigeonApiCLLocationProxyApi] used to add a new Dart instance of
  /// `CLLocationProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCLLocationProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCLLocationProxyApi
  /// An implementation of [PigeonApiAVAnalyzerResultConsumerProxyApi] used to add a new Dart instance of
  /// `AVAnalyzerResultConsumerProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAVAnalyzerResultConsumerProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVAnalyzerResultConsumerProxyApi
  /// An implementation of [PigeonApiImageProxyConsumerProxyApi] used to add a new Dart instance of
  /// `ImageProxyConsumerProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageProxyConsumerProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageProxyConsumerProxyApi
  /// An implementation of [PigeonApiVideoRecordEventConsumerProxyApi] used to add a new Dart instance of
  /// `VideoRecordEventConsumerProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordEventConsumerProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventConsumerProxyApi
  /// An implementation of [PigeonApiCameraStateObserverProxyApi] used to add a new Dart instance of
  /// `CameraStateObserverProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraStateObserverProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraStateObserverProxyApi
  /// An implementation of [PigeonApiTorchStateObserverProxyApi] used to add a new Dart instance of
  /// `TorchStateObserverProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiTorchStateObserverProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiTorchStateObserverProxyApi
  /// An implementation of [PigeonApiZoomStateObserverProxyApi] used to add a new Dart instance of
  /// `ZoomStateObserverProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateObserverProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiZoomStateObserverProxyApi
  /// An implementation of [PigeonApiPermissionManagerProxyApi] used to add a new Dart instance of
  /// `PermissionManagerProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPermissionManagerProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPermissionManagerProxyApi
  /// An implementation of [PigeonApiPointProxyApi] used to add a new Dart instance of
  /// `PointProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPointProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPointProxyApi
  /// An implementation of [PigeonApiPointFProxyApi] used to add a new Dart instance of
  /// `PointFProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPointFProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPointFProxyApi
  /// An implementation of [PigeonApiRectProxyApi] used to add a new Dart instance of
  /// `RectProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRectProxyApi
  /// An implementation of [PigeonApiRectFProxyApi] used to add a new Dart instance of
  /// `RectFProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRectFProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRectFProxyApi
  /// An implementation of [PigeonApiSizeProxyApi] used to add a new Dart instance of
  /// `SizeProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSizeProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiSizeProxyApi
  /// An implementation of [PigeonApiSizeFProxyApi] used to add a new Dart instance of
  /// `SizeFProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSizeFProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiSizeFProxyApi
  /// An implementation of [PigeonApiDurationTupleProxyApi] used to add a new Dart instance of
  /// `DurationTupleProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiDurationTupleProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiDurationTupleProxyApi
  /// An implementation of [PigeonApiMeteringPointTupleProxyApi] used to add a new Dart instance of
  /// `MeteringPointTupleProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointTupleProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiMeteringPointTupleProxyApi
  /// An implementation of [PigeonApiResolutionStrategyProxyApi] used to add a new Dart instance of
  /// `ResolutionStrategyProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiResolutionStrategyProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiResolutionStrategyProxyApi
  /// An implementation of [PigeonApiResolutionSelectorProxyApi] used to add a new Dart instance of
  /// `ResolutionSelectorProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiResolutionSelectorProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiResolutionSelectorProxyApi
  /// An implementation of [PigeonApiCameraControlProxyApi] used to add a new Dart instance of
  /// `CameraControlProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraControlProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraControlProxyApi
  /// An implementation of [PigeonApiCameraInfoProxyApi] used to add a new Dart instance of
  /// `CameraInfoProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraInfoProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraInfoProxyApi
  /// An implementation of [PigeonApiCameraSelectorProxyApi] used to add a new Dart instance of
  /// `CameraSelectorProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraSelectorProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraSelectorProxyApi
  /// An implementation of [PigeonApiFocusMeteringActionProxyApi] used to add a new Dart instance of
  /// `FocusMeteringActionProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFocusMeteringActionProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiFocusMeteringActionProxyApi
  /// An implementation of [PigeonApiFocusMeteringResultProxyApi] used to add a new Dart instance of
  /// `FocusMeteringResultProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFocusMeteringResultProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiFocusMeteringResultProxyApi
  /// An implementation of [PigeonApiImageAnalysisAnalyzerProxyApi] used to add a new Dart instance of
  /// `ImageAnalysisAnalyzerProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageAnalysisAnalyzerProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageAnalysisAnalyzerProxyApi
  /// An implementation of [PigeonApiImageAnalysisAnalyzerImplProxyApi] used to add a new Dart instance of
  /// `ImageAnalysisAnalyzerImplProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageAnalysisAnalyzerImplProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageAnalysisAnalyzerImplProxyApi
  /// An implementation of [PigeonApiImageCaptureOnImageCapturedCallbackProxyApi] used to add a new Dart instance of
  /// `ImageCaptureOnImageCapturedCallbackProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageCaptureOnImageCapturedCallbackProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageCaptureOnImageCapturedCallbackProxyApi
  /// An implementation of [PigeonApiImageInfoProxyApi] used to add a new Dart instance of
  /// `ImageInfoProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageInfoProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageInfoProxyApi
  /// An implementation of [PigeonApiImageProxyPlaneProxyProxyApi] used to add a new Dart instance of
  /// `ImageProxyPlaneProxyProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageProxyPlaneProxyProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageProxyPlaneProxyProxyApi
  /// An implementation of [PigeonApiImageProxyProxyApi] used to add a new Dart instance of
  /// `ImageProxyProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageProxyProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageProxyProxyApi
  /// An implementation of [PigeonApiMeteringPointProxyApi] used to add a new Dart instance of
  /// `MeteringPointProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiMeteringPointProxyApi
  /// An implementation of [PigeonApiMeteringPointFactoryProxyApi] used to add a new Dart instance of
  /// `MeteringPointFactoryProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMeteringPointFactoryProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiMeteringPointFactoryProxyApi
  /// An implementation of [PigeonApiSurfaceOrientedMeteringPointFactoryProxyApi] used to add a new Dart instance of
  /// `SurfaceOrientedMeteringPointFactoryProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiSurfaceOrientedMeteringPointFactoryProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiSurfaceOrientedMeteringPointFactoryProxyApi
  /// An implementation of [PigeonApiZoomStateProxyApi] used to add a new Dart instance of
  /// `ZoomStateProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiZoomStateProxyApi
  /// An implementation of [PigeonApiAudioStatsProxyApi] used to add a new Dart instance of
  /// `AudioStatsProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAudioStatsProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAudioStatsProxyApi
  /// An implementation of [PigeonApiOutputOptionsProxyApi] used to add a new Dart instance of
  /// `OutputOptionsProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputOptionsProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOutputOptionsProxyApi
  /// An implementation of [PigeonApiFileOutputOptionsProxyApi] used to add a new Dart instance of
  /// `FileOutputOptionsProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFileOutputOptionsProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiFileOutputOptionsProxyApi
  /// An implementation of [PigeonApiOutputResultsProxyApi] used to add a new Dart instance of
  /// `OutputResultsProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputResultsProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOutputResultsProxyApi
  /// An implementation of [PigeonApiRecordingStatsProxyApi] used to add a new Dart instance of
  /// `RecordingStatsProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRecordingStatsProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRecordingStatsProxyApi
  /// An implementation of [PigeonApiRecordingProxyApi] used to add a new Dart instance of
  /// `RecordingProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRecordingProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRecordingProxyApi
  /// An implementation of [PigeonApiVideoRecordEventProxyApi] used to add a new Dart instance of
  /// `VideoRecordEventProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordEventProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventProxyApi
  /// An implementation of [PigeonApiVideoRecordStatusEventProxyApi] used to add a new Dart instance of
  /// `VideoRecordStatusEventProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordStatusEventProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordStatusEventProxyApi
  /// An implementation of [PigeonApiVideoRecordStartEventProxyApi] used to add a new Dart instance of
  /// `VideoRecordStartEventProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordStartEventProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordStartEventProxyApi
  /// An implementation of [PigeonApiVideoRecordPauseEventProxyApi] used to add a new Dart instance of
  /// `VideoRecordPauseEventProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordPauseEventProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordPauseEventProxyApi
  /// An implementation of [PigeonApiVideoRecordResumeEventProxyApi] used to add a new Dart instance of
  /// `VideoRecordResumeEventProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordResumeEventProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordResumeEventProxyApi
  /// An implementation of [PigeonApiVideoRecordFinalizeEventProxyApi] used to add a new Dart instance of
  /// `VideoRecordFinalizeEventProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordFinalizeEventProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordFinalizeEventProxyApi
  /// An implementation of [PigeonApiAudioConfigProxyApi] used to add a new Dart instance of
  /// `AudioConfigProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAudioConfigProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAudioConfigProxyApi
  /// An implementation of [PigeonApiCameraControllerProxyApi] used to add a new Dart instance of
  /// `CameraControllerProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraControllerProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraControllerProxyApi
  /// An implementation of [PigeonApiPreviewViewProxyApi] used to add a new Dart instance of
  /// `PreviewViewProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPreviewViewProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPreviewViewProxyApi
  /// An implementation of [PigeonApiRotationProviderListenerProxyApi] used to add a new Dart instance of
  /// `RotationProviderListenerProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRotationProviderListenerProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRotationProviderListenerProxyApi
  /// An implementation of [PigeonApiRotationProviderProxyApi] used to add a new Dart instance of
  /// `RotationProviderProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRotationProviderProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRotationProviderProxyApi
}

extension CameraXApiPigeonProxyApiDelegate {
  func pigeonApiAVMetadataObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataObjectProxyApi {
    return PigeonApiAVMetadataObjectProxyApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateAVMetadataObjectProxyApi())
  }
  func pigeonApiAVMetadataBodyObjectProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAVMetadataBodyObjectProxyApi {
    return PigeonApiAVMetadataBodyObjectProxyApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateAVMetadataBodyObjectProxyApi())
  }
  func pigeonApiCloseableProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCloseableProxyApi {
    return PigeonApiCloseableProxyApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateCloseableProxyApi())
  }
  func pigeonApiCGImageProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCGImageProxyApi {
    return PigeonApiCGImageProxyApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateCGImageProxyApi())
  }
  func pigeonApiVideoRecordEventProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventProxyApi {
    return PigeonApiVideoRecordEventProxyApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateVideoRecordEventProxyApi())
  }
}

open class CameraXApiPigeonProxyApiRegistrar {
  let binaryMessenger: FlutterBinaryMessenger
  let apiDelegate: CameraXApiPigeonProxyApiDelegate
  let instanceManager: CameraXApiPigeonInstanceManager
  /// Whether APIs should ignore calling to Dart.
  public var ignoreCallsToDart = false
  private var _codec: FlutterStandardMessageCodec?
  var codec: FlutterStandardMessageCodec {
    if _codec == nil {
      _codec = FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: self))
    }
    return _codec!
  }

  private class InstanceManagerApiFinalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate {
    let api: CameraXApiPigeonInstanceManagerApi

    init(_ api: CameraXApiPigeonInstanceManagerApi) {
      self.api = api
    }

    public func onDeinit(identifier: Int64) {
      api.removeStrongReference(identifier: identifier) {
        _ in
      }
    }
  }

  init(binaryMessenger: FlutterBinaryMessenger, apiDelegate: CameraXApiPigeonProxyApiDelegate) {
    self.binaryMessenger = binaryMessenger
    self.apiDelegate = apiDelegate
    self.instanceManager = CameraXApiPigeonInstanceManager(
      finalizerDelegate: InstanceManagerApiFinalizerDelegate(
        CameraXApiPigeonInstanceManagerApi(binaryMessenger: binaryMessenger)))
  }

  func setUp() {
    CameraXApiPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: instanceManager)
    PigeonApiAVAnalyzerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAVAnalyzerProxyApi(self))
    PigeonApiAutoCloseableProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAutoCloseableProxyApi(self))
    PigeonApiCLLocationProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCLLocationProxyApi(self))
    PigeonApiAVAnalyzerResultConsumerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAVAnalyzerResultConsumerProxyApi(self))
    PigeonApiImageProxyConsumerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiImageProxyConsumerProxyApi(self))
    PigeonApiVideoRecordEventConsumerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiVideoRecordEventConsumerProxyApi(self))
    PigeonApiCameraStateObserverProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraStateObserverProxyApi(self))
    PigeonApiTorchStateObserverProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiTorchStateObserverProxyApi(self))
    PigeonApiZoomStateObserverProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiZoomStateObserverProxyApi(self))
    PigeonApiPermissionManagerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPermissionManagerProxyApi(self))
    PigeonApiPointProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPointProxyApi(self))
    PigeonApiPointFProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPointFProxyApi(self))
    PigeonApiRectProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRectProxyApi(self))
    PigeonApiRectFProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRectFProxyApi(self))
    PigeonApiSizeProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiSizeProxyApi(self))
    PigeonApiSizeFProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiSizeFProxyApi(self))
    PigeonApiDurationTupleProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiDurationTupleProxyApi(self))
    PigeonApiMeteringPointTupleProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMeteringPointTupleProxyApi(self))
    PigeonApiResolutionStrategyProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiResolutionStrategyProxyApi(self))
    PigeonApiResolutionSelectorProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiResolutionSelectorProxyApi(self))
    PigeonApiCameraControlProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraControlProxyApi(self))
    PigeonApiCameraInfoProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraInfoProxyApi(self))
    PigeonApiCameraSelectorProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraSelectorProxyApi(self))
    PigeonApiFocusMeteringActionProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFocusMeteringActionProxyApi(self))
    PigeonApiImageAnalysisAnalyzerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiImageAnalysisAnalyzerProxyApi(self))
    PigeonApiImageAnalysisAnalyzerImplProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiImageAnalysisAnalyzerImplProxyApi(self))
    PigeonApiImageCaptureOnImageCapturedCallbackProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiImageCaptureOnImageCapturedCallbackProxyApi(self))
    PigeonApiMeteringPointFactoryProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMeteringPointFactoryProxyApi(self))
    PigeonApiSurfaceOrientedMeteringPointFactoryProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiSurfaceOrientedMeteringPointFactoryProxyApi(self))
    PigeonApiOutputOptionsProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOutputOptionsProxyApi(self))
    PigeonApiFileOutputOptionsProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFileOutputOptionsProxyApi(self))
    PigeonApiRecordingProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRecordingProxyApi(self))
    PigeonApiAudioConfigProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAudioConfigProxyApi(self))
    PigeonApiCameraControllerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraControllerProxyApi(self))
    PigeonApiPreviewViewProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPreviewViewProxyApi(self))
    PigeonApiRotationProviderListenerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRotationProviderListenerProxyApi(self))
    PigeonApiRotationProviderProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRotationProviderProxyApi(self))
  }
  func tearDown() {
    CameraXApiPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: nil)
    PigeonApiAVAnalyzerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAutoCloseableProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCLLocationProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAVAnalyzerResultConsumerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiImageProxyConsumerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiVideoRecordEventConsumerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraStateObserverProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiTorchStateObserverProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiZoomStateObserverProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPermissionManagerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPointProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPointFProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRectProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRectFProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiSizeProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiSizeFProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiDurationTupleProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMeteringPointTupleProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiResolutionStrategyProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiResolutionSelectorProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraControlProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraInfoProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraSelectorProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFocusMeteringActionProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiImageAnalysisAnalyzerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiImageAnalysisAnalyzerImplProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiImageCaptureOnImageCapturedCallbackProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMeteringPointFactoryProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiSurfaceOrientedMeteringPointFactoryProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOutputOptionsProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFileOutputOptionsProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRecordingProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAudioConfigProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraControllerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPreviewViewProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRotationProviderListenerProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRotationProviderProxyApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
  }
}
private class CameraXApiPigeonInternalProxyApiCodecReaderWriter: FlutterStandardReaderWriter {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

  private class CameraXApiPigeonInternalProxyApiCodecReader: CameraXApiPigeonCodecReader {
    unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

    init(data: Data, pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func readValue(ofType type: UInt8) -> Any? {
      switch type {
      case 128:
        let identifier = self.readValue()
        let instance: AnyObject? = pigeonRegistrar.instanceManager.instance(
          forIdentifier: identifier is Int64 ? identifier as! Int64 : Int64(identifier as! Int32))
        if instance == nil {
          print("Failed to find instance with identifier: \(identifier!)")
        }
        return instance
      default:
        return super.readValue(ofType: type)
      }
    }
  }

  private class CameraXApiPigeonInternalProxyApiCodecWriter: CameraXApiPigeonCodecWriter {
    unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

    init(data: NSMutableData, pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func writeValue(_ value: Any) {
      if value is [Any] || value is Bool || value is Data || value is [AnyHashable: Any] || value is Double || value is FlutterStandardTypedData || value is Int64 || value is String || value is AVMetadataObjectTypeApi || value is TimeUnitApi || value is ImageFormatApi || value is PermissionManagerPermissionApi || value is AspectRatioStrategyFallbackRuleApi || value is ResolutionSelectorModeApi || value is ResolutionStrategyFallbackRuleApi || value is AspectRatioApi || value is CameraSelectorLensFacingApi || value is CameraStateApi || value is DynamicRangeEncodingApi || value is DynamicRangeBitDepthApi || value is ImageAnalysisStrategyApi || value is ImageAnalysisCoordinateSystemApi || value is ImageAnalysisOutputImageFormatApi || value is ImageCaptureCaptureModeApi || value is ImageCaptureFlashModeApi || value is FocusMeteringActionMeteringModeApi || value is MirrorModeApi || value is TorchStateApi || value is AudioStatsAudioStateApi || value is VideoRecordFinalizeEventErrorApi || value is CameraControllerUseCaseApi || value is PreviewViewScaleTypeApi {
        super.writeValue(value)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataCatBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataCatBodyObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataDogBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataDogBodyObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataHumanBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataHumanBodyObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 17.0.0, *), let instance = value as? AVMetadataHumanFullBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataHumanFullBodyObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataBodyObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVMetadataFaceObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataFaceObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVMetadataMachineReadableCodeObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataMachineReadableCodeObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 13.0.0, *), let instance = value as? AVMetadataSalientObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataSalientObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVMetadataObject {
        pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVAnalyzer.Result {
        pigeonRegistrar.apiDelegate.pigeonApiAVAnalyzerResultProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVAnalyzer {
        pigeonRegistrar.apiDelegate.pigeonApiAVAnalyzerProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Closeable {
        pigeonRegistrar.apiDelegate.pigeonApiCloseableProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CGImage {
        pigeonRegistrar.apiDelegate.pigeonApiCGImageProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CLLocation {
        pigeonRegistrar.apiDelegate.pigeonApiCLLocationProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AVAnalyzerResultConsumer {
        pigeonRegistrar.apiDelegate.pigeonApiAVAnalyzerResultConsumerProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageProxyConsumer {
        pigeonRegistrar.apiDelegate.pigeonApiImageProxyConsumerProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEventConsumer {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventConsumerProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraStateObserver {
        pigeonRegistrar.apiDelegate.pigeonApiCameraStateObserverProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? TorchStateObserver {
        pigeonRegistrar.apiDelegate.pigeonApiTorchStateObserverProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomStateObserver {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateObserverProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PermissionManager {
        pigeonRegistrar.apiDelegate.pigeonApiPermissionManagerProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Point {
        pigeonRegistrar.apiDelegate.pigeonApiPointProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PointF {
        pigeonRegistrar.apiDelegate.pigeonApiPointFProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Rect {
        pigeonRegistrar.apiDelegate.pigeonApiRectProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RectF {
        pigeonRegistrar.apiDelegate.pigeonApiRectFProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Size {
        pigeonRegistrar.apiDelegate.pigeonApiSizeProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? SizeF {
        pigeonRegistrar.apiDelegate.pigeonApiSizeFProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? DurationTuple {
        pigeonRegistrar.apiDelegate.pigeonApiDurationTupleProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPointTuple {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointTupleProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ResolutionStrategy {
        pigeonRegistrar.apiDelegate.pigeonApiResolutionStrategyProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ResolutionSelector {
        pigeonRegistrar.apiDelegate.pigeonApiResolutionSelectorProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraControl {
        pigeonRegistrar.apiDelegate.pigeonApiCameraControlProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraInfo {
        pigeonRegistrar.apiDelegate.pigeonApiCameraInfoProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraSelector {
        pigeonRegistrar.apiDelegate.pigeonApiCameraSelectorProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FocusMeteringAction {
        pigeonRegistrar.apiDelegate.pigeonApiFocusMeteringActionProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FocusMeteringResult {
        pigeonRegistrar.apiDelegate.pigeonApiFocusMeteringResultProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageAnalysis.Analyzer {
        pigeonRegistrar.apiDelegate.pigeonApiImageAnalysisAnalyzerImplProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageAnalysis.Analyzer {
        pigeonRegistrar.apiDelegate.pigeonApiImageAnalysisAnalyzerProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageCapture.OnImageCapturedCallback {
        pigeonRegistrar.apiDelegate.pigeonApiImageCaptureOnImageCapturedCallbackProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageInfo {
        pigeonRegistrar.apiDelegate.pigeonApiImageInfoProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageProxy.PlaneProxy {
        pigeonRegistrar.apiDelegate.pigeonApiImageProxyPlaneProxyProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageProxy {
        pigeonRegistrar.apiDelegate.pigeonApiImageProxyProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPoint {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? SurfaceOrientedMeteringPointFactory {
        pigeonRegistrar.apiDelegate.pigeonApiSurfaceOrientedMeteringPointFactoryProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? MeteringPointFactory {
        pigeonRegistrar.apiDelegate.pigeonApiMeteringPointFactoryProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomState {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AudioStats {
        pigeonRegistrar.apiDelegate.pigeonApiAudioStatsProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FileOutputOptions {
        pigeonRegistrar.apiDelegate.pigeonApiFileOutputOptionsProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OutputOptions {
        pigeonRegistrar.apiDelegate.pigeonApiOutputOptionsProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OutputResults {
        pigeonRegistrar.apiDelegate.pigeonApiOutputResultsProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RecordingStats {
        pigeonRegistrar.apiDelegate.pigeonApiRecordingStatsProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Recording {
        pigeonRegistrar.apiDelegate.pigeonApiRecordingProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AutoCloseable {
        pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Status {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordStatusEventProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Start {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordStartEventProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Pause {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordPauseEventProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Resume {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordResumeEventProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Finalize {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordFinalizeEventProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AudioConfig {
        pigeonRegistrar.apiDelegate.pigeonApiAudioConfigProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraController {
        pigeonRegistrar.apiDelegate.pigeonApiCameraControllerProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PreviewView {
        pigeonRegistrar.apiDelegate.pigeonApiPreviewViewProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RotationProvider.Listener {
        pigeonRegistrar.apiDelegate.pigeonApiRotationProviderListenerProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RotationProvider {
        pigeonRegistrar.apiDelegate.pigeonApiRotationProviderProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as AnyObject?, pigeonRegistrar.instanceManager.containsInstance(instance)
      {
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance)!)
      } else {
        print("Unsupported value: \(value) of \(type(of: value))")
        assert(false, "Unsupported value for CameraXApiPigeonInternalProxyApiCodecWriter")
      }

    }
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
    self.pigeonRegistrar = pigeonRegistrar
  }

  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraXApiPigeonInternalProxyApiCodecReader(data: data, pigeonRegistrar: pigeonRegistrar)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraXApiPigeonInternalProxyApiCodecWriter(data: data, pigeonRegistrar: pigeonRegistrar)
  }
}

enum AVMetadataObjectTypeApi: Int {
  case codabar = 0
  case code39 = 1
  case code39Mod43 = 2
  case code93 = 3
  case code128 = 4
  case ean8 = 5
  case ean13 = 6
  case gs1DataBar = 7
  case gs1DataBarExpanded = 8
  case gs1DataBarLimited = 9
  case interleaved2of5 = 10
  case itf14 = 11
  case upce = 12
  case aztec = 13
  case dataMatrix = 14
  case microPDF417 = 15
  case microQR = 16
  case pdf417 = 17
  case qr = 18
  case humanBody = 19
  case humanFullBody = 20
  case dogBody = 21
  case catBody = 22
  case face = 23
  case salientObject = 24
}

enum TimeUnitApi: Int {
  case nanoseconds = 0
  case microseconds = 1
  case milliseconds = 2
  case seconds = 3
  case minutes = 4
  case hours = 5
  case days = 6
}

enum ImageFormatApi: Int {
  case depth16 = 0
  case depthJpeg = 1
  case depthPointCloud = 2
  case flexRgba8888 = 3
  case flexRgb888 = 4
  case heic = 5
  case heicUltraHdr = 6
  case jpeg = 7
  case jpegR = 8
  case nv16 = 9
  case nv21 = 10
  case private = 11
  case raw10 = 12
  case raw12 = 13
  case rawPrivate = 14
  case rawSensor = 15
  case unknown = 16
  case y8 = 17
  case yCbCrP010 = 18
  case yCbCrP210 = 19
  case yuv420888 = 20
  case yuv422888 = 21
  case yuv444888 = 22
  case yuy2 = 23
  case yv12 = 24
  case a8 = 25
  case la88 = 26
  case l8 = 27
  case opaque = 28
  case rgba1010102 = 29
  case rgba4444 = 30
  case rgba5551 = 31
  case rgba8888 = 32
  case rgbaF16 = 33
  case rgbx8888 = 34
  case rgb332 = 35
  case rgb565 = 36
  case rgb888 = 37
  case translucent = 38
  case transparent = 39
  case yCbCr420Sp = 40
  case yCbCr422I = 41
  case yCbCr422Sp = 42
}

enum PermissionManagerPermissionApi: Int {
  case video = 0
  case audio = 1
}

enum AspectRatioStrategyFallbackRuleApi: Int {
  case none = 0
  case auto = 1
}

enum ResolutionSelectorModeApi: Int {
  case preferCaptureRateOverHigherResolution = 0
  case preferHigherResolutionOverCaptureRate = 1
}

enum ResolutionStrategyFallbackRuleApi: Int {
  case none = 0
  case closestHigherThenLower = 1
  case closestHigher = 2
  case closestLowerThenHigher = 3
  case closestLower = 4
}

enum AspectRatioApi: Int {
  case ratioDefault = 0
  case ratio43 = 1
  case ratio169 = 2
}

enum CameraSelectorLensFacingApi: Int {
  case unknown = 0
  case front = 1
  case back = 2
  case external = 3
}

enum CameraStateApi: Int {
  case pendingOpen = 0
  case opening = 1
  case open = 2
  case closing = 3
  case closed = 4
}

enum DynamicRangeEncodingApi: Int {
  case unspecified = 0
  case sdr = 1
  case hdrUnspecified = 2
  case hlg = 3
  case hdr10 = 4
  case hdr10Plus = 5
  case dolbyVision = 6
}

enum DynamicRangeBitDepthApi: Int {
  case unspecified = 0
  case eightBit = 1
  case tenBit = 2
}

enum ImageAnalysisStrategyApi: Int {
  case keepOnlyLatest = 0
  case blockProducer = 1
}

enum ImageAnalysisCoordinateSystemApi: Int {
  case original = 0
  case sensor = 1
  case viewReferenced = 2
}

enum ImageAnalysisOutputImageFormatApi: Int {
  case yuv420888 = 0
  case rgba8888 = 1
  case nv21 = 2
}

enum ImageCaptureCaptureModeApi: Int {
  case maximizeQuality = 0
  case minimizeLatency = 1
  case zeroShutterLag = 2
}

enum ImageCaptureFlashModeApi: Int {
  case auto = 0
  case on = 1
  case off = 2
  case screen = 3
}

enum FocusMeteringActionMeteringModeApi: Int {
  case af = 0
  case ae = 1
  case awb = 2
}

enum MirrorModeApi: Int {
  case off = 0
  case on = 1
  case onFrontOnly = 2
}

enum TorchStateApi: Int {
  case off = 0
  case on = 1
}

enum AudioStatsAudioStateApi: Int {
  case active = 0
  case disabled = 1
  case sourceSilenced = 2
  case encoderError = 3
  case sourceError = 4
  case muted = 5
}

enum VideoRecordFinalizeEventErrorApi: Int {
  case none = 0
  case unknown = 1
  case fileSizeLimitReached = 2
  case insufficientStorage = 3
  case sourceInactive = 4
  case invalidOuputOptions = 5
  case encodingFailed = 6
  case recorderError = 7
  case noValidData = 8
  case durationLimitReached = 9
  case recordingGarbageCollected = 10
}

enum CameraControllerUseCaseApi: Int {
  case imageCapture = 0
  case imageAnalysis = 1
  case videoCapture = 2
}

enum PreviewViewScaleTypeApi: Int {
  case fillStart = 0
  case fillCenter = 1
  case fillEnd = 2
  case fitStart = 3
  case fitCenter = 4
  case fitEnd = 5
}

private class CameraXApiPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AVMetadataObjectTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TimeUnitApi(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageFormatApi(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PermissionManagerPermissionApi(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AspectRatioStrategyFallbackRuleApi(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResolutionSelectorModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResolutionStrategyFallbackRuleApi(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AspectRatioApi(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CameraSelectorLensFacingApi(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CameraStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return DynamicRangeEncodingApi(rawValue: enumResultAsInt)
      }
      return nil
    case 140:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return DynamicRangeBitDepthApi(rawValue: enumResultAsInt)
      }
      return nil
    case 141:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageAnalysisStrategyApi(rawValue: enumResultAsInt)
      }
      return nil
    case 142:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageAnalysisCoordinateSystemApi(rawValue: enumResultAsInt)
      }
      return nil
    case 143:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageAnalysisOutputImageFormatApi(rawValue: enumResultAsInt)
      }
      return nil
    case 144:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageCaptureCaptureModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 145:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageCaptureFlashModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 146:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FocusMeteringActionMeteringModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 147:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MirrorModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 148:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TorchStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 149:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AudioStatsAudioStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 150:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VideoRecordFinalizeEventErrorApi(rawValue: enumResultAsInt)
      }
      return nil
    case 151:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CameraControllerUseCaseApi(rawValue: enumResultAsInt)
      }
      return nil
    case 152:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PreviewViewScaleTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class CameraXApiPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AVMetadataObjectTypeApi {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? TimeUnitApi {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageFormatApi {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? PermissionManagerPermissionApi {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? AspectRatioStrategyFallbackRuleApi {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResolutionSelectorModeApi {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResolutionStrategyFallbackRuleApi {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? AspectRatioApi {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? CameraSelectorLensFacingApi {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? CameraStateApi {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? DynamicRangeEncodingApi {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? DynamicRangeBitDepthApi {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageAnalysisStrategyApi {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageAnalysisCoordinateSystemApi {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageAnalysisOutputImageFormatApi {
      super.writeByte(143)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageCaptureCaptureModeApi {
      super.writeByte(144)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageCaptureFlashModeApi {
      super.writeByte(145)
      super.writeValue(value.rawValue)
    } else if let value = value as? FocusMeteringActionMeteringModeApi {
      super.writeByte(146)
      super.writeValue(value.rawValue)
    } else if let value = value as? MirrorModeApi {
      super.writeByte(147)
      super.writeValue(value.rawValue)
    } else if let value = value as? TorchStateApi {
      super.writeByte(148)
      super.writeValue(value.rawValue)
    } else if let value = value as? AudioStatsAudioStateApi {
      super.writeByte(149)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoRecordFinalizeEventErrorApi {
      super.writeByte(150)
      super.writeValue(value.rawValue)
    } else if let value = value as? CameraControllerUseCaseApi {
      super.writeByte(151)
      super.writeValue(value.rawValue)
    } else if let value = value as? PreviewViewScaleTypeApi {
      super.writeByte(152)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class CameraXApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraXApiPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraXApiPigeonCodecWriter(data: data)
  }
}

class CameraXApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = CameraXApiPigeonCodec(readerWriter: CameraXApiPigeonCodecReaderWriter())
}

open class PigeonApiDelegateAVMetadataObjectProxyApi {
}

protocol PigeonApiProtocolAVMetadataObjectProxyApi {
}

final class PigeonApiAVMetadataObjectProxyApi: PigeonApiProtocolAVMetadataObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataObjectProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataObjectProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVMetadataObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateAVMetadataBodyObjectProxyApi {
}

protocol PigeonApiProtocolAVMetadataBodyObjectProxyApi {
}

final class PigeonApiAVMetadataBodyObjectProxyApi: PigeonApiProtocolAVMetadataBodyObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataBodyObjectProxyApi
  ///An implementation of [AVMetadataObjectProxyApi] used to access callback methods
  var pigeonApiAVMetadataObjectProxyApi: PigeonApiAVMetadataObjectProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataBodyObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataBodyObjectProxyApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataBodyObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataCatBodyObjectProxyApi {
  @available(iOS 13.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataCatBodyObjectProxyApi, pigeonInstance: AVMetadataCatBodyObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 13.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataCatBodyObjectProxyApi, pigeonInstance: AVMetadataCatBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataCatBodyObjectProxyApi, pigeonInstance: AVMetadataCatBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataCatBodyObjectProxyApi, pigeonInstance: AVMetadataCatBodyObject) throws -> RectF
  @available(iOS 13.0.0, *)
  func bodyID(pigeonApi: PigeonApiAVMetadataCatBodyObjectProxyApi, pigeonInstance: AVMetadataCatBodyObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataCatBodyObjectProxyApi {
}

final class PigeonApiAVMetadataCatBodyObjectProxyApi: PigeonApiProtocolAVMetadataCatBodyObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataCatBodyObjectProxyApi
  ///An implementation of [AVMetadataBodyObjectProxyApi] used to access callback methods
  var pigeonApiAVMetadataBodyObjectProxyApi: PigeonApiAVMetadataBodyObjectProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataCatBodyObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataCatBodyObjectProxyApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataCatBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyIDArg = try! pigeonDelegate.bodyID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataCatBodyObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, bodyIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataDogBodyObjectProxyApi {
  @available(iOS 13.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataDogBodyObjectProxyApi, pigeonInstance: AVMetadataDogBodyObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 13.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataDogBodyObjectProxyApi, pigeonInstance: AVMetadataDogBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataDogBodyObjectProxyApi, pigeonInstance: AVMetadataDogBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataDogBodyObjectProxyApi, pigeonInstance: AVMetadataDogBodyObject) throws -> RectF
  @available(iOS 13.0.0, *)
  func bodyID(pigeonApi: PigeonApiAVMetadataDogBodyObjectProxyApi, pigeonInstance: AVMetadataDogBodyObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataDogBodyObjectProxyApi {
}

final class PigeonApiAVMetadataDogBodyObjectProxyApi: PigeonApiProtocolAVMetadataDogBodyObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataDogBodyObjectProxyApi
  ///An implementation of [AVMetadataBodyObjectProxyApi] used to access callback methods
  var pigeonApiAVMetadataBodyObjectProxyApi: PigeonApiAVMetadataBodyObjectProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataDogBodyObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataDogBodyObjectProxyApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataDogBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyIDArg = try! pigeonDelegate.bodyID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataDogBodyObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, bodyIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataHumanBodyObjectProxyApi {
  @available(iOS 13.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataHumanBodyObjectProxyApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 13.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataHumanBodyObjectProxyApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataHumanBodyObjectProxyApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataHumanBodyObjectProxyApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> RectF
  @available(iOS 13.0.0, *)
  func bodyID(pigeonApi: PigeonApiAVMetadataHumanBodyObjectProxyApi, pigeonInstance: AVMetadataHumanBodyObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataHumanBodyObjectProxyApi {
}

final class PigeonApiAVMetadataHumanBodyObjectProxyApi: PigeonApiProtocolAVMetadataHumanBodyObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataHumanBodyObjectProxyApi
  ///An implementation of [AVMetadataBodyObjectProxyApi] used to access callback methods
  var pigeonApiAVMetadataBodyObjectProxyApi: PigeonApiAVMetadataBodyObjectProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataHumanBodyObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataHumanBodyObjectProxyApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataHumanBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyIDArg = try! pigeonDelegate.bodyID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataHumanBodyObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, bodyIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataHumanFullBodyObjectProxyApi {
  @available(iOS 17.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectProxyApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 17.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectProxyApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> Int64
  @available(iOS 17.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectProxyApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> Int64
  @available(iOS 17.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectProxyApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> RectF
  @available(iOS 17.0.0, *)
  func bodyID(pigeonApi: PigeonApiAVMetadataHumanFullBodyObjectProxyApi, pigeonInstance: AVMetadataHumanFullBodyObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataHumanFullBodyObjectProxyApi {
}

final class PigeonApiAVMetadataHumanFullBodyObjectProxyApi: PigeonApiProtocolAVMetadataHumanFullBodyObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataHumanFullBodyObjectProxyApi
  ///An implementation of [AVMetadataBodyObjectProxyApi] used to access callback methods
  var pigeonApiAVMetadataBodyObjectProxyApi: PigeonApiAVMetadataBodyObjectProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataBodyObjectProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataHumanFullBodyObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataHumanFullBodyObjectProxyApi and attaches it to [pigeonInstance].
  @available(iOS 17.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataHumanFullBodyObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bodyIDArg = try! pigeonDelegate.bodyID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataHumanFullBodyObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, bodyIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataFaceObjectProxyApi {
  func type(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> AVMetadataObjectTypeApi
  func time(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> Int64
  func duration(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> Int64
  func bounds(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> RectF
  func faceID(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> Int64
  func hasRollAngle(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> Bool
  func rollAngle(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> Double
  func hasYawAngle(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> Bool
  func yawAngle(pigeonApi: PigeonApiAVMetadataFaceObjectProxyApi, pigeonInstance: AVMetadataFaceObject) throws -> Double
}

protocol PigeonApiProtocolAVMetadataFaceObjectProxyApi {
}

final class PigeonApiAVMetadataFaceObjectProxyApi: PigeonApiProtocolAVMetadataFaceObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataFaceObjectProxyApi
  ///An implementation of [AVMetadataObjectProxyApi] used to access callback methods
  var pigeonApiAVMetadataObjectProxyApi: PigeonApiAVMetadataObjectProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataFaceObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataFaceObjectProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVMetadataFaceObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let faceIDArg = try! pigeonDelegate.faceID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasRollAngleArg = try! pigeonDelegate.hasRollAngle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rollAngleArg = try! pigeonDelegate.rollAngle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasYawAngleArg = try! pigeonDelegate.hasYawAngle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yawAngleArg = try! pigeonDelegate.yawAngle(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataFaceObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, faceIDArg, hasRollAngleArg, rollAngleArg, hasYawAngleArg, yawAngleArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataMachineReadableCodeObjectProxyApi {
  func type(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectProxyApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> AVMetadataObjectTypeApi
  func time(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectProxyApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> Int64
  func duration(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectProxyApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> Int64
  func bounds(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectProxyApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> RectF
  func corners(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectProxyApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> [PointF]
  func stringValue(pigeonApi: PigeonApiAVMetadataMachineReadableCodeObjectProxyApi, pigeonInstance: AVMetadataMachineReadableCodeObject) throws -> String?
}

protocol PigeonApiProtocolAVMetadataMachineReadableCodeObjectProxyApi {
}

final class PigeonApiAVMetadataMachineReadableCodeObjectProxyApi: PigeonApiProtocolAVMetadataMachineReadableCodeObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataMachineReadableCodeObjectProxyApi
  ///An implementation of [AVMetadataObjectProxyApi] used to access callback methods
  var pigeonApiAVMetadataObjectProxyApi: PigeonApiAVMetadataObjectProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataMachineReadableCodeObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataMachineReadableCodeObjectProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVMetadataMachineReadableCodeObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let cornersArg = try! pigeonDelegate.corners(pigeonApi: self, pigeonInstance: pigeonInstance)
      let stringValueArg = try! pigeonDelegate.stringValue(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataMachineReadableCodeObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, cornersArg, stringValueArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVMetadataSalientObjectProxyApi {
  @available(iOS 13.0.0, *)
  func type(pigeonApi: PigeonApiAVMetadataSalientObjectProxyApi, pigeonInstance: AVMetadataSalientObject) throws -> AVMetadataObjectTypeApi
  @available(iOS 13.0.0, *)
  func time(pigeonApi: PigeonApiAVMetadataSalientObjectProxyApi, pigeonInstance: AVMetadataSalientObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func duration(pigeonApi: PigeonApiAVMetadataSalientObjectProxyApi, pigeonInstance: AVMetadataSalientObject) throws -> Int64
  @available(iOS 13.0.0, *)
  func bounds(pigeonApi: PigeonApiAVMetadataSalientObjectProxyApi, pigeonInstance: AVMetadataSalientObject) throws -> RectF
  @available(iOS 13.0.0, *)
  func objectID(pigeonApi: PigeonApiAVMetadataSalientObjectProxyApi, pigeonInstance: AVMetadataSalientObject) throws -> Int64
}

protocol PigeonApiProtocolAVMetadataSalientObjectProxyApi {
}

final class PigeonApiAVMetadataSalientObjectProxyApi: PigeonApiProtocolAVMetadataSalientObjectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVMetadataSalientObjectProxyApi
  ///An implementation of [AVMetadataObjectProxyApi] used to access callback methods
  var pigeonApiAVMetadataObjectProxyApi: PigeonApiAVMetadataObjectProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAVMetadataObjectProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVMetadataSalientObjectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVMetadataSalientObjectProxyApi and attaches it to [pigeonInstance].
  @available(iOS 13.0.0, *)
  func pigeonNewInstance(pigeonInstance: AVMetadataSalientObject, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let typeArg = try! pigeonDelegate.type(pigeonApi: self, pigeonInstance: pigeonInstance)
      let timeArg = try! pigeonDelegate.time(pigeonApi: self, pigeonInstance: pigeonInstance)
      let durationArg = try! pigeonDelegate.duration(pigeonApi: self, pigeonInstance: pigeonInstance)
      let boundsArg = try! pigeonDelegate.bounds(pigeonApi: self, pigeonInstance: pigeonInstance)
      let objectIDArg = try! pigeonDelegate.objectID(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVMetadataSalientObjectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, typeArg, timeArg, durationArg, boundsArg, objectIDArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVAnalyzerResultProxyApi {
  func objects(pigeonApi: PigeonApiAVAnalyzerResultProxyApi, pigeonInstance: AVAnalyzer.Result) throws -> [AVMetadataObject]
}

protocol PigeonApiProtocolAVAnalyzerResultProxyApi {
}

final class PigeonApiAVAnalyzerResultProxyApi: PigeonApiProtocolAVAnalyzerResultProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVAnalyzerResultProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVAnalyzerResultProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AVAnalyzerResultProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVAnalyzer.Result, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let objectsArg = try! pigeonDelegate.objects(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVAnalyzerResultProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, objectsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVAnalyzerProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiAVAnalyzerProxyApi, types: [AVMetadataObjectTypeApi]?, consumer: AVAnalyzerResultConsumer) throws -> AVAnalyzer
}

protocol PigeonApiProtocolAVAnalyzerProxyApi {
}

final class PigeonApiAVAnalyzerProxyApi: PigeonApiProtocolAVAnalyzerProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVAnalyzerProxyApi
  ///An implementation of [ImageAnalysisAnalyzerProxyApi] used to access callback methods
  var pigeonApiImageAnalysisAnalyzerProxyApi: PigeonApiImageAnalysisAnalyzerProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiImageAnalysisAnalyzerProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVAnalyzerProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAVAnalyzerProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AVAnalyzerProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let typesArg: [AVMetadataObjectTypeApi]? = nilOrValue(args[1])
        let consumerArg = args[2] as! AVAnalyzerResultConsumer
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, types: typesArg, consumer: consumerArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AVAnalyzerProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVAnalyzer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AVAnalyzerProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAutoCloseableProxyApi {
  func close(pigeonApi: PigeonApiAutoCloseableProxyApi, pigeonInstance: AutoCloseable) throws
}

protocol PigeonApiProtocolAutoCloseableProxyApi {
}

final class PigeonApiAutoCloseableProxyApi: PigeonApiProtocolAutoCloseableProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAutoCloseableProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAutoCloseableProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAutoCloseableProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let closeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AutoCloseableProxyApi.close", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! AutoCloseable
        do {
          try api.pigeonDelegate.close(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      closeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AutoCloseableProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AutoCloseable, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AutoCloseableProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateCloseableProxyApi {
}

protocol PigeonApiProtocolCloseableProxyApi {
}

final class PigeonApiCloseableProxyApi: PigeonApiProtocolCloseableProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCloseableProxyApi
  ///An implementation of [AutoCloseableProxyApi] used to access callback methods
  var pigeonApiAutoCloseableProxyApi: PigeonApiAutoCloseableProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCloseableProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CloseableProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Closeable, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CloseableProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateCGImageProxyApi {
}

protocol PigeonApiProtocolCGImageProxyApi {
}

final class PigeonApiCGImageProxyApi: PigeonApiProtocolCGImageProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCGImageProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCGImageProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CGImageProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CGImage, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CGImageProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCLLocationProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCLLocationProxyApi, latitude: Double, longitude: Double) throws -> CLLocation
  func latitude(pigeonApi: PigeonApiCLLocationProxyApi, pigeonInstance: CLLocation) throws -> Double
  func longitude(pigeonApi: PigeonApiCLLocationProxyApi, pigeonInstance: CLLocation) throws -> Double
}

protocol PigeonApiProtocolCLLocationProxyApi {
}

final class PigeonApiCLLocationProxyApi: PigeonApiProtocolCLLocationProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCLLocationProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCLLocationProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCLLocationProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CLLocationProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let latitudeArg = args[1] as! Double
        let longitudeArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, latitude: latitudeArg, longitude: longitudeArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CLLocationProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CLLocation, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let latitudeArg = try! pigeonDelegate.latitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let longitudeArg = try! pigeonDelegate.longitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CLLocationProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, latitudeArg, longitudeArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAVAnalyzerResultConsumerProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiAVAnalyzerResultConsumerProxyApi) throws -> AVAnalyzerResultConsumer
}

protocol PigeonApiProtocolAVAnalyzerResultConsumerProxyApi {
  func accept(pigeonInstance pigeonInstanceArg: AVAnalyzerResultConsumer, value valueArg: AVAnalyzer.Result, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiAVAnalyzerResultConsumerProxyApi: PigeonApiProtocolAVAnalyzerResultConsumerProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAVAnalyzerResultConsumerProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAVAnalyzerResultConsumerProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAVAnalyzerResultConsumerProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AVAnalyzerResultConsumerProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AVAnalyzerResultConsumerProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AVAnalyzerResultConsumer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of AVAnalyzerResultConsumerProxyApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func accept(pigeonInstance pigeonInstanceArg: AVAnalyzerResultConsumer, value valueArg: AVAnalyzer.Result, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.AVAnalyzerResultConsumerProxyApi.accept"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateImageProxyConsumerProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiImageProxyConsumerProxyApi) throws -> ImageProxyConsumer
}

protocol PigeonApiProtocolImageProxyConsumerProxyApi {
  func accept(pigeonInstance pigeonInstanceArg: ImageProxyConsumer, value valueArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiImageProxyConsumerProxyApi: PigeonApiProtocolImageProxyConsumerProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageProxyConsumerProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageProxyConsumerProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiImageProxyConsumerProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageProxyConsumerProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ImageProxyConsumerProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageProxyConsumer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ImageProxyConsumerProxyApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func accept(pigeonInstance pigeonInstanceArg: ImageProxyConsumer, value valueArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageProxyConsumerProxyApi.accept"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateVideoRecordEventConsumerProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiVideoRecordEventConsumerProxyApi) throws -> VideoRecordEventConsumer
}

protocol PigeonApiProtocolVideoRecordEventConsumerProxyApi {
  func accept(pigeonInstance pigeonInstanceArg: VideoRecordEventConsumer, value valueArg: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiVideoRecordEventConsumerProxyApi: PigeonApiProtocolVideoRecordEventConsumerProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordEventConsumerProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordEventConsumerProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiVideoRecordEventConsumerProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.VideoRecordEventConsumerProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of VideoRecordEventConsumerProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEventConsumer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of VideoRecordEventConsumerProxyApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func accept(pigeonInstance pigeonInstanceArg: VideoRecordEventConsumer, value valueArg: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordEventConsumerProxyApi.accept"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateCameraStateObserverProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraStateObserverProxyApi) throws -> CameraStateObserver
}

protocol PigeonApiProtocolCameraStateObserverProxyApi {
  func onChanged(pigeonInstance pigeonInstanceArg: CameraStateObserver, value valueArg: CameraStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiCameraStateObserverProxyApi: PigeonApiProtocolCameraStateObserverProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraStateObserverProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraStateObserverProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraStateObserverProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraStateObserverProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraStateObserverProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraStateObserver, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of CameraStateObserverProxyApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: CameraStateObserver, value valueArg: CameraStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraStateObserverProxyApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateTorchStateObserverProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiTorchStateObserverProxyApi) throws -> TorchStateObserver
}

protocol PigeonApiProtocolTorchStateObserverProxyApi {
  func onChanged(pigeonInstance pigeonInstanceArg: TorchStateObserver, value valueArg: TorchStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiTorchStateObserverProxyApi: PigeonApiProtocolTorchStateObserverProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateTorchStateObserverProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateTorchStateObserverProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiTorchStateObserverProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateObserverProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of TorchStateObserverProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: TorchStateObserver, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of TorchStateObserverProxyApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: TorchStateObserver, value valueArg: TorchStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.TorchStateObserverProxyApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateZoomStateObserverProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiZoomStateObserverProxyApi) throws -> ZoomStateObserver
}

protocol PigeonApiProtocolZoomStateObserverProxyApi {
  func onChanged(pigeonInstance pigeonInstanceArg: ZoomStateObserver, value valueArg: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiZoomStateObserverProxyApi: PigeonApiProtocolZoomStateObserverProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateObserverProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateObserverProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiZoomStateObserverProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateObserverProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ZoomStateObserverProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomStateObserver, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ZoomStateObserverProxyApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: ZoomStateObserver, value valueArg: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateObserverProxyApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegatePermissionManagerProxyApi {
  func instance(pigeonApi: PigeonApiPermissionManagerProxyApi) throws -> PermissionManager
  func checkPermissioin(pigeonApi: PigeonApiPermissionManagerProxyApi, pigeonInstance: PermissionManager, permission: PermissionManagerPermissionApi) throws -> Bool
  func requestPermissions(pigeonApi: PigeonApiPermissionManagerProxyApi, pigeonInstance: PermissionManager, permissions: [PermissionManagerPermissionApi], completion: @escaping (Result<Bool, Error>) -> Void)
}

protocol PigeonApiProtocolPermissionManagerProxyApi {
}

final class PigeonApiPermissionManagerProxyApi: PigeonApiProtocolPermissionManagerProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePermissionManagerProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePermissionManagerProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPermissionManagerProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let instanceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerProxyApi.instance", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      instanceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.instance(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      instanceChannel.setMessageHandler(nil)
    }
    let checkPermissioinChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerProxyApi.checkPermissioin", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      checkPermissioinChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PermissionManager
        let permissionArg = args[1] as! PermissionManagerPermissionApi
        do {
          let result = try api.pigeonDelegate.checkPermissioin(pigeonApi: api, pigeonInstance: pigeonInstanceArg, permission: permissionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      checkPermissioinChannel.setMessageHandler(nil)
    }
    let requestPermissionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerProxyApi.requestPermissions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestPermissionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PermissionManager
        let permissionsArg = args[1] as! [PermissionManagerPermissionApi]
        api.pigeonDelegate.requestPermissions(pigeonApi: api, pigeonInstance: pigeonInstanceArg, permissions: permissionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      requestPermissionsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PermissionManagerProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PermissionManager, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PermissionManagerProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePointProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPointProxyApi, x: Int64, y: Int64) throws -> Point
  func x(pigeonApi: PigeonApiPointProxyApi, pigeonInstance: Point) throws -> Int64
  func y(pigeonApi: PigeonApiPointProxyApi, pigeonInstance: Point) throws -> Int64
}

protocol PigeonApiProtocolPointProxyApi {
}

final class PigeonApiPointProxyApi: PigeonApiProtocolPointProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePointProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePointProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPointProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PointProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let xArg = args[1] as! Int64
        let yArg = args[2] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, x: xArg, y: yArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PointProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Point, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let xArg = try! pigeonDelegate.x(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yArg = try! pigeonDelegate.y(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PointProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, xArg, yArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePointFProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPointFProxyApi, x: Double, y: Double) throws -> PointF
  func x(pigeonApi: PigeonApiPointFProxyApi, pigeonInstance: PointF) throws -> Double
  func y(pigeonApi: PigeonApiPointFProxyApi, pigeonInstance: PointF) throws -> Double
}

protocol PigeonApiProtocolPointFProxyApi {
}

final class PigeonApiPointFProxyApi: PigeonApiProtocolPointFProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePointFProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePointFProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPointFProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PointFProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, x: xArg, y: yArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PointFProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PointF, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let xArg = try! pigeonDelegate.x(pigeonApi: self, pigeonInstance: pigeonInstance)
      let yArg = try! pigeonDelegate.y(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PointFProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, xArg, yArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRectProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiRectProxyApi, left: Int64, top: Int64, right: Int64, bottom: Int64) throws -> Rect
  func left(pigeonApi: PigeonApiRectProxyApi, pigeonInstance: Rect) throws -> Int64
  func top(pigeonApi: PigeonApiRectProxyApi, pigeonInstance: Rect) throws -> Int64
  func right(pigeonApi: PigeonApiRectProxyApi, pigeonInstance: Rect) throws -> Int64
  func bottom(pigeonApi: PigeonApiRectProxyApi, pigeonInstance: Rect) throws -> Int64
}

protocol PigeonApiProtocolRectProxyApi {
}

final class PigeonApiRectProxyApi: PigeonApiProtocolRectProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRectProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRectProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRectProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RectProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let leftArg = args[1] as! Int64
        let topArg = args[2] as! Int64
        let rightArg = args[3] as! Int64
        let bottomArg = args[4] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, left: leftArg, top: topArg, right: rightArg, bottom: bottomArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RectProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Rect, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let leftArg = try! pigeonDelegate.left(pigeonApi: self, pigeonInstance: pigeonInstance)
      let topArg = try! pigeonDelegate.top(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rightArg = try! pigeonDelegate.right(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bottomArg = try! pigeonDelegate.bottom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RectProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, leftArg, topArg, rightArg, bottomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRectFProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiRectFProxyApi, left: Double, top: Double, right: Double, bottom: Double) throws -> RectF
  func left(pigeonApi: PigeonApiRectFProxyApi, pigeonInstance: RectF) throws -> Double
  func top(pigeonApi: PigeonApiRectFProxyApi, pigeonInstance: RectF) throws -> Double
  func right(pigeonApi: PigeonApiRectFProxyApi, pigeonInstance: RectF) throws -> Double
  func bottom(pigeonApi: PigeonApiRectFProxyApi, pigeonInstance: RectF) throws -> Double
}

protocol PigeonApiProtocolRectFProxyApi {
}

final class PigeonApiRectFProxyApi: PigeonApiProtocolRectFProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRectFProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRectFProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRectFProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RectFProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let leftArg = args[1] as! Double
        let topArg = args[2] as! Double
        let rightArg = args[3] as! Double
        let bottomArg = args[4] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, left: leftArg, top: topArg, right: rightArg, bottom: bottomArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RectFProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RectF, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let leftArg = try! pigeonDelegate.left(pigeonApi: self, pigeonInstance: pigeonInstance)
      let topArg = try! pigeonDelegate.top(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rightArg = try! pigeonDelegate.right(pigeonApi: self, pigeonInstance: pigeonInstance)
      let bottomArg = try! pigeonDelegate.bottom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RectFProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, leftArg, topArg, rightArg, bottomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSizeProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiSizeProxyApi, width: Int64, height: Int64) throws -> Size
  func width(pigeonApi: PigeonApiSizeProxyApi, pigeonInstance: Size) throws -> Int64
  func height(pigeonApi: PigeonApiSizeProxyApi, pigeonInstance: Size) throws -> Int64
}

protocol PigeonApiProtocolSizeProxyApi {
}

final class PigeonApiSizeProxyApi: PigeonApiProtocolSizeProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSizeProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSizeProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiSizeProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.SizeProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let widthArg = args[1] as! Int64
        let heightArg = args[2] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, width: widthArg, height: heightArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of SizeProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Size, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SizeProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, widthArg, heightArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSizeFProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiSizeFProxyApi, width: Double, height: Double) throws -> SizeF
  func width(pigeonApi: PigeonApiSizeFProxyApi, pigeonInstance: SizeF) throws -> Double
  func height(pigeonApi: PigeonApiSizeFProxyApi, pigeonInstance: SizeF) throws -> Double
}

protocol PigeonApiProtocolSizeFProxyApi {
}

final class PigeonApiSizeFProxyApi: PigeonApiProtocolSizeFProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSizeFProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSizeFProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiSizeFProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.SizeFProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let widthArg = args[1] as! Double
        let heightArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, width: widthArg, height: heightArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of SizeFProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: SizeF, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SizeFProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, widthArg, heightArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateDurationTupleProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiDurationTupleProxyApi, duration: Int64, timeUnit: TimeUnitApi) throws -> DurationTuple
}

protocol PigeonApiProtocolDurationTupleProxyApi {
}

final class PigeonApiDurationTupleProxyApi: PigeonApiProtocolDurationTupleProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateDurationTupleProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateDurationTupleProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiDurationTupleProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.DurationTupleProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let durationArg = args[1] as! Int64
        let timeUnitArg = args[2] as! TimeUnitApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, duration: durationArg, timeUnit: timeUnitArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of DurationTupleProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: DurationTuple, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.DurationTupleProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMeteringPointTupleProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiMeteringPointTupleProxyApi, point: MeteringPoint, modes: [FocusMeteringActionMeteringModeApi]?) throws -> MeteringPointTuple
}

protocol PigeonApiProtocolMeteringPointTupleProxyApi {
}

final class PigeonApiMeteringPointTupleProxyApi: PigeonApiProtocolMeteringPointTupleProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointTupleProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointTupleProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMeteringPointTupleProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MeteringPointTupleProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let pointArg = args[1] as! MeteringPoint
        let modesArg: [FocusMeteringActionMeteringModeApi]? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, point: pointArg, modes: modesArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MeteringPointTupleProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPointTuple, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointTupleProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateResolutionStrategyProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiResolutionStrategyProxyApi, boundSize: Size, fallbackRule: ResolutionStrategyFallbackRuleApi) throws -> ResolutionStrategy
  func highestAvailableStrategy(pigeonApi: PigeonApiResolutionStrategyProxyApi) throws -> ResolutionStrategy
  func getBoundSize(pigeonApi: PigeonApiResolutionStrategyProxyApi, pigeonInstance: ResolutionStrategy) throws -> Size?
  func getFallbackRule(pigeonApi: PigeonApiResolutionStrategyProxyApi, pigeonInstance: ResolutionStrategy) throws -> ResolutionStrategyFallbackRuleApi
}

protocol PigeonApiProtocolResolutionStrategyProxyApi {
}

final class PigeonApiResolutionStrategyProxyApi: PigeonApiProtocolResolutionStrategyProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateResolutionStrategyProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateResolutionStrategyProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiResolutionStrategyProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionStrategyProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let boundSizeArg = args[1] as! Size
        let fallbackRuleArg = args[2] as! ResolutionStrategyFallbackRuleApi
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, boundSize: boundSizeArg, fallbackRule: fallbackRuleArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let highestAvailableStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionStrategyProxyApi.highestAvailableStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      highestAvailableStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.highestAvailableStrategy(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      highestAvailableStrategyChannel.setMessageHandler(nil)
    }
    let getBoundSizeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionStrategyProxyApi.getBoundSize", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getBoundSizeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ResolutionStrategy
        do {
          let result = try api.pigeonDelegate.getBoundSize(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getBoundSizeChannel.setMessageHandler(nil)
    }
    let getFallbackRuleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionStrategyProxyApi.getFallbackRule", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFallbackRuleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ResolutionStrategy
        do {
          let result = try api.pigeonDelegate.getFallbackRule(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFallbackRuleChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ResolutionStrategyProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ResolutionStrategy, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ResolutionStrategyProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateResolutionSelectorProxyApi {
  func build(pigeonApi: PigeonApiResolutionSelectorProxyApi, resolutionStrategy: ResolutionStrategy?) throws -> ResolutionSelector
  func getResolutionStrategy(pigeonApi: PigeonApiResolutionSelectorProxyApi, pigeonInstance: ResolutionSelector) throws -> ResolutionStrategy?
}

protocol PigeonApiProtocolResolutionSelectorProxyApi {
}

final class PigeonApiResolutionSelectorProxyApi: PigeonApiProtocolResolutionSelectorProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateResolutionSelectorProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateResolutionSelectorProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiResolutionSelectorProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionSelectorProxyApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let resolutionStrategyArg: ResolutionStrategy? = nilOrValue(args[1])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, resolutionStrategy: resolutionStrategyArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
    let getResolutionStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ResolutionSelectorProxyApi.getResolutionStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getResolutionStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ResolutionSelector
        do {
          let result = try api.pigeonDelegate.getResolutionStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getResolutionStrategyChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ResolutionSelectorProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ResolutionSelector, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ResolutionSelectorProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraControlProxyApi {
  func enableTorch(pigeonApi: PigeonApiCameraControlProxyApi, pigeonInstance: CameraControl, torch: Bool) throws
  func setZoomRatio(pigeonApi: PigeonApiCameraControlProxyApi, pigeonInstance: CameraControl, ratio: Double) throws
  func setLinearZoom(pigeonApi: PigeonApiCameraControlProxyApi, pigeonInstance: CameraControl, linearZoom: Double) throws
  func startFocusAndMetering(pigeonApi: PigeonApiCameraControlProxyApi, pigeonInstance: CameraControl, action: FocusMeteringAction) throws -> FocusMeteringResult
  func cancelFocusAndMetering(pigeonApi: PigeonApiCameraControlProxyApi, pigeonInstance: CameraControl) throws
  func setExposureCompensationIndex(pigeonApi: PigeonApiCameraControlProxyApi, pigeonInstance: CameraControl, value: Int64) throws -> Int64
}

protocol PigeonApiProtocolCameraControlProxyApi {
}

final class PigeonApiCameraControlProxyApi: PigeonApiProtocolCameraControlProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraControlProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraControlProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraControlProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let enableTorchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlProxyApi.enableTorch", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableTorchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let torchArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.enableTorch(pigeonApi: api, pigeonInstance: pigeonInstanceArg, torch: torchArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableTorchChannel.setMessageHandler(nil)
    }
    let setZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlProxyApi.setZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let ratioArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg, ratio: ratioArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setZoomRatioChannel.setMessageHandler(nil)
    }
    let setLinearZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlProxyApi.setLinearZoom", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLinearZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let linearZoomArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setLinearZoom(pigeonApi: api, pigeonInstance: pigeonInstanceArg, linearZoom: linearZoomArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLinearZoomChannel.setMessageHandler(nil)
    }
    let startFocusAndMeteringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlProxyApi.startFocusAndMetering", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startFocusAndMeteringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let actionArg = args[1] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.startFocusAndMetering(pigeonApi: api, pigeonInstance: pigeonInstanceArg, action: actionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startFocusAndMeteringChannel.setMessageHandler(nil)
    }
    let cancelFocusAndMeteringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlProxyApi.cancelFocusAndMetering", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelFocusAndMeteringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        do {
          try api.pigeonDelegate.cancelFocusAndMetering(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cancelFocusAndMeteringChannel.setMessageHandler(nil)
    }
    let setExposureCompensationIndexChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControlProxyApi.setExposureCompensationIndex", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposureCompensationIndexChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraControl
        let valueArg = args[1] as! Int64
        do {
          let result = try api.pigeonDelegate.setExposureCompensationIndex(pigeonApi: api, pigeonInstance: pigeonInstanceArg, value: valueArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setExposureCompensationIndexChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraControlProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraControl, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraControlProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraInfoProxyApi {
  func mustPlayShutterSound(pigeonApi: PigeonApiCameraInfoProxyApi) throws -> Bool
  func getCameraSelector(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> CameraSelector
  func getCameraState(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> CameraStateApi?
  func observeCameraState(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo, observer: CameraStateObserver) throws
  func removeCameraStateObserver(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo, observer: CameraStateObserver) throws
  func getIntrinsicZoomRatio(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> Double
  func getLensFacing(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> CameraSelectorLensFacingApi
  func getPhysicalCameraInfos(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> [CameraInfo]
  func getTorchState(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> TorchStateApi?
  func observeTorchState(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo, observer: TorchStateObserver) throws
  func removeTorchStateObserver(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo, observer: TorchStateObserver) throws
  func getZoomState(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> ZoomState?
  func observeZoomState(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo, observer: ZoomStateObserver) throws
  func removeZoomStateObserver(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo, observer: ZoomStateObserver) throws
  func hasFlashUnit(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> Bool
  func isFocusMeteringSupported(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo, action: FocusMeteringAction) throws -> Bool
  func isLogicalMultiCameraSupported(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> Bool
  func isLowLightBoostSupported(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> Bool
  func isTorchStrengthSupported(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> Bool
  func isZslSupported(pigeonApi: PigeonApiCameraInfoProxyApi, pigeonInstance: CameraInfo) throws -> Bool
}

protocol PigeonApiProtocolCameraInfoProxyApi {
}

final class PigeonApiCameraInfoProxyApi: PigeonApiProtocolCameraInfoProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraInfoProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraInfoProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraInfoProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let mustPlayShutterSoundChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.mustPlayShutterSound", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      mustPlayShutterSoundChannel.setMessageHandler { _, reply in
        do {
          let result = try api.pigeonDelegate.mustPlayShutterSound(pigeonApi: api)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      mustPlayShutterSoundChannel.setMessageHandler(nil)
    }
    let getCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.getCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraSelectorChannel.setMessageHandler(nil)
    }
    let getCameraStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.getCameraState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getCameraState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraStateChannel.setMessageHandler(nil)
    }
    let observeCameraStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.observeCameraState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeCameraStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        let observerArg = args[1] as! CameraStateObserver
        do {
          try api.pigeonDelegate.observeCameraState(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeCameraStateChannel.setMessageHandler(nil)
    }
    let removeCameraStateObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.removeCameraStateObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeCameraStateObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        let observerArg = args[1] as! CameraStateObserver
        do {
          try api.pigeonDelegate.removeCameraStateObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeCameraStateObserverChannel.setMessageHandler(nil)
    }
    let getIntrinsicZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.getIntrinsicZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIntrinsicZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getIntrinsicZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getIntrinsicZoomRatioChannel.setMessageHandler(nil)
    }
    let getLensFacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.getLensFacing", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getLensFacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getLensFacing(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getLensFacingChannel.setMessageHandler(nil)
    }
    let getPhysicalCameraInfosChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.getPhysicalCameraInfos", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPhysicalCameraInfosChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getPhysicalCameraInfos(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPhysicalCameraInfosChannel.setMessageHandler(nil)
    }
    let getTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.getTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTorchStateChannel.setMessageHandler(nil)
    }
    let observeTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.observeTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        let observerArg = args[1] as! TorchStateObserver
        do {
          try api.pigeonDelegate.observeTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeTorchStateChannel.setMessageHandler(nil)
    }
    let removeTorchStateObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.removeTorchStateObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeTorchStateObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        let observerArg = args[1] as! TorchStateObserver
        do {
          try api.pigeonDelegate.removeTorchStateObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeTorchStateObserverChannel.setMessageHandler(nil)
    }
    let getZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.getZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.getZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getZoomStateChannel.setMessageHandler(nil)
    }
    let observeZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.observeZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        let observerArg = args[1] as! ZoomStateObserver
        do {
          try api.pigeonDelegate.observeZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeZoomStateChannel.setMessageHandler(nil)
    }
    let removeZoomStateObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.removeZoomStateObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeZoomStateObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        let observerArg = args[1] as! ZoomStateObserver
        do {
          try api.pigeonDelegate.removeZoomStateObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeZoomStateObserverChannel.setMessageHandler(nil)
    }
    let hasFlashUnitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.hasFlashUnit", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasFlashUnitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.hasFlashUnit(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasFlashUnitChannel.setMessageHandler(nil)
    }
    let isFocusMeteringSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.isFocusMeteringSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isFocusMeteringSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        let actionArg = args[1] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.isFocusMeteringSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg, action: actionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isFocusMeteringSupportedChannel.setMessageHandler(nil)
    }
    let isLogicalMultiCameraSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.isLogicalMultiCameraSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isLogicalMultiCameraSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.isLogicalMultiCameraSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isLogicalMultiCameraSupportedChannel.setMessageHandler(nil)
    }
    let isLowLightBoostSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.isLowLightBoostSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isLowLightBoostSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.isLowLightBoostSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isLowLightBoostSupportedChannel.setMessageHandler(nil)
    }
    let isTorchStrengthSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.isTorchStrengthSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isTorchStrengthSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.isTorchStrengthSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isTorchStrengthSupportedChannel.setMessageHandler(nil)
    }
    let isZslSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.isZslSupported", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isZslSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraInfo
        do {
          let result = try api.pigeonDelegate.isZslSupported(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isZslSupportedChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraInfoProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraInfo, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraInfoProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraSelectorProxyApi {
  func build(pigeonApi: PigeonApiCameraSelectorProxyApi, lensFacing: CameraSelectorLensFacingApi?) throws -> CameraSelector
  func back(pigeonApi: PigeonApiCameraSelectorProxyApi) throws -> CameraSelector
  func front(pigeonApi: PigeonApiCameraSelectorProxyApi) throws -> CameraSelector
  func external(pigeonApi: PigeonApiCameraSelectorProxyApi) throws -> CameraSelector
}

protocol PigeonApiProtocolCameraSelectorProxyApi {
}

final class PigeonApiCameraSelectorProxyApi: PigeonApiProtocolCameraSelectorProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraSelectorProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraSelectorProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraSelectorProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorProxyApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let lensFacingArg: CameraSelectorLensFacingApi? = nilOrValue(args[1])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, lensFacing: lensFacingArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
    let backChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorProxyApi.back", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      backChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.back(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      backChannel.setMessageHandler(nil)
    }
    let frontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorProxyApi.front", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      frontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.front(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      frontChannel.setMessageHandler(nil)
    }
    let externalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorProxyApi.external", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      externalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.external(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      externalChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraSelectorProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraSelector, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraSelectorProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFocusMeteringActionProxyApi {
  func build(pigeonApi: PigeonApiFocusMeteringActionProxyApi, point: MeteringPointTuple, morePoints: [MeteringPointTuple]?, disableAutoCancel: Bool?, autoCancelDuration: DurationTuple?) throws -> FocusMeteringAction
  func getAutoCancelDurationInMillis(pigeonApi: PigeonApiFocusMeteringActionProxyApi, pigeonInstance: FocusMeteringAction) throws -> Int64
  func getMeteringPointsAe(pigeonApi: PigeonApiFocusMeteringActionProxyApi, pigeonInstance: FocusMeteringAction) throws -> [MeteringPoint]
  func getMeteringPointsAf(pigeonApi: PigeonApiFocusMeteringActionProxyApi, pigeonInstance: FocusMeteringAction) throws -> [MeteringPoint]
  func getMeteringPointsAwb(pigeonApi: PigeonApiFocusMeteringActionProxyApi, pigeonInstance: FocusMeteringAction) throws -> [MeteringPoint]
  func isAutoCancelEnabled(pigeonApi: PigeonApiFocusMeteringActionProxyApi, pigeonInstance: FocusMeteringAction) throws -> Bool
}

protocol PigeonApiProtocolFocusMeteringActionProxyApi {
}

final class PigeonApiFocusMeteringActionProxyApi: PigeonApiProtocolFocusMeteringActionProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFocusMeteringActionProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFocusMeteringActionProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFocusMeteringActionProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionProxyApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let pointArg = args[1] as! MeteringPointTuple
        let morePointsArg: [MeteringPointTuple]? = nilOrValue(args[2])
        let disableAutoCancelArg: Bool? = nilOrValue(args[3])
        let autoCancelDurationArg: DurationTuple? = nilOrValue(args[4])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, point: pointArg, morePoints: morePointsArg, disableAutoCancel: disableAutoCancelArg, autoCancelDuration: autoCancelDurationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
    let getAutoCancelDurationInMillisChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionProxyApi.getAutoCancelDurationInMillis", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAutoCancelDurationInMillisChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.getAutoCancelDurationInMillis(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAutoCancelDurationInMillisChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionProxyApi.getMeteringPointsAe", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAe(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAeChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAfChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionProxyApi.getMeteringPointsAf", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAfChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAf(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAfChannel.setMessageHandler(nil)
    }
    let getMeteringPointsAwbChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionProxyApi.getMeteringPointsAwb", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMeteringPointsAwbChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.getMeteringPointsAwb(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMeteringPointsAwbChannel.setMessageHandler(nil)
    }
    let isAutoCancelEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FocusMeteringActionProxyApi.isAutoCancelEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isAutoCancelEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FocusMeteringAction
        do {
          let result = try api.pigeonDelegate.isAutoCancelEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isAutoCancelEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FocusMeteringActionProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FocusMeteringAction, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FocusMeteringActionProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFocusMeteringResultProxyApi {
  func isFocusSuccessful(pigeonApi: PigeonApiFocusMeteringResultProxyApi, pigeonInstance: FocusMeteringResult) throws -> Bool
}

protocol PigeonApiProtocolFocusMeteringResultProxyApi {
}

final class PigeonApiFocusMeteringResultProxyApi: PigeonApiProtocolFocusMeteringResultProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFocusMeteringResultProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFocusMeteringResultProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of FocusMeteringResultProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FocusMeteringResult, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let isFocusSuccessfulArg = try! pigeonDelegate.isFocusSuccessful(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FocusMeteringResultProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, isFocusSuccessfulArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageAnalysisAnalyzerProxyApi {
  func analyze(pigeonApi: PigeonApiImageAnalysisAnalyzerProxyApi, pigeonInstance: ImageAnalysis.Analyzer, image: ImageProxy) throws
}

protocol PigeonApiProtocolImageAnalysisAnalyzerProxyApi {
}

final class PigeonApiImageAnalysisAnalyzerProxyApi: PigeonApiProtocolImageAnalysisAnalyzerProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageAnalysisAnalyzerProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageAnalysisAnalyzerProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiImageAnalysisAnalyzerProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let analyzeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageAnalysisAnalyzerProxyApi.analyze", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      analyzeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! ImageAnalysis.Analyzer
        let imageArg = args[1] as! ImageProxy
        do {
          try api.pigeonDelegate.analyze(pigeonApi: api, pigeonInstance: pigeonInstanceArg, image: imageArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      analyzeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ImageAnalysisAnalyzerProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageAnalysis.Analyzer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageAnalysisAnalyzerProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageAnalysisAnalyzerImplProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiImageAnalysisAnalyzerImplProxyApi, consumer: ImageProxyConsumer) throws -> ImageAnalysis.Analyzer
}

protocol PigeonApiProtocolImageAnalysisAnalyzerImplProxyApi {
}

final class PigeonApiImageAnalysisAnalyzerImplProxyApi: PigeonApiProtocolImageAnalysisAnalyzerImplProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageAnalysisAnalyzerImplProxyApi
  ///An implementation of [ImageAnalysisAnalyzerProxyApi] used to access callback methods
  var pigeonApiImageAnalysisAnalyzerProxyApi: PigeonApiImageAnalysisAnalyzerProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiImageAnalysisAnalyzerProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageAnalysisAnalyzerImplProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiImageAnalysisAnalyzerImplProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageAnalysisAnalyzerImplProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let consumerArg = args[1] as! ImageProxyConsumer
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, consumer: consumerArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ImageAnalysisAnalyzerImplProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageAnalysis.Analyzer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageAnalysisAnalyzerImplProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageCaptureOnImageCapturedCallbackProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiImageCaptureOnImageCapturedCallbackProxyApi) throws -> ImageCapture.OnImageCapturedCallback
}

protocol PigeonApiProtocolImageCaptureOnImageCapturedCallbackProxyApi {
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, bitmap bitmapArg: CGImage, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureSuccess(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onError(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiImageCaptureOnImageCapturedCallbackProxyApi: PigeonApiProtocolImageCaptureOnImageCapturedCallbackProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageCaptureOnImageCapturedCallbackProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageCaptureOnImageCapturedCallbackProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiImageCaptureOnImageCapturedCallbackProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageCaptureOnImageCapturedCallbackProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ImageCaptureOnImageCapturedCallbackProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageCaptureOnImageCapturedCallbackProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageCaptureOnImageCapturedCallbackProxyApi.onCaptureStarted"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageCaptureOnImageCapturedCallbackProxyApi.onCaptureProcessProgressed"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, progressArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, bitmap bitmapArg: CGImage, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageCaptureOnImageCapturedCallbackProxyApi.onPostviewBitmapAvailable"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, bitmapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureSuccess(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageCaptureOnImageCapturedCallbackProxyApi.onCaptureSuccess"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, imageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onError(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageCaptureOnImageCapturedCallbackProxyApi.onError"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, exceptionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateImageInfoProxyApi {
  func timestamp(pigeonApi: PigeonApiImageInfoProxyApi, pigeonInstance: ImageInfo) throws -> Int64
  func rotationDegrees(pigeonApi: PigeonApiImageInfoProxyApi, pigeonInstance: ImageInfo) throws -> Int64
}

protocol PigeonApiProtocolImageInfoProxyApi {
}

final class PigeonApiImageInfoProxyApi: PigeonApiProtocolImageInfoProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageInfoProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageInfoProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ImageInfoProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageInfo, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let timestampArg = try! pigeonDelegate.timestamp(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rotationDegreesArg = try! pigeonDelegate.rotationDegrees(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageInfoProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, timestampArg, rotationDegreesArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageProxyPlaneProxyProxyApi {
  func value(pigeonApi: PigeonApiImageProxyPlaneProxyProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> FlutterStandardTypedData
  func pixelStride(pigeonApi: PigeonApiImageProxyPlaneProxyProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> Int64
  func rowStride(pigeonApi: PigeonApiImageProxyPlaneProxyProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> Int64
}

protocol PigeonApiProtocolImageProxyPlaneProxyProxyApi {
}

final class PigeonApiImageProxyPlaneProxyProxyApi: PigeonApiProtocolImageProxyPlaneProxyProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageProxyPlaneProxyProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageProxyPlaneProxyProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ImageProxyPlaneProxyProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageProxy.PlaneProxy, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let valueArg = try! pigeonDelegate.value(pigeonApi: self, pigeonInstance: pigeonInstance)
      let pixelStrideArg = try! pigeonDelegate.pixelStride(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rowStrideArg = try! pigeonDelegate.rowStride(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageProxyPlaneProxyProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, valueArg, pixelStrideArg, rowStrideArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageProxyProxyApi {
  func format(pigeonApi: PigeonApiImageProxyProxyApi, pigeonInstance: ImageProxy) throws -> ImageFormatApi
  func width(pigeonApi: PigeonApiImageProxyProxyApi, pigeonInstance: ImageProxy) throws -> Int64
  func height(pigeonApi: PigeonApiImageProxyProxyApi, pigeonInstance: ImageProxy) throws -> Int64
  func imageInfo(pigeonApi: PigeonApiImageProxyProxyApi, pigeonInstance: ImageProxy) throws -> ImageInfo
  func planes(pigeonApi: PigeonApiImageProxyProxyApi, pigeonInstance: ImageProxy) throws -> [ImageProxy.PlaneProxy]
}

protocol PigeonApiProtocolImageProxyProxyApi {
}

final class PigeonApiImageProxyProxyApi: PigeonApiProtocolImageProxyProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageProxyProxyApi
  ///An implementation of [AutoCloseableProxyApi] used to access callback methods
  var pigeonApiAutoCloseableProxyApi: PigeonApiAutoCloseableProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageProxyProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ImageProxyProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let formatArg = try! pigeonDelegate.format(pigeonApi: self, pigeonInstance: pigeonInstance)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let imageInfoArg = try! pigeonDelegate.imageInfo(pigeonApi: self, pigeonInstance: pigeonInstance)
      let planesArg = try! pigeonDelegate.planes(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageProxyProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, formatArg, widthArg, heightArg, imageInfoArg, planesArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMeteringPointProxyApi {
  func size(pigeonApi: PigeonApiMeteringPointProxyApi, pigeonInstance: MeteringPoint) throws -> Double
}

protocol PigeonApiProtocolMeteringPointProxyApi {
}

final class PigeonApiMeteringPointProxyApi: PigeonApiProtocolMeteringPointProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of MeteringPointProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPoint, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let sizeArg = try! pigeonDelegate.size(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, sizeArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMeteringPointFactoryProxyApi {
  func getDefaultPointSize(pigeonApi: PigeonApiMeteringPointFactoryProxyApi) throws -> Double
  func createPoint1(pigeonApi: PigeonApiMeteringPointFactoryProxyApi, pigeonInstance: MeteringPointFactory, x: Double, y: Double) throws -> MeteringPoint
  func createPoint2(pigeonApi: PigeonApiMeteringPointFactoryProxyApi, pigeonInstance: MeteringPointFactory, x: Double, y: Double, size: Double) throws -> MeteringPoint
}

protocol PigeonApiProtocolMeteringPointFactoryProxyApi {
}

final class PigeonApiMeteringPointFactoryProxyApi: PigeonApiProtocolMeteringPointFactoryProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMeteringPointFactoryProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMeteringPointFactoryProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMeteringPointFactoryProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getDefaultPointSizeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MeteringPointFactoryProxyApi.getDefaultPointSize", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDefaultPointSizeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.pigeonDelegate.getDefaultPointSize(pigeonApi: api)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDefaultPointSizeChannel.setMessageHandler(nil)
    }
    let createPoint1Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MeteringPointFactoryProxyApi.createPoint1", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createPoint1Channel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! MeteringPointFactory
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        do {
          let result = try api.pigeonDelegate.createPoint1(pigeonApi: api, pigeonInstance: pigeonInstanceArg, x: xArg, y: yArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createPoint1Channel.setMessageHandler(nil)
    }
    let createPoint2Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MeteringPointFactoryProxyApi.createPoint2", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createPoint2Channel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! MeteringPointFactory
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        let sizeArg = args[3] as! Double
        do {
          let result = try api.pigeonDelegate.createPoint2(pigeonApi: api, pigeonInstance: pigeonInstanceArg, x: xArg, y: yArg, size: sizeArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createPoint2Channel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MeteringPointFactoryProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: MeteringPointFactory, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MeteringPointFactoryProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateSurfaceOrientedMeteringPointFactoryProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiSurfaceOrientedMeteringPointFactoryProxyApi, width: Double, height: Double) throws -> SurfaceOrientedMeteringPointFactory
}

protocol PigeonApiProtocolSurfaceOrientedMeteringPointFactoryProxyApi {
}

final class PigeonApiSurfaceOrientedMeteringPointFactoryProxyApi: PigeonApiProtocolSurfaceOrientedMeteringPointFactoryProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateSurfaceOrientedMeteringPointFactoryProxyApi
  ///An implementation of [MeteringPointFactoryProxyApi] used to access callback methods
  var pigeonApiMeteringPointFactoryProxyApi: PigeonApiMeteringPointFactoryProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiMeteringPointFactoryProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateSurfaceOrientedMeteringPointFactoryProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiSurfaceOrientedMeteringPointFactoryProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.SurfaceOrientedMeteringPointFactoryProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let widthArg = args[1] as! Double
        let heightArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, width: widthArg, height: heightArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of SurfaceOrientedMeteringPointFactoryProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: SurfaceOrientedMeteringPointFactory, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.SurfaceOrientedMeteringPointFactoryProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateZoomStateProxyApi {
  func minZoomRatio(pigeonApi: PigeonApiZoomStateProxyApi, pigeonInstance: ZoomState) throws -> Double
  func maxZoomRatio(pigeonApi: PigeonApiZoomStateProxyApi, pigeonInstance: ZoomState) throws -> Double
  func zoomRatio(pigeonApi: PigeonApiZoomStateProxyApi, pigeonInstance: ZoomState) throws -> Double
  func linearZoom(pigeonApi: PigeonApiZoomStateProxyApi, pigeonInstance: ZoomState) throws -> Double
}

protocol PigeonApiProtocolZoomStateProxyApi {
}

final class PigeonApiZoomStateProxyApi: PigeonApiProtocolZoomStateProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ZoomStateProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let minZoomRatioArg = try! pigeonDelegate.minZoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let maxZoomRatioArg = try! pigeonDelegate.maxZoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let zoomRatioArg = try! pigeonDelegate.zoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let linearZoomArg = try! pigeonDelegate.linearZoom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, minZoomRatioArg, maxZoomRatioArg, zoomRatioArg, linearZoomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAudioStatsProxyApi {
  func audioAmplitude(pigeonApi: PigeonApiAudioStatsProxyApi, pigeonInstance: AudioStats) throws -> Double
  func audioState(pigeonApi: PigeonApiAudioStatsProxyApi, pigeonInstance: AudioStats) throws -> AudioStatsAudioStateApi
  func errorCause(pigeonApi: PigeonApiAudioStatsProxyApi, pigeonInstance: AudioStats) throws -> [Any?]?
  func hasAudio(pigeonApi: PigeonApiAudioStatsProxyApi, pigeonInstance: AudioStats) throws -> Bool
  func hasError(pigeonApi: PigeonApiAudioStatsProxyApi, pigeonInstance: AudioStats) throws -> Bool
}

protocol PigeonApiProtocolAudioStatsProxyApi {
}

final class PigeonApiAudioStatsProxyApi: PigeonApiProtocolAudioStatsProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAudioStatsProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAudioStatsProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AudioStatsProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AudioStats, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let audioAmplitudeArg = try! pigeonDelegate.audioAmplitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let audioStateArg = try! pigeonDelegate.audioState(pigeonApi: self, pigeonInstance: pigeonInstance)
      let errorCauseArg = try! pigeonDelegate.errorCause(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasAudioArg = try! pigeonDelegate.hasAudio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasErrorArg = try! pigeonDelegate.hasError(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AudioStatsProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, audioAmplitudeArg, audioStateArg, errorCauseArg, hasAudioArg, hasErrorArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputOptionsProxyApi {
  func getDurationLimitMillis(pigeonApi: PigeonApiOutputOptionsProxyApi, pigeonInstance: OutputOptions) throws -> Int64
  func getFileSizeLimit(pigeonApi: PigeonApiOutputOptionsProxyApi, pigeonInstance: OutputOptions) throws -> Int64
  func getLocation(pigeonApi: PigeonApiOutputOptionsProxyApi, pigeonInstance: OutputOptions) throws -> CLLocation?
}

protocol PigeonApiProtocolOutputOptionsProxyApi {
}

final class PigeonApiOutputOptionsProxyApi: PigeonApiProtocolOutputOptionsProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputOptionsProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputOptionsProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOutputOptionsProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getDurationLimitMillisChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OutputOptionsProxyApi.getDurationLimitMillis", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDurationLimitMillisChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! OutputOptions
        do {
          let result = try api.pigeonDelegate.getDurationLimitMillis(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDurationLimitMillisChannel.setMessageHandler(nil)
    }
    let getFileSizeLimitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OutputOptionsProxyApi.getFileSizeLimit", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFileSizeLimitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! OutputOptions
        do {
          let result = try api.pigeonDelegate.getFileSizeLimit(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFileSizeLimitChannel.setMessageHandler(nil)
    }
    let getLocationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OutputOptionsProxyApi.getLocation", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getLocationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! OutputOptions
        do {
          let result = try api.pigeonDelegate.getLocation(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getLocationChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OutputOptionsProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OutputOptions, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputOptionsProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateFileOutputOptionsProxyApi {
  func build(pigeonApi: PigeonApiFileOutputOptionsProxyApi, file: String, durationLimitMillis: Int64?, fileSizeLimitBytes: Int64?, location: CLLocation?) throws -> FileOutputOptions
  func getFile(pigeonApi: PigeonApiFileOutputOptionsProxyApi, pigeonInstance: FileOutputOptions) throws -> String
}

protocol PigeonApiProtocolFileOutputOptionsProxyApi {
}

final class PigeonApiFileOutputOptionsProxyApi: PigeonApiProtocolFileOutputOptionsProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFileOutputOptionsProxyApi
  ///An implementation of [OutputOptionsProxyApi] used to access callback methods
  var pigeonApiOutputOptionsProxyApi: PigeonApiOutputOptionsProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiOutputOptionsProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFileOutputOptionsProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFileOutputOptionsProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FileOutputOptionsProxyApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let fileArg = args[1] as! String
        let durationLimitMillisArg: Int64? = nilOrValue(args[2])
        let fileSizeLimitBytesArg: Int64? = nilOrValue(args[3])
        let locationArg: CLLocation? = nilOrValue(args[4])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, file: fileArg, durationLimitMillis: durationLimitMillisArg, fileSizeLimitBytes: fileSizeLimitBytesArg, location: locationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
    let getFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FileOutputOptionsProxyApi.getFile", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! FileOutputOptions
        do {
          let result = try api.pigeonDelegate.getFile(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFileChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FileOutputOptionsProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FileOutputOptions, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FileOutputOptionsProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputResultsProxyApi {
  func outputUri(pigeonApi: PigeonApiOutputResultsProxyApi, pigeonInstance: OutputResults) throws -> String?
}

protocol PigeonApiProtocolOutputResultsProxyApi {
}

final class PigeonApiOutputResultsProxyApi: PigeonApiProtocolOutputResultsProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputResultsProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputResultsProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of OutputResultsProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OutputResults, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputUriArg = try! pigeonDelegate.outputUri(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputResultsProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputUriArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRecordingStatsProxyApi {
  func audioStats(pigeonApi: PigeonApiRecordingStatsProxyApi, pigeonInstance: RecordingStats) throws -> AudioStats
  func numBytesRecorded(pigeonApi: PigeonApiRecordingStatsProxyApi, pigeonInstance: RecordingStats) throws -> Int64
  func recordedDurationNanos(pigeonApi: PigeonApiRecordingStatsProxyApi, pigeonInstance: RecordingStats) throws -> Int64
}

protocol PigeonApiProtocolRecordingStatsProxyApi {
}

final class PigeonApiRecordingStatsProxyApi: PigeonApiProtocolRecordingStatsProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRecordingStatsProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRecordingStatsProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of RecordingStatsProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RecordingStats, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let audioStatsArg = try! pigeonDelegate.audioStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let numBytesRecordedArg = try! pigeonDelegate.numBytesRecorded(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordedDurationNanosArg = try! pigeonDelegate.recordedDurationNanos(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RecordingStatsProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, audioStatsArg, numBytesRecordedArg, recordedDurationNanosArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRecordingProxyApi {
  func isPersistent(pigeonApi: PigeonApiRecordingProxyApi, pigeonInstance: Recording) throws -> Bool
  func mute(pigeonApi: PigeonApiRecordingProxyApi, pigeonInstance: Recording, muted: Bool) throws
  func pause(pigeonApi: PigeonApiRecordingProxyApi, pigeonInstance: Recording) throws
  func resume(pigeonApi: PigeonApiRecordingProxyApi, pigeonInstance: Recording) throws
  func stop(pigeonApi: PigeonApiRecordingProxyApi, pigeonInstance: Recording) throws
}

protocol PigeonApiProtocolRecordingProxyApi {
}

final class PigeonApiRecordingProxyApi: PigeonApiProtocolRecordingProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRecordingProxyApi
  ///An implementation of [AutoCloseableProxyApi] used to access callback methods
  var pigeonApiAutoCloseableProxyApi: PigeonApiAutoCloseableProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRecordingProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRecordingProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let isPersistentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingProxyApi.isPersistent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPersistentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          let result = try api.pigeonDelegate.isPersistent(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPersistentChannel.setMessageHandler(nil)
    }
    let muteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingProxyApi.mute", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      muteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        let mutedArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.mute(pigeonApi: api, pigeonInstance: pigeonInstanceArg, muted: mutedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      muteChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingProxyApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.pause(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let resumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingProxyApi.resume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.resume(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resumeChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingProxyApi.stop", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.stop(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RecordingProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Recording, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RecordingProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateVideoRecordEventProxyApi {
}

protocol PigeonApiProtocolVideoRecordEventProxyApi {
}

final class PigeonApiVideoRecordEventProxyApi: PigeonApiProtocolVideoRecordEventProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordEventProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordEventProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordEventProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordEventProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordStatusEventProxyApi {
  func outputOptions(pigeonApi: PigeonApiVideoRecordStatusEventProxyApi, pigeonInstance: VideoRecordEvent.Status) throws -> OutputOptions
  func recordingStats(pigeonApi: PigeonApiVideoRecordStatusEventProxyApi, pigeonInstance: VideoRecordEvent.Status) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordStatusEventProxyApi {
}

final class PigeonApiVideoRecordStatusEventProxyApi: PigeonApiProtocolVideoRecordStatusEventProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordStatusEventProxyApi
  ///An implementation of [VideoRecordEventProxyApi] used to access callback methods
  var pigeonApiVideoRecordEventProxyApi: PigeonApiVideoRecordEventProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordStatusEventProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordStatusEventProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Status, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputOptionsArg = try! pigeonDelegate.outputOptions(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordStatusEventProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputOptionsArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordStartEventProxyApi {
  func outputOptions(pigeonApi: PigeonApiVideoRecordStartEventProxyApi, pigeonInstance: VideoRecordEvent.Start) throws -> OutputOptions
  func recordingStats(pigeonApi: PigeonApiVideoRecordStartEventProxyApi, pigeonInstance: VideoRecordEvent.Start) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordStartEventProxyApi {
}

final class PigeonApiVideoRecordStartEventProxyApi: PigeonApiProtocolVideoRecordStartEventProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordStartEventProxyApi
  ///An implementation of [VideoRecordEventProxyApi] used to access callback methods
  var pigeonApiVideoRecordEventProxyApi: PigeonApiVideoRecordEventProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordStartEventProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordStartEventProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Start, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputOptionsArg = try! pigeonDelegate.outputOptions(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordStartEventProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputOptionsArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordPauseEventProxyApi {
  func outputOptions(pigeonApi: PigeonApiVideoRecordPauseEventProxyApi, pigeonInstance: VideoRecordEvent.Pause) throws -> OutputOptions
  func recordingStats(pigeonApi: PigeonApiVideoRecordPauseEventProxyApi, pigeonInstance: VideoRecordEvent.Pause) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordPauseEventProxyApi {
}

final class PigeonApiVideoRecordPauseEventProxyApi: PigeonApiProtocolVideoRecordPauseEventProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordPauseEventProxyApi
  ///An implementation of [VideoRecordEventProxyApi] used to access callback methods
  var pigeonApiVideoRecordEventProxyApi: PigeonApiVideoRecordEventProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordPauseEventProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordPauseEventProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Pause, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputOptionsArg = try! pigeonDelegate.outputOptions(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordPauseEventProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputOptionsArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordResumeEventProxyApi {
  func outputOptions(pigeonApi: PigeonApiVideoRecordResumeEventProxyApi, pigeonInstance: VideoRecordEvent.Resume) throws -> OutputOptions
  func recordingStats(pigeonApi: PigeonApiVideoRecordResumeEventProxyApi, pigeonInstance: VideoRecordEvent.Resume) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordResumeEventProxyApi {
}

final class PigeonApiVideoRecordResumeEventProxyApi: PigeonApiProtocolVideoRecordResumeEventProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordResumeEventProxyApi
  ///An implementation of [VideoRecordEventProxyApi] used to access callback methods
  var pigeonApiVideoRecordEventProxyApi: PigeonApiVideoRecordEventProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordResumeEventProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordResumeEventProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Resume, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputOptionsArg = try! pigeonDelegate.outputOptions(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordResumeEventProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputOptionsArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordFinalizeEventProxyApi {
  func outputOptions(pigeonApi: PigeonApiVideoRecordFinalizeEventProxyApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> OutputOptions
  func recordingStats(pigeonApi: PigeonApiVideoRecordFinalizeEventProxyApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> RecordingStats
  func cause(pigeonApi: PigeonApiVideoRecordFinalizeEventProxyApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> [Any?]?
  func error(pigeonApi: PigeonApiVideoRecordFinalizeEventProxyApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> VideoRecordFinalizeEventErrorApi
  func outputResults(pigeonApi: PigeonApiVideoRecordFinalizeEventProxyApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> OutputResults
  func hasError(pigeonApi: PigeonApiVideoRecordFinalizeEventProxyApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> Bool
}

protocol PigeonApiProtocolVideoRecordFinalizeEventProxyApi {
}

final class PigeonApiVideoRecordFinalizeEventProxyApi: PigeonApiProtocolVideoRecordFinalizeEventProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordFinalizeEventProxyApi
  ///An implementation of [VideoRecordEventProxyApi] used to access callback methods
  var pigeonApiVideoRecordEventProxyApi: PigeonApiVideoRecordEventProxyApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventProxyApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordFinalizeEventProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordFinalizeEventProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Finalize, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputOptionsArg = try! pigeonDelegate.outputOptions(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let causeArg = try! pigeonDelegate.cause(pigeonApi: self, pigeonInstance: pigeonInstance)
      let errorArg = try! pigeonDelegate.error(pigeonApi: self, pigeonInstance: pigeonInstance)
      let outputResultsArg = try! pigeonDelegate.outputResults(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasErrorArg = try! pigeonDelegate.hasError(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordFinalizeEventProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputOptionsArg, recordingStatsArg, causeArg, errorArg, outputResultsArg, hasErrorArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAudioConfigProxyApi {
  func create(pigeonApi: PigeonApiAudioConfigProxyApi, enableAudio: Bool) throws -> AudioConfig
  func audioDisabled(pigeonApi: PigeonApiAudioConfigProxyApi) throws -> AudioConfig
  func getAudioEnabled(pigeonApi: PigeonApiAudioConfigProxyApi, pigeonInstance: AudioConfig) throws -> Bool
}

protocol PigeonApiProtocolAudioConfigProxyApi {
}

final class PigeonApiAudioConfigProxyApi: PigeonApiProtocolAudioConfigProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAudioConfigProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAudioConfigProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAudioConfigProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigProxyApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let enableAudioArg = args[1] as! Bool
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.create(pigeonApi: api, enableAudio: enableAudioArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let audioDisabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigProxyApi.audioDisabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      audioDisabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.audioDisabled(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      audioDisabledChannel.setMessageHandler(nil)
    }
    let getAudioEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigProxyApi.getAudioEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAudioEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! AudioConfig
        do {
          let result = try api.pigeonDelegate.getAudioEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAudioEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AudioConfigProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AudioConfig, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AudioConfigProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraControllerProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraControllerProxyApi) throws -> CameraController
  func bind(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws
  func unbind(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws
  func hasCamera(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, cameraSelector: CameraSelector) throws -> Bool
  func getCameraSelector(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> CameraSelector
  func setCameraSelector(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, cameraSelector: CameraSelector) throws
  func getCameraInfo(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> CameraInfo?
  func getCameraControl(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> CameraControl?
  func getTorchState(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> TorchStateApi?
  func observeTorchState(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, observer: TorchStateObserver) throws
  func removeTorchStateObserver(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, observer: TorchStateObserver) throws
  func enableTorch(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, torchEnabled: Bool) throws
  func getZoomState(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> ZoomState?
  func observeZoomState(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, observer: ZoomStateObserver) throws
  func removeZoomStateObserver(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, observer: ZoomStateObserver) throws
  func setZoomRatio(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, zoomRatio: Double) throws
  func setLinearZoom(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, linearZoom: Double) throws
  func isPinchToZoomEnabled(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> Bool
  func setPinchToZoomEnabled(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, enabled: Bool) throws
  func isTapToFocusEnabled(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> Bool
  func setTapToFocusEnabled(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, enabled: Bool) throws
  func isImageCaptureEnabled(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> Bool
  func isImageAnalysisEnabled(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> Bool
  func isVideoCaptureEnabled(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> Bool
  func setEnabledUseCases(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, enabledUseCases: [CameraControllerUseCaseApi]) throws
  func getImageCaptureMode(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> ImageCaptureCaptureModeApi
  func setImageCaptureMode(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, captureMode: ImageCaptureCaptureModeApi) throws
  func getImageCaptureFlashMode(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> ImageCaptureFlashModeApi
  func setImageCaptureFlashMode(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, flashMode: ImageCaptureFlashModeApi) throws
  func takePicture1(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, imageCapturedCallback: ImageCapture.OnImageCapturedCallback) throws
  func getImageAnalysisResolutionSelector(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> ResolutionSelector?
  func setImageAnalysisResolutionSelector(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, resolutionSelector: ResolutionSelector?) throws
  func getImageAnalysisBackpressureStrategy(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> ImageAnalysisStrategyApi
  func setImageAnalysisBackpressureStrategy(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, strategy: ImageAnalysisStrategyApi) throws
  func getImageAnalysisImageQueueDepth(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> Int64
  func setImageAnalysisImageQueueDepth(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, depth: Int64) throws
  func getImageAnalysisOutputImageFormat(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> ImageAnalysisOutputImageFormatApi
  func setImageAnalysisOutputImageFormat(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, imageAnalysisOutputImageFormat: ImageAnalysisOutputImageFormatApi) throws
  func setImageAnalysisAnalyzer(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, analyzer: ImageAnalysis.Analyzer) throws
  func clearImageAnalysisAnalyzer(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws
  func getVideoCaptureMirrorMode(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> MirrorModeApi
  func setVideoCaptureMirrorMode(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, mirrorMode: MirrorModeApi) throws
  func isRecording(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController) throws -> Bool
  func startRecording1(pigeonApi: PigeonApiCameraControllerProxyApi, pigeonInstance: CameraController, outputOptions: FileOutputOptions, audioConfig: AudioConfig, listener: VideoRecordEventConsumer) throws -> Recording
}

protocol PigeonApiProtocolCameraControllerProxyApi {
}

final class PigeonApiCameraControllerProxyApi: PigeonApiProtocolCameraControllerProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraControllerProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraControllerProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraControllerProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let bindChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.bind", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      bindChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.bind(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      bindChannel.setMessageHandler(nil)
    }
    let unbindChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.unbind", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unbindChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.unbind(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unbindChannel.setMessageHandler(nil)
    }
    let hasCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.hasCamera", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let cameraSelectorArg = args[1] as! CameraSelector
        do {
          let result = try api.pigeonDelegate.hasCamera(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cameraSelector: cameraSelectorArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasCameraChannel.setMessageHandler(nil)
    }
    let getCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraSelectorChannel.setMessageHandler(nil)
    }
    let setCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let cameraSelectorArg = args[1] as! CameraSelector
        do {
          try api.pigeonDelegate.setCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cameraSelector: cameraSelectorArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCameraSelectorChannel.setMessageHandler(nil)
    }
    let getCameraInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getCameraInfo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getCameraInfo(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraInfoChannel.setMessageHandler(nil)
    }
    let getCameraControlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getCameraControl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraControlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getCameraControl(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraControlChannel.setMessageHandler(nil)
    }
    let getTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTorchStateChannel.setMessageHandler(nil)
    }
    let observeTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.observeTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let observerArg = args[1] as! TorchStateObserver
        do {
          try api.pigeonDelegate.observeTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeTorchStateChannel.setMessageHandler(nil)
    }
    let removeTorchStateObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.removeTorchStateObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeTorchStateObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let observerArg = args[1] as! TorchStateObserver
        do {
          try api.pigeonDelegate.removeTorchStateObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeTorchStateObserverChannel.setMessageHandler(nil)
    }
    let enableTorchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.enableTorch", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableTorchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let torchEnabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.enableTorch(pigeonApi: api, pigeonInstance: pigeonInstanceArg, torchEnabled: torchEnabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableTorchChannel.setMessageHandler(nil)
    }
    let getZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getZoomStateChannel.setMessageHandler(nil)
    }
    let observeZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.observeZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let observerArg = args[1] as! ZoomStateObserver
        do {
          try api.pigeonDelegate.observeZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeZoomStateChannel.setMessageHandler(nil)
    }
    let removeZoomStateObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.removeZoomStateObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeZoomStateObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let observerArg = args[1] as! ZoomStateObserver
        do {
          try api.pigeonDelegate.removeZoomStateObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeZoomStateObserverChannel.setMessageHandler(nil)
    }
    let setZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let zoomRatioArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg, zoomRatio: zoomRatioArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setZoomRatioChannel.setMessageHandler(nil)
    }
    let setLinearZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setLinearZoom", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLinearZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let linearZoomArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setLinearZoom(pigeonApi: api, pigeonInstance: pigeonInstanceArg, linearZoom: linearZoomArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLinearZoomChannel.setMessageHandler(nil)
    }
    let isPinchToZoomEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.isPinchToZoomEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPinchToZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isPinchToZoomEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPinchToZoomEnabledChannel.setMessageHandler(nil)
    }
    let setPinchToZoomEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setPinchToZoomEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPinchToZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setPinchToZoomEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPinchToZoomEnabledChannel.setMessageHandler(nil)
    }
    let isTapToFocusEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.isTapToFocusEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isTapToFocusEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isTapToFocusEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isTapToFocusEnabledChannel.setMessageHandler(nil)
    }
    let setTapToFocusEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setTapToFocusEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTapToFocusEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setTapToFocusEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTapToFocusEnabledChannel.setMessageHandler(nil)
    }
    let isImageCaptureEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.isImageCaptureEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isImageCaptureEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isImageCaptureEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isImageCaptureEnabledChannel.setMessageHandler(nil)
    }
    let isImageAnalysisEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.isImageAnalysisEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isImageAnalysisEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isImageAnalysisEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isImageAnalysisEnabledChannel.setMessageHandler(nil)
    }
    let isVideoCaptureEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.isVideoCaptureEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isVideoCaptureEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isVideoCaptureEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isVideoCaptureEnabledChannel.setMessageHandler(nil)
    }
    let setEnabledUseCasesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setEnabledUseCases", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setEnabledUseCasesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledUseCasesArg = args[1] as! [CameraControllerUseCaseApi]
        do {
          try api.pigeonDelegate.setEnabledUseCases(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabledUseCases: enabledUseCasesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setEnabledUseCasesChannel.setMessageHandler(nil)
    }
    let getImageCaptureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getImageCaptureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageCaptureMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageCaptureModeChannel.setMessageHandler(nil)
    }
    let setImageCaptureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setImageCaptureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let captureModeArg = args[1] as! ImageCaptureCaptureModeApi
        do {
          try api.pigeonDelegate.setImageCaptureMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, captureMode: captureModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageCaptureModeChannel.setMessageHandler(nil)
    }
    let getImageCaptureFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getImageCaptureFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageCaptureFlashMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageCaptureFlashModeChannel.setMessageHandler(nil)
    }
    let setImageCaptureFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setImageCaptureFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let flashModeArg = args[1] as! ImageCaptureFlashModeApi
        do {
          try api.pigeonDelegate.setImageCaptureFlashMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, flashMode: flashModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageCaptureFlashModeChannel.setMessageHandler(nil)
    }
    let takePicture1Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.takePicture1", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takePicture1Channel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let imageCapturedCallbackArg = args[1] as! ImageCapture.OnImageCapturedCallback
        do {
          try api.pigeonDelegate.takePicture1(pigeonApi: api, pigeonInstance: pigeonInstanceArg, imageCapturedCallback: imageCapturedCallbackArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      takePicture1Channel.setMessageHandler(nil)
    }
    let getImageAnalysisResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getImageAnalysisResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisResolutionSelectorChannel.setMessageHandler(nil)
    }
    let setImageAnalysisResolutionSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setImageAnalysisResolutionSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisResolutionSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let resolutionSelectorArg: ResolutionSelector? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setImageAnalysisResolutionSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, resolutionSelector: resolutionSelectorArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisResolutionSelectorChannel.setMessageHandler(nil)
    }
    let getImageAnalysisBackpressureStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getImageAnalysisBackpressureStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisBackpressureStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisBackpressureStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisBackpressureStrategyChannel.setMessageHandler(nil)
    }
    let setImageAnalysisBackpressureStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setImageAnalysisBackpressureStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisBackpressureStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let strategyArg = args[1] as! ImageAnalysisStrategyApi
        do {
          try api.pigeonDelegate.setImageAnalysisBackpressureStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg, strategy: strategyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisBackpressureStrategyChannel.setMessageHandler(nil)
    }
    let getImageAnalysisImageQueueDepthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getImageAnalysisImageQueueDepth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisImageQueueDepthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisImageQueueDepth(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisImageQueueDepthChannel.setMessageHandler(nil)
    }
    let setImageAnalysisImageQueueDepthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setImageAnalysisImageQueueDepth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisImageQueueDepthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let depthArg = args[1] as! Int64
        do {
          try api.pigeonDelegate.setImageAnalysisImageQueueDepth(pigeonApi: api, pigeonInstance: pigeonInstanceArg, depth: depthArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisImageQueueDepthChannel.setMessageHandler(nil)
    }
    let getImageAnalysisOutputImageFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getImageAnalysisOutputImageFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisOutputImageFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisOutputImageFormat(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisOutputImageFormatChannel.setMessageHandler(nil)
    }
    let setImageAnalysisOutputImageFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setImageAnalysisOutputImageFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisOutputImageFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let imageAnalysisOutputImageFormatArg = args[1] as! ImageAnalysisOutputImageFormatApi
        do {
          try api.pigeonDelegate.setImageAnalysisOutputImageFormat(pigeonApi: api, pigeonInstance: pigeonInstanceArg, imageAnalysisOutputImageFormat: imageAnalysisOutputImageFormatArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisOutputImageFormatChannel.setMessageHandler(nil)
    }
    let setImageAnalysisAnalyzerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setImageAnalysisAnalyzer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisAnalyzerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let analyzerArg = args[1] as! ImageAnalysis.Analyzer
        do {
          try api.pigeonDelegate.setImageAnalysisAnalyzer(pigeonApi: api, pigeonInstance: pigeonInstanceArg, analyzer: analyzerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisAnalyzerChannel.setMessageHandler(nil)
    }
    let clearImageAnalysisAnalyzerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.clearImageAnalysisAnalyzer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearImageAnalysisAnalyzerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.clearImageAnalysisAnalyzer(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearImageAnalysisAnalyzerChannel.setMessageHandler(nil)
    }
    let getVideoCaptureMirrorModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.getVideoCaptureMirrorMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoCaptureMirrorModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getVideoCaptureMirrorMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoCaptureMirrorModeChannel.setMessageHandler(nil)
    }
    let setVideoCaptureMirrorModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.setVideoCaptureMirrorMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoCaptureMirrorModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let mirrorModeArg = args[1] as! MirrorModeApi
        do {
          try api.pigeonDelegate.setVideoCaptureMirrorMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, mirrorMode: mirrorModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVideoCaptureMirrorModeChannel.setMessageHandler(nil)
    }
    let isRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.isRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isRecording(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isRecordingChannel.setMessageHandler(nil)
    }
    let startRecording1Channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.startRecording1", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startRecording1Channel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let outputOptionsArg = args[1] as! FileOutputOptions
        let audioConfigArg = args[2] as! AudioConfig
        let listenerArg = args[3] as! VideoRecordEventConsumer
        do {
          let result = try api.pigeonDelegate.startRecording1(pigeonApi: api, pigeonInstance: pigeonInstanceArg, outputOptions: outputOptionsArg, audioConfig: audioConfigArg, listener: listenerArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startRecording1Channel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraControllerProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraController, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraControllerProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePreviewViewProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPreviewViewProxyApi) throws -> PreviewView
  func getController(pigeonApi: PigeonApiPreviewViewProxyApi, pigeonInstance: PreviewView) throws -> CameraController?
  func setController(pigeonApi: PigeonApiPreviewViewProxyApi, pigeonInstance: PreviewView, controller: CameraController?) throws
  func getScaleType(pigeonApi: PigeonApiPreviewViewProxyApi, pigeonInstance: PreviewView) throws -> PreviewViewScaleTypeApi
  func setScaleType(pigeonApi: PigeonApiPreviewViewProxyApi, pigeonInstance: PreviewView, scaleType: PreviewViewScaleTypeApi) throws
}

protocol PigeonApiProtocolPreviewViewProxyApi {
}

final class PigeonApiPreviewViewProxyApi: PigeonApiProtocolPreviewViewProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePreviewViewProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePreviewViewProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPreviewViewProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let getControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewProxyApi.getController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        do {
          let result = try api.pigeonDelegate.getController(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getControllerChannel.setMessageHandler(nil)
    }
    let setControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewProxyApi.setController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        let controllerArg: CameraController? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setController(pigeonApi: api, pigeonInstance: pigeonInstanceArg, controller: controllerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setControllerChannel.setMessageHandler(nil)
    }
    let getScaleTypeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewProxyApi.getScaleType", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getScaleTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        do {
          let result = try api.pigeonDelegate.getScaleType(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getScaleTypeChannel.setMessageHandler(nil)
    }
    let setScaleTypeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewProxyApi.setScaleType", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setScaleTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        let scaleTypeArg = args[1] as! PreviewViewScaleTypeApi
        do {
          try api.pigeonDelegate.setScaleType(pigeonApi: api, pigeonInstance: pigeonInstanceArg, scaleType: scaleTypeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setScaleTypeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PreviewViewProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PreviewView, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PreviewViewProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRotationProviderListenerProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiRotationProviderListenerProxyApi) throws -> RotationProvider.Listener
}

protocol PigeonApiProtocolRotationProviderListenerProxyApi {
  func onRotationChanged(pigeonInstance pigeonInstanceArg: RotationProvider.Listener, rotation rotationArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiRotationProviderListenerProxyApi: PigeonApiProtocolRotationProviderListenerProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRotationProviderListenerProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRotationProviderListenerProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRotationProviderListenerProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RotationProviderListenerProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RotationProviderListenerProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RotationProvider.Listener, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of RotationProviderListenerProxyApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onRotationChanged(pigeonInstance pigeonInstanceArg: RotationProvider.Listener, rotation rotationArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.RotationProviderListenerProxyApi.onRotationChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, rotationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateRotationProviderProxyApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiRotationProviderProxyApi) throws -> RotationProvider
  func addListener(pigeonApi: PigeonApiRotationProviderProxyApi, pigeonInstance: RotationProvider, listener: RotationProvider.Listener) throws -> Bool
  func removeListener(pigeonApi: PigeonApiRotationProviderProxyApi, pigeonInstance: RotationProvider, listener: RotationProvider.Listener) throws
}

protocol PigeonApiProtocolRotationProviderProxyApi {
}

final class PigeonApiRotationProviderProxyApi: PigeonApiProtocolRotationProviderProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRotationProviderProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRotationProviderProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRotationProviderProxyApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RotationProviderProxyApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let addListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RotationProviderProxyApi.addListener", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! RotationProvider
        let listenerArg = args[1] as! RotationProvider.Listener
        do {
          let result = try api.pigeonDelegate.addListener(pigeonApi: api, pigeonInstance: pigeonInstanceArg, listener: listenerArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addListenerChannel.setMessageHandler(nil)
    }
    let removeListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RotationProviderProxyApi.removeListener", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! RotationProvider
        let listenerArg = args[1] as! RotationProvider.Listener
        do {
          try api.pigeonDelegate.removeListener(pigeonApi: api, pigeonInstance: pigeonInstanceArg, listener: listenerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeListenerChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RotationProviderProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RotationProvider, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RotationProviderProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
