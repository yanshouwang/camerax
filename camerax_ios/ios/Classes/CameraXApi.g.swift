// Autogenerated from Pigeon (v25.3.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
import CoreLocation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class CameraXError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "CameraXError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? CameraXError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> CameraXError {
  return CameraXError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Handles the callback when an object is deallocated.
protocol CameraXApiPigeonInternalFinalizerDelegate: AnyObject {
  /// Invoked when the strong reference of an object is deallocated in an `InstanceManager`.
  func onDeinit(identifier: Int64)
}


// Attaches to an object to receive a callback when the object is deallocated.
internal final class CameraXApiPigeonInternalFinalizer {
  private static let associatedObjectKey = malloc(1)!

  private let identifier: Int64
  // Reference to the delegate is weak because the callback should be ignored if the
  // `InstanceManager` is deallocated.
  private weak var delegate: CameraXApiPigeonInternalFinalizerDelegate?

  private init(identifier: Int64, delegate: CameraXApiPigeonInternalFinalizerDelegate) {
    self.identifier = identifier
    self.delegate = delegate
  }

  internal static func attach(
    to instance: AnyObject, identifier: Int64, delegate: CameraXApiPigeonInternalFinalizerDelegate
  ) {
    let finalizer = CameraXApiPigeonInternalFinalizer(identifier: identifier, delegate: delegate)
    objc_setAssociatedObject(instance, associatedObjectKey, finalizer, .OBJC_ASSOCIATION_RETAIN)
  }

  static func detach(from instance: AnyObject) {
    objc_setAssociatedObject(instance, associatedObjectKey, nil, .OBJC_ASSOCIATION_ASSIGN)
  }

  deinit {
    delegate?.onDeinit(identifier: identifier)
  }
}


/// Maintains instances used to communicate with the corresponding objects in Dart.
///
/// Objects stored in this container are represented by an object in Dart that is also stored in
/// an InstanceManager with the same identifier.
///
/// When an instance is added with an identifier, either can be used to retrieve the other.
///
/// Added instances are added as a weak reference and a strong reference. When the strong
/// reference is removed and the weak reference is deallocated,`CameraXApiPigeonInternalFinalizerDelegate.onDeinit`
/// is called with the instance's identifier. However, if the strong reference is removed and then the identifier is
/// retrieved with the intention to pass the identifier to Dart (e.g. by calling `identifierWithStrongReference`),
/// the strong reference to the instance is re-added. The strong reference will then need to be removed manually
/// again.
///
/// Accessing and inserting to an InstanceManager is thread safe.
final class CameraXApiPigeonInstanceManager {
  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously from Dart.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  private static let minHostCreatedIdentifier: Int64 = 65536

  private let lockQueue = DispatchQueue(label: "CameraXApiPigeonInstanceManager")
  private let identifiers: NSMapTable<AnyObject, NSNumber> = NSMapTable(
    keyOptions: [.weakMemory, .objectPointerPersonality], valueOptions: .strongMemory)
  private let weakInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.weakMemory, .objectPointerPersonality])
  private let strongInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.strongMemory, .objectPointerPersonality])
  private let finalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate
  private var nextIdentifier: Int64 = minHostCreatedIdentifier

  public init(finalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate) {
    self.finalizerDelegate = finalizerDelegate
  }

  /// Adds a new instance that was instantiated from Dart.
  ///
  /// The same instance can be added multiple times, but each identifier must be unique. This allows
  /// two objects that are equivalent (e.g. conforms to `Equatable`)  to both be added.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored
  ///   - identifier: the identifier to be paired with instance. This value must be >= 0 and unique
  func addDartCreatedInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    lockQueue.async {
      self.addInstance(instance, withIdentifier: identifier)
    }
  }

  /// Adds a new instance that was instantiated from the host platform.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored. This must be unique to all other added instances.
  /// - Returns: the unique identifier (>= 0) stored with instance
  func addHostCreatedInstance(_ instance: AnyObject) -> Int64 {
    assert(!containsInstance(instance), "Instance of \(instance) has already been added.")
    var identifier: Int64 = -1
    lockQueue.sync {
      identifier = nextIdentifier
      nextIdentifier += 1
      self.addInstance(instance, withIdentifier: identifier)
    }
    return identifier
  }

  /// Removes `instanceIdentifier` and its associated strongly referenced instance, if present, from the manager.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier paired to an instance.
  /// - Returns: removed instance if the manager contains the given identifier, otherwise `nil` if
  ///   the manager doesn't contain the value
  func removeInstance<T: AnyObject>(withIdentifier instanceIdentifier: Int64) throws -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = strongInstances.object(forKey: NSNumber(value: instanceIdentifier))
      strongInstances.removeObject(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier associated with an instance
  /// - Returns: the instance associated with `instanceIdentifier` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func instance<T: AnyObject>(forIdentifier instanceIdentifier: Int64) -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = weakInstances.object(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  private func addInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    assert(identifier >= 0)
    assert(
      weakInstances.object(forKey: identifier as NSNumber) == nil,
      "Identifier has already been added: \(identifier)")
    identifiers.setObject(NSNumber(value: identifier), forKey: instance)
    weakInstances.setObject(instance, forKey: NSNumber(value: identifier))
    strongInstances.setObject(instance, forKey: NSNumber(value: identifier))
    CameraXApiPigeonInternalFinalizer.attach(to: instance, identifier: identifier, delegate: finalizerDelegate)
  }

  /// Retrieves the identifier paired with an instance.
  ///
  /// If the manager contains a strong reference to `instance`, it will return the identifier
  /// associated with `instance`. If the manager contains only a weak reference to `instance`, a new
  /// strong reference to `instance` will be added and will need to be removed again with `removeInstance`.
  ///
  /// If this method returns a nonnull identifier, this method also expects the Dart
  /// `CameraXApiPigeonInstanceManager` to have, or recreate, a weak reference to the Dart instance the
  /// identifier is associated with.
  ///
  /// - Parameters:
  ///   - instance: an instance that may be stored in the manager
  /// - Returns: the identifier associated with `instance` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func identifierWithStrongReference(forInstance instance: AnyObject) -> Int64? {
    var identifier: Int64? = nil
    lockQueue.sync {
      if let existingIdentifier = identifiers.object(forKey: instance)?.int64Value {
        strongInstances.setObject(instance, forKey: NSNumber(value: existingIdentifier))
        identifier = existingIdentifier
      }
    }
    return identifier
  }

  /// Whether this manager contains the given `instance`.
  ///
  /// - Parameters:
  ///   - instance: the instance whose presence in this manager is to be tested
  /// - Returns: whether this manager contains the given `instance`
  func containsInstance(_ instance: AnyObject) -> Bool {
    var containsInstance = false
    lockQueue.sync {
      containsInstance = identifiers.object(forKey: instance) != nil
    }
    return containsInstance
  }

  /// Removes all of the instances from this manager.
  ///
  /// The manager will be empty after this call returns.
  func removeAllObjects() throws {
    lockQueue.sync {
      identifiers.removeAllObjects()
      weakInstances.removeAllObjects()
      strongInstances.removeAllObjects()
      nextIdentifier = CameraXApiPigeonInstanceManager.minHostCreatedIdentifier
    }
  }

  /// The number of instances stored as a strong reference.
  ///
  /// For debugging and testing purposes.
  internal var strongInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = strongInstances.count
    }
    return count
  }

  /// The number of instances stored as a weak reference.
  ///
  /// For debugging and testing purposes. NSMapTables that store keys or objects as weak
  /// reference will be reclaimed non-deterministically.
  internal var weakInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = weakInstances.count
    }
    return count
  }
}


private class CameraXApiPigeonInstanceManagerApi {
  /// The codec used for serializing messages.
  var codec: FlutterStandardMessageCodec { CameraXApiPigeonCodec.shared }

  /// Handles sending and receiving messages with Dart.
  unowned let binaryMessenger: FlutterBinaryMessenger

  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  /// Sets up an instance of `CameraXApiPigeonInstanceManagerApi` to handle messages through the `binaryMessenger`.
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, instanceManager: CameraXApiPigeonInstanceManager?) {
    let codec = CameraXApiPigeonCodec.shared
    let removeStrongReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.removeStrongReference", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      removeStrongReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! Int64
        do {
          let _: AnyObject? = try instanceManager.removeInstance(withIdentifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStrongReferenceChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.clear", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      clearChannel.setMessageHandler { _, reply in
        do {
          try instanceManager.removeAllObjects()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
  }

  /// Sends a message to the Dart `InstanceManager` to remove the strong reference of the instance associated with `identifier`.
  func removeStrongReference(identifier identifierArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.camerax_ios.PigeonInternalInstanceManager.removeStrongReference"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
protocol CameraXApiPigeonProxyApiDelegate {
  /// An implementation of [PigeonApiPermissionManagerApi] used to add a new Dart instance of
  /// `PermissionManagerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPermissionManagerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPermissionManagerApi
  /// An implementation of [PigeonApiAutoCloseableApi] used to add a new Dart instance of
  /// `AutoCloseableApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAutoCloseableApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAutoCloseableApi
  /// An implementation of [PigeonApiCloseableApi] used to add a new Dart instance of
  /// `CloseableApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCloseableApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCloseableApi
  /// An implementation of [PigeonApiLocationApi] used to add a new Dart instance of
  /// `LocationApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiLocationApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiLocationApi
  /// An implementation of [PigeonApiCameraSelectorApi] used to add a new Dart instance of
  /// `CameraSelectorApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraSelectorApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraSelectorApi
  /// An implementation of [PigeonApiNSKeyValueObservationApi] used to add a new Dart instance of
  /// `NSKeyValueObservationApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSKeyValueObservationApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiNSKeyValueObservationApi
  /// An implementation of [PigeonApiTorchStateObserverApi] used to add a new Dart instance of
  /// `TorchStateObserverApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiTorchStateObserverApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiTorchStateObserverApi
  /// An implementation of [PigeonApiZoomStateApi] used to add a new Dart instance of
  /// `ZoomStateApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiZoomStateApi
  /// An implementation of [PigeonApiZoomStateObserverApi] used to add a new Dart instance of
  /// `ZoomStateObserverApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiZoomStateObserverApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiZoomStateObserverApi
  /// An implementation of [PigeonApiImageInfoApi] used to add a new Dart instance of
  /// `ImageInfoApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageInfoApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageInfoApi
  /// An implementation of [PigeonApiPlaneProxyApi] used to add a new Dart instance of
  /// `PlaneProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPlaneProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPlaneProxyApi
  /// An implementation of [PigeonApiImageProxyApi] used to add a new Dart instance of
  /// `ImageProxyApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageProxyApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageProxyApi
  /// An implementation of [PigeonApiMetadataApi] used to add a new Dart instance of
  /// `MetadataApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiMetadataApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiMetadataApi
  /// An implementation of [PigeonApiOutputFileOptionsApi] used to add a new Dart instance of
  /// `OutputFileOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputFileOptionsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOutputFileOptionsApi
  /// An implementation of [PigeonApiOutputFileResultsApi] used to add a new Dart instance of
  /// `OutputFileResultsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputFileResultsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOutputFileResultsApi
  /// An implementation of [PigeonApiOnImageCapturedCallbackApi] used to add a new Dart instance of
  /// `OnImageCapturedCallbackApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOnImageCapturedCallbackApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOnImageCapturedCallbackApi
  /// An implementation of [PigeonApiOnImageSavedCallbackApi] used to add a new Dart instance of
  /// `OnImageSavedCallbackApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOnImageSavedCallbackApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOnImageSavedCallbackApi
  /// An implementation of [PigeonApiAnalyzerApi] used to add a new Dart instance of
  /// `AnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAnalyzerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAnalyzerApi
  /// An implementation of [PigeonApiImageAnalyzerApi] used to add a new Dart instance of
  /// `ImageAnalyzerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiImageAnalyzerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiImageAnalyzerApi
  /// An implementation of [PigeonApiFileOutputOptionsApi] used to add a new Dart instance of
  /// `FileOutputOptionsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiFileOutputOptionsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiFileOutputOptionsApi
  /// An implementation of [PigeonApiAudioConfigApi] used to add a new Dart instance of
  /// `AudioConfigApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAudioConfigApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAudioConfigApi
  /// An implementation of [PigeonApiAudioStatsApi] used to add a new Dart instance of
  /// `AudioStatsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAudioStatsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAudioStatsApi
  /// An implementation of [PigeonApiRecordingStatsApi] used to add a new Dart instance of
  /// `RecordingStatsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRecordingStatsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRecordingStatsApi
  /// An implementation of [PigeonApiVideoRecordEventApi] used to add a new Dart instance of
  /// `VideoRecordEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventApi
  /// An implementation of [PigeonApiVideoRecordStatusEventApi] used to add a new Dart instance of
  /// `VideoRecordStatusEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordStatusEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordStatusEventApi
  /// An implementation of [PigeonApiVideoRecordStartEventApi] used to add a new Dart instance of
  /// `VideoRecordStartEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordStartEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordStartEventApi
  /// An implementation of [PigeonApiVideoRecordPauseEventApi] used to add a new Dart instance of
  /// `VideoRecordPauseEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordPauseEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordPauseEventApi
  /// An implementation of [PigeonApiVideoRecordResumeEventApi] used to add a new Dart instance of
  /// `VideoRecordResumeEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordResumeEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordResumeEventApi
  /// An implementation of [PigeonApiOutputResultsApi] used to add a new Dart instance of
  /// `OutputResultsApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiOutputResultsApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiOutputResultsApi
  /// An implementation of [PigeonApiVideoRecordFinalizeEventApi] used to add a new Dart instance of
  /// `VideoRecordFinalizeEventApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordFinalizeEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordFinalizeEventApi
  /// An implementation of [PigeonApiVideoRecordEventConsumerApi] used to add a new Dart instance of
  /// `VideoRecordEventConsumerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiVideoRecordEventConsumerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventConsumerApi
  /// An implementation of [PigeonApiRecordingApi] used to add a new Dart instance of
  /// `RecordingApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiRecordingApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiRecordingApi
  /// An implementation of [PigeonApiCameraControllerApi] used to add a new Dart instance of
  /// `CameraControllerApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCameraControllerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCameraControllerApi
  /// An implementation of [PigeonApiPreviewViewApi] used to add a new Dart instance of
  /// `PreviewViewApi` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiPreviewViewApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiPreviewViewApi
}

extension CameraXApiPigeonProxyApiDelegate {
  func pigeonApiCloseableApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiCloseableApi {
    return PigeonApiCloseableApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateCloseableApi())
  }
  func pigeonApiAnalyzerApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiAnalyzerApi {
    return PigeonApiAnalyzerApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateAnalyzerApi())
  }
  func pigeonApiVideoRecordEventApi(_ registrar: CameraXApiPigeonProxyApiRegistrar) -> PigeonApiVideoRecordEventApi {
    return PigeonApiVideoRecordEventApi(pigeonRegistrar: registrar, delegate: PigeonApiDelegateVideoRecordEventApi())
  }
}

open class CameraXApiPigeonProxyApiRegistrar {
  let binaryMessenger: FlutterBinaryMessenger
  let apiDelegate: CameraXApiPigeonProxyApiDelegate
  let instanceManager: CameraXApiPigeonInstanceManager
  /// Whether APIs should ignore calling to Dart.
  public var ignoreCallsToDart = false
  private var _codec: FlutterStandardMessageCodec?
  var codec: FlutterStandardMessageCodec {
    if _codec == nil {
      _codec = FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: self))
    }
    return _codec!
  }

  private class InstanceManagerApiFinalizerDelegate: CameraXApiPigeonInternalFinalizerDelegate {
    let api: CameraXApiPigeonInstanceManagerApi

    init(_ api: CameraXApiPigeonInstanceManagerApi) {
      self.api = api
    }

    public func onDeinit(identifier: Int64) {
      api.removeStrongReference(identifier: identifier) {
        _ in
      }
    }
  }

  init(binaryMessenger: FlutterBinaryMessenger, apiDelegate: CameraXApiPigeonProxyApiDelegate) {
    self.binaryMessenger = binaryMessenger
    self.apiDelegate = apiDelegate
    self.instanceManager = CameraXApiPigeonInstanceManager(
      finalizerDelegate: InstanceManagerApiFinalizerDelegate(
        CameraXApiPigeonInstanceManagerApi(binaryMessenger: binaryMessenger)))
  }

  func setUp() {
    CameraXApiPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: instanceManager)
    PigeonApiPermissionManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPermissionManagerApi(self))
    PigeonApiAutoCloseableApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAutoCloseableApi(self))
    PigeonApiLocationApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiLocationApi(self))
    PigeonApiCameraSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraSelectorApi(self))
    PigeonApiNSKeyValueObservationApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiNSKeyValueObservationApi(self))
    PigeonApiTorchStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiTorchStateObserverApi(self))
    PigeonApiZoomStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiZoomStateObserverApi(self))
    PigeonApiMetadataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiMetadataApi(self))
    PigeonApiOutputFileOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOutputFileOptionsApi(self))
    PigeonApiOnImageCapturedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOnImageCapturedCallbackApi(self))
    PigeonApiOnImageSavedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiOnImageSavedCallbackApi(self))
    PigeonApiImageAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiImageAnalyzerApi(self))
    PigeonApiFileOutputOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiFileOutputOptionsApi(self))
    PigeonApiAudioConfigApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAudioConfigApi(self))
    PigeonApiVideoRecordEventConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiVideoRecordEventConsumerApi(self))
    PigeonApiRecordingApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiRecordingApi(self))
    PigeonApiCameraControllerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCameraControllerApi(self))
    PigeonApiPreviewViewApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiPreviewViewApi(self))
  }
  func tearDown() {
    CameraXApiPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: nil)
    PigeonApiPermissionManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAutoCloseableApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiLocationApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraSelectorApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiNSKeyValueObservationApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiTorchStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiZoomStateObserverApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiMetadataApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOutputFileOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOnImageCapturedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiOnImageSavedCallbackApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiImageAnalyzerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiFileOutputOptionsApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAudioConfigApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiVideoRecordEventConsumerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiRecordingApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCameraControllerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiPreviewViewApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
  }
}
private class CameraXApiPigeonInternalProxyApiCodecReaderWriter: FlutterStandardReaderWriter {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

  private class CameraXApiPigeonInternalProxyApiCodecReader: CameraXApiPigeonCodecReader {
    unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

    init(data: Data, pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func readValue(ofType type: UInt8) -> Any? {
      switch type {
      case 128:
        let identifier = self.readValue()
        let instance: AnyObject? = pigeonRegistrar.instanceManager.instance(
          forIdentifier: identifier is Int64 ? identifier as! Int64 : Int64(identifier as! Int32))
        if instance == nil {
          print("Failed to find instance with identifier: \(identifier!)")
        }
        return instance
      default:
        return super.readValue(ofType: type)
      }
    }
  }

  private class CameraXApiPigeonInternalProxyApiCodecWriter: CameraXApiPigeonCodecWriter {
    unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar

    init(data: NSMutableData, pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func writeValue(_ value: Any) {
      if value is [Any] || value is Bool || value is Data || value is [AnyHashable: Any] || value is Double || value is FlutterStandardTypedData || value is Int64 || value is String || value is PermissionApi || value is LensFacingApi || value is CameraStateApi || value is TorchStateApi || value is MeteringModeApi || value is TimeUnitApi || value is AspectRatioApi || value is BitDepthApi || value is EncodingApi || value is ScaleTypeApi || value is UseCaseApi || value is ResolutionModeApi || value is AspectRatioFallbackRuleApi || value is ResolutionFallbackRuleApi || value is CaptureModeApi || value is FlashModeApi || value is BackpressureStrategyApi || value is CoordinateSystemApi || value is ImageFormatApi || value is MirrorModeApi || value is AudioStateApi || value is VideoRecordFinalizeEventErrorApi || value is ControlModeApi || value is ControlAeModeApi || value is ControlAfModeApi || value is ControlAwbModeApi {
        super.writeValue(value)
        return
      }


      if let instance = value as? PermissionManager {
        pigeonRegistrar.apiDelegate.pigeonApiPermissionManagerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Closeable {
        pigeonRegistrar.apiDelegate.pigeonApiCloseableApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CLLocation {
        pigeonRegistrar.apiDelegate.pigeonApiLocationApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraSelector {
        pigeonRegistrar.apiDelegate.pigeonApiCameraSelectorApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSKeyValueObservation {
        pigeonRegistrar.apiDelegate.pigeonApiNSKeyValueObservationApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? TorchStateObserver {
        pigeonRegistrar.apiDelegate.pigeonApiTorchStateObserverApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomState {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ZoomStateObserver {
        pigeonRegistrar.apiDelegate.pigeonApiZoomStateObserverApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageInfo {
        pigeonRegistrar.apiDelegate.pigeonApiImageInfoApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageProxy.PlaneProxy {
        pigeonRegistrar.apiDelegate.pigeonApiPlaneProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageProxy {
        pigeonRegistrar.apiDelegate.pigeonApiImageProxyApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AutoCloseable {
        pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageCapture.Metadata {
        pigeonRegistrar.apiDelegate.pigeonApiMetadataApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageCapture.OutputFileOptions {
        pigeonRegistrar.apiDelegate.pigeonApiOutputFileOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageCapture.OutputFileResults {
        pigeonRegistrar.apiDelegate.pigeonApiOutputFileResultsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageCapture.OnImageCapturedCallback {
        pigeonRegistrar.apiDelegate.pigeonApiOnImageCapturedCallbackApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageCapture.OnImageSavedCallback {
        pigeonRegistrar.apiDelegate.pigeonApiOnImageSavedCallbackApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageAnalysis.Analyzer {
        pigeonRegistrar.apiDelegate.pigeonApiImageAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? ImageAnalysis.Analyzer {
        pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? FileOutputOptions {
        pigeonRegistrar.apiDelegate.pigeonApiFileOutputOptionsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AudioConfig {
        pigeonRegistrar.apiDelegate.pigeonApiAudioConfigApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AudioStats {
        pigeonRegistrar.apiDelegate.pigeonApiAudioStatsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? RecordingStats {
        pigeonRegistrar.apiDelegate.pigeonApiRecordingStatsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Status {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordStatusEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Start {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordStartEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Pause {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordPauseEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Resume {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordResumeEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? OutputResults {
        pigeonRegistrar.apiDelegate.pigeonApiOutputResultsApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent.Finalize {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordFinalizeEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEvent {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? VideoRecordEventConsumer {
        pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventConsumerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? Recording {
        pigeonRegistrar.apiDelegate.pigeonApiRecordingApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CameraController {
        pigeonRegistrar.apiDelegate.pigeonApiCameraControllerApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? PreviewView {
        pigeonRegistrar.apiDelegate.pigeonApiPreviewViewApi(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as AnyObject?, pigeonRegistrar.instanceManager.containsInstance(instance)
      {
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance)!)
      } else {
        print("Unsupported value: \(value) of \(type(of: value))")
        assert(false, "Unsupported value for CameraXApiPigeonInternalProxyApiCodecWriter")
      }

    }
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar) {
    self.pigeonRegistrar = pigeonRegistrar
  }

  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraXApiPigeonInternalProxyApiCodecReader(data: data, pigeonRegistrar: pigeonRegistrar)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraXApiPigeonInternalProxyApiCodecWriter(data: data, pigeonRegistrar: pigeonRegistrar)
  }
}

enum PermissionApi: Int {
  case album = 0
  case audio = 1
  case video = 2
}

enum LensFacingApi: Int {
  case unknown = 0
  case front = 1
  case back = 2
  case external = 3
}

enum CameraStateApi: Int {
  case pendingOpen = 0
  case opening = 1
  case open = 2
  case closing = 3
  case closed = 4
}

enum TorchStateApi: Int {
  case off = 0
  case on = 1
}

enum MeteringModeApi: Int {
  case af = 0
  case ae = 1
  case awb = 2
}

enum TimeUnitApi: Int {
  case nanoseconds = 0
  case microseconds = 1
  case milliseconds = 2
  case seconds = 3
  case minutes = 4
  case hours = 5
  case days = 6
}

enum AspectRatioApi: Int {
  case ratioDefault = 0
  case ratio43 = 1
  case ratio169 = 2
}

enum BitDepthApi: Int {
  case bitDepthUnspecified = 0
  case bitDepth8Bit = 1
  case bitDepth10Bit = 2
}

enum EncodingApi: Int {
  case unspecified = 0
  case sdr = 1
  case hdrUnspecified = 2
  case hlg = 3
  case hdr10 = 4
  case hdr10Plus = 5
  case dolbyVision = 6
}

enum ScaleTypeApi: Int {
  case fillStart = 0
  case fillCenter = 1
  case fillEnd = 2
  case fitStart = 3
  case fitCenter = 4
  case fitEnd = 5
}

enum UseCaseApi: Int {
  case imageCapture = 0
  case imageAnalysis = 1
  case videoCapture = 2
}

enum ResolutionModeApi: Int {
  case preferCaptureRateOverHigherResolution = 0
  case preferHigherResolutionOverCaptureRate = 1
}

enum AspectRatioFallbackRuleApi: Int {
  case none = 0
  case auto = 1
}

enum ResolutionFallbackRuleApi: Int {
  case none = 0
  case closestHigherThenLower = 1
  case closestHigher = 2
  case closestLowerThenHigher = 3
  case closestLower = 4
}

enum CaptureModeApi: Int {
  case maximizeQuality = 0
  case minimizeLatency = 1
  case zeroShutterLag = 2
}

enum FlashModeApi: Int {
  case auto = 0
  case on = 1
  case off = 2
  case screen = 3
}

enum BackpressureStrategyApi: Int {
  case keepOnlyLatest = 0
  case blockProducer = 1
}

enum CoordinateSystemApi: Int {
  case original = 0
  case sensor = 1
  case viewReferenced = 2
}

enum ImageFormatApi: Int {
  case yuv420888 = 0
  case rgba8888 = 1
  case jpeg = 2
  case jpegR = 3
}

enum MirrorModeApi: Int {
  case off = 0
  case on = 1
  case onFrontOnly = 2
}

enum AudioStateApi: Int {
  case active = 0
  case disabled = 1
  case sourceSilenced = 2
  case encoderError = 3
  case sourceError = 4
  case muted = 5
}

enum VideoRecordFinalizeEventErrorApi: Int {
  case none = 0
  case unknown = 1
  case fileSizeLimitReached = 2
  case insufficientStorage = 3
  case sourceInactive = 4
  case invalidOuputOptions = 5
  case encodingFailed = 6
  case recorderError = 7
  case noValidData = 8
  case durationLimitReached = 9
  case recordingGarbageCollected = 10
}

enum ControlModeApi: Int {
  case auto = 0
  case off = 1
  case offKeepState = 2
  case useExtendedSceneMode = 3
  case useSceneMode = 4
}

enum ControlAeModeApi: Int {
  case off = 0
  case on = 1
  case onAlwaysFlash = 2
  case onAutoFlash = 3
  case onAutoFlashRedeye = 4
  case onExternalFlash = 5
  case onLowLightBoostBrightnessPriority = 6
}

enum ControlAfModeApi: Int {
  case auto = 0
  case continuousPicture = 1
  case edof = 2
  case macro = 3
  case off = 4
}

enum ControlAwbModeApi: Int {
  case auto = 0
  case cloudyDaylight = 1
  case daylight = 2
  case fluorescent = 3
  case incandesecent = 4
  case off = 5
  case shade = 6
  case twilight = 7
  case warmFluorescent = 8
}

private class CameraXApiPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PermissionApi(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return LensFacingApi(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CameraStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TorchStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MeteringModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TimeUnitApi(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AspectRatioApi(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BitDepthApi(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return EncodingApi(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ScaleTypeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UseCaseApi(rawValue: enumResultAsInt)
      }
      return nil
    case 140:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResolutionModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 141:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AspectRatioFallbackRuleApi(rawValue: enumResultAsInt)
      }
      return nil
    case 142:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResolutionFallbackRuleApi(rawValue: enumResultAsInt)
      }
      return nil
    case 143:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CaptureModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 144:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FlashModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 145:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BackpressureStrategyApi(rawValue: enumResultAsInt)
      }
      return nil
    case 146:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CoordinateSystemApi(rawValue: enumResultAsInt)
      }
      return nil
    case 147:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImageFormatApi(rawValue: enumResultAsInt)
      }
      return nil
    case 148:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MirrorModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 149:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AudioStateApi(rawValue: enumResultAsInt)
      }
      return nil
    case 150:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VideoRecordFinalizeEventErrorApi(rawValue: enumResultAsInt)
      }
      return nil
    case 151:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 152:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAeModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 153:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAfModeApi(rawValue: enumResultAsInt)
      }
      return nil
    case 154:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlAwbModeApi(rawValue: enumResultAsInt)
      }
      return nil
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class CameraXApiPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PermissionApi {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? LensFacingApi {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? CameraStateApi {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? TorchStateApi {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? MeteringModeApi {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? TimeUnitApi {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? AspectRatioApi {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? BitDepthApi {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? EncodingApi {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? ScaleTypeApi {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? UseCaseApi {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResolutionModeApi {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? AspectRatioFallbackRuleApi {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResolutionFallbackRuleApi {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else if let value = value as? CaptureModeApi {
      super.writeByte(143)
      super.writeValue(value.rawValue)
    } else if let value = value as? FlashModeApi {
      super.writeByte(144)
      super.writeValue(value.rawValue)
    } else if let value = value as? BackpressureStrategyApi {
      super.writeByte(145)
      super.writeValue(value.rawValue)
    } else if let value = value as? CoordinateSystemApi {
      super.writeByte(146)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImageFormatApi {
      super.writeByte(147)
      super.writeValue(value.rawValue)
    } else if let value = value as? MirrorModeApi {
      super.writeByte(148)
      super.writeValue(value.rawValue)
    } else if let value = value as? AudioStateApi {
      super.writeByte(149)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoRecordFinalizeEventErrorApi {
      super.writeByte(150)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlModeApi {
      super.writeByte(151)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAeModeApi {
      super.writeByte(152)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAfModeApi {
      super.writeByte(153)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlAwbModeApi {
      super.writeByte(154)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class CameraXApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraXApiPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraXApiPigeonCodecWriter(data: data)
  }
}

class CameraXApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = CameraXApiPigeonCodec(readerWriter: CameraXApiPigeonCodecReaderWriter())
}

protocol PigeonApiDelegatePermissionManagerApi {
  func instance(pigeonApi: PigeonApiPermissionManagerApi) throws -> PermissionManager
  func checkPermissioin(pigeonApi: PigeonApiPermissionManagerApi, pigeonInstance: PermissionManager, permission: PermissionApi) throws -> Bool
  func requestPermissions(pigeonApi: PigeonApiPermissionManagerApi, pigeonInstance: PermissionManager, permissions: [PermissionApi], completion: @escaping (Result<Bool, Error>) -> Void)
}

protocol PigeonApiProtocolPermissionManagerApi {
}

final class PigeonApiPermissionManagerApi: PigeonApiProtocolPermissionManagerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePermissionManagerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePermissionManagerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPermissionManagerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let instanceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.instance", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      instanceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.instance(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      instanceChannel.setMessageHandler(nil)
    }
    let checkPermissioinChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.checkPermissioin", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      checkPermissioinChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PermissionManager
        let permissionArg = args[1] as! PermissionApi
        do {
          let result = try api.pigeonDelegate.checkPermissioin(pigeonApi: api, pigeonInstance: pigeonInstanceArg, permission: permissionArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      checkPermissioinChannel.setMessageHandler(nil)
    }
    let requestPermissionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.requestPermissions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestPermissionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PermissionManager
        let permissionsArg = args[1] as! [PermissionApi]
        api.pigeonDelegate.requestPermissions(pigeonApi: api, pigeonInstance: pigeonInstanceArg, permissions: permissionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      requestPermissionsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PermissionManagerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PermissionManager, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PermissionManagerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAutoCloseableApi {
  func close(pigeonApi: PigeonApiAutoCloseableApi, pigeonInstance: AutoCloseable) throws
}

protocol PigeonApiProtocolAutoCloseableApi {
}

final class PigeonApiAutoCloseableApi: PigeonApiProtocolAutoCloseableApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAutoCloseableApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAutoCloseableApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAutoCloseableApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let closeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AutoCloseableApi.close", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! AutoCloseable
        do {
          try api.pigeonDelegate.close(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      closeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AutoCloseableApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AutoCloseable, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AutoCloseableApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateCloseableApi {
}

protocol PigeonApiProtocolCloseableApi {
}

final class PigeonApiCloseableApi: PigeonApiProtocolCloseableApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCloseableApi
  ///An implementation of [AutoCloseableApi] used to access callback methods
  var pigeonApiAutoCloseableApi: PigeonApiAutoCloseableApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCloseableApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CloseableApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Closeable, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CloseableApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateLocationApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiLocationApi, latitude: Double, longitude: Double) throws -> CLLocation
  func latitude(pigeonApi: PigeonApiLocationApi, pigeonInstance: CLLocation) throws -> Double
  func longitude(pigeonApi: PigeonApiLocationApi, pigeonInstance: CLLocation) throws -> Double
}

protocol PigeonApiProtocolLocationApi {
}

final class PigeonApiLocationApi: PigeonApiProtocolLocationApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateLocationApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateLocationApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiLocationApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.LocationApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let latitudeArg = args[1] as! Double
        let longitudeArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, latitude: latitudeArg, longitude: longitudeArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of LocationApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CLLocation, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let latitudeArg = try! pigeonDelegate.latitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let longitudeArg = try! pigeonDelegate.longitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.LocationApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, latitudeArg, longitudeArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraSelectorApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraSelectorApi, lensFacing: LensFacingApi?) throws -> CameraSelector
  func front(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelector
  func back(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelector
  func external(pigeonApi: PigeonApiCameraSelectorApi) throws -> CameraSelector
}

protocol PigeonApiProtocolCameraSelectorApi {
}

final class PigeonApiCameraSelectorApi: PigeonApiProtocolCameraSelectorApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraSelectorApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraSelectorApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraSelectorApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let lensFacingArg: LensFacingApi? = nilOrValue(args[1])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, lensFacing: lensFacingArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let frontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.front", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      frontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.front(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      frontChannel.setMessageHandler(nil)
    }
    let backChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.back", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      backChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.back(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      backChannel.setMessageHandler(nil)
    }
    let externalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.external", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      externalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.external(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      externalChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraSelectorApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraSelector, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraSelectorApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateNSKeyValueObservationApi {
  func invalidate(pigeonApi: PigeonApiNSKeyValueObservationApi, pigeonInstance: NSKeyValueObservation) throws
}

protocol PigeonApiProtocolNSKeyValueObservationApi {
}

final class PigeonApiNSKeyValueObservationApi: PigeonApiProtocolNSKeyValueObservationApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSKeyValueObservationApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSKeyValueObservationApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiNSKeyValueObservationApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let invalidateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.NSKeyValueObservationApi.invalidate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      invalidateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSKeyValueObservation
        do {
          try api.pigeonDelegate.invalidate(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      invalidateChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of NSKeyValueObservationApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSKeyValueObservation, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.NSKeyValueObservationApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateTorchStateObserverApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiTorchStateObserverApi) throws -> TorchStateObserver
}

protocol PigeonApiProtocolTorchStateObserverApi {
  func onChanged(pigeonInstance pigeonInstanceArg: TorchStateObserver, value valueArg: TorchStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiTorchStateObserverApi: PigeonApiProtocolTorchStateObserverApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateTorchStateObserverApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateTorchStateObserverApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiTorchStateObserverApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.TorchStateObserverApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of TorchStateObserverApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: TorchStateObserver, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of TorchStateObserverApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: TorchStateObserver, value valueArg: TorchStateApi, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.TorchStateObserverApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateZoomStateApi {
  func minZoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomState) throws -> Double
  func maxZoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomState) throws -> Double
  func zoomRatio(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomState) throws -> Double
  func linearZoom(pigeonApi: PigeonApiZoomStateApi, pigeonInstance: ZoomState) throws -> Double
}

protocol PigeonApiProtocolZoomStateApi {
}

final class PigeonApiZoomStateApi: PigeonApiProtocolZoomStateApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ZoomStateApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let minZoomRatioArg = try! pigeonDelegate.minZoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let maxZoomRatioArg = try! pigeonDelegate.maxZoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let zoomRatioArg = try! pigeonDelegate.zoomRatio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let linearZoomArg = try! pigeonDelegate.linearZoom(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, minZoomRatioArg, maxZoomRatioArg, zoomRatioArg, linearZoomArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateZoomStateObserverApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiZoomStateObserverApi) throws -> ZoomStateObserver
}

protocol PigeonApiProtocolZoomStateObserverApi {
  func onChanged(pigeonInstance pigeonInstanceArg: ZoomStateObserver, value valueArg: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiZoomStateObserverApi: PigeonApiProtocolZoomStateObserverApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateZoomStateObserverApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateZoomStateObserverApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiZoomStateObserverApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ZoomStateObserverApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ZoomStateObserverApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ZoomStateObserver, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ZoomStateObserverApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func onChanged(pigeonInstance pigeonInstanceArg: ZoomStateObserver, value valueArg: ZoomState, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ZoomStateObserverApi.onChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateImageInfoApi {
  func timestamp(pigeonApi: PigeonApiImageInfoApi, pigeonInstance: ImageInfo) throws -> Int64
  func rotationDegrees(pigeonApi: PigeonApiImageInfoApi, pigeonInstance: ImageInfo) throws -> Int64
}

protocol PigeonApiProtocolImageInfoApi {
}

final class PigeonApiImageInfoApi: PigeonApiProtocolImageInfoApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageInfoApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageInfoApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ImageInfoApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageInfo, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let timestampArg = try! pigeonDelegate.timestamp(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rotationDegreesArg = try! pigeonDelegate.rotationDegrees(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageInfoApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, timestampArg, rotationDegreesArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePlaneProxyApi {
  func buffer(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> FlutterStandardTypedData
  func pixelStride(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> Int64
  func rowStride(pigeonApi: PigeonApiPlaneProxyApi, pigeonInstance: ImageProxy.PlaneProxy) throws -> Int64
}

protocol PigeonApiProtocolPlaneProxyApi {
}

final class PigeonApiPlaneProxyApi: PigeonApiProtocolPlaneProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePlaneProxyApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePlaneProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of PlaneProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageProxy.PlaneProxy, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let bufferArg = try! pigeonDelegate.buffer(pigeonApi: self, pigeonInstance: pigeonInstance)
      let pixelStrideArg = try! pigeonDelegate.pixelStride(pigeonApi: self, pigeonInstance: pigeonInstance)
      let rowStrideArg = try! pigeonDelegate.rowStride(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PlaneProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, bufferArg, pixelStrideArg, rowStrideArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageProxyApi {
  func format(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> ImageFormatApi
  func width(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> Int64
  func height(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> Int64
  func planes(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> [ImageProxy.PlaneProxy]
  func imageInfo(pigeonApi: PigeonApiImageProxyApi, pigeonInstance: ImageProxy) throws -> ImageInfo
}

protocol PigeonApiProtocolImageProxyApi {
}

final class PigeonApiImageProxyApi: PigeonApiProtocolImageProxyApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageProxyApi
  ///An implementation of [AutoCloseableApi] used to access callback methods
  var pigeonApiAutoCloseableApi: PigeonApiAutoCloseableApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAutoCloseableApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageProxyApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of ImageProxyApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let formatArg = try! pigeonDelegate.format(pigeonApi: self, pigeonInstance: pigeonInstance)
      let widthArg = try! pigeonDelegate.width(pigeonApi: self, pigeonInstance: pigeonInstance)
      let heightArg = try! pigeonDelegate.height(pigeonApi: self, pigeonInstance: pigeonInstance)
      let planesArg = try! pigeonDelegate.planes(pigeonApi: self, pigeonInstance: pigeonInstance)
      let imageInfoArg = try! pigeonDelegate.imageInfo(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageProxyApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, formatArg, widthArg, heightArg, planesArg, imageInfoArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateMetadataApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiMetadataApi, isReversedHorizontal: Bool, isReversedVertical: Bool, location: CLLocation?) throws -> ImageCapture.Metadata
  func isReversedHorizontal(pigeonApi: PigeonApiMetadataApi, pigeonInstance: ImageCapture.Metadata) throws -> Bool
  func isReversedVertical(pigeonApi: PigeonApiMetadataApi, pigeonInstance: ImageCapture.Metadata) throws -> Bool
  func location(pigeonApi: PigeonApiMetadataApi, pigeonInstance: ImageCapture.Metadata) throws -> CLLocation?
}

protocol PigeonApiProtocolMetadataApi {
}

final class PigeonApiMetadataApi: PigeonApiProtocolMetadataApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateMetadataApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateMetadataApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiMetadataApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.MetadataApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let isReversedHorizontalArg = args[1] as! Bool
        let isReversedVerticalArg = args[2] as! Bool
        let locationArg: CLLocation? = nilOrValue(args[3])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, isReversedHorizontal: isReversedHorizontalArg, isReversedVertical: isReversedVerticalArg, location: locationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of MetadataApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageCapture.Metadata, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let isReversedHorizontalArg = try! pigeonDelegate.isReversedHorizontal(pigeonApi: self, pigeonInstance: pigeonInstance)
      let isReversedVerticalArg = try! pigeonDelegate.isReversedVertical(pigeonApi: self, pigeonInstance: pigeonInstance)
      let locationArg = try! pigeonDelegate.location(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.MetadataApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, isReversedHorizontalArg, isReversedVerticalArg, locationArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputFileOptionsApi {
  func build(pigeonApi: PigeonApiOutputFileOptionsApi, file: String, metadata: ImageCapture.Metadata?) throws -> ImageCapture.OutputFileOptions
}

protocol PigeonApiProtocolOutputFileOptionsApi {
}

final class PigeonApiOutputFileOptionsApi: PigeonApiProtocolOutputFileOptionsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputFileOptionsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputFileOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOutputFileOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OutputFileOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let fileArg = args[1] as! String
        let metadataArg: ImageCapture.Metadata? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, file: fileArg, metadata: metadataArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OutputFileOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageCapture.OutputFileOptions, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputFileOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputFileResultsApi {
  func savedUri(pigeonApi: PigeonApiOutputFileResultsApi, pigeonInstance: ImageCapture.OutputFileResults) throws -> String?
}

protocol PigeonApiProtocolOutputFileResultsApi {
}

final class PigeonApiOutputFileResultsApi: PigeonApiProtocolOutputFileResultsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputFileResultsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputFileResultsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of OutputFileResultsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageCapture.OutputFileResults, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let savedUriArg = try! pigeonDelegate.savedUri(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputFileResultsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, savedUriArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOnImageCapturedCallbackApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiOnImageCapturedCallbackApi) throws -> ImageCapture.OnImageCapturedCallback
}

protocol PigeonApiProtocolOnImageCapturedCallbackApi {
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureSuccess(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onError(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiOnImageCapturedCallbackApi: PigeonApiProtocolOnImageCapturedCallbackApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOnImageCapturedCallbackApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOnImageCapturedCallbackApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOnImageCapturedCallbackApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OnImageCapturedCallbackApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureStarted"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureProcessProgressed"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, progressArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onPostviewBitmapAvailable"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, bitmapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureSuccess(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onCaptureSuccess"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, imageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onError(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageCapturedCallback, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageCapturedCallbackApi.onError"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, exceptionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateOnImageSavedCallbackApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiOnImageSavedCallbackApi) throws -> ImageCapture.OnImageSavedCallback
}

protocol PigeonApiProtocolOnImageSavedCallbackApi {
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onImageSaved(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, outputFileResults outputFileResultsArg: ImageCapture.OutputFileResults, completion: @escaping (Result<Void, CameraXError>) -> Void)
  func onError(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiOnImageSavedCallbackApi: PigeonApiProtocolOnImageSavedCallbackApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOnImageSavedCallbackApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOnImageSavedCallbackApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiOnImageSavedCallbackApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of OnImageSavedCallbackApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageCapture.OnImageSavedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
  func onCaptureStarted(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onCaptureStarted"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onCaptureProcessProgressed(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, progress progressArg: Int64, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onCaptureProcessProgressed"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, progressArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onPostviewBitmapAvailable(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, bitmap bitmapArg: FlutterStandardTypedData, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onPostviewBitmapAvailable"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, bitmapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onImageSaved(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, outputFileResults outputFileResultsArg: ImageCapture.OutputFileResults, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onImageSaved"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, outputFileResultsArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  func onError(pigeonInstance pigeonInstanceArg: ImageCapture.OnImageSavedCallback, exception exceptionArg: [Any?], completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.OnImageSavedCallbackApi.onError"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, exceptionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
open class PigeonApiDelegateAnalyzerApi {
}

protocol PigeonApiProtocolAnalyzerApi {
}

final class PigeonApiAnalyzerApi: PigeonApiProtocolAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAnalyzerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageAnalysis.Analyzer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AnalyzerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateImageAnalyzerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiImageAnalyzerApi) throws -> ImageAnalysis.Analyzer
}

protocol PigeonApiProtocolImageAnalyzerApi {
  func analyze(pigeonInstance pigeonInstanceArg: ImageAnalysis.Analyzer, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiImageAnalyzerApi: PigeonApiProtocolImageAnalyzerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateImageAnalyzerApi
  ///An implementation of [AnalyzerApi] used to access callback methods
  var pigeonApiAnalyzerApi: PigeonApiAnalyzerApi {
    return pigeonRegistrar.apiDelegate.pigeonApiAnalyzerApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateImageAnalyzerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiImageAnalyzerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.ImageAnalyzerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ImageAnalyzerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: ImageAnalysis.Analyzer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of ImageAnalyzerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func analyze(pigeonInstance pigeonInstanceArg: ImageAnalysis.Analyzer, image imageArg: ImageProxy, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.ImageAnalyzerApi.analyze"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, imageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateFileOutputOptionsApi {
  func build(pigeonApi: PigeonApiFileOutputOptionsApi, file: String, durationLimitMillis: Int64?, fileSizeLimitBytes: Int64?, location: CLLocation?) throws -> FileOutputOptions
  func file(pigeonApi: PigeonApiFileOutputOptionsApi, pigeonInstance: FileOutputOptions) throws -> String
}

protocol PigeonApiProtocolFileOutputOptionsApi {
}

final class PigeonApiFileOutputOptionsApi: PigeonApiProtocolFileOutputOptionsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateFileOutputOptionsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateFileOutputOptionsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiFileOutputOptionsApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let buildChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.FileOutputOptionsApi.build", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      buildChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let fileArg = args[1] as! String
        let durationLimitMillisArg: Int64? = nilOrValue(args[2])
        let fileSizeLimitBytesArg: Int64? = nilOrValue(args[3])
        let locationArg: CLLocation? = nilOrValue(args[4])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.build(pigeonApi: api, file: fileArg, durationLimitMillis: durationLimitMillisArg, fileSizeLimitBytes: fileSizeLimitBytesArg, location: locationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      buildChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of FileOutputOptionsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: FileOutputOptions, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let fileArg = try! pigeonDelegate.file(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.FileOutputOptionsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, fileArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAudioConfigApi {
  func create(pigeonApi: PigeonApiAudioConfigApi, enableAudio: Bool) throws -> AudioConfig
  func audioDisabled(pigeonApi: PigeonApiAudioConfigApi) throws -> AudioConfig
  func getAudioEnabled(pigeonApi: PigeonApiAudioConfigApi, pigeonInstance: AudioConfig) throws -> Bool
}

protocol PigeonApiProtocolAudioConfigApi {
}

final class PigeonApiAudioConfigApi: PigeonApiProtocolAudioConfigApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAudioConfigApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAudioConfigApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAudioConfigApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let enableAudioArg = args[1] as! Bool
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.create(pigeonApi: api, enableAudio: enableAudioArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let audioDisabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.audioDisabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      audioDisabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.audioDisabled(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      audioDisabledChannel.setMessageHandler(nil)
    }
    let getAudioEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.AudioConfigApi.getAudioEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAudioEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! AudioConfig
        do {
          let result = try api.pigeonDelegate.getAudioEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAudioEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AudioConfigApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AudioConfig, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AudioConfigApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateAudioStatsApi {
  func audioAmplitude(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> Double
  func audioState(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> AudioStateApi
  func errorCause(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> [Any?]?
  func hasAudio(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> Bool
  func hasError(pigeonApi: PigeonApiAudioStatsApi, pigeonInstance: AudioStats) throws -> Bool
}

protocol PigeonApiProtocolAudioStatsApi {
}

final class PigeonApiAudioStatsApi: PigeonApiProtocolAudioStatsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAudioStatsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAudioStatsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AudioStatsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AudioStats, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let audioAmplitudeArg = try! pigeonDelegate.audioAmplitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let audioStateArg = try! pigeonDelegate.audioState(pigeonApi: self, pigeonInstance: pigeonInstance)
      let errorCauseArg = try! pigeonDelegate.errorCause(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasAudioArg = try! pigeonDelegate.hasAudio(pigeonApi: self, pigeonInstance: pigeonInstance)
      let hasErrorArg = try! pigeonDelegate.hasError(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.AudioStatsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, audioAmplitudeArg, audioStateArg, errorCauseArg, hasAudioArg, hasErrorArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateRecordingStatsApi {
  func audioStats(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStats) throws -> AudioStats
  func numBytesRecorded(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStats) throws -> Int64
  func recordedDurationNanos(pigeonApi: PigeonApiRecordingStatsApi, pigeonInstance: RecordingStats) throws -> Int64
}

protocol PigeonApiProtocolRecordingStatsApi {
}

final class PigeonApiRecordingStatsApi: PigeonApiProtocolRecordingStatsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRecordingStatsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRecordingStatsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of RecordingStatsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: RecordingStats, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let audioStatsArg = try! pigeonDelegate.audioStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let numBytesRecordedArg = try! pigeonDelegate.numBytesRecorded(pigeonApi: self, pigeonInstance: pigeonInstance)
      let recordedDurationNanosArg = try! pigeonDelegate.recordedDurationNanos(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RecordingStatsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, audioStatsArg, numBytesRecordedArg, recordedDurationNanosArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class PigeonApiDelegateVideoRecordEventApi {
}

protocol PigeonApiProtocolVideoRecordEventApi {
}

final class PigeonApiVideoRecordEventApi: PigeonApiProtocolVideoRecordEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordEventApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordStatusEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordStatusEventApi, pigeonInstance: VideoRecordEvent.Status) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordStatusEventApi {
}

final class PigeonApiVideoRecordStatusEventApi: PigeonApiProtocolVideoRecordStatusEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordStatusEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordStatusEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordStatusEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Status, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordStatusEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordStartEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordStartEventApi, pigeonInstance: VideoRecordEvent.Start) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordStartEventApi {
}

final class PigeonApiVideoRecordStartEventApi: PigeonApiProtocolVideoRecordStartEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordStartEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordStartEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordStartEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Start, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordStartEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordPauseEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordPauseEventApi, pigeonInstance: VideoRecordEvent.Pause) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordPauseEventApi {
}

final class PigeonApiVideoRecordPauseEventApi: PigeonApiProtocolVideoRecordPauseEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordPauseEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordPauseEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordPauseEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Pause, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordPauseEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordResumeEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordResumeEventApi, pigeonInstance: VideoRecordEvent.Resume) throws -> RecordingStats
}

protocol PigeonApiProtocolVideoRecordResumeEventApi {
}

final class PigeonApiVideoRecordResumeEventApi: PigeonApiProtocolVideoRecordResumeEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordResumeEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordResumeEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordResumeEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Resume, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordResumeEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateOutputResultsApi {
  func outputUri(pigeonApi: PigeonApiOutputResultsApi, pigeonInstance: OutputResults) throws -> String?
}

protocol PigeonApiProtocolOutputResultsApi {
}

final class PigeonApiOutputResultsApi: PigeonApiProtocolOutputResultsApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateOutputResultsApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateOutputResultsApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of OutputResultsApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: OutputResults, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let outputUriArg = try! pigeonDelegate.outputUri(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.OutputResultsApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, outputUriArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordFinalizeEventApi {
  func recordingStats(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> RecordingStats
  func cause(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> [Any?]?
  func error(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> VideoRecordFinalizeEventErrorApi
  func outputResults(pigeonApi: PigeonApiVideoRecordFinalizeEventApi, pigeonInstance: VideoRecordEvent.Finalize) throws -> OutputResults
}

protocol PigeonApiProtocolVideoRecordFinalizeEventApi {
}

final class PigeonApiVideoRecordFinalizeEventApi: PigeonApiProtocolVideoRecordFinalizeEventApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordFinalizeEventApi
  ///An implementation of [VideoRecordEventApi] used to access callback methods
  var pigeonApiVideoRecordEventApi: PigeonApiVideoRecordEventApi {
    return pigeonRegistrar.apiDelegate.pigeonApiVideoRecordEventApi(pigeonRegistrar)
  }

  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordFinalizeEventApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of VideoRecordFinalizeEventApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEvent.Finalize, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let recordingStatsArg = try! pigeonDelegate.recordingStats(pigeonApi: self, pigeonInstance: pigeonInstance)
      let causeArg = try! pigeonDelegate.cause(pigeonApi: self, pigeonInstance: pigeonInstance)
      let errorArg = try! pigeonDelegate.error(pigeonApi: self, pigeonInstance: pigeonInstance)
      let outputResultsArg = try! pigeonDelegate.outputResults(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordFinalizeEventApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, recordingStatsArg, causeArg, errorArg, outputResultsArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateVideoRecordEventConsumerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiVideoRecordEventConsumerApi) throws -> VideoRecordEventConsumer
}

protocol PigeonApiProtocolVideoRecordEventConsumerApi {
  func accept(pigeonInstance pigeonInstanceArg: VideoRecordEventConsumer, value valueArg: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void)
}

final class PigeonApiVideoRecordEventConsumerApi: PigeonApiProtocolVideoRecordEventConsumerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateVideoRecordEventConsumerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateVideoRecordEventConsumerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiVideoRecordEventConsumerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.VideoRecordEventConsumerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of VideoRecordEventConsumerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: VideoRecordEventConsumer, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      completion(
        .failure(
          CameraXError(
            code: "new-instance-error",
            message: "Error: Attempting to create a new Dart instance of VideoRecordEventConsumerApi, but the class has a nonnull callback method.", details: "")))
    }
  }
  func accept(pigeonInstance pigeonInstanceArg: VideoRecordEventConsumer, value valueArg: VideoRecordEvent, completion: @escaping (Result<Void, CameraXError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.camerax_ios.VideoRecordEventConsumerApi.accept"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, valueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(CameraXError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol PigeonApiDelegateRecordingApi {
  func isPersistene(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws -> Bool
  func mute(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording, muted: Bool) throws
  func pause(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws
  func resume(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws
  func stop(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws
  func close(pigeonApi: PigeonApiRecordingApi, pigeonInstance: Recording) throws
}

protocol PigeonApiProtocolRecordingApi {
}

final class PigeonApiRecordingApi: PigeonApiProtocolRecordingApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateRecordingApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateRecordingApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiRecordingApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let isPersisteneChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.isPersistene", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPersisteneChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          let result = try api.pigeonDelegate.isPersistene(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPersisteneChannel.setMessageHandler(nil)
    }
    let muteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.mute", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      muteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        let mutedArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.mute(pigeonApi: api, pigeonInstance: pigeonInstanceArg, muted: mutedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      muteChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.pause(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let resumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.resume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.resume(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resumeChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.stop", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.stop(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    let closeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.RecordingApi.close", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      closeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! Recording
        do {
          try api.pigeonDelegate.close(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      closeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of RecordingApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: Recording, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.RecordingApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCameraControllerApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCameraControllerApi) throws -> CameraController
  func initialize(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, completion: @escaping (Result<Void, Error>) -> Void)
  func bind(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws
  func unbind(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws
  func hasCamera(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, cameraSelector: CameraSelector) throws -> Bool
  func getCameraSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> CameraSelector
  func setCameraSelector(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, cameraSelector: CameraSelector) throws
  func getTorchState(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> TorchStateApi?
  func observeTorchState(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, observer: TorchStateObserver) throws -> NSKeyValueObservation
  func enableTorch(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, torchEnabled: Bool) throws
  func getZoomState(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> ZoomState?
  func observeZoomState(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, observer: ZoomStateObserver) throws -> NSKeyValueObservation
  func setZoomRatio(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, zoomRatio: Double) throws
  func setLinearZoom(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, linearZoom: Double) throws
  func isPinchToZoomEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func setPinchToZoomEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, enabled: Bool) throws
  func isTapToFocusEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func setTapToFocusEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, enabled: Bool) throws
  func isImageCaptureEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func isImageAnalysisEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func isVideoCaptureEnabled(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func setEnabledUseCases(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, enabledUseCases: [UseCaseApi]) throws
  func getImageCaptureMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> CaptureModeApi
  func setImageCaptureMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, captureMode: CaptureModeApi) throws
  func getImageCaptureFlashMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> FlashModeApi
  func setImageCaptureFlashMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, flashMode: FlashModeApi) throws
  func takePictureToMemory(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, capturedCallback: ImageCapture.OnImageCapturedCallback, completion: @escaping (Result<Void, Error>) -> Void)
  func takePictureToFile(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, outputFileOptions: ImageCapture.OutputFileOptions, savedCallback: ImageCapture.OnImageSavedCallback, completion: @escaping (Result<Void, Error>) -> Void)
  func getImageAnalysisBackpressureStrategy(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> BackpressureStrategyApi
  func setImageAnalysisBackpressureStrategy(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, strategy: BackpressureStrategyApi) throws
  func getImageAnalysisImageQueueDepth(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Int64
  func setImageAnalysisImageQueueDepth(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, depth: Int64) throws
  func getImageAnalysisOutputImageFormat(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> ImageFormatApi
  func setImageAnalysisOutputImageFormat(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, imageAnalysisOutputImageFormat: ImageFormatApi) throws
  func setImageAnalysisAnalyzer(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, analyzer: ImageAnalysis.Analyzer) throws
  func clearImageAnalysisAnalyzer(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws
  func getVideoCaptureMirrorMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> MirrorModeApi
  func setVideoCaptureMirrorMode(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, mirrorMode: MirrorModeApi) throws
  func isRecording(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController) throws -> Bool
  func startRecording(pigeonApi: PigeonApiCameraControllerApi, pigeonInstance: CameraController, outputOptions: FileOutputOptions, audioConfig: AudioConfig, listener: VideoRecordEventConsumer) throws -> Recording
}

protocol PigeonApiProtocolCameraControllerApi {
}

final class PigeonApiCameraControllerApi: PigeonApiProtocolCameraControllerApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCameraControllerApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCameraControllerApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCameraControllerApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.initialize", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        api.pigeonDelegate.initialize(pigeonApi: api, pigeonInstance: pigeonInstanceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    let bindChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.bind", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      bindChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.bind(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      bindChannel.setMessageHandler(nil)
    }
    let unbindChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.unbind", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unbindChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.unbind(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unbindChannel.setMessageHandler(nil)
    }
    let hasCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.hasCamera", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let cameraSelectorArg = args[1] as! CameraSelector
        do {
          let result = try api.pigeonDelegate.hasCamera(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cameraSelector: cameraSelectorArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasCameraChannel.setMessageHandler(nil)
    }
    let getCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraSelectorChannel.setMessageHandler(nil)
    }
    let setCameraSelectorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setCameraSelector", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCameraSelectorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let cameraSelectorArg = args[1] as! CameraSelector
        do {
          try api.pigeonDelegate.setCameraSelector(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cameraSelector: cameraSelectorArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCameraSelectorChannel.setMessageHandler(nil)
    }
    let getTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTorchStateChannel.setMessageHandler(nil)
    }
    let observeTorchStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.observeTorchState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeTorchStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let observerArg = args[1] as! TorchStateObserver
        do {
          let result = try api.pigeonDelegate.observeTorchState(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeTorchStateChannel.setMessageHandler(nil)
    }
    let enableTorchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.enableTorch", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enableTorchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let torchEnabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.enableTorch(pigeonApi: api, pigeonInstance: pigeonInstanceArg, torchEnabled: torchEnabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      enableTorchChannel.setMessageHandler(nil)
    }
    let getZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getZoomStateChannel.setMessageHandler(nil)
    }
    let observeZoomStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.observeZoomState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      observeZoomStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let observerArg = args[1] as! ZoomStateObserver
        do {
          let result = try api.pigeonDelegate.observeZoomState(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      observeZoomStateChannel.setMessageHandler(nil)
    }
    let setZoomRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setZoomRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let zoomRatioArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setZoomRatio(pigeonApi: api, pigeonInstance: pigeonInstanceArg, zoomRatio: zoomRatioArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setZoomRatioChannel.setMessageHandler(nil)
    }
    let setLinearZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setLinearZoom", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLinearZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let linearZoomArg = args[1] as! Double
        do {
          try api.pigeonDelegate.setLinearZoom(pigeonApi: api, pigeonInstance: pigeonInstanceArg, linearZoom: linearZoomArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLinearZoomChannel.setMessageHandler(nil)
    }
    let isPinchToZoomEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isPinchToZoomEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPinchToZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isPinchToZoomEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPinchToZoomEnabledChannel.setMessageHandler(nil)
    }
    let setPinchToZoomEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setPinchToZoomEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPinchToZoomEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setPinchToZoomEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPinchToZoomEnabledChannel.setMessageHandler(nil)
    }
    let isTapToFocusEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isTapToFocusEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isTapToFocusEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isTapToFocusEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isTapToFocusEnabledChannel.setMessageHandler(nil)
    }
    let setTapToFocusEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setTapToFocusEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTapToFocusEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setTapToFocusEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTapToFocusEnabledChannel.setMessageHandler(nil)
    }
    let isImageCaptureEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isImageCaptureEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isImageCaptureEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isImageCaptureEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isImageCaptureEnabledChannel.setMessageHandler(nil)
    }
    let isImageAnalysisEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isImageAnalysisEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isImageAnalysisEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isImageAnalysisEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isImageAnalysisEnabledChannel.setMessageHandler(nil)
    }
    let isVideoCaptureEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isVideoCaptureEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isVideoCaptureEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isVideoCaptureEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isVideoCaptureEnabledChannel.setMessageHandler(nil)
    }
    let setEnabledUseCasesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setEnabledUseCases", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setEnabledUseCasesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let enabledUseCasesArg = args[1] as! [UseCaseApi]
        do {
          try api.pigeonDelegate.setEnabledUseCases(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabledUseCases: enabledUseCasesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setEnabledUseCasesChannel.setMessageHandler(nil)
    }
    let getImageCaptureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageCaptureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageCaptureMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageCaptureModeChannel.setMessageHandler(nil)
    }
    let setImageCaptureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageCaptureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let captureModeArg = args[1] as! CaptureModeApi
        do {
          try api.pigeonDelegate.setImageCaptureMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, captureMode: captureModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageCaptureModeChannel.setMessageHandler(nil)
    }
    let getImageCaptureFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageCaptureFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageCaptureFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageCaptureFlashMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageCaptureFlashModeChannel.setMessageHandler(nil)
    }
    let setImageCaptureFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageCaptureFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageCaptureFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let flashModeArg = args[1] as! FlashModeApi
        do {
          try api.pigeonDelegate.setImageCaptureFlashMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, flashMode: flashModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageCaptureFlashModeChannel.setMessageHandler(nil)
    }
    let takePictureToMemoryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.takePictureToMemory", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takePictureToMemoryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let capturedCallbackArg = args[1] as! ImageCapture.OnImageCapturedCallback
        api.pigeonDelegate.takePictureToMemory(pigeonApi: api, pigeonInstance: pigeonInstanceArg, capturedCallback: capturedCallbackArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      takePictureToMemoryChannel.setMessageHandler(nil)
    }
    let takePictureToFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.takePictureToFile", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takePictureToFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let outputFileOptionsArg = args[1] as! ImageCapture.OutputFileOptions
        let savedCallbackArg = args[2] as! ImageCapture.OnImageSavedCallback
        api.pigeonDelegate.takePictureToFile(pigeonApi: api, pigeonInstance: pigeonInstanceArg, outputFileOptions: outputFileOptionsArg, savedCallback: savedCallbackArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      takePictureToFileChannel.setMessageHandler(nil)
    }
    let getImageAnalysisBackpressureStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisBackpressureStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisBackpressureStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisBackpressureStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisBackpressureStrategyChannel.setMessageHandler(nil)
    }
    let setImageAnalysisBackpressureStrategyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisBackpressureStrategy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisBackpressureStrategyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let strategyArg = args[1] as! BackpressureStrategyApi
        do {
          try api.pigeonDelegate.setImageAnalysisBackpressureStrategy(pigeonApi: api, pigeonInstance: pigeonInstanceArg, strategy: strategyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisBackpressureStrategyChannel.setMessageHandler(nil)
    }
    let getImageAnalysisImageQueueDepthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisImageQueueDepth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisImageQueueDepthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisImageQueueDepth(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisImageQueueDepthChannel.setMessageHandler(nil)
    }
    let setImageAnalysisImageQueueDepthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisImageQueueDepth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisImageQueueDepthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let depthArg = args[1] as! Int64
        do {
          try api.pigeonDelegate.setImageAnalysisImageQueueDepth(pigeonApi: api, pigeonInstance: pigeonInstanceArg, depth: depthArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisImageQueueDepthChannel.setMessageHandler(nil)
    }
    let getImageAnalysisOutputImageFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getImageAnalysisOutputImageFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getImageAnalysisOutputImageFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getImageAnalysisOutputImageFormat(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getImageAnalysisOutputImageFormatChannel.setMessageHandler(nil)
    }
    let setImageAnalysisOutputImageFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisOutputImageFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisOutputImageFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let imageAnalysisOutputImageFormatArg = args[1] as! ImageFormatApi
        do {
          try api.pigeonDelegate.setImageAnalysisOutputImageFormat(pigeonApi: api, pigeonInstance: pigeonInstanceArg, imageAnalysisOutputImageFormat: imageAnalysisOutputImageFormatArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisOutputImageFormatChannel.setMessageHandler(nil)
    }
    let setImageAnalysisAnalyzerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setImageAnalysisAnalyzer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageAnalysisAnalyzerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let analyzerArg = args[1] as! ImageAnalysis.Analyzer
        do {
          try api.pigeonDelegate.setImageAnalysisAnalyzer(pigeonApi: api, pigeonInstance: pigeonInstanceArg, analyzer: analyzerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setImageAnalysisAnalyzerChannel.setMessageHandler(nil)
    }
    let clearImageAnalysisAnalyzerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.clearImageAnalysisAnalyzer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearImageAnalysisAnalyzerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          try api.pigeonDelegate.clearImageAnalysisAnalyzer(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearImageAnalysisAnalyzerChannel.setMessageHandler(nil)
    }
    let getVideoCaptureMirrorModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.getVideoCaptureMirrorMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoCaptureMirrorModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.getVideoCaptureMirrorMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoCaptureMirrorModeChannel.setMessageHandler(nil)
    }
    let setVideoCaptureMirrorModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.setVideoCaptureMirrorMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoCaptureMirrorModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let mirrorModeArg = args[1] as! MirrorModeApi
        do {
          try api.pigeonDelegate.setVideoCaptureMirrorMode(pigeonApi: api, pigeonInstance: pigeonInstanceArg, mirrorMode: mirrorModeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVideoCaptureMirrorModeChannel.setMessageHandler(nil)
    }
    let isRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.isRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        do {
          let result = try api.pigeonDelegate.isRecording(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isRecordingChannel.setMessageHandler(nil)
    }
    let startRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.CameraControllerApi.startRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CameraController
        let outputOptionsArg = args[1] as! FileOutputOptions
        let audioConfigArg = args[2] as! AudioConfig
        let listenerArg = args[3] as! VideoRecordEventConsumer
        do {
          let result = try api.pigeonDelegate.startRecording(pigeonApi: api, pigeonInstance: pigeonInstanceArg, outputOptions: outputOptionsArg, audioConfig: audioConfigArg, listener: listenerArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startRecordingChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CameraControllerApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CameraController, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.CameraControllerApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegatePreviewViewApi {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiPreviewViewApi) throws -> PreviewView
  func getController(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewView) throws -> CameraController?
  func setController(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewView, controller: CameraController?) throws
  func getScaleType(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewView) throws -> ScaleTypeApi
  func setScaleType(pigeonApi: PigeonApiPreviewViewApi, pigeonInstance: PreviewView, scaleType: ScaleTypeApi) throws
}

protocol PigeonApiProtocolPreviewViewApi {
}

final class PigeonApiPreviewViewApi: PigeonApiProtocolPreviewViewApi  {
  unowned let pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegatePreviewViewApi
  init(pigeonRegistrar: CameraXApiPigeonProxyApiRegistrar, delegate: PigeonApiDelegatePreviewViewApi) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiPreviewViewApi?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CameraXApiPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let getControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.getController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        do {
          let result = try api.pigeonDelegate.getController(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getControllerChannel.setMessageHandler(nil)
    }
    let setControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.setController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        let controllerArg: CameraController? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setController(pigeonApi: api, pigeonInstance: pigeonInstanceArg, controller: controllerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setControllerChannel.setMessageHandler(nil)
    }
    let getScaleTypeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.getScaleType", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getScaleTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        do {
          let result = try api.pigeonDelegate.getScaleType(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getScaleTypeChannel.setMessageHandler(nil)
    }
    let setScaleTypeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.camerax_ios.PreviewViewApi.setScaleType", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setScaleTypeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! PreviewView
        let scaleTypeArg = args[1] as! ScaleTypeApi
        do {
          try api.pigeonDelegate.setScaleType(pigeonApi: api, pigeonInstance: pigeonInstanceArg, scaleType: scaleTypeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setScaleTypeChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of PreviewViewApi and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: PreviewView, completion: @escaping (Result<Void, CameraXError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          CameraXError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.camerax_ios.PreviewViewApi.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(CameraXError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
